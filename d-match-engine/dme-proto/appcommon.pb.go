// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: appcommon.proto

package distributed_match_engine

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import "github.com/mobiledgex/edge-cloud/util"
import "errors"
import "strconv"
import "encoding/json"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// LProto indicates which protocol to use for accessing an application on a particular port. This is required by Kubernetes for port mapping.
type LProto int32

const (
	// Unknown protocol
	LProto_L_PROTO_UNKNOWN LProto = 0
	// TCP (L4) protocol
	LProto_L_PROTO_TCP LProto = 1
	// UDP (L4) protocol
	LProto_L_PROTO_UDP LProto = 2
	// HTTP (L7 tcp) protocol
	LProto_L_PROTO_HTTP LProto = 3
)

var LProto_name = map[int32]string{
	0: "L_PROTO_UNKNOWN",
	1: "L_PROTO_TCP",
	2: "L_PROTO_UDP",
	3: "L_PROTO_HTTP",
}
var LProto_value = map[string]int32{
	"L_PROTO_UNKNOWN": 0,
	"L_PROTO_TCP":     1,
	"L_PROTO_UDP":     2,
	"L_PROTO_HTTP":    3,
}

func (x LProto) String() string {
	return proto.EnumName(LProto_name, int32(x))
}
func (LProto) EnumDescriptor() ([]byte, []int) { return fileDescriptorAppcommon, []int{0} }

// AppPort describes an L4 or L7 public access port/path mapping. This is used to track external to internal mappings for access via a shared load balancer or reverse proxy.
type AppPort struct {
	// TCP (L4), UDP (L4), or HTTP (L7) protocol
	Proto LProto `protobuf:"varint,1,opt,name=proto,proto3,enum=distributed_match_engine.LProto" json:"proto,omitempty"`
	// Container port
	InternalPort int32 `protobuf:"varint,2,opt,name=internal_port,json=internalPort,proto3" json:"internal_port,omitempty"`
	// Public facing port for TCP/UDP (may be mapped on shared LB reverse proxy)
	PublicPort int32 `protobuf:"varint,3,opt,name=public_port,json=publicPort,proto3" json:"public_port,omitempty"`
	// Public facing path for HTTP L7 access.
	PathPrefix string `protobuf:"bytes,4,opt,name=path_prefix,json=pathPrefix,proto3" json:"path_prefix,omitempty"`
	// FQDN prefix to append to base FQDN in FindCloudlet response. May be empty.
	FqdnPrefix string `protobuf:"bytes,5,opt,name=fqdn_prefix,json=fqdnPrefix,proto3" json:"fqdn_prefix,omitempty"`
	// A non-zero end port indicates this is a port range from internal port to end port, inclusive.
	EndPort int32 `protobuf:"varint,6,opt,name=end_port,json=endPort,proto3" json:"end_port,omitempty"`
}

func (m *AppPort) Reset()                    { *m = AppPort{} }
func (m *AppPort) String() string            { return proto.CompactTextString(m) }
func (*AppPort) ProtoMessage()               {}
func (*AppPort) Descriptor() ([]byte, []int) { return fileDescriptorAppcommon, []int{0} }

func init() {
	proto.RegisterType((*AppPort)(nil), "distributed_match_engine.AppPort")
	proto.RegisterEnum("distributed_match_engine.LProto", LProto_name, LProto_value)
}
func (m *AppPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppPort) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Proto != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppcommon(dAtA, i, uint64(m.Proto))
	}
	if m.InternalPort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppcommon(dAtA, i, uint64(m.InternalPort))
	}
	if m.PublicPort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppcommon(dAtA, i, uint64(m.PublicPort))
	}
	if len(m.PathPrefix) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppcommon(dAtA, i, uint64(len(m.PathPrefix)))
		i += copy(dAtA[i:], m.PathPrefix)
	}
	if len(m.FqdnPrefix) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppcommon(dAtA, i, uint64(len(m.FqdnPrefix)))
		i += copy(dAtA[i:], m.FqdnPrefix)
	}
	if m.EndPort != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAppcommon(dAtA, i, uint64(m.EndPort))
	}
	return i, nil
}

func encodeVarintAppcommon(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AppPort) CopyInFields(src *AppPort) int {
	changed := 0
	if m.Proto != src.Proto {
		m.Proto = src.Proto
		changed++
	}
	if m.InternalPort != src.InternalPort {
		m.InternalPort = src.InternalPort
		changed++
	}
	if m.PublicPort != src.PublicPort {
		m.PublicPort = src.PublicPort
		changed++
	}
	if m.PathPrefix != src.PathPrefix {
		m.PathPrefix = src.PathPrefix
		changed++
	}
	if m.FqdnPrefix != src.FqdnPrefix {
		m.FqdnPrefix = src.FqdnPrefix
		changed++
	}
	if m.EndPort != src.EndPort {
		m.EndPort = src.EndPort
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *AppPort) ValidateEnums() error {
	if _, ok := LProto_name[int32(m.Proto)]; !ok {
		return errors.New("invalid Proto")
	}
	return nil
}

var LProtoStrings = []string{
	"L_PROTO_UNKNOWN",
	"L_PROTO_TCP",
	"L_PROTO_UDP",
	"L_PROTO_HTTP",
}

const (
	LProtoL_PROTO_UNKNOWN uint64 = 1 << 0
	LProtoL_PROTO_TCP     uint64 = 1 << 1
	LProtoL_PROTO_UDP     uint64 = 1 << 2
	LProtoL_PROTO_HTTP    uint64 = 1 << 3
)

var LProto_CamelName = map[int32]string{
	// L_PROTO_UNKNOWN -> LProtoUnknown
	0: "LProtoUnknown",
	// L_PROTO_TCP -> LProtoTcp
	1: "LProtoTcp",
	// L_PROTO_UDP -> LProtoUdp
	2: "LProtoUdp",
	// L_PROTO_HTTP -> LProtoHttp
	3: "LProtoHttp",
}
var LProto_CamelValue = map[string]int32{
	"LProtoUnknown": 0,
	"LProtoTcp":     1,
	"LProtoUdp":     2,
	"LProtoHttp":    3,
}

func (e *LProto) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := LProto_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = LProto_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = LProto(val)
	return nil
}

func (e LProto) MarshalYAML() (interface{}, error) {
	return proto.EnumName(LProto_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *LProto) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := LProto_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = LProto_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = LProto(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = LProto(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}
func (m *AppPort) Size() (n int) {
	var l int
	_ = l
	if m.Proto != 0 {
		n += 1 + sovAppcommon(uint64(m.Proto))
	}
	if m.InternalPort != 0 {
		n += 1 + sovAppcommon(uint64(m.InternalPort))
	}
	if m.PublicPort != 0 {
		n += 1 + sovAppcommon(uint64(m.PublicPort))
	}
	l = len(m.PathPrefix)
	if l > 0 {
		n += 1 + l + sovAppcommon(uint64(l))
	}
	l = len(m.FqdnPrefix)
	if l > 0 {
		n += 1 + l + sovAppcommon(uint64(l))
	}
	if m.EndPort != 0 {
		n += 1 + sovAppcommon(uint64(m.EndPort))
	}
	return n
}

func sovAppcommon(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAppcommon(x uint64) (n int) {
	return sovAppcommon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AppPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppcommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto", wireType)
			}
			m.Proto = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppcommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proto |= (LProto(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalPort", wireType)
			}
			m.InternalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppcommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InternalPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicPort", wireType)
			}
			m.PublicPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppcommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PublicPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppcommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppcommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqdnPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppcommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppcommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqdnPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndPort", wireType)
			}
			m.EndPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppcommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppcommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppcommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAppcommon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAppcommon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppcommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppcommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAppcommon
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAppcommon
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAppcommon(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAppcommon = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAppcommon   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("appcommon.proto", fileDescriptorAppcommon) }

var fileDescriptorAppcommon = []byte{
	// 283 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0xd0, 0xbb, 0x4e, 0xf3, 0x30,
	0x18, 0xc6, 0xf1, 0xba, 0xfd, 0xda, 0x7e, 0xbc, 0x2d, 0xd4, 0x32, 0x4b, 0x58, 0x42, 0x04, 0x4b,
	0xc5, 0xd0, 0x01, 0x24, 0x76, 0x0e, 0x03, 0x12, 0x55, 0x63, 0xa2, 0x54, 0x8c, 0x56, 0x0e, 0x2e,
	0xb5, 0xd4, 0xd8, 0xc6, 0xb8, 0x12, 0x97, 0xd8, 0x91, 0x4b, 0x80, 0x88, 0x0b, 0x41, 0xb1, 0x09,
	0x62, 0x61, 0xfd, 0xeb, 0xe7, 0x47, 0xd6, 0x0b, 0x93, 0x4c, 0xeb, 0x42, 0x55, 0x95, 0x92, 0x33,
	0x6d, 0x94, 0x55, 0x24, 0x28, 0xc5, 0x8b, 0x35, 0x22, 0xdf, 0x5a, 0x5e, 0xb2, 0x2a, 0xb3, 0xc5,
	0x9a, 0x71, 0xf9, 0x24, 0x24, 0x3f, 0xf9, 0x44, 0x30, 0xbc, 0xd2, 0x9a, 0x2a, 0x63, 0xc9, 0x25,
	0xf4, 0x1d, 0x0f, 0x50, 0x84, 0xa6, 0x07, 0xe7, 0xd1, 0xec, 0xaf, 0x57, 0xb3, 0x39, 0x6d, 0x5c,
	0xe2, 0x39, 0x39, 0x85, 0x7d, 0x21, 0x2d, 0x37, 0x32, 0xdb, 0x30, 0xad, 0x8c, 0x0d, 0xba, 0x11,
	0x9a, 0xf6, 0x93, 0x71, 0x1b, 0xdd, 0xf8, 0x31, 0x8c, 0xf4, 0x36, 0xdf, 0x88, 0xc2, 0x93, 0x9e,
	0x23, 0xe0, 0xd3, 0x0f, 0xc8, 0xec, 0x9a, 0x69, 0xc3, 0x57, 0xe2, 0x35, 0xf8, 0x17, 0xa1, 0xe9,
	0x5e, 0x02, 0x4d, 0xa2, 0xae, 0x34, 0x60, 0xf5, 0x5c, 0xca, 0x16, 0xf4, 0x3d, 0x68, 0xd2, 0x37,
	0x38, 0x82, 0xff, 0x5c, 0x96, 0x7e, 0x7f, 0xe0, 0xf6, 0x87, 0x5c, 0x96, 0xcd, 0xf8, 0xd9, 0x03,
	0x0c, 0xfc, 0x9f, 0xc9, 0x21, 0x4c, 0xe6, 0x8c, 0x26, 0x71, 0x1a, 0xb3, 0xe5, 0xe2, 0x7e, 0x11,
	0x3f, 0x2e, 0x70, 0x87, 0x4c, 0x60, 0xd4, 0xc6, 0xf4, 0x86, 0x62, 0xf4, 0x3b, 0x2c, 0x6f, 0x29,
	0xee, 0x12, 0x0c, 0xe3, 0x36, 0xdc, 0xa5, 0x29, 0xc5, 0xbd, 0x6b, 0xbc, 0xfb, 0x08, 0x3b, 0xbb,
	0x3a, 0x44, 0x6f, 0x75, 0x88, 0xde, 0xeb, 0x10, 0xe5, 0x03, 0x77, 0x8e, 0x8b, 0xaf, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xb2, 0x50, 0xc7, 0xfc, 0x7f, 0x01, 0x00, 0x00,
}
