// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app-client.proto

/*
	Package distributed_match_engine is a generated protocol buffer package.

	It is generated from these files:
		app-client.proto
		appcommon.proto
		dynamic-location-group.proto
		loc.proto

	It has these top-level messages:
		RegisterClientRequest
		RegisterClientReply
		FindCloudletRequest
		FindCloudletReply
		VerifyLocationRequest
		VerifyLocationReply
		GetLocationRequest
		GetLocationReply
		AppInstListRequest
		Appinstance
		CloudletLocation
		AppInstListReply
		FqdnListRequest
		AppFqdn
		FqdnListReply
		DynamicLocGroupRequest
		DynamicLocGroupReply
		QosPosition
		QosPositionKpiRequest
		QosPositionResult
		QosPositionKpiReply
		AppPort
		DlgMessage
		DlgReply
		Timestamp
		Loc
*/
package distributed_match_engine

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import binary "encoding/binary"

import "github.com/mobiledgex/edge-cloud/util"
import "errors"
import "strconv"
import "encoding/json"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type IDTypes int32

const (
	IDTypes_ID_UNDEFINED IDTypes = 0
	IDTypes_IMEI         IDTypes = 1
	IDTypes_MSISDN       IDTypes = 2
	IDTypes_IPADDR       IDTypes = 3
)

var IDTypes_name = map[int32]string{
	0: "ID_UNDEFINED",
	1: "IMEI",
	2: "MSISDN",
	3: "IPADDR",
}
var IDTypes_value = map[string]int32{
	"ID_UNDEFINED": 0,
	"IMEI":         1,
	"MSISDN":       2,
	"IPADDR":       3,
}

func (x IDTypes) String() string {
	return proto.EnumName(IDTypes_name, int32(x))
}
func (IDTypes) EnumDescriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{0} }

type ReplyStatus int32

const (
	ReplyStatus_RS_UNDEFINED ReplyStatus = 0
	ReplyStatus_RS_SUCCESS   ReplyStatus = 1
	ReplyStatus_RS_FAIL      ReplyStatus = 2
)

var ReplyStatus_name = map[int32]string{
	0: "RS_UNDEFINED",
	1: "RS_SUCCESS",
	2: "RS_FAIL",
}
var ReplyStatus_value = map[string]int32{
	"RS_UNDEFINED": 0,
	"RS_SUCCESS":   1,
	"RS_FAIL":      2,
}

func (x ReplyStatus) String() string {
	return proto.EnumName(ReplyStatus_name, int32(x))
}
func (ReplyStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{1} }

type FindCloudletReply_FindStatus int32

const (
	FindCloudletReply_FIND_UNKNOWN  FindCloudletReply_FindStatus = 0
	FindCloudletReply_FIND_FOUND    FindCloudletReply_FindStatus = 1
	FindCloudletReply_FIND_NOTFOUND FindCloudletReply_FindStatus = 2
)

var FindCloudletReply_FindStatus_name = map[int32]string{
	0: "FIND_UNKNOWN",
	1: "FIND_FOUND",
	2: "FIND_NOTFOUND",
}
var FindCloudletReply_FindStatus_value = map[string]int32{
	"FIND_UNKNOWN":  0,
	"FIND_FOUND":    1,
	"FIND_NOTFOUND": 2,
}

func (x FindCloudletReply_FindStatus) String() string {
	return proto.EnumName(FindCloudletReply_FindStatus_name, int32(x))
}
func (FindCloudletReply_FindStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{3, 0}
}

// Status of the reply
type VerifyLocationReply_TowerStatus int32

const (
	VerifyLocationReply_TOWER_UNKNOWN                    VerifyLocationReply_TowerStatus = 0
	VerifyLocationReply_CONNECTED_TO_SPECIFIED_TOWER     VerifyLocationReply_TowerStatus = 1
	VerifyLocationReply_NOT_CONNECTED_TO_SPECIFIED_TOWER VerifyLocationReply_TowerStatus = 2
)

var VerifyLocationReply_TowerStatus_name = map[int32]string{
	0: "TOWER_UNKNOWN",
	1: "CONNECTED_TO_SPECIFIED_TOWER",
	2: "NOT_CONNECTED_TO_SPECIFIED_TOWER",
}
var VerifyLocationReply_TowerStatus_value = map[string]int32{
	"TOWER_UNKNOWN":                    0,
	"CONNECTED_TO_SPECIFIED_TOWER":     1,
	"NOT_CONNECTED_TO_SPECIFIED_TOWER": 2,
}

func (x VerifyLocationReply_TowerStatus) String() string {
	return proto.EnumName(VerifyLocationReply_TowerStatus_name, int32(x))
}
func (VerifyLocationReply_TowerStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{5, 0}
}

type VerifyLocationReply_GPSLocationStatus int32

const (
	VerifyLocationReply_LOC_UNKNOWN                  VerifyLocationReply_GPSLocationStatus = 0
	VerifyLocationReply_LOC_VERIFIED                 VerifyLocationReply_GPSLocationStatus = 1
	VerifyLocationReply_LOC_MISMATCH_SAME_COUNTRY    VerifyLocationReply_GPSLocationStatus = 2
	VerifyLocationReply_LOC_MISMATCH_OTHER_COUNTRY   VerifyLocationReply_GPSLocationStatus = 3
	VerifyLocationReply_LOC_ROAMING_COUNTRY_MATCH    VerifyLocationReply_GPSLocationStatus = 4
	VerifyLocationReply_LOC_ROAMING_COUNTRY_MISMATCH VerifyLocationReply_GPSLocationStatus = 5
	VerifyLocationReply_LOC_ERROR_UNAUTHORIZED       VerifyLocationReply_GPSLocationStatus = 6
	VerifyLocationReply_LOC_ERROR_OTHER              VerifyLocationReply_GPSLocationStatus = 7
)

var VerifyLocationReply_GPSLocationStatus_name = map[int32]string{
	0: "LOC_UNKNOWN",
	1: "LOC_VERIFIED",
	2: "LOC_MISMATCH_SAME_COUNTRY",
	3: "LOC_MISMATCH_OTHER_COUNTRY",
	4: "LOC_ROAMING_COUNTRY_MATCH",
	5: "LOC_ROAMING_COUNTRY_MISMATCH",
	6: "LOC_ERROR_UNAUTHORIZED",
	7: "LOC_ERROR_OTHER",
}
var VerifyLocationReply_GPSLocationStatus_value = map[string]int32{
	"LOC_UNKNOWN":                  0,
	"LOC_VERIFIED":                 1,
	"LOC_MISMATCH_SAME_COUNTRY":    2,
	"LOC_MISMATCH_OTHER_COUNTRY":   3,
	"LOC_ROAMING_COUNTRY_MATCH":    4,
	"LOC_ROAMING_COUNTRY_MISMATCH": 5,
	"LOC_ERROR_UNAUTHORIZED":       6,
	"LOC_ERROR_OTHER":              7,
}

func (x VerifyLocationReply_GPSLocationStatus) String() string {
	return proto.EnumName(VerifyLocationReply_GPSLocationStatus_name, int32(x))
}
func (VerifyLocationReply_GPSLocationStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{5, 1}
}

// Status of the reply
type GetLocationReply_LocStatus int32

const (
	GetLocationReply_LOC_UNKNOWN GetLocationReply_LocStatus = 0
	GetLocationReply_LOC_FOUND   GetLocationReply_LocStatus = 1
	// The user does not allow his location to be tracked
	GetLocationReply_LOC_DENIED GetLocationReply_LocStatus = 2
)

var GetLocationReply_LocStatus_name = map[int32]string{
	0: "LOC_UNKNOWN",
	1: "LOC_FOUND",
	2: "LOC_DENIED",
}
var GetLocationReply_LocStatus_value = map[string]int32{
	"LOC_UNKNOWN": 0,
	"LOC_FOUND":   1,
	"LOC_DENIED":  2,
}

func (x GetLocationReply_LocStatus) String() string {
	return proto.EnumName(GetLocationReply_LocStatus_name, int32(x))
}
func (GetLocationReply_LocStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{7, 0}
}

// Status of the reply
type AppInstListReply_AIStatus int32

const (
	AppInstListReply_AI_UNDEFINED AppInstListReply_AIStatus = 0
	AppInstListReply_AI_SUCCESS   AppInstListReply_AIStatus = 1
	AppInstListReply_AI_FAIL      AppInstListReply_AIStatus = 2
)

var AppInstListReply_AIStatus_name = map[int32]string{
	0: "AI_UNDEFINED",
	1: "AI_SUCCESS",
	2: "AI_FAIL",
}
var AppInstListReply_AIStatus_value = map[string]int32{
	"AI_UNDEFINED": 0,
	"AI_SUCCESS":   1,
	"AI_FAIL":      2,
}

func (x AppInstListReply_AIStatus) String() string {
	return proto.EnumName(AppInstListReply_AIStatus_name, int32(x))
}
func (AppInstListReply_AIStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{11, 0}
}

// Status of the reply
type FqdnListReply_FLStatus int32

const (
	FqdnListReply_FL_UNDEFINED FqdnListReply_FLStatus = 0
	FqdnListReply_FL_SUCCESS   FqdnListReply_FLStatus = 1
	FqdnListReply_FL_FAIL      FqdnListReply_FLStatus = 2
)

var FqdnListReply_FLStatus_name = map[int32]string{
	0: "FL_UNDEFINED",
	1: "FL_SUCCESS",
	2: "FL_FAIL",
}
var FqdnListReply_FLStatus_value = map[string]int32{
	"FL_UNDEFINED": 0,
	"FL_SUCCESS":   1,
	"FL_FAIL":      2,
}

func (x FqdnListReply_FLStatus) String() string {
	return proto.EnumName(FqdnListReply_FLStatus_name, int32(x))
}
func (FqdnListReply_FLStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{14, 0}
}

// Use Secure communication or Open with the group
type DynamicLocGroupRequest_DlgCommType int32

const (
	DynamicLocGroupRequest_DLG_UNDEFINED DynamicLocGroupRequest_DlgCommType = 0
	DynamicLocGroupRequest_DLG_SECURE    DynamicLocGroupRequest_DlgCommType = 1
	DynamicLocGroupRequest_DLG_OPEN      DynamicLocGroupRequest_DlgCommType = 2
)

var DynamicLocGroupRequest_DlgCommType_name = map[int32]string{
	0: "DLG_UNDEFINED",
	1: "DLG_SECURE",
	2: "DLG_OPEN",
}
var DynamicLocGroupRequest_DlgCommType_value = map[string]int32{
	"DLG_UNDEFINED": 0,
	"DLG_SECURE":    1,
	"DLG_OPEN":      2,
}

func (x DynamicLocGroupRequest_DlgCommType) String() string {
	return proto.EnumName(DynamicLocGroupRequest_DlgCommType_name, int32(x))
}
func (DynamicLocGroupRequest_DlgCommType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{15, 0}
}

type RegisterClientRequest struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// App Developer Name
	DevName string `protobuf:"bytes,2,opt,name=dev_name,json=devName,proto3" json:"dev_name,omitempty"`
	// App Name
	AppName string `protobuf:"bytes,3,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	// App Version
	AppVers string `protobuf:"bytes,4,opt,name=app_vers,json=appVers,proto3" json:"app_vers,omitempty"`
	// carrier name, not currently used
	CarrierName string `protobuf:"bytes,5,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	// authentication token
	AuthToken string `protobuf:"bytes,6,opt,name=auth_token,json=authToken,proto3" json:"auth_token,omitempty"`
}

func (m *RegisterClientRequest) Reset()                    { *m = RegisterClientRequest{} }
func (m *RegisterClientRequest) String() string            { return proto.CompactTextString(m) }
func (*RegisterClientRequest) ProtoMessage()               {}
func (*RegisterClientRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{0} }

type RegisterClientReply struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Status of the reply
	Status ReplyStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.ReplyStatus" json:"status,omitempty"`
	// Session Cookie to be used in later API calls
	SessionCookie string `protobuf:"bytes,3,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// URI for Token Server
	TokenServerUri string `protobuf:"bytes,4,opt,name=token_server_uri,json=tokenServerUri,proto3" json:"token_server_uri,omitempty"`
}

func (m *RegisterClientReply) Reset()                    { *m = RegisterClientReply{} }
func (m *RegisterClientReply) String() string            { return proto.CompactTextString(m) }
func (*RegisterClientReply) ProtoMessage()               {}
func (*RegisterClientReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{1} }

type FindCloudletRequest struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// The carrier name that user is connected to ("Cellular Carrier Name")
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	// The GPS location of the user
	GpsLocation *Loc `protobuf:"bytes,4,opt,name=gps_location,json=gpsLocation" json:"gps_location,omitempty"`
	// DevName is applicable to Platform apps only
	DevName string `protobuf:"bytes,5,opt,name=dev_name,json=devName,proto3" json:"dev_name,omitempty"`
	// App Name is applicable to Platform apps only
	AppName string `protobuf:"bytes,6,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	// App Version is applicable to Platform apps only
	AppVers string `protobuf:"bytes,7,opt,name=app_vers,json=appVers,proto3" json:"app_vers,omitempty"`
}

func (m *FindCloudletRequest) Reset()                    { *m = FindCloudletRequest{} }
func (m *FindCloudletRequest) String() string            { return proto.CompactTextString(m) }
func (*FindCloudletRequest) ProtoMessage()               {}
func (*FindCloudletRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{2} }

type FindCloudletReply struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Status return
	Status FindCloudletReply_FindStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.FindCloudletReply_FindStatus" json:"status,omitempty"`
	// Full Qualified Domain Name of Closest App instance
	Fqdn string `protobuf:"bytes,3,opt,name=fqdn,proto3" json:"fqdn,omitempty"`
	// List of Service Endpoints for AppInst
	Ports []*AppPort `protobuf:"bytes,4,rep,name=ports" json:"ports,omitempty"`
	// Location of the cloudlet
	CloudletLocation *Loc `protobuf:"bytes,5,opt,name=cloudlet_location,json=cloudletLocation" json:"cloudlet_location,omitempty"`
}

func (m *FindCloudletReply) Reset()                    { *m = FindCloudletReply{} }
func (m *FindCloudletReply) String() string            { return proto.CompactTextString(m) }
func (*FindCloudletReply) ProtoMessage()               {}
func (*FindCloudletReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{3} }

type VerifyLocationRequest struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// The carrier name that user is connected to ("Cellular Carrier Name")
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	// The GPS location to verify
	GpsLocation *Loc `protobuf:"bytes,4,opt,name=gps_location,json=gpsLocation" json:"gps_location,omitempty"`
	// token used for location verification, app must retrieve from TokenServerURI
	VerifyLocToken string `protobuf:"bytes,5,opt,name=verify_loc_token,json=verifyLocToken,proto3" json:"verify_loc_token,omitempty"`
}

func (m *VerifyLocationRequest) Reset()                    { *m = VerifyLocationRequest{} }
func (m *VerifyLocationRequest) String() string            { return proto.CompactTextString(m) }
func (*VerifyLocationRequest) ProtoMessage()               {}
func (*VerifyLocationRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{4} }

type VerifyLocationReply struct {
	// API version
	Ver               uint32                                `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	TowerStatus       VerifyLocationReply_TowerStatus       `protobuf:"varint,2,opt,name=tower_status,json=towerStatus,proto3,enum=distributed_match_engine.VerifyLocationReply_TowerStatus" json:"tower_status,omitempty"`
	GpsLocationStatus VerifyLocationReply_GPSLocationStatus `protobuf:"varint,3,opt,name=gps_location_status,json=gpsLocationStatus,proto3,enum=distributed_match_engine.VerifyLocationReply_GPSLocationStatus" json:"gps_location_status,omitempty"`
	// location accuracy, the location is verified to
	// be within this number of kilometers.  Negative value
	// means no verification was done
	GpsLocationAccuracyKm float64 `protobuf:"fixed64,4,opt,name=gps_location_accuracy_km,json=gpsLocationAccuracyKm,proto3" json:"gps_location_accuracy_km,omitempty"`
}

func (m *VerifyLocationReply) Reset()                    { *m = VerifyLocationReply{} }
func (m *VerifyLocationReply) String() string            { return proto.CompactTextString(m) }
func (*VerifyLocationReply) ProtoMessage()               {}
func (*VerifyLocationReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{5} }

type GetLocationRequest struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// The carrier name that user is connected to ("Cellular Carrier Name")
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
}

func (m *GetLocationRequest) Reset()                    { *m = GetLocationRequest{} }
func (m *GetLocationRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLocationRequest) ProtoMessage()               {}
func (*GetLocationRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{6} }

type GetLocationReply struct {
	Ver    uint32                     `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	Status GetLocationReply_LocStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.GetLocationReply_LocStatus" json:"status,omitempty"`
	// The carrier name that user is connected to ("Cellular Carrier Name")
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	// The tower that user is currently connected to
	Tower uint64 `protobuf:"varint,4,opt,name=tower,proto3" json:"tower,omitempty"`
	// The GPS location of the user
	NetworkLocation *Loc `protobuf:"bytes,5,opt,name=network_location,json=networkLocation" json:"network_location,omitempty"`
}

func (m *GetLocationReply) Reset()                    { *m = GetLocationReply{} }
func (m *GetLocationReply) String() string            { return proto.CompactTextString(m) }
func (*GetLocationReply) ProtoMessage()               {}
func (*GetLocationReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{7} }

type AppInstListRequest struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// The carrier name that user is connected to ("Cellular Carrier Name")
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	// The GPS location of the user
	GpsLocation *Loc `protobuf:"bytes,4,opt,name=gps_location,json=gpsLocation" json:"gps_location,omitempty"`
}

func (m *AppInstListRequest) Reset()                    { *m = AppInstListRequest{} }
func (m *AppInstListRequest) String() string            { return proto.CompactTextString(m) }
func (*AppInstListRequest) ProtoMessage()               {}
func (*AppInstListRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{8} }

type Appinstance struct {
	// App Instance Name
	AppName string `protobuf:"bytes,1,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	// App Instance Version
	AppVers string `protobuf:"bytes,2,opt,name=app_vers,json=appVers,proto3" json:"app_vers,omitempty"`
	// App Instance FQDN
	Fqdn string `protobuf:"bytes,3,opt,name=fqdn,proto3" json:"fqdn,omitempty"`
	// ports to access app
	Ports []*AppPort `protobuf:"bytes,4,rep,name=ports" json:"ports,omitempty"`
}

func (m *Appinstance) Reset()                    { *m = Appinstance{} }
func (m *Appinstance) String() string            { return proto.CompactTextString(m) }
func (*Appinstance) ProtoMessage()               {}
func (*Appinstance) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{9} }

type CloudletLocation struct {
	// The carrier name that user is connected to ("Cellular Carrier Name")
	CarrierName string `protobuf:"bytes,1,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	// Cloudlet Name
	CloudletName string `protobuf:"bytes,2,opt,name=cloudlet_name,json=cloudletName,proto3" json:"cloudlet_name,omitempty"`
	// The GPS Location of the user
	GpsLocation *Loc `protobuf:"bytes,3,opt,name=gps_location,json=gpsLocation" json:"gps_location,omitempty"`
	// Distance of cloudlet vs loc in request
	Distance float64 `protobuf:"fixed64,4,opt,name=distance,proto3" json:"distance,omitempty"`
	// App instances
	Appinstances []*Appinstance `protobuf:"bytes,5,rep,name=appinstances" json:"appinstances,omitempty"`
}

func (m *CloudletLocation) Reset()                    { *m = CloudletLocation{} }
func (m *CloudletLocation) String() string            { return proto.CompactTextString(m) }
func (*CloudletLocation) ProtoMessage()               {}
func (*CloudletLocation) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{10} }

type AppInstListReply struct {
	// API version
	Ver       uint32                    `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	Status    AppInstListReply_AIStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.AppInstListReply_AIStatus" json:"status,omitempty"`
	Cloudlets []*CloudletLocation       `protobuf:"bytes,3,rep,name=cloudlets" json:"cloudlets,omitempty"`
}

func (m *AppInstListReply) Reset()                    { *m = AppInstListReply{} }
func (m *AppInstListReply) String() string            { return proto.CompactTextString(m) }
func (*AppInstListReply) ProtoMessage()               {}
func (*AppInstListReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{11} }

type FqdnListRequest struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
}

func (m *FqdnListRequest) Reset()                    { *m = FqdnListRequest{} }
func (m *FqdnListRequest) String() string            { return proto.CompactTextString(m) }
func (*FqdnListRequest) ProtoMessage()               {}
func (*FqdnListRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{12} }

type AppFqdn struct {
	// App  Name
	AppName string `protobuf:"bytes,1,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	// App Version
	AppVers string `protobuf:"bytes,2,opt,name=app_vers,json=appVers,proto3" json:"app_vers,omitempty"`
	// developer name
	DevName string `protobuf:"bytes,3,opt,name=dev_name,json=devName,proto3" json:"dev_name,omitempty"`
	// App FQDN
	Fqdns []string `protobuf:"bytes,4,rep,name=fqdns" json:"fqdns,omitempty"`
	// optional android package name
	AndroidPackageName string `protobuf:"bytes,5,opt,name=android_package_name,json=androidPackageName,proto3" json:"android_package_name,omitempty"`
}

func (m *AppFqdn) Reset()                    { *m = AppFqdn{} }
func (m *AppFqdn) String() string            { return proto.CompactTextString(m) }
func (*AppFqdn) ProtoMessage()               {}
func (*AppFqdn) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{13} }

type FqdnListReply struct {
	// API version
	Ver      uint32                 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	AppFqdns []*AppFqdn             `protobuf:"bytes,3,rep,name=app_fqdns,json=appFqdns" json:"app_fqdns,omitempty"`
	Status   FqdnListReply_FLStatus `protobuf:"varint,4,opt,name=status,proto3,enum=distributed_match_engine.FqdnListReply_FLStatus" json:"status,omitempty"`
}

func (m *FqdnListReply) Reset()                    { *m = FqdnListReply{} }
func (m *FqdnListReply) String() string            { return proto.CompactTextString(m) }
func (*FqdnListReply) ProtoMessage()               {}
func (*FqdnListReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{14} }

type DynamicLocGroupRequest struct {
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// Dynamic Location Group Id
	LgId     uint64                             `protobuf:"varint,3,opt,name=lg_id,json=lgId,proto3" json:"lg_id,omitempty"`
	CommType DynamicLocGroupRequest_DlgCommType `protobuf:"varint,11,opt,name=comm_type,json=commType,proto3,enum=distributed_match_engine.DynamicLocGroupRequest_DlgCommType" json:"comm_type,omitempty"`
	// Unused
	UserData string `protobuf:"bytes,12,opt,name=user_data,json=userData,proto3" json:"user_data,omitempty"`
}

func (m *DynamicLocGroupRequest) Reset()                    { *m = DynamicLocGroupRequest{} }
func (m *DynamicLocGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*DynamicLocGroupRequest) ProtoMessage()               {}
func (*DynamicLocGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{15} }

type DynamicLocGroupReply struct {
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Status of the reply
	Status ReplyStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.ReplyStatus" json:"status,omitempty"`
	// Error Code based on Failure
	ErrorCode uint32 `protobuf:"varint,3,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	// Group Cookie for Secure Group Communication
	GroupCookie string `protobuf:"bytes,5,opt,name=group_cookie,json=groupCookie,proto3" json:"group_cookie,omitempty"`
}

func (m *DynamicLocGroupReply) Reset()                    { *m = DynamicLocGroupReply{} }
func (m *DynamicLocGroupReply) String() string            { return proto.CompactTextString(m) }
func (*DynamicLocGroupReply) ProtoMessage()               {}
func (*DynamicLocGroupReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{16} }

type QosPosition struct {
	// as set by the client, must be unique within QosRequest
	Positionid int64 `protobuf:"varint,1,opt,name=positionid,proto3" json:"positionid,omitempty"`
	// location
	GpsLocation *Loc `protobuf:"bytes,2,opt,name=gps_location,json=gpsLocation" json:"gps_location,omitempty"`
}

func (m *QosPosition) Reset()                    { *m = QosPosition{} }
func (m *QosPosition) String() string            { return proto.CompactTextString(m) }
func (*QosPosition) ProtoMessage()               {}
func (*QosPosition) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{17} }

type QosPositionKpiRequest struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// list of positions
	Positions []*QosPosition `protobuf:"bytes,3,rep,name=positions" json:"positions,omitempty"`
}

func (m *QosPositionKpiRequest) Reset()                    { *m = QosPositionKpiRequest{} }
func (m *QosPositionKpiRequest) String() string            { return proto.CompactTextString(m) }
func (*QosPositionKpiRequest) ProtoMessage()               {}
func (*QosPositionKpiRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{18} }

type QosPositionResult struct {
	// as set by the client, must be unique within one QosPositionKpiRequest
	Positionid int64 `protobuf:"varint,1,opt,name=positionid,proto3" json:"positionid,omitempty"`
	// the location which was requested
	GpsLocation *Loc `protobuf:"bytes,2,opt,name=gps_location,json=gpsLocation" json:"gps_location,omitempty"`
	// throughput
	DluserthroughputMin float32 `protobuf:"fixed32,3,opt,name=dluserthroughput_min,json=dluserthroughputMin,proto3" json:"dluserthroughput_min,omitempty"`
	DluserthroughputAvg float32 `protobuf:"fixed32,4,opt,name=dluserthroughput_avg,json=dluserthroughputAvg,proto3" json:"dluserthroughput_avg,omitempty"`
	DluserthroughputMax float32 `protobuf:"fixed32,5,opt,name=dluserthroughput_max,json=dluserthroughputMax,proto3" json:"dluserthroughput_max,omitempty"`
	UluserthroughputMin float32 `protobuf:"fixed32,6,opt,name=uluserthroughput_min,json=uluserthroughputMin,proto3" json:"uluserthroughput_min,omitempty"`
	UluserthroughputAvg float32 `protobuf:"fixed32,7,opt,name=uluserthroughput_avg,json=uluserthroughputAvg,proto3" json:"uluserthroughput_avg,omitempty"`
	UluserthroughputMax float32 `protobuf:"fixed32,8,opt,name=uluserthroughput_max,json=uluserthroughputMax,proto3" json:"uluserthroughput_max,omitempty"`
	LatencyMin          float32 `protobuf:"fixed32,9,opt,name=latency_min,json=latencyMin,proto3" json:"latency_min,omitempty"`
	LatencyAvg          float32 `protobuf:"fixed32,10,opt,name=latency_avg,json=latencyAvg,proto3" json:"latency_avg,omitempty"`
	LatencyMax          float32 `protobuf:"fixed32,11,opt,name=latency_max,json=latencyMax,proto3" json:"latency_max,omitempty"`
}

func (m *QosPositionResult) Reset()                    { *m = QosPositionResult{} }
func (m *QosPositionResult) String() string            { return proto.CompactTextString(m) }
func (*QosPositionResult) ProtoMessage()               {}
func (*QosPositionResult) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{19} }

type QosPositionKpiReply struct {
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Status of the reply
	Status ReplyStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.ReplyStatus" json:"status,omitempty"`
	// kpi details
	PositionResults []*QosPositionResult `protobuf:"bytes,3,rep,name=position_results,json=positionResults" json:"position_results,omitempty"`
}

func (m *QosPositionKpiReply) Reset()                    { *m = QosPositionKpiReply{} }
func (m *QosPositionKpiReply) String() string            { return proto.CompactTextString(m) }
func (*QosPositionKpiReply) ProtoMessage()               {}
func (*QosPositionKpiReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{20} }

func init() {
	proto.RegisterType((*RegisterClientRequest)(nil), "distributed_match_engine.RegisterClientRequest")
	proto.RegisterType((*RegisterClientReply)(nil), "distributed_match_engine.RegisterClientReply")
	proto.RegisterType((*FindCloudletRequest)(nil), "distributed_match_engine.FindCloudletRequest")
	proto.RegisterType((*FindCloudletReply)(nil), "distributed_match_engine.FindCloudletReply")
	proto.RegisterType((*VerifyLocationRequest)(nil), "distributed_match_engine.VerifyLocationRequest")
	proto.RegisterType((*VerifyLocationReply)(nil), "distributed_match_engine.VerifyLocationReply")
	proto.RegisterType((*GetLocationRequest)(nil), "distributed_match_engine.GetLocationRequest")
	proto.RegisterType((*GetLocationReply)(nil), "distributed_match_engine.GetLocationReply")
	proto.RegisterType((*AppInstListRequest)(nil), "distributed_match_engine.AppInstListRequest")
	proto.RegisterType((*Appinstance)(nil), "distributed_match_engine.Appinstance")
	proto.RegisterType((*CloudletLocation)(nil), "distributed_match_engine.CloudletLocation")
	proto.RegisterType((*AppInstListReply)(nil), "distributed_match_engine.AppInstListReply")
	proto.RegisterType((*FqdnListRequest)(nil), "distributed_match_engine.FqdnListRequest")
	proto.RegisterType((*AppFqdn)(nil), "distributed_match_engine.AppFqdn")
	proto.RegisterType((*FqdnListReply)(nil), "distributed_match_engine.FqdnListReply")
	proto.RegisterType((*DynamicLocGroupRequest)(nil), "distributed_match_engine.DynamicLocGroupRequest")
	proto.RegisterType((*DynamicLocGroupReply)(nil), "distributed_match_engine.DynamicLocGroupReply")
	proto.RegisterType((*QosPosition)(nil), "distributed_match_engine.QosPosition")
	proto.RegisterType((*QosPositionKpiRequest)(nil), "distributed_match_engine.QosPositionKpiRequest")
	proto.RegisterType((*QosPositionResult)(nil), "distributed_match_engine.QosPositionResult")
	proto.RegisterType((*QosPositionKpiReply)(nil), "distributed_match_engine.QosPositionKpiReply")
	proto.RegisterEnum("distributed_match_engine.IDTypes", IDTypes_name, IDTypes_value)
	proto.RegisterEnum("distributed_match_engine.ReplyStatus", ReplyStatus_name, ReplyStatus_value)
	proto.RegisterEnum("distributed_match_engine.FindCloudletReply_FindStatus", FindCloudletReply_FindStatus_name, FindCloudletReply_FindStatus_value)
	proto.RegisterEnum("distributed_match_engine.VerifyLocationReply_TowerStatus", VerifyLocationReply_TowerStatus_name, VerifyLocationReply_TowerStatus_value)
	proto.RegisterEnum("distributed_match_engine.VerifyLocationReply_GPSLocationStatus", VerifyLocationReply_GPSLocationStatus_name, VerifyLocationReply_GPSLocationStatus_value)
	proto.RegisterEnum("distributed_match_engine.GetLocationReply_LocStatus", GetLocationReply_LocStatus_name, GetLocationReply_LocStatus_value)
	proto.RegisterEnum("distributed_match_engine.AppInstListReply_AIStatus", AppInstListReply_AIStatus_name, AppInstListReply_AIStatus_value)
	proto.RegisterEnum("distributed_match_engine.FqdnListReply_FLStatus", FqdnListReply_FLStatus_name, FqdnListReply_FLStatus_value)
	proto.RegisterEnum("distributed_match_engine.DynamicLocGroupRequest_DlgCommType", DynamicLocGroupRequest_DlgCommType_name, DynamicLocGroupRequest_DlgCommType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for MatchEngineApi service

type MatchEngineApiClient interface {
	RegisterClient(ctx context.Context, in *RegisterClientRequest, opts ...grpc.CallOption) (*RegisterClientReply, error)
	FindCloudlet(ctx context.Context, in *FindCloudletRequest, opts ...grpc.CallOption) (*FindCloudletReply, error)
	VerifyLocation(ctx context.Context, in *VerifyLocationRequest, opts ...grpc.CallOption) (*VerifyLocationReply, error)
	GetLocation(ctx context.Context, in *GetLocationRequest, opts ...grpc.CallOption) (*GetLocationReply, error)
	AddUserToGroup(ctx context.Context, in *DynamicLocGroupRequest, opts ...grpc.CallOption) (*DynamicLocGroupReply, error)
	GetAppInstList(ctx context.Context, in *AppInstListRequest, opts ...grpc.CallOption) (*AppInstListReply, error)
	GetFqdnList(ctx context.Context, in *FqdnListRequest, opts ...grpc.CallOption) (*FqdnListReply, error)
	GetQosPositionKpi(ctx context.Context, in *QosPositionKpiRequest, opts ...grpc.CallOption) (MatchEngineApi_GetQosPositionKpiClient, error)
}

type matchEngineApiClient struct {
	cc *grpc.ClientConn
}

func NewMatchEngineApiClient(cc *grpc.ClientConn) MatchEngineApiClient {
	return &matchEngineApiClient{cc}
}

func (c *matchEngineApiClient) RegisterClient(ctx context.Context, in *RegisterClientRequest, opts ...grpc.CallOption) (*RegisterClientReply, error) {
	out := new(RegisterClientReply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/RegisterClient", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) FindCloudlet(ctx context.Context, in *FindCloudletRequest, opts ...grpc.CallOption) (*FindCloudletReply, error) {
	out := new(FindCloudletReply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/FindCloudlet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) VerifyLocation(ctx context.Context, in *VerifyLocationRequest, opts ...grpc.CallOption) (*VerifyLocationReply, error) {
	out := new(VerifyLocationReply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/VerifyLocation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) GetLocation(ctx context.Context, in *GetLocationRequest, opts ...grpc.CallOption) (*GetLocationReply, error) {
	out := new(GetLocationReply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/GetLocation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) AddUserToGroup(ctx context.Context, in *DynamicLocGroupRequest, opts ...grpc.CallOption) (*DynamicLocGroupReply, error) {
	out := new(DynamicLocGroupReply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/AddUserToGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) GetAppInstList(ctx context.Context, in *AppInstListRequest, opts ...grpc.CallOption) (*AppInstListReply, error) {
	out := new(AppInstListReply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/GetAppInstList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) GetFqdnList(ctx context.Context, in *FqdnListRequest, opts ...grpc.CallOption) (*FqdnListReply, error) {
	out := new(FqdnListReply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/GetFqdnList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) GetQosPositionKpi(ctx context.Context, in *QosPositionKpiRequest, opts ...grpc.CallOption) (MatchEngineApi_GetQosPositionKpiClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_MatchEngineApi_serviceDesc.Streams[0], c.cc, "/distributed_match_engine.MatchEngineApi/GetQosPositionKpi", opts...)
	if err != nil {
		return nil, err
	}
	x := &matchEngineApiGetQosPositionKpiClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MatchEngineApi_GetQosPositionKpiClient interface {
	Recv() (*QosPositionKpiReply, error)
	grpc.ClientStream
}

type matchEngineApiGetQosPositionKpiClient struct {
	grpc.ClientStream
}

func (x *matchEngineApiGetQosPositionKpiClient) Recv() (*QosPositionKpiReply, error) {
	m := new(QosPositionKpiReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for MatchEngineApi service

type MatchEngineApiServer interface {
	RegisterClient(context.Context, *RegisterClientRequest) (*RegisterClientReply, error)
	FindCloudlet(context.Context, *FindCloudletRequest) (*FindCloudletReply, error)
	VerifyLocation(context.Context, *VerifyLocationRequest) (*VerifyLocationReply, error)
	GetLocation(context.Context, *GetLocationRequest) (*GetLocationReply, error)
	AddUserToGroup(context.Context, *DynamicLocGroupRequest) (*DynamicLocGroupReply, error)
	GetAppInstList(context.Context, *AppInstListRequest) (*AppInstListReply, error)
	GetFqdnList(context.Context, *FqdnListRequest) (*FqdnListReply, error)
	GetQosPositionKpi(*QosPositionKpiRequest, MatchEngineApi_GetQosPositionKpiServer) error
}

func RegisterMatchEngineApiServer(s *grpc.Server, srv MatchEngineApiServer) {
	s.RegisterService(&_MatchEngineApi_serviceDesc, srv)
}

func _MatchEngineApi_RegisterClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).RegisterClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/RegisterClient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).RegisterClient(ctx, req.(*RegisterClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_FindCloudlet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindCloudletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).FindCloudlet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/FindCloudlet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).FindCloudlet(ctx, req.(*FindCloudletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_VerifyLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).VerifyLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/VerifyLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).VerifyLocation(ctx, req.(*VerifyLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_GetLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).GetLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/GetLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).GetLocation(ctx, req.(*GetLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_AddUserToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DynamicLocGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).AddUserToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/AddUserToGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).AddUserToGroup(ctx, req.(*DynamicLocGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_GetAppInstList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInstListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).GetAppInstList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/GetAppInstList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).GetAppInstList(ctx, req.(*AppInstListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_GetFqdnList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FqdnListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).GetFqdnList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/GetFqdnList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).GetFqdnList(ctx, req.(*FqdnListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_GetQosPositionKpi_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QosPositionKpiRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MatchEngineApiServer).GetQosPositionKpi(m, &matchEngineApiGetQosPositionKpiServer{stream})
}

type MatchEngineApi_GetQosPositionKpiServer interface {
	Send(*QosPositionKpiReply) error
	grpc.ServerStream
}

type matchEngineApiGetQosPositionKpiServer struct {
	grpc.ServerStream
}

func (x *matchEngineApiGetQosPositionKpiServer) Send(m *QosPositionKpiReply) error {
	return x.ServerStream.SendMsg(m)
}

var _MatchEngineApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "distributed_match_engine.MatchEngineApi",
	HandlerType: (*MatchEngineApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterClient",
			Handler:    _MatchEngineApi_RegisterClient_Handler,
		},
		{
			MethodName: "FindCloudlet",
			Handler:    _MatchEngineApi_FindCloudlet_Handler,
		},
		{
			MethodName: "VerifyLocation",
			Handler:    _MatchEngineApi_VerifyLocation_Handler,
		},
		{
			MethodName: "GetLocation",
			Handler:    _MatchEngineApi_GetLocation_Handler,
		},
		{
			MethodName: "AddUserToGroup",
			Handler:    _MatchEngineApi_AddUserToGroup_Handler,
		},
		{
			MethodName: "GetAppInstList",
			Handler:    _MatchEngineApi_GetAppInstList_Handler,
		},
		{
			MethodName: "GetFqdnList",
			Handler:    _MatchEngineApi_GetFqdnList_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetQosPositionKpi",
			Handler:       _MatchEngineApi_GetQosPositionKpi_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "app-client.proto",
}

func (m *RegisterClientRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterClientRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.DevName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.DevName)))
		i += copy(dAtA[i:], m.DevName)
	}
	if len(m.AppName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppName)))
		i += copy(dAtA[i:], m.AppName)
	}
	if len(m.AppVers) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppVers)))
		i += copy(dAtA[i:], m.AppVers)
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if len(m.AuthToken) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AuthToken)))
		i += copy(dAtA[i:], m.AuthToken)
	}
	return i, nil
}

func (m *RegisterClientReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterClientReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if len(m.TokenServerUri) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.TokenServerUri)))
		i += copy(dAtA[i:], m.TokenServerUri)
	}
	return i, nil
}

func (m *FindCloudletRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindCloudletRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n1, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.DevName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.DevName)))
		i += copy(dAtA[i:], m.DevName)
	}
	if len(m.AppName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppName)))
		i += copy(dAtA[i:], m.AppName)
	}
	if len(m.AppVers) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppVers)))
		i += copy(dAtA[i:], m.AppVers)
	}
	return i, nil
}

func (m *FindCloudletReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindCloudletReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if len(m.Fqdn) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Fqdn)))
		i += copy(dAtA[i:], m.Fqdn)
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CloudletLocation != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CloudletLocation.Size()))
		n2, err := m.CloudletLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *VerifyLocationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyLocationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n3, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.VerifyLocToken) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.VerifyLocToken)))
		i += copy(dAtA[i:], m.VerifyLocToken)
	}
	return i, nil
}

func (m *VerifyLocationReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyLocationReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.TowerStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.TowerStatus))
	}
	if m.GpsLocationStatus != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocationStatus))
	}
	if m.GpsLocationAccuracyKm != 0 {
		dAtA[i] = 0x21
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GpsLocationAccuracyKm))))
		i += 8
	}
	return i, nil
}

func (m *GetLocationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLocationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	return i, nil
}

func (m *GetLocationReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLocationReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if m.Tower != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Tower))
	}
	if m.NetworkLocation != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.NetworkLocation.Size()))
		n4, err := m.NetworkLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *AppInstListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n5, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *Appinstance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Appinstance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppName)))
		i += copy(dAtA[i:], m.AppName)
	}
	if len(m.AppVers) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppVers)))
		i += copy(dAtA[i:], m.AppVers)
	}
	if len(m.Fqdn) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Fqdn)))
		i += copy(dAtA[i:], m.Fqdn)
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CloudletLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletLocation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if len(m.CloudletName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CloudletName)))
		i += copy(dAtA[i:], m.CloudletName)
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n6, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Distance != 0 {
		dAtA[i] = 0x21
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Distance))))
		i += 8
	}
	if len(m.Appinstances) > 0 {
		for _, msg := range m.Appinstances {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AppInstListReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstListReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if len(m.Cloudlets) > 0 {
		for _, msg := range m.Cloudlets {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FqdnListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FqdnListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	return i, nil
}

func (m *AppFqdn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppFqdn) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppName)))
		i += copy(dAtA[i:], m.AppName)
	}
	if len(m.AppVers) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppVers)))
		i += copy(dAtA[i:], m.AppVers)
	}
	if len(m.DevName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.DevName)))
		i += copy(dAtA[i:], m.DevName)
	}
	if len(m.Fqdns) > 0 {
		for _, s := range m.Fqdns {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.AndroidPackageName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AndroidPackageName)))
		i += copy(dAtA[i:], m.AndroidPackageName)
	}
	return i, nil
}

func (m *FqdnListReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FqdnListReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.AppFqdns) > 0 {
		for _, msg := range m.AppFqdns {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Status != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *DynamicLocGroupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicLocGroupRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if m.LgId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.LgId))
	}
	if m.CommType != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CommType))
	}
	if len(m.UserData) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.UserData)))
		i += copy(dAtA[i:], m.UserData)
	}
	return i, nil
}

func (m *DynamicLocGroupReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicLocGroupReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.GroupCookie) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.GroupCookie)))
		i += copy(dAtA[i:], m.GroupCookie)
	}
	return i, nil
}

func (m *QosPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPosition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Positionid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Positionid))
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n7, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *QosPositionKpiRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPositionKpiRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if len(m.Positions) > 0 {
		for _, msg := range m.Positions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosPositionResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPositionResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Positionid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Positionid))
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n8, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.DluserthroughputMin != 0 {
		dAtA[i] = 0x1d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DluserthroughputMin))))
		i += 4
	}
	if m.DluserthroughputAvg != 0 {
		dAtA[i] = 0x25
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DluserthroughputAvg))))
		i += 4
	}
	if m.DluserthroughputMax != 0 {
		dAtA[i] = 0x2d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DluserthroughputMax))))
		i += 4
	}
	if m.UluserthroughputMin != 0 {
		dAtA[i] = 0x35
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UluserthroughputMin))))
		i += 4
	}
	if m.UluserthroughputAvg != 0 {
		dAtA[i] = 0x3d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UluserthroughputAvg))))
		i += 4
	}
	if m.UluserthroughputMax != 0 {
		dAtA[i] = 0x45
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UluserthroughputMax))))
		i += 4
	}
	if m.LatencyMin != 0 {
		dAtA[i] = 0x4d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LatencyMin))))
		i += 4
	}
	if m.LatencyAvg != 0 {
		dAtA[i] = 0x55
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LatencyAvg))))
		i += 4
	}
	if m.LatencyMax != 0 {
		dAtA[i] = 0x5d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LatencyMax))))
		i += 4
	}
	return i, nil
}

func (m *QosPositionKpiReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPositionKpiReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if len(m.PositionResults) > 0 {
		for _, msg := range m.PositionResults {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintAppClient(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RegisterClientRequest) CopyInFields(src *RegisterClientRequest) {
	m.Ver = src.Ver
	m.DevName = src.DevName
	m.AppName = src.AppName
	m.AppVers = src.AppVers
	m.CarrierName = src.CarrierName
	m.AuthToken = src.AuthToken
}

// Helper method to check that enums have valid values
func (m *RegisterClientRequest) ValidateEnums() error {
	return nil
}

func (m *RegisterClientReply) CopyInFields(src *RegisterClientReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	m.SessionCookie = src.SessionCookie
	m.TokenServerUri = src.TokenServerUri
}

// Helper method to check that enums have valid values
func (m *RegisterClientReply) ValidateEnums() error {
	if _, ok := ReplyStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	return nil
}

func (m *FindCloudletRequest) CopyInFields(src *FindCloudletRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.CarrierName = src.CarrierName
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		m.GpsLocation.Latitude = src.GpsLocation.Latitude
		m.GpsLocation.Longitude = src.GpsLocation.Longitude
		m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
		m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
		m.GpsLocation.Altitude = src.GpsLocation.Altitude
		m.GpsLocation.Course = src.GpsLocation.Course
		m.GpsLocation.Speed = src.GpsLocation.Speed
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &Timestamp{}
			m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
			m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
		}
	}
	m.DevName = src.DevName
	m.AppName = src.AppName
	m.AppVers = src.AppVers
}

// Helper method to check that enums have valid values
func (m *FindCloudletRequest) ValidateEnums() error {
	if err := m.GpsLocation.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *FindCloudletReply) CopyInFields(src *FindCloudletReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	m.Fqdn = src.Fqdn
	if src.Ports != nil {
		if m.Ports == nil || len(m.Ports) != len(src.Ports) {
			m.Ports = make([]*AppPort, len(src.Ports))
		}
		for i0 := 0; i0 < len(src.Ports); i0++ {
			m.Ports[i0] = &AppPort{}
			m.Ports[i0].Proto = src.Ports[i0].Proto
			m.Ports[i0].InternalPort = src.Ports[i0].InternalPort
			m.Ports[i0].PublicPort = src.Ports[i0].PublicPort
			m.Ports[i0].PathPrefix = src.Ports[i0].PathPrefix
			m.Ports[i0].FqdnPrefix = src.Ports[i0].FqdnPrefix
		}
	}
	if src.CloudletLocation != nil {
		m.CloudletLocation = &Loc{}
		m.CloudletLocation.Latitude = src.CloudletLocation.Latitude
		m.CloudletLocation.Longitude = src.CloudletLocation.Longitude
		m.CloudletLocation.HorizontalAccuracy = src.CloudletLocation.HorizontalAccuracy
		m.CloudletLocation.VerticalAccuracy = src.CloudletLocation.VerticalAccuracy
		m.CloudletLocation.Altitude = src.CloudletLocation.Altitude
		m.CloudletLocation.Course = src.CloudletLocation.Course
		m.CloudletLocation.Speed = src.CloudletLocation.Speed
		if src.CloudletLocation.Timestamp != nil {
			m.CloudletLocation.Timestamp = &Timestamp{}
			m.CloudletLocation.Timestamp.Seconds = src.CloudletLocation.Timestamp.Seconds
			m.CloudletLocation.Timestamp.Nanos = src.CloudletLocation.Timestamp.Nanos
		}
	}
}

// Helper method to check that enums have valid values
func (m *FindCloudletReply) ValidateEnums() error {
	if _, ok := FindCloudletReply_FindStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	for _, e := range m.Ports {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if err := m.CloudletLocation.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *VerifyLocationRequest) CopyInFields(src *VerifyLocationRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.CarrierName = src.CarrierName
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		m.GpsLocation.Latitude = src.GpsLocation.Latitude
		m.GpsLocation.Longitude = src.GpsLocation.Longitude
		m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
		m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
		m.GpsLocation.Altitude = src.GpsLocation.Altitude
		m.GpsLocation.Course = src.GpsLocation.Course
		m.GpsLocation.Speed = src.GpsLocation.Speed
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &Timestamp{}
			m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
			m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
		}
	}
	m.VerifyLocToken = src.VerifyLocToken
}

// Helper method to check that enums have valid values
func (m *VerifyLocationRequest) ValidateEnums() error {
	if err := m.GpsLocation.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *VerifyLocationReply) CopyInFields(src *VerifyLocationReply) {
	m.Ver = src.Ver
	m.TowerStatus = src.TowerStatus
	m.GpsLocationStatus = src.GpsLocationStatus
	m.GpsLocationAccuracyKm = src.GpsLocationAccuracyKm
}

// Helper method to check that enums have valid values
func (m *VerifyLocationReply) ValidateEnums() error {
	if _, ok := VerifyLocationReply_TowerStatus_name[int32(m.TowerStatus)]; !ok {
		return errors.New("invalid TowerStatus")
	}
	if _, ok := VerifyLocationReply_GPSLocationStatus_name[int32(m.GpsLocationStatus)]; !ok {
		return errors.New("invalid GpsLocationStatus")
	}
	return nil
}

func (m *GetLocationRequest) CopyInFields(src *GetLocationRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.CarrierName = src.CarrierName
}

// Helper method to check that enums have valid values
func (m *GetLocationRequest) ValidateEnums() error {
	return nil
}

func (m *GetLocationReply) CopyInFields(src *GetLocationReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	m.CarrierName = src.CarrierName
	m.Tower = src.Tower
	if src.NetworkLocation != nil {
		m.NetworkLocation = &Loc{}
		m.NetworkLocation.Latitude = src.NetworkLocation.Latitude
		m.NetworkLocation.Longitude = src.NetworkLocation.Longitude
		m.NetworkLocation.HorizontalAccuracy = src.NetworkLocation.HorizontalAccuracy
		m.NetworkLocation.VerticalAccuracy = src.NetworkLocation.VerticalAccuracy
		m.NetworkLocation.Altitude = src.NetworkLocation.Altitude
		m.NetworkLocation.Course = src.NetworkLocation.Course
		m.NetworkLocation.Speed = src.NetworkLocation.Speed
		if src.NetworkLocation.Timestamp != nil {
			m.NetworkLocation.Timestamp = &Timestamp{}
			m.NetworkLocation.Timestamp.Seconds = src.NetworkLocation.Timestamp.Seconds
			m.NetworkLocation.Timestamp.Nanos = src.NetworkLocation.Timestamp.Nanos
		}
	}
}

// Helper method to check that enums have valid values
func (m *GetLocationReply) ValidateEnums() error {
	if _, ok := GetLocationReply_LocStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	if err := m.NetworkLocation.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *AppInstListRequest) CopyInFields(src *AppInstListRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.CarrierName = src.CarrierName
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		m.GpsLocation.Latitude = src.GpsLocation.Latitude
		m.GpsLocation.Longitude = src.GpsLocation.Longitude
		m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
		m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
		m.GpsLocation.Altitude = src.GpsLocation.Altitude
		m.GpsLocation.Course = src.GpsLocation.Course
		m.GpsLocation.Speed = src.GpsLocation.Speed
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &Timestamp{}
			m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
			m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
		}
	}
}

// Helper method to check that enums have valid values
func (m *AppInstListRequest) ValidateEnums() error {
	if err := m.GpsLocation.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *Appinstance) CopyInFields(src *Appinstance) {
	m.AppName = src.AppName
	m.AppVers = src.AppVers
	m.Fqdn = src.Fqdn
	if src.Ports != nil {
		if m.Ports == nil || len(m.Ports) != len(src.Ports) {
			m.Ports = make([]*AppPort, len(src.Ports))
		}
		for i0 := 0; i0 < len(src.Ports); i0++ {
			m.Ports[i0] = &AppPort{}
			m.Ports[i0].Proto = src.Ports[i0].Proto
			m.Ports[i0].InternalPort = src.Ports[i0].InternalPort
			m.Ports[i0].PublicPort = src.Ports[i0].PublicPort
			m.Ports[i0].PathPrefix = src.Ports[i0].PathPrefix
			m.Ports[i0].FqdnPrefix = src.Ports[i0].FqdnPrefix
		}
	}
}

// Helper method to check that enums have valid values
func (m *Appinstance) ValidateEnums() error {
	for _, e := range m.Ports {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *CloudletLocation) CopyInFields(src *CloudletLocation) {
	m.CarrierName = src.CarrierName
	m.CloudletName = src.CloudletName
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		m.GpsLocation.Latitude = src.GpsLocation.Latitude
		m.GpsLocation.Longitude = src.GpsLocation.Longitude
		m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
		m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
		m.GpsLocation.Altitude = src.GpsLocation.Altitude
		m.GpsLocation.Course = src.GpsLocation.Course
		m.GpsLocation.Speed = src.GpsLocation.Speed
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &Timestamp{}
			m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
			m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
		}
	}
	m.Distance = src.Distance
	if src.Appinstances != nil {
		if m.Appinstances == nil || len(m.Appinstances) != len(src.Appinstances) {
			m.Appinstances = make([]*Appinstance, len(src.Appinstances))
		}
		for i0 := 0; i0 < len(src.Appinstances); i0++ {
			m.Appinstances[i0] = &Appinstance{}
			m.Appinstances[i0].AppName = src.Appinstances[i0].AppName
			m.Appinstances[i0].AppVers = src.Appinstances[i0].AppVers
			m.Appinstances[i0].Fqdn = src.Appinstances[i0].Fqdn
			if src.Appinstances[i0].Ports != nil {
				if m.Appinstances[i0].Ports == nil || len(m.Appinstances[i0].Ports) != len(src.Appinstances[i0].Ports) {
					m.Appinstances[i0].Ports = make([]*AppPort, len(src.Appinstances[i0].Ports))
				}
				for i1 := 0; i1 < len(src.Appinstances[i0].Ports); i1++ {
					m.Appinstances[i0].Ports[i1] = &AppPort{}
					m.Appinstances[i0].Ports[i1].Proto = src.Appinstances[i0].Ports[i1].Proto
					m.Appinstances[i0].Ports[i1].InternalPort = src.Appinstances[i0].Ports[i1].InternalPort
					m.Appinstances[i0].Ports[i1].PublicPort = src.Appinstances[i0].Ports[i1].PublicPort
					m.Appinstances[i0].Ports[i1].PathPrefix = src.Appinstances[i0].Ports[i1].PathPrefix
					m.Appinstances[i0].Ports[i1].FqdnPrefix = src.Appinstances[i0].Ports[i1].FqdnPrefix
				}
			}
		}
	}
}

// Helper method to check that enums have valid values
func (m *CloudletLocation) ValidateEnums() error {
	if err := m.GpsLocation.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.Appinstances {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *AppInstListReply) CopyInFields(src *AppInstListReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	if src.Cloudlets != nil {
		if m.Cloudlets == nil || len(m.Cloudlets) != len(src.Cloudlets) {
			m.Cloudlets = make([]*CloudletLocation, len(src.Cloudlets))
		}
		for i0 := 0; i0 < len(src.Cloudlets); i0++ {
			m.Cloudlets[i0] = &CloudletLocation{}
			m.Cloudlets[i0].CarrierName = src.Cloudlets[i0].CarrierName
			m.Cloudlets[i0].CloudletName = src.Cloudlets[i0].CloudletName
			if src.Cloudlets[i0].GpsLocation != nil {
				m.Cloudlets[i0].GpsLocation = &Loc{}
				m.Cloudlets[i0].GpsLocation.Latitude = src.Cloudlets[i0].GpsLocation.Latitude
				m.Cloudlets[i0].GpsLocation.Longitude = src.Cloudlets[i0].GpsLocation.Longitude
				m.Cloudlets[i0].GpsLocation.HorizontalAccuracy = src.Cloudlets[i0].GpsLocation.HorizontalAccuracy
				m.Cloudlets[i0].GpsLocation.VerticalAccuracy = src.Cloudlets[i0].GpsLocation.VerticalAccuracy
				m.Cloudlets[i0].GpsLocation.Altitude = src.Cloudlets[i0].GpsLocation.Altitude
				m.Cloudlets[i0].GpsLocation.Course = src.Cloudlets[i0].GpsLocation.Course
				m.Cloudlets[i0].GpsLocation.Speed = src.Cloudlets[i0].GpsLocation.Speed
				if src.Cloudlets[i0].GpsLocation.Timestamp != nil {
					m.Cloudlets[i0].GpsLocation.Timestamp = &Timestamp{}
					m.Cloudlets[i0].GpsLocation.Timestamp.Seconds = src.Cloudlets[i0].GpsLocation.Timestamp.Seconds
					m.Cloudlets[i0].GpsLocation.Timestamp.Nanos = src.Cloudlets[i0].GpsLocation.Timestamp.Nanos
				}
			}
			m.Cloudlets[i0].Distance = src.Cloudlets[i0].Distance
			if src.Cloudlets[i0].Appinstances != nil {
				if m.Cloudlets[i0].Appinstances == nil || len(m.Cloudlets[i0].Appinstances) != len(src.Cloudlets[i0].Appinstances) {
					m.Cloudlets[i0].Appinstances = make([]*Appinstance, len(src.Cloudlets[i0].Appinstances))
				}
				for i1 := 0; i1 < len(src.Cloudlets[i0].Appinstances); i1++ {
					m.Cloudlets[i0].Appinstances[i1] = &Appinstance{}
					m.Cloudlets[i0].Appinstances[i1].AppName = src.Cloudlets[i0].Appinstances[i1].AppName
					m.Cloudlets[i0].Appinstances[i1].AppVers = src.Cloudlets[i0].Appinstances[i1].AppVers
					m.Cloudlets[i0].Appinstances[i1].Fqdn = src.Cloudlets[i0].Appinstances[i1].Fqdn
					if src.Cloudlets[i0].Appinstances[i1].Ports != nil {
						if m.Cloudlets[i0].Appinstances[i1].Ports == nil || len(m.Cloudlets[i0].Appinstances[i1].Ports) != len(src.Cloudlets[i0].Appinstances[i1].Ports) {
							m.Cloudlets[i0].Appinstances[i1].Ports = make([]*AppPort, len(src.Cloudlets[i0].Appinstances[i1].Ports))
						}
						for i2 := 0; i2 < len(src.Cloudlets[i0].Appinstances[i1].Ports); i2++ {
							m.Cloudlets[i0].Appinstances[i1].Ports[i2] = &AppPort{}
							m.Cloudlets[i0].Appinstances[i1].Ports[i2].Proto = src.Cloudlets[i0].Appinstances[i1].Ports[i2].Proto
							m.Cloudlets[i0].Appinstances[i1].Ports[i2].InternalPort = src.Cloudlets[i0].Appinstances[i1].Ports[i2].InternalPort
							m.Cloudlets[i0].Appinstances[i1].Ports[i2].PublicPort = src.Cloudlets[i0].Appinstances[i1].Ports[i2].PublicPort
							m.Cloudlets[i0].Appinstances[i1].Ports[i2].PathPrefix = src.Cloudlets[i0].Appinstances[i1].Ports[i2].PathPrefix
							m.Cloudlets[i0].Appinstances[i1].Ports[i2].FqdnPrefix = src.Cloudlets[i0].Appinstances[i1].Ports[i2].FqdnPrefix
						}
					}
				}
			}
		}
	}
}

// Helper method to check that enums have valid values
func (m *AppInstListReply) ValidateEnums() error {
	if _, ok := AppInstListReply_AIStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	for _, e := range m.Cloudlets {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *FqdnListRequest) CopyInFields(src *FqdnListRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
}

// Helper method to check that enums have valid values
func (m *FqdnListRequest) ValidateEnums() error {
	return nil
}

func (m *AppFqdn) CopyInFields(src *AppFqdn) {
	m.AppName = src.AppName
	m.AppVers = src.AppVers
	m.DevName = src.DevName
	if m.Fqdns == nil || len(m.Fqdns) != len(src.Fqdns) {
		m.Fqdns = make([]string, len(src.Fqdns))
	}
	copy(m.Fqdns, src.Fqdns)
	m.AndroidPackageName = src.AndroidPackageName
}

// Helper method to check that enums have valid values
func (m *AppFqdn) ValidateEnums() error {
	return nil
}

func (m *FqdnListReply) CopyInFields(src *FqdnListReply) {
	m.Ver = src.Ver
	if src.AppFqdns != nil {
		if m.AppFqdns == nil || len(m.AppFqdns) != len(src.AppFqdns) {
			m.AppFqdns = make([]*AppFqdn, len(src.AppFqdns))
		}
		for i0 := 0; i0 < len(src.AppFqdns); i0++ {
			m.AppFqdns[i0] = &AppFqdn{}
			m.AppFqdns[i0].AppName = src.AppFqdns[i0].AppName
			m.AppFqdns[i0].AppVers = src.AppFqdns[i0].AppVers
			m.AppFqdns[i0].DevName = src.AppFqdns[i0].DevName
			if m.AppFqdns[i0].Fqdns == nil || len(m.AppFqdns[i0].Fqdns) != len(src.AppFqdns[i0].Fqdns) {
				m.AppFqdns[i0].Fqdns = make([]string, len(src.AppFqdns[i0].Fqdns))
			}
			copy(m.AppFqdns[i0].Fqdns, src.AppFqdns[i0].Fqdns)
			m.AppFqdns[i0].AndroidPackageName = src.AppFqdns[i0].AndroidPackageName
		}
	}
	m.Status = src.Status
}

// Helper method to check that enums have valid values
func (m *FqdnListReply) ValidateEnums() error {
	for _, e := range m.AppFqdns {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if _, ok := FqdnListReply_FLStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	return nil
}

func (m *DynamicLocGroupRequest) CopyInFields(src *DynamicLocGroupRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.LgId = src.LgId
	m.CommType = src.CommType
	m.UserData = src.UserData
}

// Helper method to check that enums have valid values
func (m *DynamicLocGroupRequest) ValidateEnums() error {
	if _, ok := DynamicLocGroupRequest_DlgCommType_name[int32(m.CommType)]; !ok {
		return errors.New("invalid CommType")
	}
	return nil
}

func (m *DynamicLocGroupReply) CopyInFields(src *DynamicLocGroupReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	m.ErrorCode = src.ErrorCode
	m.GroupCookie = src.GroupCookie
}

// Helper method to check that enums have valid values
func (m *DynamicLocGroupReply) ValidateEnums() error {
	if _, ok := ReplyStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	return nil
}

func (m *QosPosition) CopyInFields(src *QosPosition) {
	m.Positionid = src.Positionid
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		m.GpsLocation.Latitude = src.GpsLocation.Latitude
		m.GpsLocation.Longitude = src.GpsLocation.Longitude
		m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
		m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
		m.GpsLocation.Altitude = src.GpsLocation.Altitude
		m.GpsLocation.Course = src.GpsLocation.Course
		m.GpsLocation.Speed = src.GpsLocation.Speed
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &Timestamp{}
			m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
			m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
		}
	}
}

// Helper method to check that enums have valid values
func (m *QosPosition) ValidateEnums() error {
	if err := m.GpsLocation.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *QosPositionKpiRequest) CopyInFields(src *QosPositionKpiRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	if src.Positions != nil {
		if m.Positions == nil || len(m.Positions) != len(src.Positions) {
			m.Positions = make([]*QosPosition, len(src.Positions))
		}
		for i0 := 0; i0 < len(src.Positions); i0++ {
			m.Positions[i0] = &QosPosition{}
			m.Positions[i0].Positionid = src.Positions[i0].Positionid
			if src.Positions[i0].GpsLocation != nil {
				m.Positions[i0].GpsLocation = &Loc{}
				m.Positions[i0].GpsLocation.Latitude = src.Positions[i0].GpsLocation.Latitude
				m.Positions[i0].GpsLocation.Longitude = src.Positions[i0].GpsLocation.Longitude
				m.Positions[i0].GpsLocation.HorizontalAccuracy = src.Positions[i0].GpsLocation.HorizontalAccuracy
				m.Positions[i0].GpsLocation.VerticalAccuracy = src.Positions[i0].GpsLocation.VerticalAccuracy
				m.Positions[i0].GpsLocation.Altitude = src.Positions[i0].GpsLocation.Altitude
				m.Positions[i0].GpsLocation.Course = src.Positions[i0].GpsLocation.Course
				m.Positions[i0].GpsLocation.Speed = src.Positions[i0].GpsLocation.Speed
				if src.Positions[i0].GpsLocation.Timestamp != nil {
					m.Positions[i0].GpsLocation.Timestamp = &Timestamp{}
					m.Positions[i0].GpsLocation.Timestamp.Seconds = src.Positions[i0].GpsLocation.Timestamp.Seconds
					m.Positions[i0].GpsLocation.Timestamp.Nanos = src.Positions[i0].GpsLocation.Timestamp.Nanos
				}
			}
		}
	}
}

// Helper method to check that enums have valid values
func (m *QosPositionKpiRequest) ValidateEnums() error {
	for _, e := range m.Positions {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *QosPositionResult) CopyInFields(src *QosPositionResult) {
	m.Positionid = src.Positionid
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		m.GpsLocation.Latitude = src.GpsLocation.Latitude
		m.GpsLocation.Longitude = src.GpsLocation.Longitude
		m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
		m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
		m.GpsLocation.Altitude = src.GpsLocation.Altitude
		m.GpsLocation.Course = src.GpsLocation.Course
		m.GpsLocation.Speed = src.GpsLocation.Speed
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &Timestamp{}
			m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
			m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
		}
	}
	m.DluserthroughputMin = src.DluserthroughputMin
	m.DluserthroughputAvg = src.DluserthroughputAvg
	m.DluserthroughputMax = src.DluserthroughputMax
	m.UluserthroughputMin = src.UluserthroughputMin
	m.UluserthroughputAvg = src.UluserthroughputAvg
	m.UluserthroughputMax = src.UluserthroughputMax
	m.LatencyMin = src.LatencyMin
	m.LatencyAvg = src.LatencyAvg
	m.LatencyMax = src.LatencyMax
}

// Helper method to check that enums have valid values
func (m *QosPositionResult) ValidateEnums() error {
	if err := m.GpsLocation.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *QosPositionKpiReply) CopyInFields(src *QosPositionKpiReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	if src.PositionResults != nil {
		if m.PositionResults == nil || len(m.PositionResults) != len(src.PositionResults) {
			m.PositionResults = make([]*QosPositionResult, len(src.PositionResults))
		}
		for i0 := 0; i0 < len(src.PositionResults); i0++ {
			m.PositionResults[i0] = &QosPositionResult{}
			m.PositionResults[i0].Positionid = src.PositionResults[i0].Positionid
			if src.PositionResults[i0].GpsLocation != nil {
				m.PositionResults[i0].GpsLocation = &Loc{}
				m.PositionResults[i0].GpsLocation.Latitude = src.PositionResults[i0].GpsLocation.Latitude
				m.PositionResults[i0].GpsLocation.Longitude = src.PositionResults[i0].GpsLocation.Longitude
				m.PositionResults[i0].GpsLocation.HorizontalAccuracy = src.PositionResults[i0].GpsLocation.HorizontalAccuracy
				m.PositionResults[i0].GpsLocation.VerticalAccuracy = src.PositionResults[i0].GpsLocation.VerticalAccuracy
				m.PositionResults[i0].GpsLocation.Altitude = src.PositionResults[i0].GpsLocation.Altitude
				m.PositionResults[i0].GpsLocation.Course = src.PositionResults[i0].GpsLocation.Course
				m.PositionResults[i0].GpsLocation.Speed = src.PositionResults[i0].GpsLocation.Speed
				if src.PositionResults[i0].GpsLocation.Timestamp != nil {
					m.PositionResults[i0].GpsLocation.Timestamp = &Timestamp{}
					m.PositionResults[i0].GpsLocation.Timestamp.Seconds = src.PositionResults[i0].GpsLocation.Timestamp.Seconds
					m.PositionResults[i0].GpsLocation.Timestamp.Nanos = src.PositionResults[i0].GpsLocation.Timestamp.Nanos
				}
			}
			m.PositionResults[i0].DluserthroughputMin = src.PositionResults[i0].DluserthroughputMin
			m.PositionResults[i0].DluserthroughputAvg = src.PositionResults[i0].DluserthroughputAvg
			m.PositionResults[i0].DluserthroughputMax = src.PositionResults[i0].DluserthroughputMax
			m.PositionResults[i0].UluserthroughputMin = src.PositionResults[i0].UluserthroughputMin
			m.PositionResults[i0].UluserthroughputAvg = src.PositionResults[i0].UluserthroughputAvg
			m.PositionResults[i0].UluserthroughputMax = src.PositionResults[i0].UluserthroughputMax
			m.PositionResults[i0].LatencyMin = src.PositionResults[i0].LatencyMin
			m.PositionResults[i0].LatencyAvg = src.PositionResults[i0].LatencyAvg
			m.PositionResults[i0].LatencyMax = src.PositionResults[i0].LatencyMax
		}
	}
}

// Helper method to check that enums have valid values
func (m *QosPositionKpiReply) ValidateEnums() error {
	if _, ok := ReplyStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	for _, e := range m.PositionResults {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

var IDTypesStrings = []string{
	"ID_UNDEFINED",
	"IMEI",
	"MSISDN",
	"IPADDR",
}

const (
	IDTypesID_UNDEFINED uint64 = 1 << 0
	IDTypesIMEI         uint64 = 1 << 1
	IDTypesMSISDN       uint64 = 1 << 2
	IDTypesIPADDR       uint64 = 1 << 3
)

var IDTypes_CamelName = map[int32]string{
	// ID_UNDEFINED -> IdUndefined
	0: "IdUndefined",
	// IMEI -> Imei
	1: "Imei",
	// MSISDN -> Msisdn
	2: "Msisdn",
	// IPADDR -> Ipaddr
	3: "Ipaddr",
}
var IDTypes_CamelValue = map[string]int32{
	"IdUndefined": 0,
	"Imei":        1,
	"Msisdn":      2,
	"Ipaddr":      3,
}

func (e *IDTypes) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := IDTypes_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = IDTypes_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = IDTypes(val)
	return nil
}

func (e IDTypes) MarshalYAML() (interface{}, error) {
	return proto.EnumName(IDTypes_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *IDTypes) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := IDTypes_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = IDTypes_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = IDTypes(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = IDTypes(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

var ReplyStatusStrings = []string{
	"RS_UNDEFINED",
	"RS_SUCCESS",
	"RS_FAIL",
}

const (
	ReplyStatusRS_UNDEFINED uint64 = 1 << 0
	ReplyStatusRS_SUCCESS   uint64 = 1 << 1
	ReplyStatusRS_FAIL      uint64 = 1 << 2
)

var ReplyStatus_CamelName = map[int32]string{
	// RS_UNDEFINED -> RsUndefined
	0: "RsUndefined",
	// RS_SUCCESS -> RsSuccess
	1: "RsSuccess",
	// RS_FAIL -> RsFail
	2: "RsFail",
}
var ReplyStatus_CamelValue = map[string]int32{
	"RsUndefined": 0,
	"RsSuccess":   1,
	"RsFail":      2,
}

func (e *ReplyStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := ReplyStatus_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = ReplyStatus_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = ReplyStatus(val)
	return nil
}

func (e ReplyStatus) MarshalYAML() (interface{}, error) {
	return proto.EnumName(ReplyStatus_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *ReplyStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := ReplyStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = ReplyStatus_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = ReplyStatus(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = ReplyStatus(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

var FindStatusStrings = []string{
	"FIND_UNKNOWN",
	"FIND_FOUND",
	"FIND_NOTFOUND",
}

const (
	FindStatusFIND_UNKNOWN  uint64 = 1 << 0
	FindStatusFIND_FOUND    uint64 = 1 << 1
	FindStatusFIND_NOTFOUND uint64 = 1 << 2
)

var FindCloudletReply_FindStatus_CamelName = map[int32]string{
	// FIND_UNKNOWN -> FindUnknown
	0: "FindUnknown",
	// FIND_FOUND -> FindFound
	1: "FindFound",
	// FIND_NOTFOUND -> FindNotfound
	2: "FindNotfound",
}
var FindCloudletReply_FindStatus_CamelValue = map[string]int32{
	"FindUnknown":  0,
	"FindFound":    1,
	"FindNotfound": 2,
}

func (e *FindCloudletReply_FindStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := FindCloudletReply_FindStatus_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = FindCloudletReply_FindStatus_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = FindCloudletReply_FindStatus(val)
	return nil
}

func (e FindCloudletReply_FindStatus) MarshalYAML() (interface{}, error) {
	return proto.EnumName(FindCloudletReply_FindStatus_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *FindCloudletReply_FindStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := FindCloudletReply_FindStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = FindCloudletReply_FindStatus_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = FindCloudletReply_FindStatus(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = FindCloudletReply_FindStatus(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

var TowerStatusStrings = []string{
	"TOWER_UNKNOWN",
	"CONNECTED_TO_SPECIFIED_TOWER",
	"NOT_CONNECTED_TO_SPECIFIED_TOWER",
}

const (
	TowerStatusTOWER_UNKNOWN                    uint64 = 1 << 0
	TowerStatusCONNECTED_TO_SPECIFIED_TOWER     uint64 = 1 << 1
	TowerStatusNOT_CONNECTED_TO_SPECIFIED_TOWER uint64 = 1 << 2
)

var VerifyLocationReply_TowerStatus_CamelName = map[int32]string{
	// TOWER_UNKNOWN -> TowerUnknown
	0: "TowerUnknown",
	// CONNECTED_TO_SPECIFIED_TOWER -> ConnectedToSpecifiedTower
	1: "ConnectedToSpecifiedTower",
	// NOT_CONNECTED_TO_SPECIFIED_TOWER -> NotConnectedToSpecifiedTower
	2: "NotConnectedToSpecifiedTower",
}
var VerifyLocationReply_TowerStatus_CamelValue = map[string]int32{
	"TowerUnknown":                 0,
	"ConnectedToSpecifiedTower":    1,
	"NotConnectedToSpecifiedTower": 2,
}

func (e *VerifyLocationReply_TowerStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := VerifyLocationReply_TowerStatus_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = VerifyLocationReply_TowerStatus_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = VerifyLocationReply_TowerStatus(val)
	return nil
}

func (e VerifyLocationReply_TowerStatus) MarshalYAML() (interface{}, error) {
	return proto.EnumName(VerifyLocationReply_TowerStatus_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *VerifyLocationReply_TowerStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := VerifyLocationReply_TowerStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = VerifyLocationReply_TowerStatus_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = VerifyLocationReply_TowerStatus(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = VerifyLocationReply_TowerStatus(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

var GPSLocationStatusStrings = []string{
	"LOC_UNKNOWN",
	"LOC_VERIFIED",
	"LOC_MISMATCH_SAME_COUNTRY",
	"LOC_MISMATCH_OTHER_COUNTRY",
	"LOC_ROAMING_COUNTRY_MATCH",
	"LOC_ROAMING_COUNTRY_MISMATCH",
	"LOC_ERROR_UNAUTHORIZED",
	"LOC_ERROR_OTHER",
}

const (
	GPSLocationStatusLOC_UNKNOWN                  uint64 = 1 << 0
	GPSLocationStatusLOC_VERIFIED                 uint64 = 1 << 1
	GPSLocationStatusLOC_MISMATCH_SAME_COUNTRY    uint64 = 1 << 2
	GPSLocationStatusLOC_MISMATCH_OTHER_COUNTRY   uint64 = 1 << 3
	GPSLocationStatusLOC_ROAMING_COUNTRY_MATCH    uint64 = 1 << 4
	GPSLocationStatusLOC_ROAMING_COUNTRY_MISMATCH uint64 = 1 << 5
	GPSLocationStatusLOC_ERROR_UNAUTHORIZED       uint64 = 1 << 6
	GPSLocationStatusLOC_ERROR_OTHER              uint64 = 1 << 7
)

var VerifyLocationReply_GPSLocationStatus_CamelName = map[int32]string{
	// LOC_UNKNOWN -> LocUnknown
	0: "LocUnknown",
	// LOC_VERIFIED -> LocVerified
	1: "LocVerified",
	// LOC_MISMATCH_SAME_COUNTRY -> LocMismatchSameCountry
	2: "LocMismatchSameCountry",
	// LOC_MISMATCH_OTHER_COUNTRY -> LocMismatchOtherCountry
	3: "LocMismatchOtherCountry",
	// LOC_ROAMING_COUNTRY_MATCH -> LocRoamingCountryMatch
	4: "LocRoamingCountryMatch",
	// LOC_ROAMING_COUNTRY_MISMATCH -> LocRoamingCountryMismatch
	5: "LocRoamingCountryMismatch",
	// LOC_ERROR_UNAUTHORIZED -> LocErrorUnauthorized
	6: "LocErrorUnauthorized",
	// LOC_ERROR_OTHER -> LocErrorOther
	7: "LocErrorOther",
}
var VerifyLocationReply_GPSLocationStatus_CamelValue = map[string]int32{
	"LocUnknown":                0,
	"LocVerified":               1,
	"LocMismatchSameCountry":    2,
	"LocMismatchOtherCountry":   3,
	"LocRoamingCountryMatch":    4,
	"LocRoamingCountryMismatch": 5,
	"LocErrorUnauthorized":      6,
	"LocErrorOther":             7,
}

func (e *VerifyLocationReply_GPSLocationStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := VerifyLocationReply_GPSLocationStatus_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = VerifyLocationReply_GPSLocationStatus_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = VerifyLocationReply_GPSLocationStatus(val)
	return nil
}

func (e VerifyLocationReply_GPSLocationStatus) MarshalYAML() (interface{}, error) {
	return proto.EnumName(VerifyLocationReply_GPSLocationStatus_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *VerifyLocationReply_GPSLocationStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := VerifyLocationReply_GPSLocationStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = VerifyLocationReply_GPSLocationStatus_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = VerifyLocationReply_GPSLocationStatus(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = VerifyLocationReply_GPSLocationStatus(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

var LocStatusStrings = []string{
	"LOC_UNKNOWN",
	"LOC_FOUND",
	"LOC_DENIED",
}

const (
	LocStatusLOC_UNKNOWN uint64 = 1 << 0
	LocStatusLOC_FOUND   uint64 = 1 << 1
	LocStatusLOC_DENIED  uint64 = 1 << 2
)

var GetLocationReply_LocStatus_CamelName = map[int32]string{
	// LOC_UNKNOWN -> LocUnknown
	0: "LocUnknown",
	// LOC_FOUND -> LocFound
	1: "LocFound",
	// LOC_DENIED -> LocDenied
	2: "LocDenied",
}
var GetLocationReply_LocStatus_CamelValue = map[string]int32{
	"LocUnknown": 0,
	"LocFound":   1,
	"LocDenied":  2,
}

func (e *GetLocationReply_LocStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := GetLocationReply_LocStatus_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = GetLocationReply_LocStatus_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = GetLocationReply_LocStatus(val)
	return nil
}

func (e GetLocationReply_LocStatus) MarshalYAML() (interface{}, error) {
	return proto.EnumName(GetLocationReply_LocStatus_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *GetLocationReply_LocStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := GetLocationReply_LocStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = GetLocationReply_LocStatus_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = GetLocationReply_LocStatus(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = GetLocationReply_LocStatus(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

var AIStatusStrings = []string{
	"AI_UNDEFINED",
	"AI_SUCCESS",
	"AI_FAIL",
}

const (
	AIStatusAI_UNDEFINED uint64 = 1 << 0
	AIStatusAI_SUCCESS   uint64 = 1 << 1
	AIStatusAI_FAIL      uint64 = 1 << 2
)

var AppInstListReply_AIStatus_CamelName = map[int32]string{
	// AI_UNDEFINED -> AiUndefined
	0: "AiUndefined",
	// AI_SUCCESS -> AiSuccess
	1: "AiSuccess",
	// AI_FAIL -> AiFail
	2: "AiFail",
}
var AppInstListReply_AIStatus_CamelValue = map[string]int32{
	"AiUndefined": 0,
	"AiSuccess":   1,
	"AiFail":      2,
}

func (e *AppInstListReply_AIStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := AppInstListReply_AIStatus_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = AppInstListReply_AIStatus_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = AppInstListReply_AIStatus(val)
	return nil
}

func (e AppInstListReply_AIStatus) MarshalYAML() (interface{}, error) {
	return proto.EnumName(AppInstListReply_AIStatus_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *AppInstListReply_AIStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := AppInstListReply_AIStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = AppInstListReply_AIStatus_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = AppInstListReply_AIStatus(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = AppInstListReply_AIStatus(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

var FLStatusStrings = []string{
	"FL_UNDEFINED",
	"FL_SUCCESS",
	"FL_FAIL",
}

const (
	FLStatusFL_UNDEFINED uint64 = 1 << 0
	FLStatusFL_SUCCESS   uint64 = 1 << 1
	FLStatusFL_FAIL      uint64 = 1 << 2
)

var FqdnListReply_FLStatus_CamelName = map[int32]string{
	// FL_UNDEFINED -> FlUndefined
	0: "FlUndefined",
	// FL_SUCCESS -> FlSuccess
	1: "FlSuccess",
	// FL_FAIL -> FlFail
	2: "FlFail",
}
var FqdnListReply_FLStatus_CamelValue = map[string]int32{
	"FlUndefined": 0,
	"FlSuccess":   1,
	"FlFail":      2,
}

func (e *FqdnListReply_FLStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := FqdnListReply_FLStatus_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = FqdnListReply_FLStatus_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = FqdnListReply_FLStatus(val)
	return nil
}

func (e FqdnListReply_FLStatus) MarshalYAML() (interface{}, error) {
	return proto.EnumName(FqdnListReply_FLStatus_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *FqdnListReply_FLStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := FqdnListReply_FLStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = FqdnListReply_FLStatus_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = FqdnListReply_FLStatus(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = FqdnListReply_FLStatus(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

var DlgCommTypeStrings = []string{
	"DLG_UNDEFINED",
	"DLG_SECURE",
	"DLG_OPEN",
}

const (
	DlgCommTypeDLG_UNDEFINED uint64 = 1 << 0
	DlgCommTypeDLG_SECURE    uint64 = 1 << 1
	DlgCommTypeDLG_OPEN      uint64 = 1 << 2
)

var DynamicLocGroupRequest_DlgCommType_CamelName = map[int32]string{
	// DLG_UNDEFINED -> DlgUndefined
	0: "DlgUndefined",
	// DLG_SECURE -> DlgSecure
	1: "DlgSecure",
	// DLG_OPEN -> DlgOpen
	2: "DlgOpen",
}
var DynamicLocGroupRequest_DlgCommType_CamelValue = map[string]int32{
	"DlgUndefined": 0,
	"DlgSecure":    1,
	"DlgOpen":      2,
}

func (e *DynamicLocGroupRequest_DlgCommType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := DynamicLocGroupRequest_DlgCommType_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = DynamicLocGroupRequest_DlgCommType_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = DynamicLocGroupRequest_DlgCommType(val)
	return nil
}

func (e DynamicLocGroupRequest_DlgCommType) MarshalYAML() (interface{}, error) {
	return proto.EnumName(DynamicLocGroupRequest_DlgCommType_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *DynamicLocGroupRequest_DlgCommType) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := DynamicLocGroupRequest_DlgCommType_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = DynamicLocGroupRequest_DlgCommType_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = DynamicLocGroupRequest_DlgCommType(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = DynamicLocGroupRequest_DlgCommType(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

type MatchOptions struct {
	// Filter will ignore 0 or nil fields on the passed in object
	Filter bool
	// IgnoreBackend will ignore fields that were marked backend in .proto
	IgnoreBackend bool
	// Sort repeated (arrays) of Key objects so matching does not
	// fail due to order.
	SortArrayedKeys bool
}

type MatchOpt func(*MatchOptions)

func MatchFilter() MatchOpt {
	return func(opts *MatchOptions) {
		opts.Filter = true
	}
}

func MatchIgnoreBackend() MatchOpt {
	return func(opts *MatchOptions) {
		opts.IgnoreBackend = true
	}
}

func MatchSortArrayedKeys() MatchOpt {
	return func(opts *MatchOptions) {
		opts.SortArrayedKeys = true
	}
}

func applyMatchOptions(opts *MatchOptions, args ...MatchOpt) {
	for _, f := range args {
		f(opts)
	}
}

// DecodeHook for use with the mapstructure package.
// Allows decoding to handle protobuf enums that are
// represented as strings.
func EnumDecodeHook(from, to reflect.Type, data interface{}) (interface{}, error) {
	if from.Kind() != reflect.String {
		return data, nil
	}
	switch to {
	case reflect.TypeOf(LProto(0)):
		if en, ok := LProto_CamelValue[util.CamelCase(data.(string))]; ok {
			return en, nil
		}
	case reflect.TypeOf(IDTypes(0)):
		if en, ok := IDTypes_CamelValue[util.CamelCase(data.(string))]; ok {
			return en, nil
		}
	case reflect.TypeOf(ReplyStatus(0)):
		if en, ok := ReplyStatus_CamelValue[util.CamelCase(data.(string))]; ok {
			return en, nil
		}
	}
	return data, nil
}

func (m *RegisterClientRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.DevName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppVers)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AuthToken)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *RegisterClientReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.TokenServerUri)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *FindCloudletRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.DevName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppVers)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *FindCloudletReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	l = len(m.Fqdn)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if m.CloudletLocation != nil {
		l = m.CloudletLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *VerifyLocationRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.VerifyLocToken)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *VerifyLocationReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.TowerStatus != 0 {
		n += 1 + sovAppClient(uint64(m.TowerStatus))
	}
	if m.GpsLocationStatus != 0 {
		n += 1 + sovAppClient(uint64(m.GpsLocationStatus))
	}
	if m.GpsLocationAccuracyKm != 0 {
		n += 9
	}
	return n
}

func (m *GetLocationRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *GetLocationReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Tower != 0 {
		n += 1 + sovAppClient(uint64(m.Tower))
	}
	if m.NetworkLocation != nil {
		l = m.NetworkLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *AppInstListRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *Appinstance) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppVers)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.Fqdn)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *CloudletLocation) Size() (n int) {
	var l int
	_ = l
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CloudletName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Distance != 0 {
		n += 9
	}
	if len(m.Appinstances) > 0 {
		for _, e := range m.Appinstances {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *AppInstListReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	if len(m.Cloudlets) > 0 {
		for _, e := range m.Cloudlets {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *FqdnListRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *AppFqdn) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppVers)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.DevName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Fqdns) > 0 {
		for _, s := range m.Fqdns {
			l = len(s)
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	l = len(m.AndroidPackageName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *FqdnListReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if len(m.AppFqdns) > 0 {
		for _, e := range m.AppFqdns {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	return n
}

func (m *DynamicLocGroupRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.LgId != 0 {
		n += 1 + sovAppClient(uint64(m.LgId))
	}
	if m.CommType != 0 {
		n += 1 + sovAppClient(uint64(m.CommType))
	}
	l = len(m.UserData)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *DynamicLocGroupReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAppClient(uint64(m.ErrorCode))
	}
	l = len(m.GroupCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *QosPosition) Size() (n int) {
	var l int
	_ = l
	if m.Positionid != 0 {
		n += 1 + sovAppClient(uint64(m.Positionid))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *QosPositionKpiRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Positions) > 0 {
		for _, e := range m.Positions {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *QosPositionResult) Size() (n int) {
	var l int
	_ = l
	if m.Positionid != 0 {
		n += 1 + sovAppClient(uint64(m.Positionid))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.DluserthroughputMin != 0 {
		n += 5
	}
	if m.DluserthroughputAvg != 0 {
		n += 5
	}
	if m.DluserthroughputMax != 0 {
		n += 5
	}
	if m.UluserthroughputMin != 0 {
		n += 5
	}
	if m.UluserthroughputAvg != 0 {
		n += 5
	}
	if m.UluserthroughputMax != 0 {
		n += 5
	}
	if m.LatencyMin != 0 {
		n += 5
	}
	if m.LatencyAvg != 0 {
		n += 5
	}
	if m.LatencyMax != 0 {
		n += 5
	}
	return n
}

func (m *QosPositionKpiReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	if len(m.PositionResults) > 0 {
		for _, e := range m.PositionResults {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func sovAppClient(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAppClient(x uint64) (n int) {
	return sovAppClient(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RegisterClientRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterClientRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterClientRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterClientReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterClientReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterClientReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (ReplyStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenServerUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenServerUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindCloudletRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindCloudletRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindCloudletRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindCloudletReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindCloudletReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindCloudletReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (FindCloudletReply_FindStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fqdn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fqdn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &AppPort{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloudletLocation == nil {
				m.CloudletLocation = &Loc{}
			}
			if err := m.CloudletLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyLocationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyLocationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyLocationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyLocToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifyLocToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyLocationReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyLocationReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyLocationReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TowerStatus", wireType)
			}
			m.TowerStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TowerStatus |= (VerifyLocationReply_TowerStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocationStatus", wireType)
			}
			m.GpsLocationStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpsLocationStatus |= (VerifyLocationReply_GPSLocationStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocationAccuracyKm", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GpsLocationAccuracyKm = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLocationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLocationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLocationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLocationReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLocationReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLocationReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (GetLocationReply_LocStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tower", wireType)
			}
			m.Tower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tower |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkLocation == nil {
				m.NetworkLocation = &Loc{}
			}
			if err := m.NetworkLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Appinstance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Appinstance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Appinstance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fqdn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fqdn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &AppPort{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudletName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Distance = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appinstances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Appinstances = append(m.Appinstances, &Appinstance{})
			if err := m.Appinstances[len(m.Appinstances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstListReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstListReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstListReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (AppInstListReply_AIStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cloudlets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cloudlets = append(m.Cloudlets, &CloudletLocation{})
			if err := m.Cloudlets[len(m.Cloudlets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FqdnListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FqdnListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FqdnListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppFqdn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppFqdn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppFqdn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fqdns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fqdns = append(m.Fqdns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AndroidPackageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AndroidPackageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FqdnListReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FqdnListReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FqdnListReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppFqdns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppFqdns = append(m.AppFqdns, &AppFqdn{})
			if err := m.AppFqdns[len(m.AppFqdns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (FqdnListReply_FLStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicLocGroupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicLocGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicLocGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LgId", wireType)
			}
			m.LgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LgId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommType", wireType)
			}
			m.CommType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommType |= (DynamicLocGroupRequest_DlgCommType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicLocGroupReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicLocGroupReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicLocGroupReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (ReplyStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positionid", wireType)
			}
			m.Positionid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Positionid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPositionKpiRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPositionKpiRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPositionKpiRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Positions = append(m.Positions, &QosPosition{})
			if err := m.Positions[len(m.Positions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPositionResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPositionResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPositionResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positionid", wireType)
			}
			m.Positionid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Positionid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DluserthroughputMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DluserthroughputMin = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DluserthroughputAvg", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DluserthroughputAvg = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DluserthroughputMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DluserthroughputMax = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UluserthroughputMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UluserthroughputMin = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UluserthroughputAvg", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UluserthroughputAvg = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UluserthroughputMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UluserthroughputMax = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LatencyMin = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyAvg", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LatencyAvg = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LatencyMax = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPositionKpiReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPositionKpiReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPositionKpiReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (ReplyStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PositionResults = append(m.PositionResults, &QosPositionResult{})
			if err := m.PositionResults[len(m.PositionResults)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAppClient(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAppClient
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAppClient(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAppClient = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAppClient   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("app-client.proto", fileDescriptorAppClient) }

var fileDescriptorAppClient = []byte{
	// 1941 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x59, 0x41, 0x6f, 0xeb, 0x58,
	0x15, 0x9e, 0xeb, 0x34, 0x6d, 0x73, 0x92, 0xa6, 0xee, 0x6d, 0x3b, 0x74, 0x32, 0xd3, 0xd2, 0x31,
	0x3c, 0x51, 0x3a, 0xbc, 0xf6, 0xcd, 0x1b, 0xc4, 0x68, 0x86, 0x99, 0x01, 0x93, 0x38, 0xad, 0xe7,
	0xa5, 0x4e, 0x71, 0x92, 0xf7, 0x34, 0x08, 0xc9, 0xf2, 0xd8, 0xf7, 0xa5, 0x56, 0x13, 0xdb, 0xcf,
	0x76, 0x32, 0xed, 0x82, 0x0d, 0x0f, 0x09, 0xc1, 0x06, 0x10, 0x42, 0xec, 0x58, 0xb0, 0x63, 0x3b,
	0x1b, 0x36, 0x88, 0xf5, 0x2c, 0x41, 0xfc, 0x00, 0xe0, 0x09, 0xc1, 0x3f, 0x60, 0x87, 0x84, 0xee,
	0xb5, 0xdd, 0xd8, 0x8e, 0x13, 0xa5, 0xcc, 0x3c, 0xa4, 0xd9, 0xc5, 0xe7, 0xde, 0x73, 0xce, 0x77,
	0xcf, 0xfd, 0xee, 0x39, 0xe7, 0xde, 0x00, 0xaf, 0xbb, 0xee, 0x5d, 0x63, 0x60, 0x11, 0x3b, 0x38,
	0x72, 0x3d, 0x27, 0x70, 0xf0, 0x8e, 0x69, 0xf9, 0x81, 0x67, 0x7d, 0x38, 0x0a, 0x88, 0xa9, 0x0d,
	0xf5, 0xc0, 0xb8, 0xd0, 0x88, 0xdd, 0xb7, 0x6c, 0x52, 0x7b, 0xa5, 0xef, 0x38, 0xfd, 0x01, 0x39,
	0xd6, 0x5d, 0xeb, 0x58, 0xb7, 0x6d, 0x27, 0xd0, 0x03, 0xcb, 0xb1, 0xfd, 0x50, 0xaf, 0x56, 0x1a,
	0x38, 0x46, 0xf4, 0x73, 0x5d, 0x77, 0x5d, 0xc3, 0x19, 0x0e, 0x1d, 0x3b, 0x14, 0x08, 0x7f, 0x40,
	0xb0, 0xad, 0x92, 0xbe, 0xe5, 0x07, 0xc4, 0xab, 0x33, 0x67, 0x2a, 0x79, 0x32, 0x22, 0x7e, 0x80,
	0x79, 0x28, 0x8c, 0x89, 0xb7, 0x83, 0xf6, 0xd1, 0xc1, 0x9a, 0x4a, 0x7f, 0xe2, 0x97, 0x60, 0xd5,
	0x24, 0x63, 0xcd, 0xd6, 0x87, 0x64, 0x87, 0xdb, 0x47, 0x07, 0x25, 0x75, 0xc5, 0x24, 0x63, 0x45,
	0x1f, 0x12, 0x3a, 0xa4, 0xbb, 0x6e, 0x38, 0x54, 0x08, 0x87, 0x74, 0xd7, 0x4d, 0x0e, 0x8d, 0x89,
	0xe7, 0xef, 0x2c, 0xdd, 0x0c, 0x3d, 0x24, 0x9e, 0x8f, 0x5f, 0x85, 0x8a, 0xa1, 0x7b, 0x9e, 0x45,
	0xbc, 0x50, 0xb3, 0xc8, 0x86, 0xcb, 0x91, 0x8c, 0x69, 0xef, 0x02, 0xe8, 0xa3, 0xe0, 0x42, 0x0b,
	0x9c, 0x4b, 0x62, 0xef, 0x2c, 0xb3, 0x09, 0x25, 0x2a, 0xe9, 0x52, 0x81, 0xf0, 0x7b, 0x04, 0x9b,
	0x59, 0xf8, 0xee, 0xe0, 0x3a, 0x07, 0xfc, 0xbb, 0xb0, 0xec, 0x07, 0x7a, 0x30, 0xf2, 0x19, 0xf4,
	0xea, 0xfd, 0x3b, 0x47, 0xb3, 0xa2, 0x79, 0xc4, 0x4c, 0x74, 0xd8, 0x64, 0x35, 0x52, 0xc2, 0x77,
	0xa0, 0xea, 0x13, 0xdf, 0xb7, 0x1c, 0x5b, 0x33, 0x1c, 0xe7, 0xd2, 0x8a, 0x97, 0xb9, 0x16, 0x49,
	0xeb, 0x4c, 0x88, 0x0f, 0x80, 0x67, 0x48, 0x35, 0x9f, 0x78, 0x63, 0xe2, 0x69, 0x23, 0xcf, 0x8a,
	0x16, 0x5d, 0x65, 0xf2, 0x0e, 0x13, 0xf7, 0x3c, 0x4b, 0xf8, 0x11, 0x07, 0x9b, 0x4d, 0xcb, 0x36,
	0xeb, 0x03, 0x67, 0x64, 0x0e, 0xc8, 0x9c, 0xb0, 0x4f, 0xbb, 0xe6, 0xf2, 0x5c, 0x67, 0x83, 0x59,
	0x98, 0x0e, 0xe6, 0xb7, 0xa1, 0xd2, 0x77, 0x7d, 0x6d, 0xe0, 0x18, 0x8c, 0x1f, 0x0c, 0x59, 0xf9,
	0xfe, 0xee, 0xec, 0x48, 0xb4, 0x1c, 0x43, 0x2d, 0xf7, 0x5d, 0xbf, 0x15, 0x69, 0xa4, 0x28, 0x50,
	0x9c, 0x4d, 0x81, 0xe5, 0xd9, 0x14, 0x58, 0x49, 0x51, 0x40, 0xf8, 0x33, 0x07, 0x1b, 0xe9, 0x30,
	0xe4, 0x6f, 0x9f, 0x92, 0xd9, 0xbe, 0x6f, 0xcc, 0x06, 0x3d, 0x65, 0x8e, 0x49, 0x32, 0xfb, 0x89,
	0x61, 0xe9, 0xf1, 0x13, 0xd3, 0x8e, 0xa2, 0xc4, 0x7e, 0xe3, 0x37, 0xa1, 0xe8, 0x3a, 0x5e, 0x40,
	0x69, 0x5a, 0x38, 0x28, 0xdf, 0x7f, 0x75, 0xb6, 0x0b, 0xd1, 0x75, 0xcf, 0x1d, 0x2f, 0x50, 0xc3,
	0xf9, 0xf8, 0x7d, 0xd8, 0x30, 0x22, 0x87, 0x93, 0xe0, 0x16, 0x17, 0x09, 0x2e, 0x1f, 0xeb, 0xc5,
	0x11, 0x16, 0x44, 0x80, 0x09, 0x5c, 0xcc, 0x43, 0xa5, 0x29, 0x2b, 0x0d, 0xad, 0xa7, 0x3c, 0x50,
	0xda, 0x8f, 0x14, 0xfe, 0x05, 0x5c, 0x05, 0x60, 0x92, 0x66, 0xbb, 0xa7, 0x34, 0x78, 0x84, 0x37,
	0x60, 0x8d, 0x7d, 0x2b, 0xed, 0x6e, 0x28, 0xe2, 0x84, 0xbf, 0x22, 0xd8, 0x7e, 0x48, 0x3c, 0xeb,
	0xf1, 0x75, 0x6c, 0xf5, 0xf3, 0x41, 0xae, 0x03, 0xe0, 0xc7, 0x0c, 0x36, 0x35, 0x12, 0x9d, 0xf8,
	0x90, 0x64, 0xd5, 0x71, 0xbc, 0x9c, 0xf0, 0xd8, 0x3f, 0x2d, 0xc2, 0x66, 0x76, 0x85, 0xf9, 0xbc,
	0xf9, 0x3e, 0x54, 0x02, 0xe7, 0x23, 0xe2, 0x69, 0x29, 0xf6, 0xbc, 0x35, 0x1b, 0x55, 0x8e, 0xd9,
	0xa3, 0x2e, 0xb5, 0x10, 0x11, 0xa8, 0x1c, 0x4c, 0x3e, 0xb0, 0x03, 0x9b, 0xc9, 0x35, 0xc7, 0x4e,
	0x0a, 0xcc, 0xc9, 0xb7, 0x6e, 0xe7, 0xe4, 0xe4, 0xbc, 0x13, 0x0b, 0x22, 0x57, 0x1b, 0x89, 0xe0,
	0x44, 0x0e, 0xdf, 0x84, 0x9d, 0x94, 0x43, 0xdd, 0x30, 0x46, 0x9e, 0x6e, 0x5c, 0x6b, 0x97, 0x43,
	0x16, 0x70, 0xa4, 0x6e, 0x27, 0x94, 0xc4, 0x68, 0xf4, 0xc1, 0x50, 0xb8, 0x80, 0x72, 0x62, 0x15,
	0x94, 0x35, 0xdd, 0xf6, 0x23, 0x49, 0x4d, 0x10, 0x6b, 0x1f, 0x5e, 0xa9, 0xb7, 0x15, 0x45, 0xaa,
	0x77, 0xa5, 0x86, 0xd6, 0x6d, 0x6b, 0x9d, 0x73, 0xa9, 0x2e, 0x37, 0x65, 0xf6, 0xf1, 0x48, 0x52,
	0x79, 0x84, 0xbf, 0x0c, 0xfb, 0x4a, 0xbb, 0xab, 0xcd, 0x9d, 0xc5, 0x09, 0xff, 0x42, 0xb0, 0x31,
	0xb5, 0x16, 0xbc, 0x0e, 0xe5, 0x56, 0xbb, 0x9e, 0x70, 0xc7, 0x43, 0x85, 0x0a, 0x1e, 0x4a, 0x2a,
	0x53, 0xe7, 0x11, 0xde, 0x85, 0x97, 0xa8, 0xe4, 0x4c, 0xee, 0x9c, 0x89, 0xdd, 0xfa, 0xa9, 0xd6,
	0x11, 0xcf, 0x24, 0xad, 0xde, 0xee, 0x29, 0x5d, 0xf5, 0x03, 0x9e, 0xc3, 0x7b, 0x50, 0x4b, 0x0d,
	0xb7, 0xbb, 0xa7, 0x92, 0x7a, 0x33, 0x5e, 0x88, 0xd5, 0xd5, 0xb6, 0x78, 0x26, 0x2b, 0x27, 0xf1,
	0x80, 0xc6, 0x26, 0xf3, 0x4b, 0x74, 0x79, 0xb9, 0xc3, 0x91, 0x39, 0xbe, 0x88, 0x6b, 0xf0, 0x22,
	0x9d, 0x21, 0xa9, 0x6a, 0x9b, 0xc6, 0x45, 0xec, 0x75, 0x4f, 0xdb, 0xaa, 0xfc, 0x3d, 0xa9, 0xc1,
	0x2f, 0xe3, 0x4d, 0x58, 0x9f, 0x8c, 0x31, 0xcf, 0xfc, 0x8a, 0xe0, 0x02, 0x3e, 0x99, 0x9c, 0xdc,
	0xff, 0xc3, 0x19, 0x13, 0x3e, 0xe6, 0x80, 0x4f, 0xb9, 0xcc, 0x27, 0x7d, 0x2b, 0x93, 0x2c, 0xbf,
	0x3e, 0x9b, 0x89, 0x59, 0x6b, 0xf4, 0x54, 0x66, 0x52, 0xe5, 0x02, 0x67, 0x7f, 0x0b, 0x8a, 0xec,
	0x58, 0x30, 0x0e, 0x2e, 0xa9, 0xe1, 0x07, 0x3e, 0x05, 0xde, 0x26, 0xc1, 0x47, 0x8e, 0x77, 0x79,
	0xcb, 0xac, 0xb8, 0x1e, 0xa9, 0xdd, 0x24, 0xc5, 0x6f, 0x42, 0xe9, 0x06, 0xd7, 0x34, 0x95, 0xd6,
	0xa0, 0x44, 0x05, 0x71, 0x46, 0xac, 0x02, 0xd0, 0xcf, 0x86, 0xa4, 0x50, 0x5e, 0x71, 0xc2, 0xc7,
	0x08, 0xb0, 0xe8, 0xba, 0xb2, 0xed, 0x07, 0x2d, 0xcb, 0xff, 0x7c, 0x14, 0x5a, 0xe1, 0xe7, 0x08,
	0xca, 0xa2, 0xeb, 0x5a, 0xb6, 0x1f, 0xe8, 0xb6, 0x91, 0xae, 0xae, 0x68, 0x76, 0x75, 0xe5, 0xd2,
	0x0d, 0xd6, 0x67, 0x59, 0xe5, 0x84, 0xa7, 0x1c, 0xf0, 0xf5, 0x4c, 0xb9, 0x9a, 0x0a, 0x06, 0x9a,
	0x0e, 0xc6, 0x97, 0x60, 0xed, 0xa6, 0x3a, 0x26, 0x7a, 0xc7, 0x4a, 0x2c, 0xcc, 0x8d, 0x58, 0xe1,
	0xd6, 0xd5, 0xa3, 0x06, 0xab, 0x74, 0x32, 0x8d, 0x56, 0x94, 0x0a, 0x6f, 0xbe, 0xb1, 0x0c, 0x15,
	0x7d, 0x12, 0x4c, 0x7f, 0xa7, 0xc8, 0x96, 0x7e, 0x67, 0xee, 0xd2, 0xe3, 0xd9, 0x6a, 0x4a, 0x55,
	0xf8, 0x37, 0x02, 0x3e, 0xc5, 0xa6, 0xfc, 0x23, 0xf8, 0x20, 0x73, 0x04, 0xdf, 0x98, 0xeb, 0x2b,
	0x65, 0xed, 0x48, 0x94, 0x33, 0x27, 0xf0, 0x14, 0x4a, 0x71, 0xb0, 0x68, 0x71, 0xa1, 0xd8, 0x0f,
	0x67, 0xdb, 0xcb, 0xee, 0x91, 0x3a, 0x51, 0x16, 0xde, 0x82, 0xd5, 0xd8, 0x3a, 0xcd, 0xc0, 0xa2,
	0xac, 0xf5, 0x94, 0x86, 0xd4, 0x94, 0x15, 0xa9, 0x11, 0xf6, 0x16, 0xa2, 0xac, 0x75, 0x7a, 0xf5,
	0xba, 0xd4, 0xe9, 0xf0, 0x08, 0x97, 0x61, 0x45, 0x94, 0xb5, 0xa6, 0x28, 0xb7, 0x78, 0x4e, 0x78,
	0x1f, 0xd6, 0x9b, 0x4f, 0x4c, 0xfb, 0xb3, 0x38, 0x42, 0xc2, 0x6f, 0x11, 0xac, 0x88, 0xae, 0x4b,
	0xed, 0xfd, 0x8f, 0xcc, 0x4e, 0x36, 0xa2, 0x85, 0x74, 0x23, 0xba, 0x05, 0x45, 0x4a, 0xf4, 0x90,
	0xe0, 0x25, 0x35, 0xfc, 0xc0, 0xf7, 0x60, 0x4b, 0xb7, 0x4d, 0xcf, 0xb1, 0x4c, 0xcd, 0xd5, 0x8d,
	0x4b, 0xbd, 0x4f, 0x92, 0x5d, 0x2c, 0x8e, 0xc6, 0xce, 0xc3, 0x21, 0x96, 0x6c, 0xff, 0x89, 0x60,
	0x6d, 0xb2, 0xe2, 0xfc, 0x6d, 0x7e, 0x0f, 0x4a, 0x14, 0x61, 0xe8, 0xaf, 0xb0, 0xc0, 0x81, 0xa2,
	0x06, 0x55, 0xba, 0xaa, 0x26, 0x43, 0x75, 0x7a, 0x43, 0x93, 0x25, 0x46, 0x93, 0x7b, 0x73, 0xda,
	0xda, 0x24, 0x94, 0xa3, 0x66, 0x2b, 0xcd, 0x11, 0xba, 0xb3, 0xb1, 0x8c, 0x75, 0x8d, 0xad, 0xec,
	0xce, 0x36, 0x5b, 0xe9, 0x9d, 0x6d, 0xb6, 0xe2, 0x9d, 0xfd, 0x0d, 0x07, 0x2f, 0x36, 0xae, 0x6d,
	0x7d, 0x68, 0x19, 0x2d, 0xc7, 0x38, 0xf1, 0x9c, 0x91, 0xfb, 0xa9, 0x93, 0xe4, 0x26, 0x14, 0x07,
	0x7d, 0xcd, 0x32, 0xd9, 0xe6, 0x2c, 0xa9, 0x4b, 0x83, 0xbe, 0x6c, 0xe2, 0x0f, 0xa0, 0x44, 0x2f,
	0x9f, 0x5a, 0x70, 0xed, 0x92, 0x9d, 0x32, 0x5b, 0xf0, 0x3b, 0xb3, 0x17, 0x9c, 0x0f, 0xe9, 0xa8,
	0x31, 0xe8, 0xd7, 0x9d, 0xe1, 0xb0, 0x7b, 0xed, 0x12, 0x75, 0xd5, 0x88, 0x7e, 0xe1, 0x97, 0xa1,
	0x34, 0xf2, 0x89, 0xa7, 0x99, 0x7a, 0xa0, 0xef, 0x54, 0x18, 0xa2, 0x55, 0x2a, 0x68, 0xe8, 0x81,
	0x2e, 0xbc, 0x07, 0xe5, 0x84, 0x16, 0x6d, 0x7e, 0x1a, 0xad, 0x93, 0x6c, 0x7c, 0xa8, 0xa8, 0x23,
	0xd5, 0x7b, 0xaa, 0xc4, 0x23, 0x5c, 0x81, 0x55, 0xfa, 0xdd, 0x3e, 0x97, 0x14, 0x9e, 0x13, 0x7e,
	0x87, 0x60, 0x6b, 0x0a, 0xcd, 0x73, 0xb9, 0x66, 0xee, 0x02, 0x10, 0xcf, 0x73, 0x3c, 0xcd, 0x70,
	0xcc, 0x90, 0xd8, 0x6b, 0x6a, 0x89, 0x49, 0xea, 0x8e, 0xc9, 0x4a, 0x4f, 0x9f, 0x7a, 0x8f, 0x43,
	0x1f, 0x5d, 0x98, 0x99, 0x2c, 0x3a, 0x5a, 0x0e, 0x94, 0xbf, 0xeb, 0xf8, 0xe7, 0x8e, 0x6f, 0xb1,
	0xac, 0xb8, 0x07, 0xe0, 0x46, 0xbf, 0x2d, 0x93, 0x01, 0x2d, 0xa8, 0x09, 0xc9, 0x54, 0xde, 0xe5,
	0x6e, 0x5d, 0xa9, 0x7e, 0x85, 0x60, 0x3b, 0xe1, 0xf1, 0x81, 0x6b, 0x7d, 0x6a, 0xf2, 0xd4, 0xa1,
	0x14, 0x43, 0x8c, 0x4f, 0xd5, 0x9c, 0x38, 0x26, 0x9c, 0xab, 0x13, 0x3d, 0xe1, 0xa7, 0x4b, 0xb0,
	0x91, 0x1c, 0x22, 0xfe, 0x68, 0x10, 0x3c, 0xff, 0x78, 0xe0, 0xd7, 0x61, 0xcb, 0x1c, 0x50, 0xea,
	0x05, 0x17, 0x9e, 0x33, 0xea, 0x5f, 0xb8, 0xa3, 0x40, 0x1b, 0x5a, 0x61, 0x45, 0xe3, 0xd4, 0xcd,
	0xec, 0xd8, 0x99, 0x95, 0xaf, 0xa2, 0x8f, 0xfb, 0x2c, 0x27, 0xe4, 0xa8, 0x88, 0xe3, 0x7e, 0xbe,
	0x17, 0xfd, 0x8a, 0x31, 0x22, 0xcf, 0x8b, 0x7e, 0x45, 0x55, 0x46, 0x79, 0xc0, 0x96, 0x43, 0x95,
	0x51, 0x3e, 0xb0, 0x51, 0x1e, 0xb0, 0x95, 0x7c, 0x95, 0x08, 0xd8, 0x28, 0x0f, 0xd8, 0xea, 0x0c,
	0x2f, 0xfa, 0x15, 0xfe, 0x22, 0x94, 0x07, 0x7a, 0x40, 0x6c, 0xe3, 0x9a, 0xe1, 0x29, 0xb1, 0x99,
	0x10, 0x89, 0x28, 0x8c, 0xc4, 0x04, 0xea, 0x1d, 0x52, 0x13, 0xa8, 0xd3, 0xa4, 0x05, 0xfd, 0x8a,
	0xa5, 0x96, 0x84, 0x05, 0xfd, 0x4a, 0xf8, 0x23, 0x82, 0xcd, 0x2c, 0x49, 0x9f, 0xcb, 0x01, 0x7e,
	0x08, 0x7c, 0xcc, 0x26, 0xcd, 0x63, 0x94, 0x8b, 0x19, 0xfc, 0xda, 0x62, 0x0c, 0x66, 0x3a, 0xea,
	0xba, 0x9b, 0xfa, 0xf6, 0x0f, 0xdf, 0x85, 0x15, 0xb9, 0x41, 0xb3, 0x17, 0xcb, 0xee, 0x72, 0x23,
	0x95, 0xbd, 0x56, 0x61, 0x49, 0x3e, 0x93, 0x64, 0x1e, 0x61, 0x80, 0xe5, 0xb3, 0x8e, 0xdc, 0x69,
	0x28, 0x3c, 0x47, 0x7f, 0xcb, 0xe7, 0x62, 0xa3, 0xa1, 0xf2, 0x85, 0xc3, 0x77, 0xa0, 0x9c, 0x40,
	0x4b, 0x4d, 0xa8, 0x9d, 0x6c, 0x02, 0x54, 0x3b, 0xe9, 0x02, 0xa1, 0x76, 0xa2, 0x02, 0x71, 0xff,
	0x3f, 0xab, 0x50, 0x3d, 0xa3, 0x80, 0x25, 0x86, 0x57, 0x74, 0x2d, 0xfc, 0x33, 0x04, 0xd5, 0xf4,
	0xc3, 0x1b, 0x3e, 0x9e, 0x17, 0xa9, 0x9c, 0x17, 0xc6, 0xda, 0xdd, 0xc5, 0x15, 0xdc, 0xc1, 0xb5,
	0xb0, 0xfb, 0xc3, 0xbf, 0xfc, 0xe3, 0x97, 0xdc, 0x17, 0x04, 0x7c, 0x3c, 0x7e, 0xfd, 0xd8, 0x8b,
	0x26, 0x84, 0x0f, 0xa4, 0x6f, 0xa3, 0x43, 0xfc, 0x63, 0x04, 0x95, 0xe4, 0xd3, 0x0f, 0xbe, 0xbb,
	0xe8, 0x13, 0x51, 0x88, 0xe6, 0xb5, 0x5b, 0xbc, 0x28, 0x09, 0x2f, 0x33, 0x2c, 0xdb, 0x02, 0x4f,
	0xb1, 0x3c, 0xb6, 0x6c, 0x33, 0x6e, 0xb1, 0x28, 0x12, 0x1a, 0x9b, 0xf4, 0x0d, 0x7f, 0x5e, 0x6c,
	0x72, 0x5f, 0x6a, 0xe6, 0xc5, 0x26, 0xe7, 0xf1, 0x20, 0x1d, 0x9b, 0xf0, 0xb1, 0x24, 0x4e, 0x61,
	0x14, 0xd1, 0x53, 0x04, 0xe5, 0xc4, 0x4d, 0x0f, 0x7f, 0x6d, 0xc1, 0x0b, 0x61, 0x88, 0xe5, 0x70,
	0xf1, 0xeb, 0xa3, 0x50, 0x63, 0x40, 0xb6, 0x84, 0x75, 0x0a, 0xa4, 0x4f, 0x82, 0x24, 0x8a, 0x5f,
	0x20, 0xa8, 0x8a, 0xa6, 0xd9, 0xf3, 0x89, 0xd7, 0x75, 0x58, 0x15, 0xc5, 0xf7, 0x6e, 0x5b, 0xfe,
	0x6b, 0x47, 0xb7, 0xd0, 0x98, 0x8a, 0x8c, 0x6e, 0x9a, 0x2c, 0xfd, 0x38, 0xac, 0x62, 0x52, 0x4c,
	0x3f, 0x41, 0x50, 0x3d, 0x21, 0x41, 0xa2, 0x07, 0x9f, 0x17, 0x9c, 0xe9, 0x6b, 0xe4, 0xbc, 0xe0,
	0x64, 0x1b, 0xfb, 0x34, 0x96, 0x3e, 0x09, 0xa2, 0x8b, 0xc5, 0xc0, 0xf2, 0x19, 0x6f, 0x7e, 0xc0,
	0x36, 0x29, 0xee, 0xf3, 0xf0, 0x57, 0x17, 0xe9, 0x05, 0x43, 0x10, 0x5f, 0x59, 0xb0, 0x6d, 0x9c,
	0xda, 0x1e, 0xda, 0xb8, 0xc6, 0xee, 0x7f, 0x8d, 0x60, 0xe3, 0x84, 0x04, 0xe9, 0x34, 0x39, 0x8f,
	0xb9, 0xb9, 0x55, 0x7f, 0x1e, 0x73, 0x73, 0x32, 0xb0, 0xb0, 0xcf, 0x10, 0xd5, 0x84, 0xed, 0x08,
	0xd1, 0x13, 0xc7, 0x8f, 0x73, 0xdf, 0xa5, 0x6b, 0xbd, 0x8d, 0x0e, 0xef, 0xa1, 0xef, 0xf0, 0x9f,
	0xfc, 0x7d, 0xef, 0x85, 0x4f, 0x9e, 0xed, 0xa1, 0x3f, 0x3d, 0xdb, 0x43, 0x7f, 0x7b, 0xb6, 0x87,
	0x3e, 0x5c, 0x66, 0xff, 0x5e, 0xbc, 0xf1, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xde, 0x14, 0x43,
	0x6d, 0x25, 0x19, 0x00, 0x00,
}
