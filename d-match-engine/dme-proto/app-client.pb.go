// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app-client.proto

package distributed_match_engine

import (
	context "context"
	encoding_binary "encoding/binary"
	"encoding/json"
	"errors"
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	proto "github.com/gogo/protobuf/proto"
	"github.com/mobiledgex/edge-cloud/util"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	"strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type IDTypes int32

const (
	IDTypes_ID_UNDEFINED IDTypes = 0
	IDTypes_IMEI         IDTypes = 1
	IDTypes_MSISDN       IDTypes = 2
	IDTypes_IPADDR       IDTypes = 3
)

var IDTypes_name = map[int32]string{
	0: "ID_UNDEFINED",
	1: "IMEI",
	2: "MSISDN",
	3: "IPADDR",
}

var IDTypes_value = map[string]int32{
	"ID_UNDEFINED": 0,
	"IMEI":         1,
	"MSISDN":       2,
	"IPADDR":       3,
}

func (x IDTypes) String() string {
	return proto.EnumName(IDTypes_name, int32(x))
}

func (IDTypes) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{0}
}

type ReplyStatus int32

const (
	ReplyStatus_RS_UNDEFINED ReplyStatus = 0
	ReplyStatus_RS_SUCCESS   ReplyStatus = 1
	ReplyStatus_RS_FAIL      ReplyStatus = 2
)

var ReplyStatus_name = map[int32]string{
	0: "RS_UNDEFINED",
	1: "RS_SUCCESS",
	2: "RS_FAIL",
}

var ReplyStatus_value = map[string]int32{
	"RS_UNDEFINED": 0,
	"RS_SUCCESS":   1,
	"RS_FAIL":      2,
}

func (x ReplyStatus) String() string {
	return proto.EnumName(ReplyStatus_name, int32(x))
}

func (ReplyStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{1}
}

type QosSessionProfile int32

const (
	// Specifies that no priority session should be created
	QosSessionProfile_QOS_NO_PRIORITY QosSessionProfile = 0
	// Corresponds to a specific set of network parameters for low latency that will be
	// negotiated with the network provider in advance
	QosSessionProfile_QOS_LOW_LATENCY QosSessionProfile = 1
	// Downlink traffic from AppInst to client is prioritized up to 20Mbps
	QosSessionProfile_QOS_THROUGHPUT_DOWN_S QosSessionProfile = 2
	// Downlink traffic from AppInst to client is prioritized up to 50Mbps
	QosSessionProfile_QOS_THROUGHPUT_DOWN_M QosSessionProfile = 3
	// Downlink traffic from AppInst to client is prioritized up to 100Mbps
	QosSessionProfile_QOS_THROUGHPUT_DOWN_L QosSessionProfile = 4
)

var QosSessionProfile_name = map[int32]string{
	0: "QOS_NO_PRIORITY",
	1: "QOS_LOW_LATENCY",
	2: "QOS_THROUGHPUT_DOWN_S",
	3: "QOS_THROUGHPUT_DOWN_M",
	4: "QOS_THROUGHPUT_DOWN_L",
}

var QosSessionProfile_value = map[string]int32{
	"QOS_NO_PRIORITY":       0,
	"QOS_LOW_LATENCY":       1,
	"QOS_THROUGHPUT_DOWN_S": 2,
	"QOS_THROUGHPUT_DOWN_M": 3,
	"QOS_THROUGHPUT_DOWN_L": 4,
}

func (x QosSessionProfile) String() string {
	return proto.EnumName(QosSessionProfile_name, int32(x))
}

func (QosSessionProfile) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{2}
}

type QosSessionProtocol int32

const (
	QosSessionProtocol_TCP QosSessionProtocol = 0
	QosSessionProtocol_UDP QosSessionProtocol = 1
	QosSessionProtocol_ANY QosSessionProtocol = 2
)

var QosSessionProtocol_name = map[int32]string{
	0: "TCP",
	1: "UDP",
	2: "ANY",
}

var QosSessionProtocol_value = map[string]int32{
	"TCP": 0,
	"UDP": 1,
	"ANY": 2,
}

func (x QosSessionProtocol) String() string {
	return proto.EnumName(QosSessionProtocol_name, int32(x))
}

func (QosSessionProtocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{3}
}

type FindCloudletReply_FindStatus int32

const (
	FindCloudletReply_FIND_UNKNOWN  FindCloudletReply_FindStatus = 0
	FindCloudletReply_FIND_FOUND    FindCloudletReply_FindStatus = 1
	FindCloudletReply_FIND_NOTFOUND FindCloudletReply_FindStatus = 2
)

var FindCloudletReply_FindStatus_name = map[int32]string{
	0: "FIND_UNKNOWN",
	1: "FIND_FOUND",
	2: "FIND_NOTFOUND",
}

var FindCloudletReply_FindStatus_value = map[string]int32{
	"FIND_UNKNOWN":  0,
	"FIND_FOUND":    1,
	"FIND_NOTFOUND": 2,
}

func (x FindCloudletReply_FindStatus) String() string {
	return proto.EnumName(FindCloudletReply_FindStatus_name, int32(x))
}

func (FindCloudletReply_FindStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{4, 0}
}

type FindCloudletReply_QosSessionResult int32

const (
	FindCloudletReply_QOS_NOT_ATTEMPTED   FindCloudletReply_QosSessionResult = 0
	FindCloudletReply_QOS_SESSION_CREATED FindCloudletReply_QosSessionResult = 1
	FindCloudletReply_QOS_SESSION_FAILED  FindCloudletReply_QosSessionResult = 2
)

var FindCloudletReply_QosSessionResult_name = map[int32]string{
	0: "QOS_NOT_ATTEMPTED",
	1: "QOS_SESSION_CREATED",
	2: "QOS_SESSION_FAILED",
}

var FindCloudletReply_QosSessionResult_value = map[string]int32{
	"QOS_NOT_ATTEMPTED":   0,
	"QOS_SESSION_CREATED": 1,
	"QOS_SESSION_FAILED":  2,
}

func (x FindCloudletReply_QosSessionResult) String() string {
	return proto.EnumName(FindCloudletReply_QosSessionResult_name, int32(x))
}

func (FindCloudletReply_QosSessionResult) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{4, 1}
}

type QosPrioritySessionDeleteReply_DeleteStatus int32

const (
	QosPrioritySessionDeleteReply_QDEL_UNKNOWN   QosPrioritySessionDeleteReply_DeleteStatus = 0
	QosPrioritySessionDeleteReply_QDEL_DELETED   QosPrioritySessionDeleteReply_DeleteStatus = 1
	QosPrioritySessionDeleteReply_QDEL_NOT_FOUND QosPrioritySessionDeleteReply_DeleteStatus = 2
)

var QosPrioritySessionDeleteReply_DeleteStatus_name = map[int32]string{
	0: "QDEL_UNKNOWN",
	1: "QDEL_DELETED",
	2: "QDEL_NOT_FOUND",
}

var QosPrioritySessionDeleteReply_DeleteStatus_value = map[string]int32{
	"QDEL_UNKNOWN":   0,
	"QDEL_DELETED":   1,
	"QDEL_NOT_FOUND": 2,
}

func (x QosPrioritySessionDeleteReply_DeleteStatus) String() string {
	return proto.EnumName(QosPrioritySessionDeleteReply_DeleteStatus_name, int32(x))
}

func (QosPrioritySessionDeleteReply_DeleteStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{8, 0}
}

// Status of the reply
type VerifyLocationReply_TowerStatus int32

const (
	VerifyLocationReply_TOWER_UNKNOWN                    VerifyLocationReply_TowerStatus = 0
	VerifyLocationReply_CONNECTED_TO_SPECIFIED_TOWER     VerifyLocationReply_TowerStatus = 1
	VerifyLocationReply_NOT_CONNECTED_TO_SPECIFIED_TOWER VerifyLocationReply_TowerStatus = 2
)

var VerifyLocationReply_TowerStatus_name = map[int32]string{
	0: "TOWER_UNKNOWN",
	1: "CONNECTED_TO_SPECIFIED_TOWER",
	2: "NOT_CONNECTED_TO_SPECIFIED_TOWER",
}

var VerifyLocationReply_TowerStatus_value = map[string]int32{
	"TOWER_UNKNOWN":                    0,
	"CONNECTED_TO_SPECIFIED_TOWER":     1,
	"NOT_CONNECTED_TO_SPECIFIED_TOWER": 2,
}

func (x VerifyLocationReply_TowerStatus) String() string {
	return proto.EnumName(VerifyLocationReply_TowerStatus_name, int32(x))
}

func (VerifyLocationReply_TowerStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{10, 0}
}

type VerifyLocationReply_GPSLocationStatus int32

const (
	VerifyLocationReply_LOC_UNKNOWN                  VerifyLocationReply_GPSLocationStatus = 0
	VerifyLocationReply_LOC_VERIFIED                 VerifyLocationReply_GPSLocationStatus = 1
	VerifyLocationReply_LOC_MISMATCH_SAME_COUNTRY    VerifyLocationReply_GPSLocationStatus = 2
	VerifyLocationReply_LOC_MISMATCH_OTHER_COUNTRY   VerifyLocationReply_GPSLocationStatus = 3
	VerifyLocationReply_LOC_ROAMING_COUNTRY_MATCH    VerifyLocationReply_GPSLocationStatus = 4
	VerifyLocationReply_LOC_ROAMING_COUNTRY_MISMATCH VerifyLocationReply_GPSLocationStatus = 5
	VerifyLocationReply_LOC_ERROR_UNAUTHORIZED       VerifyLocationReply_GPSLocationStatus = 6
	VerifyLocationReply_LOC_ERROR_OTHER              VerifyLocationReply_GPSLocationStatus = 7
)

var VerifyLocationReply_GPSLocationStatus_name = map[int32]string{
	0: "LOC_UNKNOWN",
	1: "LOC_VERIFIED",
	2: "LOC_MISMATCH_SAME_COUNTRY",
	3: "LOC_MISMATCH_OTHER_COUNTRY",
	4: "LOC_ROAMING_COUNTRY_MATCH",
	5: "LOC_ROAMING_COUNTRY_MISMATCH",
	6: "LOC_ERROR_UNAUTHORIZED",
	7: "LOC_ERROR_OTHER",
}

var VerifyLocationReply_GPSLocationStatus_value = map[string]int32{
	"LOC_UNKNOWN":                  0,
	"LOC_VERIFIED":                 1,
	"LOC_MISMATCH_SAME_COUNTRY":    2,
	"LOC_MISMATCH_OTHER_COUNTRY":   3,
	"LOC_ROAMING_COUNTRY_MATCH":    4,
	"LOC_ROAMING_COUNTRY_MISMATCH": 5,
	"LOC_ERROR_UNAUTHORIZED":       6,
	"LOC_ERROR_OTHER":              7,
}

func (x VerifyLocationReply_GPSLocationStatus) String() string {
	return proto.EnumName(VerifyLocationReply_GPSLocationStatus_name, int32(x))
}

func (VerifyLocationReply_GPSLocationStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{10, 1}
}

// Status of the reply
type GetLocationReply_LocStatus int32

const (
	GetLocationReply_LOC_UNKNOWN GetLocationReply_LocStatus = 0
	GetLocationReply_LOC_FOUND   GetLocationReply_LocStatus = 1
	// The user does not allow his location to be tracked
	GetLocationReply_LOC_DENIED GetLocationReply_LocStatus = 2
)

var GetLocationReply_LocStatus_name = map[int32]string{
	0: "LOC_UNKNOWN",
	1: "LOC_FOUND",
	2: "LOC_DENIED",
}

var GetLocationReply_LocStatus_value = map[string]int32{
	"LOC_UNKNOWN": 0,
	"LOC_FOUND":   1,
	"LOC_DENIED":  2,
}

func (x GetLocationReply_LocStatus) String() string {
	return proto.EnumName(GetLocationReply_LocStatus_name, int32(x))
}

func (GetLocationReply_LocStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{12, 0}
}

// Status of the reply
type AppInstListReply_AIStatus int32

const (
	AppInstListReply_AI_UNDEFINED AppInstListReply_AIStatus = 0
	AppInstListReply_AI_SUCCESS   AppInstListReply_AIStatus = 1
	AppInstListReply_AI_FAIL      AppInstListReply_AIStatus = 2
)

var AppInstListReply_AIStatus_name = map[int32]string{
	0: "AI_UNDEFINED",
	1: "AI_SUCCESS",
	2: "AI_FAIL",
}

var AppInstListReply_AIStatus_value = map[string]int32{
	"AI_UNDEFINED": 0,
	"AI_SUCCESS":   1,
	"AI_FAIL":      2,
}

func (x AppInstListReply_AIStatus) String() string {
	return proto.EnumName(AppInstListReply_AIStatus_name, int32(x))
}

func (AppInstListReply_AIStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{16, 0}
}

// Status of the reply
type FqdnListReply_FLStatus int32

const (
	FqdnListReply_FL_UNDEFINED FqdnListReply_FLStatus = 0
	FqdnListReply_FL_SUCCESS   FqdnListReply_FLStatus = 1
	FqdnListReply_FL_FAIL      FqdnListReply_FLStatus = 2
)

var FqdnListReply_FLStatus_name = map[int32]string{
	0: "FL_UNDEFINED",
	1: "FL_SUCCESS",
	2: "FL_FAIL",
}

var FqdnListReply_FLStatus_value = map[string]int32{
	"FL_UNDEFINED": 0,
	"FL_SUCCESS":   1,
	"FL_FAIL":      2,
}

func (x FqdnListReply_FLStatus) String() string {
	return proto.EnumName(FqdnListReply_FLStatus_name, int32(x))
}

func (FqdnListReply_FLStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{19, 0}
}

type AppOfficialFqdnReply_AOFStatus int32

const (
	AppOfficialFqdnReply_AOF_UNDEFINED AppOfficialFqdnReply_AOFStatus = 0
	AppOfficialFqdnReply_AOF_SUCCESS   AppOfficialFqdnReply_AOFStatus = 1
	AppOfficialFqdnReply_AOF_FAIL      AppOfficialFqdnReply_AOFStatus = 2
)

var AppOfficialFqdnReply_AOFStatus_name = map[int32]string{
	0: "AOF_UNDEFINED",
	1: "AOF_SUCCESS",
	2: "AOF_FAIL",
}

var AppOfficialFqdnReply_AOFStatus_value = map[string]int32{
	"AOF_UNDEFINED": 0,
	"AOF_SUCCESS":   1,
	"AOF_FAIL":      2,
}

func (x AppOfficialFqdnReply_AOFStatus) String() string {
	return proto.EnumName(AppOfficialFqdnReply_AOFStatus_name, int32(x))
}

func (AppOfficialFqdnReply_AOFStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{21, 0}
}

// Use Secure communication or Open with the group
type DynamicLocGroupRequest_DlgCommType int32

const (
	DynamicLocGroupRequest_DLG_UNDEFINED DynamicLocGroupRequest_DlgCommType = 0
	DynamicLocGroupRequest_DLG_SECURE    DynamicLocGroupRequest_DlgCommType = 1
	DynamicLocGroupRequest_DLG_OPEN      DynamicLocGroupRequest_DlgCommType = 2
)

var DynamicLocGroupRequest_DlgCommType_name = map[int32]string{
	0: "DLG_UNDEFINED",
	1: "DLG_SECURE",
	2: "DLG_OPEN",
}

var DynamicLocGroupRequest_DlgCommType_value = map[string]int32{
	"DLG_UNDEFINED": 0,
	"DLG_SECURE":    1,
	"DLG_OPEN":      2,
}

func (x DynamicLocGroupRequest_DlgCommType) String() string {
	return proto.EnumName(DynamicLocGroupRequest_DlgCommType_name, int32(x))
}

func (DynamicLocGroupRequest_DlgCommType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{22, 0}
}

type ClientEdgeEvent_ClientEventType int32

const (
	ClientEdgeEvent_EVENT_UNKNOWN              ClientEdgeEvent_ClientEventType = 0
	ClientEdgeEvent_EVENT_INIT_CONNECTION      ClientEdgeEvent_ClientEventType = 1
	ClientEdgeEvent_EVENT_TERMINATE_CONNECTION ClientEdgeEvent_ClientEventType = 2
	ClientEdgeEvent_EVENT_LATENCY_SAMPLES      ClientEdgeEvent_ClientEventType = 3
	ClientEdgeEvent_EVENT_LOCATION_UPDATE      ClientEdgeEvent_ClientEventType = 4
	ClientEdgeEvent_EVENT_CUSTOM_EVENT         ClientEdgeEvent_ClientEventType = 5
)

var ClientEdgeEvent_ClientEventType_name = map[int32]string{
	0: "EVENT_UNKNOWN",
	1: "EVENT_INIT_CONNECTION",
	2: "EVENT_TERMINATE_CONNECTION",
	3: "EVENT_LATENCY_SAMPLES",
	4: "EVENT_LOCATION_UPDATE",
	5: "EVENT_CUSTOM_EVENT",
}

var ClientEdgeEvent_ClientEventType_value = map[string]int32{
	"EVENT_UNKNOWN":              0,
	"EVENT_INIT_CONNECTION":      1,
	"EVENT_TERMINATE_CONNECTION": 2,
	"EVENT_LATENCY_SAMPLES":      3,
	"EVENT_LOCATION_UPDATE":      4,
	"EVENT_CUSTOM_EVENT":         5,
}

func (x ClientEdgeEvent_ClientEventType) String() string {
	return proto.EnumName(ClientEdgeEvent_ClientEventType_name, int32(x))
}

func (ClientEdgeEvent_ClientEventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{29, 0}
}

type ServerEdgeEvent_ServerEventType int32

const (
	ServerEdgeEvent_EVENT_UNKNOWN              ServerEdgeEvent_ServerEventType = 0
	ServerEdgeEvent_EVENT_INIT_CONNECTION      ServerEdgeEvent_ServerEventType = 1
	ServerEdgeEvent_EVENT_LATENCY_REQUEST      ServerEdgeEvent_ServerEventType = 2
	ServerEdgeEvent_EVENT_LATENCY_PROCESSED    ServerEdgeEvent_ServerEventType = 3
	ServerEdgeEvent_EVENT_CLOUDLET_STATE       ServerEdgeEvent_ServerEventType = 4
	ServerEdgeEvent_EVENT_CLOUDLET_MAINTENANCE ServerEdgeEvent_ServerEventType = 5
	ServerEdgeEvent_EVENT_APPINST_HEALTH       ServerEdgeEvent_ServerEventType = 6
	ServerEdgeEvent_EVENT_CLOUDLET_UPDATE      ServerEdgeEvent_ServerEventType = 7
	ServerEdgeEvent_EVENT_ERROR                ServerEdgeEvent_ServerEventType = 8
)

var ServerEdgeEvent_ServerEventType_name = map[int32]string{
	0: "EVENT_UNKNOWN",
	1: "EVENT_INIT_CONNECTION",
	2: "EVENT_LATENCY_REQUEST",
	3: "EVENT_LATENCY_PROCESSED",
	4: "EVENT_CLOUDLET_STATE",
	5: "EVENT_CLOUDLET_MAINTENANCE",
	6: "EVENT_APPINST_HEALTH",
	7: "EVENT_CLOUDLET_UPDATE",
	8: "EVENT_ERROR",
}

var ServerEdgeEvent_ServerEventType_value = map[string]int32{
	"EVENT_UNKNOWN":              0,
	"EVENT_INIT_CONNECTION":      1,
	"EVENT_LATENCY_REQUEST":      2,
	"EVENT_LATENCY_PROCESSED":    3,
	"EVENT_CLOUDLET_STATE":       4,
	"EVENT_CLOUDLET_MAINTENANCE": 5,
	"EVENT_APPINST_HEALTH":       6,
	"EVENT_CLOUDLET_UPDATE":      7,
	"EVENT_ERROR":                8,
}

func (x ServerEdgeEvent_ServerEventType) String() string {
	return proto.EnumName(ServerEdgeEvent_ServerEventType_name, int32(x))
}

func (ServerEdgeEvent_ServerEventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{30, 0}
}

type RegisterClientRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	//
	// App Organization Name
	//
	// App developer organization name.
	OrgName string `protobuf:"bytes,2,opt,name=org_name,json=orgName,proto3" json:"org_name,omitempty"`
	//
	// App Name
	//
	// Name of your application.
	AppName string `protobuf:"bytes,3,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	//
	// App Version
	//
	// Application version.
	AppVers string `protobuf:"bytes,4,opt,name=app_vers,json=appVers,proto3" json:"app_vers,omitempty"`
	//
	// Carrier Name
	//
	// _(hidden)_ Reserved for future use
	CarrierName string `protobuf:"bytes,5,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	//
	// Authentication Token
	//
	// _(optional)_ An authentication token supplied by the application.
	AuthToken string `protobuf:"bytes,6,opt,name=auth_token,json=authToken,proto3" json:"auth_token,omitempty"`
	//
	// Unique ID Type
	//
	// _(optional)_ Type of unique ID provided by the client.
	// If left blank, a new Unique ID type will be assigned in the RegisterClient Reply.
	UniqueIdType string `protobuf:"bytes,8,opt,name=unique_id_type,json=uniqueIdType,proto3" json:"unique_id_type,omitempty"`
	//
	// Unique ID
	//
	// _(optional)_ Unique identification of the client device or user. May be overridden by the server.
	// If left blank, a new Unique ID will be assigned in the RegisterClient Reply.
	UniqueId string `protobuf:"bytes,9,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
	//
	// Tags
	//
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *RegisterClientRequest) Reset()         { *m = RegisterClientRequest{} }
func (m *RegisterClientRequest) String() string { return proto.CompactTextString(m) }
func (*RegisterClientRequest) ProtoMessage()    {}
func (*RegisterClientRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{0}
}
func (m *RegisterClientRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterClientRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterClientRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterClientRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterClientRequest.Merge(m, src)
}
func (m *RegisterClientRequest) XXX_Size() int {
	return m.Size()
}
func (m *RegisterClientRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterClientRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterClientRequest proto.InternalMessageInfo

type RegisterClientReply struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Status of the reply
	Status ReplyStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.ReplyStatus" json:"status,omitempty"`
	// Session Cookie to be used in later API calls
	SessionCookie string `protobuf:"bytes,3,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// URI for the Token Server
	TokenServerUri string `protobuf:"bytes,4,opt,name=token_server_uri,json=tokenServerUri,proto3" json:"token_server_uri,omitempty"`
	//
	// Unique ID Type
	//
	// _(optional)_ Type of unique ID provided by the server
	// A unique_id_type and unique_id may be provided by the client to be registered.
	// During registering, if a unique_id_type and unique_id are provided by the client in their request,
	// the unique_id_type and unique_id will be left blank in the response.
	// But, if the client does not provide a unique_id_type and unique_id, then the server generates
	// one and provides the unique_id in the response. If possible, the unique_id should be saved by the
	// client locally and used for subsequent RegisterClient API calls. Otherwise, a new unique_id will be
	// generated for further API calls.
	UniqueIdType string `protobuf:"bytes,5,opt,name=unique_id_type,json=uniqueIdType,proto3" json:"unique_id_type,omitempty"`
	//
	// Unique ID
	//
	// _(optional)_ Unique identification of the client device or user
	// A unique_id_type and unique_id may be provided by the client to be registered.
	// During registering, if a unique_id_type and unique_id are provided by the client in their request,
	// the unique_id_type and unique_id will be left blank in the response.
	// But, if the client does not provide a unique_id_type and unique_id, then the server generates
	// one and provides the unique_id in the response. If possible, the unique_id should be saved by the
	// client locally and used for subsequent RegisterClient API calls. Otherwise, a new unique_id will be
	// generated for further API calls.
	UniqueId string `protobuf:"bytes,6,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
	// Vendor specific data
	//
	// _(optional)_ Array of Tags.
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *RegisterClientReply) Reset()         { *m = RegisterClientReply{} }
func (m *RegisterClientReply) String() string { return proto.CompactTextString(m) }
func (*RegisterClientReply) ProtoMessage()    {}
func (*RegisterClientReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{1}
}
func (m *RegisterClientReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterClientReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterClientReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterClientReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterClientReply.Merge(m, src)
}
func (m *RegisterClientReply) XXX_Size() int {
	return m.Size()
}
func (m *RegisterClientReply) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterClientReply.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterClientReply proto.InternalMessageInfo

type FindCloudletRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	//
	// Session Cookie
	//
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	//
	// Carrier Name
	//
	// _(optional)_ By default, all SDKs will automatically fill in this parameter with the MCC+MNC of your current provider. Only override this parameter if you need to filter for a specific carrier on the DME. The DME will filter for App instances that are associated with the specified carrier.
	// If you wish to search for any App Instance on the DME regardless of carrier name, you can input “” to consider all carriers as “Any”.
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	//
	// GPS Location
	//
	// The GPS location of the user
	GpsLocation *Loc `protobuf:"bytes,4,opt,name=gps_location,json=gpsLocation,proto3" json:"gps_location,omitempty"`
	//
	// Tags
	//
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *FindCloudletRequest) Reset()         { *m = FindCloudletRequest{} }
func (m *FindCloudletRequest) String() string { return proto.CompactTextString(m) }
func (*FindCloudletRequest) ProtoMessage()    {}
func (*FindCloudletRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{2}
}
func (m *FindCloudletRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindCloudletRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindCloudletRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindCloudletRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindCloudletRequest.Merge(m, src)
}
func (m *FindCloudletRequest) XXX_Size() int {
	return m.Size()
}
func (m *FindCloudletRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FindCloudletRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FindCloudletRequest proto.InternalMessageInfo

type PlatformFindCloudletRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	//
	// Session Cookie
	//
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	//
	// Carrier Name
	//
	// _(optional)_ By default, all SDKs will automatically fill in this parameter with the MCC+MNC of your current provider. Only override this parameter if you need to filter for a specific carrier on the DME. The DME will filter for App instances that are associated with the specified carrier.
	// If you wish to search for any app instance on the DME regardless of carrier name, you can input “” to consider all carriers as “Any”.
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	//
	// Client Token
	//
	// Token with encoded client data
	ClientToken string `protobuf:"bytes,4,opt,name=client_token,json=clientToken,proto3" json:"client_token,omitempty"`
	//
	// Tags
	//
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *PlatformFindCloudletRequest) Reset()         { *m = PlatformFindCloudletRequest{} }
func (m *PlatformFindCloudletRequest) String() string { return proto.CompactTextString(m) }
func (*PlatformFindCloudletRequest) ProtoMessage()    {}
func (*PlatformFindCloudletRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{3}
}
func (m *PlatformFindCloudletRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlatformFindCloudletRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlatformFindCloudletRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlatformFindCloudletRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlatformFindCloudletRequest.Merge(m, src)
}
func (m *PlatformFindCloudletRequest) XXX_Size() int {
	return m.Size()
}
func (m *PlatformFindCloudletRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PlatformFindCloudletRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PlatformFindCloudletRequest proto.InternalMessageInfo

type FindCloudletReply struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Status return
	Status FindCloudletReply_FindStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.FindCloudletReply_FindStatus" json:"status,omitempty"`
	// Fully Qualified Domain Name of the Closest App instance
	Fqdn string `protobuf:"bytes,3,opt,name=fqdn,proto3" json:"fqdn,omitempty"`
	// List of Service Endpoints for AppInst
	Ports []*AppPort `protobuf:"bytes,4,rep,name=ports,proto3" json:"ports,omitempty"`
	// Location of the cloudlet
	CloudletLocation *Loc `protobuf:"bytes,5,opt,name=cloudlet_location,json=cloudletLocation,proto3" json:"cloudlet_location,omitempty"`
	// Session Cookie for specific EdgeEvents for specific AppInst
	EdgeEventsCookie string `protobuf:"bytes,6,opt,name=edge_events_cookie,json=edgeEventsCookie,proto3" json:"edge_events_cookie,omitempty"`
	// Result of QOS priority session creation attempt
	QosResult FindCloudletReply_QosSessionResult `protobuf:"varint,7,opt,name=qos_result,json=qosResult,proto3,enum=distributed_match_engine.FindCloudletReply_QosSessionResult" json:"qos_result,omitempty"`
	// Error message in case of QOS_SESSION_FAILED
	QosErrorMsg string `protobuf:"bytes,8,opt,name=qos_error_msg,json=qosErrorMsg,proto3" json:"qos_error_msg,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *FindCloudletReply) Reset()         { *m = FindCloudletReply{} }
func (m *FindCloudletReply) String() string { return proto.CompactTextString(m) }
func (*FindCloudletReply) ProtoMessage()    {}
func (*FindCloudletReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{4}
}
func (m *FindCloudletReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindCloudletReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindCloudletReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindCloudletReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindCloudletReply.Merge(m, src)
}
func (m *FindCloudletReply) XXX_Size() int {
	return m.Size()
}
func (m *FindCloudletReply) XXX_DiscardUnknown() {
	xxx_messageInfo_FindCloudletReply.DiscardUnknown(m)
}

var xxx_messageInfo_FindCloudletReply proto.InternalMessageInfo

type QosPrioritySessionCreateRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	//
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	//
	// _(optional)_ QOS Priority Session duration in seconds
	SessionDuration uint32 `protobuf:"varint,3,opt,name=session_duration,json=sessionDuration,proto3" json:"session_duration,omitempty"`
	//
	// IP address of mobile device
	IpUserEquipment string `protobuf:"bytes,4,opt,name=ip_user_equipment,json=ipUserEquipment,proto3" json:"ip_user_equipment,omitempty"`
	//
	// IP address of the application server
	IpApplicationServer string `protobuf:"bytes,5,opt,name=ip_application_server,json=ipApplicationServer,proto3" json:"ip_application_server,omitempty"`
	//
	// _(optional)_ A list of single ports or port ranges on the user equipment.
	PortUserEquipment string `protobuf:"bytes,6,opt,name=port_user_equipment,json=portUserEquipment,proto3" json:"port_user_equipment,omitempty"`
	//
	// _(optional)_ A list of single ports or port ranges on the application server
	PortApplicationServer string `protobuf:"bytes,7,opt,name=port_application_server,json=portApplicationServer,proto3" json:"port_application_server,omitempty"`
	//
	// _(optional)_ The used transport protocol for the uplink
	ProtocolIn QosSessionProtocol `protobuf:"varint,8,opt,name=protocol_in,json=protocolIn,proto3,enum=distributed_match_engine.QosSessionProtocol" json:"protocol_in,omitempty"`
	//
	// _(optional)_ The used transport protocol for the downlink
	ProtocolOut QosSessionProtocol `protobuf:"varint,9,opt,name=protocol_out,json=protocolOut,proto3,enum=distributed_match_engine.QosSessionProtocol" json:"protocol_out,omitempty"`
	//
	// QOS Priority Session profile name
	Profile QosSessionProfile `protobuf:"varint,10,opt,name=profile,proto3,enum=distributed_match_engine.QosSessionProfile" json:"profile,omitempty"`
	//
	//  _(optional)_ URI of the callback receiver. Allows asynchronous delivery of session related events.
	NotificationUri string `protobuf:"bytes,11,opt,name=notification_uri,json=notificationUri,proto3" json:"notification_uri,omitempty"`
	//
	// _(optional)_ Authentification token for callback API
	NotificationAuthToken string `protobuf:"bytes,12,opt,name=notification_auth_token,json=notificationAuthToken,proto3" json:"notification_auth_token,omitempty"`
	//
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *QosPrioritySessionCreateRequest) Reset()         { *m = QosPrioritySessionCreateRequest{} }
func (m *QosPrioritySessionCreateRequest) String() string { return proto.CompactTextString(m) }
func (*QosPrioritySessionCreateRequest) ProtoMessage()    {}
func (*QosPrioritySessionCreateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{5}
}
func (m *QosPrioritySessionCreateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QosPrioritySessionCreateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QosPrioritySessionCreateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QosPrioritySessionCreateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosPrioritySessionCreateRequest.Merge(m, src)
}
func (m *QosPrioritySessionCreateRequest) XXX_Size() int {
	return m.Size()
}
func (m *QosPrioritySessionCreateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QosPrioritySessionCreateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QosPrioritySessionCreateRequest proto.InternalMessageInfo

type QosPrioritySessionReply struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	//
	// QOS Priority Session duration in seconds
	SessionDuration uint32 `protobuf:"varint,2,opt,name=session_duration,json=sessionDuration,proto3" json:"session_duration,omitempty"`
	//
	// QOS Priority Session profile name
	Profile QosSessionProfile `protobuf:"varint,3,opt,name=profile,proto3,enum=distributed_match_engine.QosSessionProfile" json:"profile,omitempty"`
	//
	// Session ID in UUID format
	SessionId string `protobuf:"bytes,4,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	//
	// Timestamp of session start in seconds since unix epoch
	StartedAt uint32 `protobuf:"varint,5,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	//
	// Timestamp of session expiration if the session was not deleted in seconds since unix epoch
	ExpiresAt uint32 `protobuf:"varint,6,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	//
	// HTTP Status Code of call to operator's API server.
	HttpStatus uint32 `protobuf:"varint,7,opt,name=http_status,json=httpStatus,proto3" json:"http_status,omitempty"`
	//
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *QosPrioritySessionReply) Reset()         { *m = QosPrioritySessionReply{} }
func (m *QosPrioritySessionReply) String() string { return proto.CompactTextString(m) }
func (*QosPrioritySessionReply) ProtoMessage()    {}
func (*QosPrioritySessionReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{6}
}
func (m *QosPrioritySessionReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QosPrioritySessionReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QosPrioritySessionReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QosPrioritySessionReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosPrioritySessionReply.Merge(m, src)
}
func (m *QosPrioritySessionReply) XXX_Size() int {
	return m.Size()
}
func (m *QosPrioritySessionReply) XXX_DiscardUnknown() {
	xxx_messageInfo_QosPrioritySessionReply.DiscardUnknown(m)
}

var xxx_messageInfo_QosPrioritySessionReply proto.InternalMessageInfo

type QosPrioritySessionDeleteRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	//
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	//
	// QOS Priority Session profile name
	Profile QosSessionProfile `protobuf:"varint,3,opt,name=profile,proto3,enum=distributed_match_engine.QosSessionProfile" json:"profile,omitempty"`
	//
	// QOS Priority Session ID to be deleted
	SessionId string `protobuf:"bytes,4,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	//
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *QosPrioritySessionDeleteRequest) Reset()         { *m = QosPrioritySessionDeleteRequest{} }
func (m *QosPrioritySessionDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*QosPrioritySessionDeleteRequest) ProtoMessage()    {}
func (*QosPrioritySessionDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{7}
}
func (m *QosPrioritySessionDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QosPrioritySessionDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QosPrioritySessionDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QosPrioritySessionDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosPrioritySessionDeleteRequest.Merge(m, src)
}
func (m *QosPrioritySessionDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *QosPrioritySessionDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QosPrioritySessionDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QosPrioritySessionDeleteRequest proto.InternalMessageInfo

type QosPrioritySessionDeleteReply struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Status return.
	Status QosPrioritySessionDeleteReply_DeleteStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.QosPrioritySessionDeleteReply_DeleteStatus" json:"status,omitempty"`
	//
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *QosPrioritySessionDeleteReply) Reset()         { *m = QosPrioritySessionDeleteReply{} }
func (m *QosPrioritySessionDeleteReply) String() string { return proto.CompactTextString(m) }
func (*QosPrioritySessionDeleteReply) ProtoMessage()    {}
func (*QosPrioritySessionDeleteReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{8}
}
func (m *QosPrioritySessionDeleteReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QosPrioritySessionDeleteReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QosPrioritySessionDeleteReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QosPrioritySessionDeleteReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosPrioritySessionDeleteReply.Merge(m, src)
}
func (m *QosPrioritySessionDeleteReply) XXX_Size() int {
	return m.Size()
}
func (m *QosPrioritySessionDeleteReply) XXX_DiscardUnknown() {
	xxx_messageInfo_QosPrioritySessionDeleteReply.DiscardUnknown(m)
}

var xxx_messageInfo_QosPrioritySessionDeleteReply proto.InternalMessageInfo

type VerifyLocationRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	//
	// Session Cookie
	//
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	//
	// Carrier Name
	//
	// Unique carrier identification (typically MCC + MNC)
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	//
	// GPS Location
	//
	// The GPS location to verify
	GpsLocation *Loc `protobuf:"bytes,4,opt,name=gps_location,json=gpsLocation,proto3" json:"gps_location,omitempty"`
	//
	// Verify Location Token
	//
	// Must be retrieved from TokenServerURI
	VerifyLocToken string `protobuf:"bytes,5,opt,name=verify_loc_token,json=verifyLocToken,proto3" json:"verify_loc_token,omitempty"`
	//
	// Tags
	//
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *VerifyLocationRequest) Reset()         { *m = VerifyLocationRequest{} }
func (m *VerifyLocationRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyLocationRequest) ProtoMessage()    {}
func (*VerifyLocationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{9}
}
func (m *VerifyLocationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyLocationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyLocationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyLocationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyLocationRequest.Merge(m, src)
}
func (m *VerifyLocationRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyLocationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyLocationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyLocationRequest proto.InternalMessageInfo

type VerifyLocationReply struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver               uint32                                `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	TowerStatus       VerifyLocationReply_TowerStatus       `protobuf:"varint,2,opt,name=tower_status,json=towerStatus,proto3,enum=distributed_match_engine.VerifyLocationReply_TowerStatus" json:"tower_status,omitempty"`
	GpsLocationStatus VerifyLocationReply_GPSLocationStatus `protobuf:"varint,3,opt,name=gps_location_status,json=gpsLocationStatus,proto3,enum=distributed_match_engine.VerifyLocationReply_GPSLocationStatus" json:"gps_location_status,omitempty"`
	// location accuracy, the location is verified to
	// be within this number of kilometers.  Negative value
	// means no verification was performed
	GpsLocationAccuracyKm float64 `protobuf:"fixed64,4,opt,name=gps_location_accuracy_km,json=gpsLocationAccuracyKm,proto3" json:"gps_location_accuracy_km,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *VerifyLocationReply) Reset()         { *m = VerifyLocationReply{} }
func (m *VerifyLocationReply) String() string { return proto.CompactTextString(m) }
func (*VerifyLocationReply) ProtoMessage()    {}
func (*VerifyLocationReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{10}
}
func (m *VerifyLocationReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyLocationReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyLocationReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyLocationReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyLocationReply.Merge(m, src)
}
func (m *VerifyLocationReply) XXX_Size() int {
	return m.Size()
}
func (m *VerifyLocationReply) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyLocationReply.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyLocationReply proto.InternalMessageInfo

type GetLocationRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// Unique carrier identification (typically MCC + MNC)
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetLocationRequest) Reset()         { *m = GetLocationRequest{} }
func (m *GetLocationRequest) String() string { return proto.CompactTextString(m) }
func (*GetLocationRequest) ProtoMessage()    {}
func (*GetLocationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{11}
}
func (m *GetLocationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLocationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLocationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLocationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLocationRequest.Merge(m, src)
}
func (m *GetLocationRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetLocationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLocationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLocationRequest proto.InternalMessageInfo

type GetLocationReply struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver    uint32                     `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	Status GetLocationReply_LocStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.GetLocationReply_LocStatus" json:"status,omitempty"`
	// Unique carrier identification (typically MCC + MNC)
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	// The tower that the user is currently connected to
	Tower uint64 `protobuf:"varint,4,opt,name=tower,proto3" json:"tower,omitempty"`
	// The GPS location of the user
	NetworkLocation *Loc `protobuf:"bytes,5,opt,name=network_location,json=networkLocation,proto3" json:"network_location,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetLocationReply) Reset()         { *m = GetLocationReply{} }
func (m *GetLocationReply) String() string { return proto.CompactTextString(m) }
func (*GetLocationReply) ProtoMessage()    {}
func (*GetLocationReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{12}
}
func (m *GetLocationReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLocationReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLocationReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLocationReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLocationReply.Merge(m, src)
}
func (m *GetLocationReply) XXX_Size() int {
	return m.Size()
}
func (m *GetLocationReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLocationReply.DiscardUnknown(m)
}

var xxx_messageInfo_GetLocationReply proto.InternalMessageInfo

type AppInstListRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	//
	// Carrier Name
	//
	// _(optional)_ By default, all SDKs will automatically fill in this parameter with the MCC+MNC of your current provider. Only override this parameter if you need to filter for a specific carrier on the DME. The DME will filter for App instances that are associated with the specified carrier.
	// If you wish to search for any App Instance on the DME regardless of carrier name, you can input “” to consider all carriers as “Any”.
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	// The GPS location of the user
	GpsLocation *Loc `protobuf:"bytes,4,opt,name=gps_location,json=gpsLocation,proto3" json:"gps_location,omitempty"`
	// _(optional)_ Limit the number of results, defaults to 3
	Limit uint32 `protobuf:"varint,6,opt,name=limit,proto3" json:"limit,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AppInstListRequest) Reset()         { *m = AppInstListRequest{} }
func (m *AppInstListRequest) String() string { return proto.CompactTextString(m) }
func (*AppInstListRequest) ProtoMessage()    {}
func (*AppInstListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{13}
}
func (m *AppInstListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppInstListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppInstListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppInstListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppInstListRequest.Merge(m, src)
}
func (m *AppInstListRequest) XXX_Size() int {
	return m.Size()
}
func (m *AppInstListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AppInstListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AppInstListRequest proto.InternalMessageInfo

type Appinstance struct {
	// App Instance Name
	AppName string `protobuf:"bytes,1,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	// App Instance Version
	AppVers string `protobuf:"bytes,2,opt,name=app_vers,json=appVers,proto3" json:"app_vers,omitempty"`
	// App Instance FQDN
	Fqdn string `protobuf:"bytes,3,opt,name=fqdn,proto3" json:"fqdn,omitempty"`
	// ports to access app
	Ports []*AppPort `protobuf:"bytes,4,rep,name=ports,proto3" json:"ports,omitempty"`
	// App Organization Name
	OrgName string `protobuf:"bytes,5,opt,name=org_name,json=orgName,proto3" json:"org_name,omitempty"`
	// Session Cookie for specific EdgeEvents for specific AppInst
	EdgeEventsCookie     string   `protobuf:"bytes,6,opt,name=edge_events_cookie,json=edgeEventsCookie,proto3" json:"edge_events_cookie,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Appinstance) Reset()         { *m = Appinstance{} }
func (m *Appinstance) String() string { return proto.CompactTextString(m) }
func (*Appinstance) ProtoMessage()    {}
func (*Appinstance) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{14}
}
func (m *Appinstance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Appinstance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Appinstance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Appinstance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Appinstance.Merge(m, src)
}
func (m *Appinstance) XXX_Size() int {
	return m.Size()
}
func (m *Appinstance) XXX_DiscardUnknown() {
	xxx_messageInfo_Appinstance.DiscardUnknown(m)
}

var xxx_messageInfo_Appinstance proto.InternalMessageInfo

type CloudletLocation struct {
	// Cloudlet Organization Name
	CarrierName string `protobuf:"bytes,1,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	// Cloudlet Name
	CloudletName string `protobuf:"bytes,2,opt,name=cloudlet_name,json=cloudletName,proto3" json:"cloudlet_name,omitempty"`
	// The GPS Location of the cloudlet
	GpsLocation *Loc `protobuf:"bytes,3,opt,name=gps_location,json=gpsLocation,proto3" json:"gps_location,omitempty"`
	// Distance of cloudlet vs loc in request
	Distance float64 `protobuf:"fixed64,4,opt,name=distance,proto3" json:"distance,omitempty"`
	// App instances
	Appinstances         []*Appinstance `protobuf:"bytes,5,rep,name=appinstances,proto3" json:"appinstances,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CloudletLocation) Reset()         { *m = CloudletLocation{} }
func (m *CloudletLocation) String() string { return proto.CompactTextString(m) }
func (*CloudletLocation) ProtoMessage()    {}
func (*CloudletLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{15}
}
func (m *CloudletLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletLocation.Merge(m, src)
}
func (m *CloudletLocation) XXX_Size() int {
	return m.Size()
}
func (m *CloudletLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletLocation.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletLocation proto.InternalMessageInfo

type AppInstListReply struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver       uint32                    `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	Status    AppInstListReply_AIStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.AppInstListReply_AIStatus" json:"status,omitempty"`
	Cloudlets []*CloudletLocation       `protobuf:"bytes,3,rep,name=cloudlets,proto3" json:"cloudlets,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AppInstListReply) Reset()         { *m = AppInstListReply{} }
func (m *AppInstListReply) String() string { return proto.CompactTextString(m) }
func (*AppInstListReply) ProtoMessage()    {}
func (*AppInstListReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{16}
}
func (m *AppInstListReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppInstListReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppInstListReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppInstListReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppInstListReply.Merge(m, src)
}
func (m *AppInstListReply) XXX_Size() int {
	return m.Size()
}
func (m *AppInstListReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AppInstListReply.DiscardUnknown(m)
}

var xxx_messageInfo_AppInstListReply proto.InternalMessageInfo

type FqdnListRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *FqdnListRequest) Reset()         { *m = FqdnListRequest{} }
func (m *FqdnListRequest) String() string { return proto.CompactTextString(m) }
func (*FqdnListRequest) ProtoMessage()    {}
func (*FqdnListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{17}
}
func (m *FqdnListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FqdnListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FqdnListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FqdnListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FqdnListRequest.Merge(m, src)
}
func (m *FqdnListRequest) XXX_Size() int {
	return m.Size()
}
func (m *FqdnListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FqdnListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FqdnListRequest proto.InternalMessageInfo

type AppFqdn struct {
	// App  Name
	AppName string `protobuf:"bytes,1,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	// App Version
	AppVers string `protobuf:"bytes,2,opt,name=app_vers,json=appVers,proto3" json:"app_vers,omitempty"`
	// App organization name
	OrgName string `protobuf:"bytes,3,opt,name=org_name,json=orgName,proto3" json:"org_name,omitempty"`
	// App FQDN
	Fqdns []string `protobuf:"bytes,4,rep,name=fqdns,proto3" json:"fqdns,omitempty"`
	// _(optional)_ Android package name
	AndroidPackageName   string   `protobuf:"bytes,5,opt,name=android_package_name,json=androidPackageName,proto3" json:"android_package_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppFqdn) Reset()         { *m = AppFqdn{} }
func (m *AppFqdn) String() string { return proto.CompactTextString(m) }
func (*AppFqdn) ProtoMessage()    {}
func (*AppFqdn) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{18}
}
func (m *AppFqdn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppFqdn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppFqdn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppFqdn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppFqdn.Merge(m, src)
}
func (m *AppFqdn) XXX_Size() int {
	return m.Size()
}
func (m *AppFqdn) XXX_DiscardUnknown() {
	xxx_messageInfo_AppFqdn.DiscardUnknown(m)
}

var xxx_messageInfo_AppFqdn proto.InternalMessageInfo

type FqdnListReply struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver      uint32                 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	AppFqdns []*AppFqdn             `protobuf:"bytes,3,rep,name=app_fqdns,json=appFqdns,proto3" json:"app_fqdns,omitempty"`
	Status   FqdnListReply_FLStatus `protobuf:"varint,4,opt,name=status,proto3,enum=distributed_match_engine.FqdnListReply_FLStatus" json:"status,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *FqdnListReply) Reset()         { *m = FqdnListReply{} }
func (m *FqdnListReply) String() string { return proto.CompactTextString(m) }
func (*FqdnListReply) ProtoMessage()    {}
func (*FqdnListReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{19}
}
func (m *FqdnListReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FqdnListReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FqdnListReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FqdnListReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FqdnListReply.Merge(m, src)
}
func (m *FqdnListReply) XXX_Size() int {
	return m.Size()
}
func (m *FqdnListReply) XXX_DiscardUnknown() {
	xxx_messageInfo_FqdnListReply.DiscardUnknown(m)
}

var xxx_messageInfo_FqdnListReply proto.InternalMessageInfo

type AppOfficialFqdnRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// The GPS location of the user
	GpsLocation *Loc `protobuf:"bytes,3,opt,name=gps_location,json=gpsLocation,proto3" json:"gps_location,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AppOfficialFqdnRequest) Reset()         { *m = AppOfficialFqdnRequest{} }
func (m *AppOfficialFqdnRequest) String() string { return proto.CompactTextString(m) }
func (*AppOfficialFqdnRequest) ProtoMessage()    {}
func (*AppOfficialFqdnRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{20}
}
func (m *AppOfficialFqdnRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppOfficialFqdnRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppOfficialFqdnRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppOfficialFqdnRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppOfficialFqdnRequest.Merge(m, src)
}
func (m *AppOfficialFqdnRequest) XXX_Size() int {
	return m.Size()
}
func (m *AppOfficialFqdnRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AppOfficialFqdnRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AppOfficialFqdnRequest proto.InternalMessageInfo

type AppOfficialFqdnReply struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// The FQDN to which the app is reached independent of the edge
	AppOfficialFqdn string `protobuf:"bytes,2,opt,name=app_official_fqdn,json=appOfficialFqdn,proto3" json:"app_official_fqdn,omitempty"`
	// Tokenized client data
	ClientToken string `protobuf:"bytes,3,opt,name=client_token,json=clientToken,proto3" json:"client_token,omitempty"`
	// Status of the reply
	Status AppOfficialFqdnReply_AOFStatus `protobuf:"varint,4,opt,name=status,proto3,enum=distributed_match_engine.AppOfficialFqdnReply_AOFStatus" json:"status,omitempty"`
	// List of Service Endpoints for AppInst
	Ports []*AppPort `protobuf:"bytes,5,rep,name=ports,proto3" json:"ports,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AppOfficialFqdnReply) Reset()         { *m = AppOfficialFqdnReply{} }
func (m *AppOfficialFqdnReply) String() string { return proto.CompactTextString(m) }
func (*AppOfficialFqdnReply) ProtoMessage()    {}
func (*AppOfficialFqdnReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{21}
}
func (m *AppOfficialFqdnReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppOfficialFqdnReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppOfficialFqdnReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppOfficialFqdnReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppOfficialFqdnReply.Merge(m, src)
}
func (m *AppOfficialFqdnReply) XXX_Size() int {
	return m.Size()
}
func (m *AppOfficialFqdnReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AppOfficialFqdnReply.DiscardUnknown(m)
}

var xxx_messageInfo_AppOfficialFqdnReply proto.InternalMessageInfo

type DynamicLocGroupRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// Dynamic Location Group Id
	LgId     uint64                             `protobuf:"varint,3,opt,name=lg_id,json=lgId,proto3" json:"lg_id,omitempty"`
	CommType DynamicLocGroupRequest_DlgCommType `protobuf:"varint,11,opt,name=comm_type,json=commType,proto3,enum=distributed_match_engine.DynamicLocGroupRequest_DlgCommType" json:"comm_type,omitempty"`
	// Unused
	UserData string `protobuf:"bytes,12,opt,name=user_data,json=userData,proto3" json:"user_data,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *DynamicLocGroupRequest) Reset()         { *m = DynamicLocGroupRequest{} }
func (m *DynamicLocGroupRequest) String() string { return proto.CompactTextString(m) }
func (*DynamicLocGroupRequest) ProtoMessage()    {}
func (*DynamicLocGroupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{22}
}
func (m *DynamicLocGroupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynamicLocGroupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynamicLocGroupRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynamicLocGroupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynamicLocGroupRequest.Merge(m, src)
}
func (m *DynamicLocGroupRequest) XXX_Size() int {
	return m.Size()
}
func (m *DynamicLocGroupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DynamicLocGroupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DynamicLocGroupRequest proto.InternalMessageInfo

type DynamicLocGroupReply struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Status of the reply
	Status ReplyStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.ReplyStatus" json:"status,omitempty"`
	// Error Code based on Failure
	ErrorCode uint32 `protobuf:"varint,3,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	// Group Cookie for Secure Group Communication
	GroupCookie string `protobuf:"bytes,5,opt,name=group_cookie,json=groupCookie,proto3" json:"group_cookie,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *DynamicLocGroupReply) Reset()         { *m = DynamicLocGroupReply{} }
func (m *DynamicLocGroupReply) String() string { return proto.CompactTextString(m) }
func (*DynamicLocGroupReply) ProtoMessage()    {}
func (*DynamicLocGroupReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{23}
}
func (m *DynamicLocGroupReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynamicLocGroupReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynamicLocGroupReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynamicLocGroupReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynamicLocGroupReply.Merge(m, src)
}
func (m *DynamicLocGroupReply) XXX_Size() int {
	return m.Size()
}
func (m *DynamicLocGroupReply) XXX_DiscardUnknown() {
	xxx_messageInfo_DynamicLocGroupReply.DiscardUnknown(m)
}

var xxx_messageInfo_DynamicLocGroupReply proto.InternalMessageInfo

type QosPosition struct {
	// as set by the client, must be unique within QosRequest
	Positionid int64 `protobuf:"varint,1,opt,name=positionid,proto3" json:"positionid,omitempty"`
	//location
	GpsLocation          *Loc     `protobuf:"bytes,2,opt,name=gps_location,json=gpsLocation,proto3" json:"gps_location,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QosPosition) Reset()         { *m = QosPosition{} }
func (m *QosPosition) String() string { return proto.CompactTextString(m) }
func (*QosPosition) ProtoMessage()    {}
func (*QosPosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{24}
}
func (m *QosPosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QosPosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QosPosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QosPosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosPosition.Merge(m, src)
}
func (m *QosPosition) XXX_Size() int {
	return m.Size()
}
func (m *QosPosition) XXX_DiscardUnknown() {
	xxx_messageInfo_QosPosition.DiscardUnknown(m)
}

var xxx_messageInfo_QosPosition proto.InternalMessageInfo

// supported band values
type BandSelection struct {
	// Radio Access Technologies
	Rat_2G               []string `protobuf:"bytes,1,rep,name=rat_2g,json=rat2g,proto3" json:"rat_2g,omitempty"`
	Rat_3G               []string `protobuf:"bytes,2,rep,name=rat_3g,json=rat3g,proto3" json:"rat_3g,omitempty"`
	Rat_4G               []string `protobuf:"bytes,3,rep,name=rat_4g,json=rat4g,proto3" json:"rat_4g,omitempty"`
	Rat_5G               []string `protobuf:"bytes,4,rep,name=rat_5g,json=rat5g,proto3" json:"rat_5g,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BandSelection) Reset()         { *m = BandSelection{} }
func (m *BandSelection) String() string { return proto.CompactTextString(m) }
func (*BandSelection) ProtoMessage()    {}
func (*BandSelection) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{25}
}
func (m *BandSelection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BandSelection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BandSelection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BandSelection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BandSelection.Merge(m, src)
}
func (m *BandSelection) XXX_Size() int {
	return m.Size()
}
func (m *BandSelection) XXX_DiscardUnknown() {
	xxx_messageInfo_BandSelection.DiscardUnknown(m)
}

var xxx_messageInfo_BandSelection proto.InternalMessageInfo

// QosPositionRequest is used for both GetQosPositionKpi
type QosPositionRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// list of positions
	Positions []*QosPosition `protobuf:"bytes,3,rep,name=positions,proto3" json:"positions,omitempty"`
	// _(optional)_ Client's device LTE category number.
	LteCategory int32 `protobuf:"varint,4,opt,name=lte_category,json=lteCategory,proto3" json:"lte_category,omitempty"`
	// _(optional)_ Band list used by the client.
	BandSelection *BandSelection `protobuf:"bytes,5,opt,name=band_selection,json=bandSelection,proto3" json:"band_selection,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *QosPositionRequest) Reset()         { *m = QosPositionRequest{} }
func (m *QosPositionRequest) String() string { return proto.CompactTextString(m) }
func (*QosPositionRequest) ProtoMessage()    {}
func (*QosPositionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{26}
}
func (m *QosPositionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QosPositionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QosPositionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QosPositionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosPositionRequest.Merge(m, src)
}
func (m *QosPositionRequest) XXX_Size() int {
	return m.Size()
}
func (m *QosPositionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QosPositionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QosPositionRequest proto.InternalMessageInfo

type QosPositionKpiResult struct {
	// as set by the client, must be unique within one QosPositionRequest
	Positionid int64 `protobuf:"varint,1,opt,name=positionid,proto3" json:"positionid,omitempty"`
	// the location which was requested
	GpsLocation *Loc `protobuf:"bytes,2,opt,name=gps_location,json=gpsLocation,proto3" json:"gps_location,omitempty"`
	// throughput
	DluserthroughputMin  float32  `protobuf:"fixed32,3,opt,name=dluserthroughput_min,json=dluserthroughputMin,proto3" json:"dluserthroughput_min,omitempty"`
	DluserthroughputAvg  float32  `protobuf:"fixed32,4,opt,name=dluserthroughput_avg,json=dluserthroughputAvg,proto3" json:"dluserthroughput_avg,omitempty"`
	DluserthroughputMax  float32  `protobuf:"fixed32,5,opt,name=dluserthroughput_max,json=dluserthroughputMax,proto3" json:"dluserthroughput_max,omitempty"`
	UluserthroughputMin  float32  `protobuf:"fixed32,6,opt,name=uluserthroughput_min,json=uluserthroughputMin,proto3" json:"uluserthroughput_min,omitempty"`
	UluserthroughputAvg  float32  `protobuf:"fixed32,7,opt,name=uluserthroughput_avg,json=uluserthroughputAvg,proto3" json:"uluserthroughput_avg,omitempty"`
	UluserthroughputMax  float32  `protobuf:"fixed32,8,opt,name=uluserthroughput_max,json=uluserthroughputMax,proto3" json:"uluserthroughput_max,omitempty"`
	LatencyMin           float32  `protobuf:"fixed32,9,opt,name=latency_min,json=latencyMin,proto3" json:"latency_min,omitempty"`
	LatencyAvg           float32  `protobuf:"fixed32,10,opt,name=latency_avg,json=latencyAvg,proto3" json:"latency_avg,omitempty"`
	LatencyMax           float32  `protobuf:"fixed32,11,opt,name=latency_max,json=latencyMax,proto3" json:"latency_max,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QosPositionKpiResult) Reset()         { *m = QosPositionKpiResult{} }
func (m *QosPositionKpiResult) String() string { return proto.CompactTextString(m) }
func (*QosPositionKpiResult) ProtoMessage()    {}
func (*QosPositionKpiResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{27}
}
func (m *QosPositionKpiResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QosPositionKpiResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QosPositionKpiResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QosPositionKpiResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosPositionKpiResult.Merge(m, src)
}
func (m *QosPositionKpiResult) XXX_Size() int {
	return m.Size()
}
func (m *QosPositionKpiResult) XXX_DiscardUnknown() {
	xxx_messageInfo_QosPositionKpiResult.DiscardUnknown(m)
}

var xxx_messageInfo_QosPositionKpiResult proto.InternalMessageInfo

type QosPositionKpiReply struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Status of the reply
	Status ReplyStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.ReplyStatus" json:"status,omitempty"`
	// kpi details
	PositionResults []*QosPositionKpiResult `protobuf:"bytes,3,rep,name=position_results,json=positionResults,proto3" json:"position_results,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *QosPositionKpiReply) Reset()         { *m = QosPositionKpiReply{} }
func (m *QosPositionKpiReply) String() string { return proto.CompactTextString(m) }
func (*QosPositionKpiReply) ProtoMessage()    {}
func (*QosPositionKpiReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{28}
}
func (m *QosPositionKpiReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QosPositionKpiReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QosPositionKpiReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QosPositionKpiReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosPositionKpiReply.Merge(m, src)
}
func (m *QosPositionKpiReply) XXX_Size() int {
	return m.Size()
}
func (m *QosPositionKpiReply) XXX_DiscardUnknown() {
	xxx_messageInfo_QosPositionKpiReply.DiscardUnknown(m)
}

var xxx_messageInfo_QosPositionKpiReply proto.InternalMessageInfo

// Messages from SDK to DME
type ClientEdgeEvent struct {
	// Session Cookie from RegisterClientReply
	SessionCookie string `protobuf:"bytes,1,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// Session Cookie from FindCloudletReply
	EdgeEventsCookie string                          `protobuf:"bytes,2,opt,name=edge_events_cookie,json=edgeEventsCookie,proto3" json:"edge_events_cookie,omitempty"`
	EventType        ClientEdgeEvent_ClientEventType `protobuf:"varint,3,opt,name=event_type,json=eventType,proto3,enum=distributed_match_engine.ClientEdgeEvent_ClientEventType" json:"event_type,omitempty"`
	// GPS Location info if event_type is EVENT_LOCATION_UPDATE or EVENT_LATENCY_SAMPLES
	GpsLocation *Loc `protobuf:"bytes,4,opt,name=gps_location,json=gpsLocation,proto3" json:"gps_location,omitempty"`
	// Latency Samples if event_type is EVENT_LATENCY_SAMPLES or EVENT_CUSTOM_EVENT
	Samples []*Sample `protobuf:"bytes,5,rep,name=samples,proto3" json:"samples,omitempty"`
	//
	// _(optional)_ Static device information for latency and deviceinfo stats
	// Send on EVENT_INIT_CONNECTION to get this information in latency stats and deviceinfo stats
	DeviceInfoStatic *DeviceInfoStatic `protobuf:"bytes,6,opt,name=device_info_static,json=deviceInfoStatic,proto3" json:"device_info_static,omitempty"`
	//
	// _(optional)_ Dynamic device information for latency and deviceinfo stats
	// Send on EVENT_INIT_CONNECTION to get this information in first deviceinfo stat
	// Send on EVENT_LOCATION_UPDATE to get this information in dynamic deviceinfo stats
	// Send on EVENT_LATENCY_SAMPLES to get this information in latency stats
	DeviceInfoDynamic *DeviceInfoDynamic `protobuf:"bytes,7,opt,name=device_info_dynamic,json=deviceInfoDynamic,proto3" json:"device_info_dynamic,omitempty"`
	// Custom event specified by the application
	CustomEvent string `protobuf:"bytes,8,opt,name=custom_event,json=customEvent,proto3" json:"custom_event,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ClientEdgeEvent) Reset()         { *m = ClientEdgeEvent{} }
func (m *ClientEdgeEvent) String() string { return proto.CompactTextString(m) }
func (*ClientEdgeEvent) ProtoMessage()    {}
func (*ClientEdgeEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{29}
}
func (m *ClientEdgeEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientEdgeEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientEdgeEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientEdgeEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientEdgeEvent.Merge(m, src)
}
func (m *ClientEdgeEvent) XXX_Size() int {
	return m.Size()
}
func (m *ClientEdgeEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientEdgeEvent.DiscardUnknown(m)
}

var xxx_messageInfo_ClientEdgeEvent proto.InternalMessageInfo

// Message from DME to SDK
type ServerEdgeEvent struct {
	EventType ServerEdgeEvent_ServerEventType `protobuf:"varint,1,opt,name=event_type,json=eventType,proto3,enum=distributed_match_engine.ServerEdgeEvent_ServerEventType" json:"event_type,omitempty"`
	// Cloudlet state information if cloudlet state is not CLOUDLET_STATE_READY
	CloudletState CloudletState `protobuf:"varint,2,opt,name=cloudlet_state,json=cloudletState,proto3,enum=distributed_match_engine.CloudletState" json:"cloudlet_state,omitempty"`
	// Cloudlet maintenance state information if maintenance state is not NORMAL_OPERATION
	MaintenanceState MaintenanceState `protobuf:"varint,3,opt,name=maintenance_state,json=maintenanceState,proto3,enum=distributed_match_engine.MaintenanceState" json:"maintenance_state,omitempty"`
	// AppInst health state information if health check is not HEALTH_CHECK_OK
	HealthCheck HealthCheck `protobuf:"varint,4,opt,name=health_check,json=healthCheck,proto3,enum=distributed_match_engine.HealthCheck" json:"health_check,omitempty"`
	// Summarized RTT Latency stats from samples provided from client if event_type is EVENT_LATENCY
	Statistics *Statistics `protobuf:"bytes,5,opt,name=statistics,proto3" json:"statistics,omitempty"`
	//
	// New and closer cloudlet if event_type is EVENT_CLOUDLET_UPDATE.
	// (EVENT_CLOUDLET_UPDATE occurs if the client is closer to a different cloudlet, or a new closer appinst is created, or a previously down appinst/cloudlet that is closest to the client is now operational)
	// Also sent on EVENT_CLOUDLET_STATE if another cloudlet is available
	// Also sent on EVENT_CLOUDLET_MAINTENANCE, if another cloudlet is available and maintenance_state == UNDER_MAINTENANCE
	// Also sent on EVENT_APPINST_HEALTH, if another cloudlet is available and health_check != HEALTH_CHECK_UNKNOWN
	NewCloudlet *FindCloudletReply `protobuf:"bytes,6,opt,name=new_cloudlet,json=newCloudlet,proto3" json:"new_cloudlet,omitempty"`
	// Error message if event_type is EVENT_ERROR
	ErrorMsg string `protobuf:"bytes,7,opt,name=error_msg,json=errorMsg,proto3" json:"error_msg,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ServerEdgeEvent) Reset()         { *m = ServerEdgeEvent{} }
func (m *ServerEdgeEvent) String() string { return proto.CompactTextString(m) }
func (*ServerEdgeEvent) ProtoMessage()    {}
func (*ServerEdgeEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{30}
}
func (m *ServerEdgeEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerEdgeEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerEdgeEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerEdgeEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerEdgeEvent.Merge(m, src)
}
func (m *ServerEdgeEvent) XXX_Size() int {
	return m.Size()
}
func (m *ServerEdgeEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerEdgeEvent.DiscardUnknown(m)
}

var xxx_messageInfo_ServerEdgeEvent proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("distributed_match_engine.IDTypes", IDTypes_name, IDTypes_value)
	proto.RegisterEnum("distributed_match_engine.ReplyStatus", ReplyStatus_name, ReplyStatus_value)
	proto.RegisterEnum("distributed_match_engine.QosSessionProfile", QosSessionProfile_name, QosSessionProfile_value)
	proto.RegisterEnum("distributed_match_engine.QosSessionProtocol", QosSessionProtocol_name, QosSessionProtocol_value)
	proto.RegisterEnum("distributed_match_engine.FindCloudletReply_FindStatus", FindCloudletReply_FindStatus_name, FindCloudletReply_FindStatus_value)
	proto.RegisterEnum("distributed_match_engine.FindCloudletReply_QosSessionResult", FindCloudletReply_QosSessionResult_name, FindCloudletReply_QosSessionResult_value)
	proto.RegisterEnum("distributed_match_engine.QosPrioritySessionDeleteReply_DeleteStatus", QosPrioritySessionDeleteReply_DeleteStatus_name, QosPrioritySessionDeleteReply_DeleteStatus_value)
	proto.RegisterEnum("distributed_match_engine.VerifyLocationReply_TowerStatus", VerifyLocationReply_TowerStatus_name, VerifyLocationReply_TowerStatus_value)
	proto.RegisterEnum("distributed_match_engine.VerifyLocationReply_GPSLocationStatus", VerifyLocationReply_GPSLocationStatus_name, VerifyLocationReply_GPSLocationStatus_value)
	proto.RegisterEnum("distributed_match_engine.GetLocationReply_LocStatus", GetLocationReply_LocStatus_name, GetLocationReply_LocStatus_value)
	proto.RegisterEnum("distributed_match_engine.AppInstListReply_AIStatus", AppInstListReply_AIStatus_name, AppInstListReply_AIStatus_value)
	proto.RegisterEnum("distributed_match_engine.FqdnListReply_FLStatus", FqdnListReply_FLStatus_name, FqdnListReply_FLStatus_value)
	proto.RegisterEnum("distributed_match_engine.AppOfficialFqdnReply_AOFStatus", AppOfficialFqdnReply_AOFStatus_name, AppOfficialFqdnReply_AOFStatus_value)
	proto.RegisterEnum("distributed_match_engine.DynamicLocGroupRequest_DlgCommType", DynamicLocGroupRequest_DlgCommType_name, DynamicLocGroupRequest_DlgCommType_value)
	proto.RegisterEnum("distributed_match_engine.ClientEdgeEvent_ClientEventType", ClientEdgeEvent_ClientEventType_name, ClientEdgeEvent_ClientEventType_value)
	proto.RegisterEnum("distributed_match_engine.ServerEdgeEvent_ServerEventType", ServerEdgeEvent_ServerEventType_name, ServerEdgeEvent_ServerEventType_value)
	proto.RegisterType((*RegisterClientRequest)(nil), "distributed_match_engine.RegisterClientRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.RegisterClientRequest.TagsEntry")
	proto.RegisterType((*RegisterClientReply)(nil), "distributed_match_engine.RegisterClientReply")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.RegisterClientReply.TagsEntry")
	proto.RegisterType((*FindCloudletRequest)(nil), "distributed_match_engine.FindCloudletRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.FindCloudletRequest.TagsEntry")
	proto.RegisterType((*PlatformFindCloudletRequest)(nil), "distributed_match_engine.PlatformFindCloudletRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.PlatformFindCloudletRequest.TagsEntry")
	proto.RegisterType((*FindCloudletReply)(nil), "distributed_match_engine.FindCloudletReply")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.FindCloudletReply.TagsEntry")
	proto.RegisterType((*QosPrioritySessionCreateRequest)(nil), "distributed_match_engine.QosPrioritySessionCreateRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.QosPrioritySessionCreateRequest.TagsEntry")
	proto.RegisterType((*QosPrioritySessionReply)(nil), "distributed_match_engine.QosPrioritySessionReply")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.QosPrioritySessionReply.TagsEntry")
	proto.RegisterType((*QosPrioritySessionDeleteRequest)(nil), "distributed_match_engine.QosPrioritySessionDeleteRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.QosPrioritySessionDeleteRequest.TagsEntry")
	proto.RegisterType((*QosPrioritySessionDeleteReply)(nil), "distributed_match_engine.QosPrioritySessionDeleteReply")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.QosPrioritySessionDeleteReply.TagsEntry")
	proto.RegisterType((*VerifyLocationRequest)(nil), "distributed_match_engine.VerifyLocationRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.VerifyLocationRequest.TagsEntry")
	proto.RegisterType((*VerifyLocationReply)(nil), "distributed_match_engine.VerifyLocationReply")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.VerifyLocationReply.TagsEntry")
	proto.RegisterType((*GetLocationRequest)(nil), "distributed_match_engine.GetLocationRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.GetLocationRequest.TagsEntry")
	proto.RegisterType((*GetLocationReply)(nil), "distributed_match_engine.GetLocationReply")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.GetLocationReply.TagsEntry")
	proto.RegisterType((*AppInstListRequest)(nil), "distributed_match_engine.AppInstListRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.AppInstListRequest.TagsEntry")
	proto.RegisterType((*Appinstance)(nil), "distributed_match_engine.Appinstance")
	proto.RegisterType((*CloudletLocation)(nil), "distributed_match_engine.CloudletLocation")
	proto.RegisterType((*AppInstListReply)(nil), "distributed_match_engine.AppInstListReply")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.AppInstListReply.TagsEntry")
	proto.RegisterType((*FqdnListRequest)(nil), "distributed_match_engine.FqdnListRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.FqdnListRequest.TagsEntry")
	proto.RegisterType((*AppFqdn)(nil), "distributed_match_engine.AppFqdn")
	proto.RegisterType((*FqdnListReply)(nil), "distributed_match_engine.FqdnListReply")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.FqdnListReply.TagsEntry")
	proto.RegisterType((*AppOfficialFqdnRequest)(nil), "distributed_match_engine.AppOfficialFqdnRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.AppOfficialFqdnRequest.TagsEntry")
	proto.RegisterType((*AppOfficialFqdnReply)(nil), "distributed_match_engine.AppOfficialFqdnReply")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.AppOfficialFqdnReply.TagsEntry")
	proto.RegisterType((*DynamicLocGroupRequest)(nil), "distributed_match_engine.DynamicLocGroupRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.DynamicLocGroupRequest.TagsEntry")
	proto.RegisterType((*DynamicLocGroupReply)(nil), "distributed_match_engine.DynamicLocGroupReply")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.DynamicLocGroupReply.TagsEntry")
	proto.RegisterType((*QosPosition)(nil), "distributed_match_engine.QosPosition")
	proto.RegisterType((*BandSelection)(nil), "distributed_match_engine.BandSelection")
	proto.RegisterType((*QosPositionRequest)(nil), "distributed_match_engine.QosPositionRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.QosPositionRequest.TagsEntry")
	proto.RegisterType((*QosPositionKpiResult)(nil), "distributed_match_engine.QosPositionKpiResult")
	proto.RegisterType((*QosPositionKpiReply)(nil), "distributed_match_engine.QosPositionKpiReply")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.QosPositionKpiReply.TagsEntry")
	proto.RegisterType((*ClientEdgeEvent)(nil), "distributed_match_engine.ClientEdgeEvent")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.ClientEdgeEvent.TagsEntry")
	proto.RegisterType((*ServerEdgeEvent)(nil), "distributed_match_engine.ServerEdgeEvent")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.ServerEdgeEvent.TagsEntry")
}

func init() { proto.RegisterFile("app-client.proto", fileDescriptor_bb90079a337be67f) }

var fileDescriptor_bb90079a337be67f = []byte{
	// 3772 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x5b, 0xdd, 0x8f, 0xe3, 0x46,
	0x72, 0x5f, 0xea, 0x63, 0x34, 0x2a, 0xcd, 0x68, 0x38, 0x3d, 0x33, 0xbb, 0xb2, 0xd6, 0xbb, 0x5e,
	0xeb, 0x6c, 0x78, 0x3d, 0x67, 0xef, 0xae, 0xc7, 0x1f, 0x7b, 0xde, 0x3b, 0xdf, 0x85, 0x27, 0x71,
	0x66, 0xe8, 0xd5, 0xd7, 0x52, 0x92, 0xf7, 0xf6, 0x2e, 0x00, 0x41, 0x93, 0x3d, 0x1a, 0x62, 0x24,
	0x92, 0x43, 0x52, 0xe3, 0x9d, 0x87, 0x00, 0x41, 0x2e, 0x40, 0x70, 0x08, 0x2e, 0x41, 0x90, 0x20,
	0xc0, 0x01, 0x01, 0x02, 0x04, 0xc8, 0x43, 0x02, 0x04, 0x48, 0x80, 0x7c, 0xfc, 0x09, 0x31, 0xf2,
	0x14, 0x24, 0x4f, 0x41, 0xf2, 0x70, 0x31, 0x82, 0xdc, 0x7f, 0x90, 0x20, 0x6f, 0x41, 0x37, 0x9b,
	0x12, 0x49, 0x51, 0x5a, 0x69, 0x57, 0x6b, 0xc0, 0x6f, 0x62, 0x55, 0x77, 0x57, 0x75, 0xd5, 0xaf,
	0xaa, 0xbb, 0xab, 0x5b, 0xc0, 0xab, 0xb6, 0xfd, 0xae, 0x36, 0x30, 0xb0, 0xe9, 0xdd, 0xb1, 0x1d,
	0xcb, 0xb3, 0x50, 0x49, 0x37, 0x5c, 0xcf, 0x31, 0x3e, 0x1f, 0x79, 0x58, 0x57, 0x86, 0xaa, 0xa7,
	0x9d, 0x2a, 0xd8, 0xec, 0x1b, 0x26, 0x2e, 0xbf, 0xda, 0xb7, 0xac, 0xfe, 0x00, 0xdf, 0x55, 0x6d,
	0xe3, 0xae, 0x6a, 0x9a, 0x96, 0xa7, 0x7a, 0x86, 0x65, 0xba, 0x7e, 0xbf, 0x72, 0x7e, 0x60, 0x69,
	0xec, 0xe7, 0x96, 0x6a, 0xdb, 0x9a, 0x35, 0x1c, 0x5a, 0xa6, 0x4f, 0xa8, 0xfc, 0x71, 0x1a, 0xf6,
	0x64, 0xdc, 0x37, 0x5c, 0x0f, 0x3b, 0x55, 0x2a, 0x4c, 0xc6, 0xe7, 0x23, 0xec, 0x7a, 0x88, 0x87,
	0xf4, 0x05, 0x76, 0x4a, 0xdc, 0x2d, 0xee, 0xf6, 0xa6, 0x4c, 0x7e, 0xa2, 0x57, 0x60, 0xdd, 0x72,
	0xfa, 0x8a, 0xa9, 0x0e, 0x71, 0x29, 0x75, 0x8b, 0xbb, 0x9d, 0x97, 0x73, 0x96, 0xd3, 0x6f, 0xaa,
	0x43, 0x4c, 0x58, 0xaa, 0x6d, 0xfb, 0xac, 0xb4, 0xcf, 0x52, 0x6d, 0x3b, 0xcc, 0xba, 0xc0, 0x8e,
	0x5b, 0xca, 0x8c, 0x59, 0x9f, 0x61, 0xc7, 0x45, 0xaf, 0xc3, 0x86, 0xa6, 0x3a, 0x8e, 0x81, 0x1d,
	0xbf, 0x67, 0x96, 0xb2, 0x0b, 0x8c, 0x46, 0x7b, 0xdf, 0x00, 0x50, 0x47, 0xde, 0xa9, 0xe2, 0x59,
	0x67, 0xd8, 0x2c, 0xad, 0xd1, 0x06, 0x79, 0x42, 0xe9, 0x12, 0x02, 0x7a, 0x03, 0x8a, 0x23, 0xd3,
	0x38, 0x1f, 0x61, 0xc5, 0xd0, 0x15, 0xef, 0xd2, 0xc6, 0xa5, 0x75, 0xda, 0x64, 0xc3, 0xa7, 0x4a,
	0x7a, 0xf7, 0xd2, 0xc6, 0xe8, 0x3a, 0xe4, 0xc7, 0xad, 0x4a, 0x79, 0xda, 0x60, 0x3d, 0x68, 0x80,
	0x1a, 0x90, 0xf1, 0xd4, 0xbe, 0x5b, 0xd2, 0x6f, 0xa5, 0x6f, 0x17, 0x0e, 0x3e, 0xbe, 0x33, 0xcb,
	0xc8, 0x77, 0x12, 0xcd, 0x74, 0xa7, 0xab, 0xf6, 0x5d, 0xd1, 0xf4, 0x9c, 0x4b, 0x99, 0x0e, 0x53,
	0xbe, 0x0f, 0xf9, 0x31, 0x89, 0xd8, 0xf0, 0x0c, 0x5f, 0x52, 0x1b, 0xe6, 0x65, 0xf2, 0x13, 0xed,
	0x42, 0xf6, 0x42, 0x1d, 0x8c, 0x02, 0x03, 0xfa, 0x1f, 0x0f, 0x52, 0xdf, 0xe1, 0x3e, 0xcd, 0xac,
	0xe7, 0xf8, 0x75, 0x39, 0xa7, 0xe1, 0xc1, 0x40, 0x31, 0xf4, 0xca, 0x6f, 0xa6, 0x61, 0x27, 0x2e,
	0xd1, 0x1e, 0x5c, 0x26, 0xb8, 0xe5, 0x13, 0x58, 0x73, 0x3d, 0xd5, 0x1b, 0xb9, 0x74, 0xcc, 0xe2,
	0xc1, 0x9b, 0xf3, 0xa6, 0x60, 0x0f, 0x2e, 0x3b, 0xb4, 0xb1, 0xcc, 0x3a, 0xa1, 0x37, 0xa1, 0xe8,
	0x62, 0xd7, 0x35, 0x2c, 0x53, 0xd1, 0x2c, 0xeb, 0xcc, 0x08, 0x1c, 0xb8, 0xc9, 0xa8, 0x55, 0x4a,
	0x44, 0xb7, 0x81, 0xa7, 0x3e, 0x50, 0x5c, 0xec, 0x5c, 0x60, 0x47, 0x19, 0x39, 0x06, 0x73, 0x67,
	0x91, 0xd2, 0x3b, 0x94, 0xdc, 0x73, 0x8c, 0x04, 0x9f, 0x64, 0x9f, 0xe5, 0x93, 0xb5, 0x98, 0x4f,
	0x1e, 0x46, 0x7c, 0x72, 0x7f, 0x71, 0x9f, 0xd8, 0x83, 0xcb, 0x95, 0x79, 0xa4, 0xf2, 0x65, 0x0a,
	0x76, 0x0e, 0x0d, 0x53, 0xaf, 0x0e, 0xac, 0x91, 0x3e, 0xc0, 0x73, 0x22, 0x63, 0xda, 0x86, 0xa9,
	0x24, 0x1b, 0xc6, 0xf1, 0x9e, 0x9e, 0xc6, 0xfb, 0xaf, 0xc1, 0x46, 0xdf, 0x76, 0x95, 0x81, 0xa5,
	0xd1, 0x10, 0xa6, 0x26, 0x2e, 0x1c, 0xdc, 0x98, 0x6d, 0x81, 0xba, 0xa5, 0xc9, 0x85, 0xbe, 0xed,
	0xd6, 0x59, 0x8f, 0xc5, 0x6d, 0x97, 0x30, 0xb5, 0x55, 0xa2, 0x79, 0x9d, 0xcf, 0x4f, 0xd0, 0xfc,
	0x97, 0x29, 0xb8, 0xde, 0x1e, 0xa8, 0xde, 0x89, 0xe5, 0x0c, 0xbf, 0x6e, 0x93, 0x92, 0x26, 0x14,
	0x1e, 0x2c, 0x89, 0x64, 0x58, 0x13, 0x4a, 0xf3, 0xd3, 0x48, 0x27, 0x62, 0xb3, 0x1f, 0xcc, 0xb6,
	0xd9, 0x9c, 0x39, 0xac, 0x0e, 0x77, 0xbf, 0xcc, 0xc2, 0x76, 0x54, 0x40, 0x72, 0xe0, 0x37, 0x63,
	0x81, 0xff, 0xd1, 0xa2, 0xbe, 0x26, 0x51, 0x42, 0x28, 0xb1, 0x4c, 0x80, 0x20, 0x73, 0x72, 0xae,
	0x9b, 0xcc, 0x86, 0xf4, 0x37, 0xba, 0x0f, 0x59, 0xdb, 0x72, 0x3c, 0x92, 0xba, 0x89, 0x69, 0x5e,
	0x9f, 0x2d, 0x42, 0xb0, 0xed, 0xb6, 0xe5, 0x78, 0xb2, 0xdf, 0x1e, 0x7d, 0x0a, 0xdb, 0x1a, 0x13,
	0x38, 0x41, 0x73, 0x76, 0x11, 0x34, 0xf3, 0x41, 0xbf, 0x31, 0xa4, 0xdf, 0x01, 0x84, 0xf5, 0x3e,
	0x56, 0xf0, 0x05, 0x36, 0x3d, 0x37, 0xc0, 0x83, 0x9f, 0x34, 0x78, 0xc2, 0x11, 0x29, 0x83, 0x41,
	0xe2, 0x27, 0x00, 0xe7, 0x96, 0xab, 0x38, 0xd8, 0x1d, 0x0d, 0xbc, 0x52, 0x8e, 0x9a, 0xe6, 0x7b,
	0xcb, 0x98, 0xe6, 0x91, 0xe5, 0x76, 0x7c, 0x90, 0xc9, 0x74, 0x0c, 0x39, 0x7f, 0x6e, 0xb9, 0xfe,
	0x4f, 0x54, 0x81, 0x4d, 0x32, 0x38, 0x76, 0x1c, 0xcb, 0x51, 0x86, 0x6e, 0x9f, 0xad, 0x37, 0x85,
	0x73, 0xcb, 0x15, 0x09, 0xad, 0xe1, 0xf6, 0x91, 0x14, 0x41, 0xd3, 0x87, 0xcb, 0x88, 0x5e, 0x19,
	0x86, 0x04, 0x80, 0x89, 0x87, 0x11, 0x0f, 0x1b, 0x87, 0x52, 0xb3, 0xa6, 0xf4, 0x9a, 0x0f, 0x9b,
	0xad, 0xc7, 0x4d, 0xfe, 0x0a, 0x2a, 0x02, 0x50, 0xca, 0x61, 0xab, 0xd7, 0xac, 0xf1, 0x1c, 0xda,
	0x86, 0x4d, 0xfa, 0xdd, 0x6c, 0x75, 0x7d, 0x52, 0xaa, 0xf2, 0x63, 0xe0, 0xe3, 0x96, 0x40, 0x7b,
	0xb0, 0xfd, 0xa8, 0xd5, 0x21, 0xad, 0x14, 0xa1, 0xdb, 0x15, 0x1b, 0xed, 0xae, 0x58, 0xe3, 0xaf,
	0xa0, 0x6b, 0xb0, 0x43, 0xc8, 0x1d, 0xb1, 0xd3, 0x91, 0x5a, 0x4d, 0xa5, 0x2a, 0x8b, 0x02, 0x61,
	0x70, 0xe8, 0x2a, 0xa0, 0x30, 0xe3, 0x50, 0x90, 0xea, 0x22, 0x19, 0xfb, 0x2f, 0xd6, 0xe0, 0xb5,
	0x47, 0x96, 0xdb, 0x76, 0x0c, 0xcb, 0x31, 0xbc, 0x4b, 0x26, 0xa4, 0xea, 0x60, 0xd5, 0xc3, 0x2f,
	0x9c, 0x13, 0xde, 0x06, 0x3e, 0x68, 0xa6, 0x8f, 0x1c, 0x1f, 0x79, 0x69, 0x3a, 0xca, 0x16, 0xa3,
	0xd7, 0x18, 0x19, 0xed, 0xc3, 0xb6, 0x61, 0x2b, 0x23, 0x17, 0x3b, 0x0a, 0x3e, 0x1f, 0x19, 0xf6,
	0x10, 0x9b, 0x1e, 0x4b, 0x10, 0x5b, 0x86, 0xdd, 0x73, 0xb1, 0x23, 0x06, 0x64, 0x74, 0x00, 0x7b,
	0x86, 0xad, 0xa8, 0xb6, 0x3d, 0x30, 0x7c, 0x5c, 0xb2, 0xa5, 0x90, 0x2d, 0x6f, 0x3b, 0x86, 0x2d,
	0x4c, 0x78, 0xfe, 0x72, 0x88, 0xee, 0xc0, 0x0e, 0x09, 0x87, 0xb8, 0x04, 0x1f, 0xba, 0xdb, 0x84,
	0x15, 0x95, 0xf1, 0x11, 0x5c, 0xa3, 0xed, 0x13, 0xa4, 0xe4, 0x68, 0x9f, 0x3d, 0xc2, 0x9e, 0x96,
	0xd3, 0x80, 0x02, 0xdd, 0xcf, 0x69, 0xd6, 0x40, 0x31, 0x4c, 0x0a, 0xca, 0xe2, 0xc1, 0x3b, 0xb3,
	0x91, 0x37, 0x71, 0x6c, 0x9b, 0x75, 0x93, 0x21, 0x18, 0x40, 0x32, 0x51, 0x0b, 0x36, 0xc6, 0xc3,
	0x59, 0x23, 0x8f, 0xee, 0x99, 0x96, 0x1d, 0x6f, 0xac, 0x50, 0x6b, 0xe4, 0x21, 0x11, 0x72, 0xb6,
	0x63, 0x9d, 0x18, 0x03, 0x5c, 0x02, 0x3a, 0xd6, 0xb7, 0x17, 0x1c, 0x8b, 0x74, 0x91, 0x83, 0xbe,
	0xc4, 0xb3, 0xa6, 0xe5, 0x19, 0x27, 0x81, 0x69, 0xc8, 0x26, 0xa4, 0xe0, 0x7b, 0x2b, 0x4c, 0x27,
	0xbb, 0x90, 0x8f, 0xe0, 0x5a, 0xa4, 0x69, 0x68, 0x17, 0xb9, 0xe1, 0x5b, 0x32, 0xcc, 0x16, 0xc6,
	0x3b, 0xca, 0xc7, 0x91, 0xe0, 0xad, 0xce, 0x55, 0x73, 0x1e, 0x7c, 0x57, 0x17, 0xca, 0x7f, 0x9e,
	0x86, 0x6b, 0xd3, 0xc2, 0x66, 0x2d, 0x0a, 0x49, 0xe0, 0x4f, 0x25, 0x83, 0x3f, 0xe4, 0x94, 0xf4,
	0x0b, 0x38, 0xe5, 0x06, 0x40, 0x20, 0xd1, 0xd0, 0x59, 0xf0, 0xe4, 0x19, 0x45, 0xd2, 0x29, 0xdb,
	0x53, 0x1d, 0x32, 0xa2, 0xea, 0xd1, 0x58, 0xd9, 0x94, 0xf3, 0x8c, 0x22, 0x78, 0x84, 0x8d, 0x9f,
	0xda, 0x86, 0x83, 0x5d, 0xc2, 0x5e, 0xf3, 0xd9, 0x8c, 0x22, 0x78, 0xe8, 0x35, 0x28, 0x9c, 0x7a,
	0x9e, 0xad, 0xb0, 0x85, 0x2e, 0x47, 0xf9, 0x40, 0x48, 0x2c, 0xb5, 0xb5, 0x22, 0xfe, 0xfa, 0xee,
	0x32, 0xfe, 0x5a, 0x71, 0xca, 0xfd, 0x97, 0x54, 0x52, 0x4e, 0xab, 0xe1, 0x01, 0x5e, 0x41, 0x4e,
	0xfb, 0x7a, 0x7c, 0xf5, 0x02, 0xe0, 0x8f, 0xcc, 0x73, 0x75, 0x46, 0xfd, 0x55, 0x0a, 0x6e, 0xcc,
	0x16, 0x96, 0x1c, 0x02, 0xbf, 0x1e, 0xdb, 0x17, 0xd5, 0x9e, 0x67, 0x1e, 0x04, 0x1a, 0xfe, 0xef,
	0xd8, 0x2e, 0xa9, 0x17, 0xb1, 0x91, 0xf0, 0xbc, 0x63, 0xaf, 0xcc, 0x42, 0x87, 0xb0, 0x11, 0xd6,
	0x93, 0xac, 0xf5, 0x8f, 0x6a, 0x62, 0x3d, 0xb4, 0xd6, 0x07, 0x94, 0x9a, 0x58, 0x17, 0xfd, 0x65,
	0x19, 0x41, 0x91, 0x52, 0xc8, 0x3a, 0x1e, 0x2c, 0xf7, 0xff, 0x93, 0x82, 0xbd, 0xcf, 0xb0, 0x63,
	0x9c, 0x5c, 0x06, 0xfb, 0xae, 0x6f, 0xc6, 0x79, 0xe7, 0x36, 0xf0, 0x17, 0x54, 0x6d, 0x32, 0x08,
	0xcb, 0xf0, 0xfe, 0x8a, 0x5c, 0xbc, 0x08, 0xa6, 0xe3, 0xa7, 0xf6, 0x85, 0x4f, 0xfa, 0x89, 0x66,
	0x58, 0xe5, 0xd9, 0x68, 0x8d, 0xcf, 0x4d, 0xce, 0x46, 0x3f, 0x5b, 0x83, 0x9d, 0xb8, 0xc4, 0x59,
	0xc0, 0xde, 0xf0, 0xac, 0x2f, 0xb0, 0xa3, 0x44, 0xe0, 0xbd, 0xc4, 0x44, 0x28, 0xf0, 0xc8, 0x08,
	0x0c, 0xd3, 0x05, 0x6f, 0xf2, 0x81, 0x2c, 0xd8, 0x09, 0xbb, 0x22, 0x10, 0xe2, 0xa7, 0x9b, 0x1f,
	0x2c, 0x27, 0xe4, 0xa8, 0xdd, 0x09, 0x08, 0x4c, 0xd4, 0x76, 0xc8, 0x67, 0x4c, 0xe0, 0x7d, 0x28,
	0x45, 0x04, 0xaa, 0x9a, 0x36, 0x72, 0x54, 0xed, 0x52, 0x39, 0x1b, 0x52, 0x1c, 0x70, 0xf2, 0x5e,
	0xa8, 0x93, 0xc0, 0xb8, 0x0f, 0x87, 0x8b, 0x1f, 0x71, 0x13, 0xe7, 0xbf, 0xaa, 0xc0, 0x3b, 0x85,
	0x42, 0xc8, 0x96, 0x64, 0x07, 0xdd, 0x6d, 0x3d, 0x16, 0xe5, 0x50, 0xe0, 0xdd, 0x82, 0x57, 0xab,
	0xad, 0x66, 0x53, 0xac, 0x76, 0xc5, 0x9a, 0xd2, 0x6d, 0x29, 0x9d, 0xb6, 0x58, 0x95, 0x0e, 0x25,
	0xfa, 0xf1, 0x58, 0x94, 0x79, 0x0e, 0xbd, 0x01, 0xb7, 0x48, 0x0c, 0xce, 0x6d, 0x95, 0xaa, 0xfc,
	0x8a, 0x83, 0xed, 0x29, 0x8b, 0xa2, 0x2d, 0x28, 0xd4, 0x5b, 0xd5, 0x68, 0x9c, 0x13, 0xc2, 0x67,
	0xa2, 0x4c, 0xbb, 0xf3, 0x1c, 0xba, 0x01, 0xaf, 0x10, 0x4a, 0x43, 0xea, 0x34, 0x84, 0x6e, 0xf5,
	0x58, 0xe9, 0x08, 0x0d, 0x51, 0xa9, 0xb6, 0x7a, 0xcd, 0xae, 0xfc, 0x84, 0x4f, 0xa1, 0x9b, 0x50,
	0x8e, 0xb0, 0x5b, 0xdd, 0x63, 0x51, 0x1e, 0xf3, 0xd3, 0x41, 0x77, 0xb9, 0x25, 0x34, 0xa4, 0xe6,
	0x51, 0xc0, 0x50, 0x68, 0x63, 0x3e, 0x43, 0xa6, 0x97, 0xc8, 0x66, 0xc3, 0xf1, 0x59, 0x54, 0x86,
	0xab, 0xa4, 0x85, 0x28, 0xcb, 0x2d, 0x62, 0x17, 0xa1, 0xd7, 0x3d, 0x6e, 0xc9, 0xd2, 0x8f, 0xc5,
	0x1a, 0xbf, 0x86, 0x76, 0x60, 0x6b, 0xc2, 0xa3, 0x92, 0xf9, 0x5c, 0xe5, 0xb7, 0x53, 0x80, 0x8e,
	0x26, 0x27, 0xbf, 0xaf, 0x23, 0x03, 0x7d, 0x1a, 0x01, 0xd3, 0x9c, 0x33, 0xf4, 0xb4, 0x5e, 0xab,
	0x4c, 0x09, 0x19, 0x3e, 0x3b, 0x49, 0x09, 0x7f, 0x97, 0x06, 0x3e, 0x22, 0x2e, 0x39, 0x1f, 0xd4,
	0x63, 0x0b, 0xdd, 0x07, 0x0b, 0x2a, 0x4f, 0xc2, 0xa0, 0x6e, 0x69, 0xb1, 0x85, 0x6d, 0x01, 0x5b,
	0xed, 0x42, 0x96, 0x66, 0x0c, 0x1a, 0x9e, 0x19, 0xd9, 0xff, 0x40, 0xc7, 0xc0, 0x9b, 0xd8, 0xfb,
	0xc2, 0x72, 0xce, 0x96, 0x3c, 0xe9, 0x6f, 0xb1, 0x6e, 0xe3, 0x5c, 0x7e, 0x1c, 0xf1, 0xc5, 0x32,
	0xd3, 0x59, 0x59, 0x54, 0x7f, 0x17, 0xf2, 0x63, 0xd3, 0x4c, 0x87, 0xd8, 0x26, 0xe4, 0x09, 0x21,
	0x38, 0x35, 0x17, 0x01, 0xc8, 0x67, 0x4d, 0x6c, 0x4a, 0xf4, 0x58, 0xfb, 0x1f, 0x29, 0x40, 0x82,
	0x6d, 0x4b, 0xa6, 0xeb, 0xd5, 0x0d, 0xf7, 0x1b, 0x52, 0x30, 0xdc, 0x85, 0xec, 0xc0, 0x18, 0x1a,
	0xc1, 0xe6, 0xdb, 0xff, 0x58, 0x3c, 0x2c, 0xa6, 0xe7, 0xbb, 0xca, 0xb0, 0xc8, 0xf2, 0x6b, 0x93,
	0xb0, 0xf8, 0x37, 0x0e, 0x0a, 0x82, 0x6d, 0x1b, 0xa6, 0xeb, 0xa9, 0xa6, 0x16, 0xbd, 0x75, 0xe0,
	0x66, 0xdf, 0x3a, 0xa4, 0xa2, 0xb7, 0x0e, 0x2b, 0x2d, 0x73, 0x85, 0xef, 0x44, 0xb2, 0xd1, 0x3b,
	0x91, 0xa5, 0xaa, 0x56, 0x95, 0x9f, 0xa6, 0x80, 0xaf, 0xc6, 0x0b, 0x5f, 0x71, 0xff, 0x73, 0xd3,
	0xfe, 0xff, 0x16, 0x6c, 0x8e, 0xeb, 0x6c, 0xa1, 0x9b, 0x99, 0x8d, 0x80, 0x98, 0x08, 0x92, 0xf4,
	0xd2, 0x20, 0x29, 0xc3, 0x3a, 0x69, 0x4c, 0xcc, 0xce, 0xd6, 0xe6, 0xf1, 0x37, 0x92, 0x60, 0x43,
	0x9d, 0x78, 0xc5, 0x2d, 0x65, 0xa9, 0x0d, 0xdf, 0x9c, 0x6b, 0xc3, 0xa0, 0xb5, 0x1c, 0xe9, 0x5a,
	0xf9, 0xbf, 0x14, 0xf0, 0x11, 0x40, 0x25, 0x27, 0xbe, 0x87, 0xb1, 0xc4, 0xf7, 0xfe, 0x82, 0xf0,
	0x24, 0x99, 0x42, 0x90, 0x62, 0x79, 0xef, 0x18, 0xf2, 0x81, 0xb1, 0xc8, 0x6e, 0x87, 0xe8, 0xbe,
	0x3f, 0x7b, 0xbc, 0xb8, 0x8f, 0xe4, 0x49, 0xe7, 0xc5, 0xd3, 0xd7, 0x94, 0x52, 0x2b, 0x4b, 0x5f,
	0x1f, 0xc3, 0x7a, 0x30, 0x41, 0xb2, 0x1f, 0x10, 0x24, 0xa5, 0xd7, 0xac, 0x89, 0x87, 0x52, 0x93,
	0xd6, 0xe9, 0x8a, 0x00, 0x82, 0xa4, 0x74, 0x7a, 0xd5, 0xaa, 0xd8, 0xe9, 0xf0, 0x1c, 0x2a, 0x40,
	0x4e, 0x90, 0x68, 0x55, 0x8e, 0x4f, 0x55, 0xfe, 0x9d, 0x83, 0xad, 0xc3, 0x73, 0xdd, 0x5c, 0x49,
	0xe6, 0x3a, 0x8a, 0x98, 0x62, 0x8e, 0x7f, 0x62, 0x12, 0x57, 0x99, 0x3b, 0xd2, 0x7c, 0x66, 0x92,
	0x3b, 0xfe, 0x8c, 0x83, 0x9c, 0x60, 0xdb, 0x44, 0xdc, 0x73, 0xe6, 0x8d, 0x70, 0xa8, 0xa7, 0xa3,
	0xa1, 0xbe, 0x0b, 0x59, 0x92, 0x46, 0xfc, 0xf4, 0x91, 0x97, 0xfd, 0x0f, 0x74, 0x0f, 0x76, 0x55,
	0x53, 0x77, 0x2c, 0x43, 0x57, 0x6c, 0x55, 0x3b, 0x53, 0xfb, 0x38, 0x9c, 0x27, 0x10, 0xe3, 0xb5,
	0x7d, 0x16, 0x19, 0xa7, 0xf2, 0xdf, 0x29, 0xd8, 0x9c, 0x18, 0x24, 0x19, 0xfb, 0xdf, 0x87, 0x3c,
	0xd1, 0xd0, 0x97, 0x97, 0x5e, 0x20, 0x5d, 0x91, 0x01, 0x65, 0x32, 0xab, 0x43, 0xaa, 0xd5, 0xf1,
	0x38, 0x76, 0x32, 0x34, 0x76, 0xee, 0x2d, 0xe2, 0x1b, 0x7a, 0x63, 0x50, 0x8f, 0x05, 0x8e, 0x18,
	0xf1, 0xf1, 0x7b, 0x8b, 0x8e, 0xb3, 0x4a, 0xac, 0x07, 0x3a, 0xd1, 0x0a, 0x77, 0x3d, 0x8e, 0xf5,
	0xc3, 0x7a, 0x14, 0xeb, 0x87, 0xf5, 0x00, 0xeb, 0x7f, 0x92, 0x82, 0xab, 0x82, 0x6d, 0xb7, 0x4e,
	0x4e, 0x0c, 0xcd, 0x50, 0x07, 0xd4, 0x44, 0x2f, 0x0a, 0xf9, 0x17, 0x4f, 0xb2, 0xcd, 0x88, 0x41,
	0x1f, 0xcc, 0xf5, 0x6a, 0x82, 0xea, 0x2b, 0xbc, 0xf9, 0x4c, 0xc3, 0xee, 0x94, 0x8c, 0x64, 0x38,
	0xee, 0xc3, 0x36, 0x81, 0xa3, 0xc5, 0x9a, 0x52, 0x5c, 0xb2, 0x01, 0xb7, 0xd4, 0xe8, 0x10, 0x53,
	0x37, 0x71, 0xe9, 0xe9, 0x9b, 0xb8, 0x76, 0x0c, 0x9d, 0xdf, 0x59, 0xc2, 0x08, 0x34, 0xbb, 0xb7,
	0x0e, 0x63, 0x28, 0x1d, 0x2f, 0xed, 0xd9, 0x25, 0x97, 0xf6, 0x7a, 0xc4, 0x1b, 0xcb, 0x2a, 0xb2,
	0x32, 0x5f, 0x7c, 0x02, 0xf9, 0xf1, 0xa4, 0xc8, 0x21, 0x53, 0x68, 0x1d, 0x46, 0x70, 0xbe, 0x05,
	0x05, 0x42, 0x9a, 0x00, 0x7d, 0x03, 0xd6, 0x09, 0x81, 0x21, 0xfd, 0xef, 0xd3, 0x70, 0xb5, 0x76,
	0x69, 0xaa, 0x43, 0x43, 0xab, 0x5b, 0xda, 0x91, 0x63, 0x8d, 0xec, 0x17, 0x46, 0xfa, 0x0e, 0x64,
	0x07, 0x7d, 0xc5, 0xd0, 0xa9, 0x03, 0x33, 0x72, 0x66, 0xd0, 0x97, 0x74, 0xf4, 0x04, 0xf2, 0x9a,
	0x35, 0x1c, 0xfa, 0x37, 0xfe, 0x85, 0x67, 0xdd, 0xba, 0x25, 0xab, 0x74, 0xa7, 0x36, 0xe8, 0x57,
	0xad, 0xe1, 0xb0, 0x7b, 0x69, 0x63, 0x79, 0x5d, 0x63, 0xbf, 0xe8, 0x5b, 0x01, 0x17, 0x3b, 0x8a,
	0xae, 0x7a, 0x2a, 0xab, 0xde, 0xaf, 0x13, 0x42, 0x4d, 0xf5, 0xd4, 0xc5, 0x83, 0x66, 0x86, 0xc8,
	0x95, 0x39, 0xea, 0xfb, 0x50, 0x08, 0xa9, 0x4f, 0x5c, 0x55, 0xab, 0x1f, 0xc5, 0x53, 0x12, 0x21,
	0x75, 0xc4, 0x6a, 0x4f, 0x16, 0x7d, 0x4f, 0x91, 0xef, 0x56, 0x5b, 0x6c, 0xf2, 0xa9, 0x4f, 0x33,
	0xeb, 0x9b, 0x7c, 0x71, 0xb2, 0x60, 0xfd, 0x75, 0x0a, 0x76, 0xa7, 0x54, 0x7e, 0x29, 0x2f, 0x40,
	0x6e, 0x00, 0xf8, 0xf7, 0x99, 0x9a, 0xa5, 0x63, 0x76, 0x53, 0x96, 0xa7, 0x94, 0xaa, 0xa5, 0xd3,
	0x43, 0x48, 0x9f, 0x48, 0x0f, 0x20, 0xc1, 0x5e, 0xe9, 0x50, 0x1a, 0x03, 0xc4, 0xc2, 0xa1, 0x92,
	0x34, 0xa1, 0xd5, 0x79, 0xc0, 0x82, 0xc2, 0x23, 0xcb, 0x6d, 0x5b, 0xae, 0x41, 0xd3, 0xe9, 0x4d,
	0x00, 0x9b, 0xfd, 0x36, 0x74, 0x3a, 0x42, 0x5a, 0x0e, 0x51, 0xa6, 0x12, 0x76, 0x6a, 0xd9, 0x84,
	0x5d, 0x39, 0x83, 0xcd, 0x1f, 0xaa, 0xa6, 0xde, 0xc1, 0x03, 0xac, 0x51, 0x91, 0x7b, 0xb0, 0xe6,
	0xa8, 0x9e, 0x72, 0xd0, 0x2f, 0x71, 0xfe, 0x4e, 0xc0, 0x51, 0xbd, 0x83, 0x7e, 0x40, 0x7e, 0xbf,
	0x5f, 0x4a, 0x8d, 0xc9, 0xef, 0x8f, 0xc9, 0x1f, 0xf4, 0xe9, 0x3a, 0xee, 0x93, 0x3f, 0x18, 0x93,
	0x3f, 0xec, 0x07, 0xdb, 0x09, 0x47, 0xf5, 0x3e, 0xec, 0x57, 0x7e, 0x91, 0x06, 0x14, 0x9a, 0xde,
	0x0b, 0x47, 0x71, 0x15, 0xf2, 0x81, 0x31, 0x82, 0x8d, 0xc4, 0x9b, 0xf3, 0xab, 0xd9, 0x81, 0xe4,
	0x49, 0x3f, 0x02, 0x8e, 0x81, 0x87, 0x15, 0x4d, 0xf5, 0x70, 0xdf, 0x72, 0x2e, 0x69, 0xd6, 0xce,
	0xca, 0x85, 0x81, 0x87, 0xab, 0x8c, 0x84, 0x9a, 0x50, 0xfc, 0x5c, 0x35, 0x75, 0xc5, 0x0d, 0xac,
	0xc4, 0x8a, 0x03, 0x6f, 0xcd, 0x16, 0x16, 0x31, 0xaa, 0xbc, 0xf9, 0x79, 0xc4, 0xc6, 0x0b, 0x9f,
	0x4c, 0xa7, 0x8d, 0xf5, 0xd2, 0x6a, 0xb8, 0x3f, 0xcf, 0xc0, 0x6e, 0x48, 0xdc, 0x43, 0xdb, 0x60,
	0x17, 0xe6, 0x2f, 0x1d, 0x83, 0xe8, 0x3d, 0xd8, 0xd5, 0x07, 0x24, 0x1b, 0x7a, 0xa7, 0x8e, 0x35,
	0xea, 0x9f, 0xda, 0x23, 0x4f, 0x19, 0x1a, 0xfe, 0xe2, 0x9a, 0x92, 0x77, 0xe2, 0xbc, 0x86, 0x91,
	0xdc, 0x45, 0xbd, 0xe8, 0x53, 0xe7, 0x25, 0x74, 0x11, 0x2e, 0xfa, 0xc9, 0x52, 0xd4, 0xa7, 0xd4,
	0x95, 0x49, 0x52, 0xd4, 0xa7, 0xa4, 0xcb, 0x28, 0x49, 0xb1, 0x35, 0xbf, 0xcb, 0x28, 0x59, 0xb1,
	0x51, 0x92, 0x62, 0xb9, 0xe4, 0x2e, 0x4c, 0xb1, 0x51, 0x92, 0x62, 0xeb, 0x33, 0xa4, 0xa8, 0x4f,
	0xd1, 0x6b, 0x50, 0x18, 0xa8, 0x1e, 0x36, 0xb5, 0x4b, 0xaa, 0x4f, 0x9e, 0xb6, 0x04, 0x46, 0x22,
	0x6a, 0x84, 0x1a, 0x10, 0xe9, 0x10, 0x69, 0x40, 0x84, 0x86, 0x47, 0x50, 0x9f, 0xd2, 0xd5, 0x2e,
	0x34, 0x82, 0xfa, 0xb4, 0xf2, 0x8f, 0x29, 0xd8, 0x89, 0xe3, 0xe1, 0xa5, 0xe4, 0xee, 0x27, 0xc0,
	0x07, 0x68, 0x62, 0x2f, 0x5e, 0x82, 0x58, 0xbe, 0xb3, 0x50, 0x60, 0x8c, 0x91, 0x2a, 0x6f, 0xd9,
	0xe3, 0x58, 0xa1, 0xc3, 0x2c, 0x5e, 0x65, 0x4f, 0x98, 0xe8, 0xea, 0x72, 0xfa, 0x3f, 0xad, 0xc1,
	0x96, 0xff, 0xba, 0x4f, 0x0c, 0x4a, 0x26, 0x09, 0x09, 0x8e, 0x4b, 0x4a, 0x70, 0xc9, 0x05, 0x98,
	0xd4, 0x8c, 0x67, 0x43, 0x3f, 0x02, 0xa0, 0x0d, 0xfd, 0x0d, 0x4c, 0xfa, 0x59, 0x57, 0x2b, 0x31,
	0x9d, 0x82, 0x6f, 0xf2, 0x9b, 0xee, 0x5e, 0xf2, 0x38, 0xf8, 0xb9, 0x82, 0x12, 0xdd, 0x03, 0xc8,
	0xb9, 0xea, 0xd0, 0x1e, 0x8c, 0x8b, 0x2b, 0xb7, 0x66, 0x77, 0xee, 0xd0, 0x86, 0x72, 0xd0, 0x01,
	0xfd, 0x08, 0x90, 0x8e, 0x2f, 0x0c, 0x0d, 0x2b, 0x86, 0x79, 0x62, 0xd1, 0x5b, 0x1d, 0x43, 0xa3,
	0x41, 0x38, 0xb7, 0xce, 0x51, 0xa3, 0x7d, 0x24, 0xf3, 0xc4, 0xea, 0xd0, 0x1e, 0x32, 0xaf, 0xc7,
	0x28, 0xe8, 0x27, 0xb0, 0x13, 0x1e, 0x59, 0xf7, 0xd7, 0x76, 0x1a, 0xac, 0x85, 0x79, 0xf7, 0xd3,
	0x93, 0xa1, 0xd9, 0x76, 0x40, 0xde, 0xd6, 0xe3, 0x24, 0x7a, 0x56, 0x18, 0xb9, 0x9e, 0x35, 0xf4,
	0xdd, 0x17, 0xbc, 0xb3, 0xf2, 0x69, 0x3e, 0x0c, 0x16, 0xae, 0x31, 0xc4, 0x7d, 0xb5, 0x32, 0x70,
	0xfe, 0x15, 0x37, 0x06, 0xe7, 0xd8, 0xdb, 0xdb, 0xb0, 0x29, 0x7e, 0x26, 0x36, 0xbb, 0xa1, 0xaa,
	0xf1, 0x2b, 0xb0, 0xe7, 0x93, 0xa4, 0xa6, 0x34, 0xbe, 0xec, 0x91, 0x5a, 0x4d, 0x9e, 0x43, 0x37,
	0xa1, 0xec, 0xb3, 0xba, 0xa2, 0xdc, 0x90, 0x9a, 0x42, 0x57, 0x0c, 0xf3, 0x53, 0x93, 0xae, 0x75,
	0xa1, 0x2b, 0x36, 0xab, 0x4f, 0x94, 0x8e, 0xd0, 0x68, 0xd7, 0xc5, 0x0e, 0x9f, 0x0e, 0xb1, 0x5a,
	0x55, 0x81, 0x34, 0x57, 0x7a, 0xed, 0x9a, 0xd0, 0x15, 0xf9, 0x0c, 0xba, 0x0a, 0xc8, 0x67, 0x55,
	0x7b, 0x9d, 0x6e, 0xab, 0xa1, 0xd0, 0x0f, 0x3e, 0x5b, 0xf9, 0x79, 0x0e, 0xb6, 0xfc, 0x17, 0x43,
	0x93, 0x60, 0x8a, 0xe2, 0x9e, 0x7b, 0x16, 0xee, 0x63, 0xdd, 0x83, 0xef, 0x24, 0xdc, 0x37, 0xa1,
	0x38, 0x2e, 0x4d, 0x12, 0xd8, 0x61, 0x96, 0xe2, 0xde, 0x7a, 0x76, 0x75, 0x8d, 0x20, 0x0c, 0xcb,
	0xe3, 0xca, 0x26, 0xfd, 0x44, 0x8f, 0x61, 0x7b, 0xa8, 0x1a, 0xa6, 0x87, 0x4d, 0xd5, 0xd4, 0x30,
	0x1b, 0xd2, 0x0f, 0xd4, 0x39, 0x40, 0x6e, 0x4c, 0xba, 0xf8, 0xa3, 0xf2, 0xc3, 0x18, 0x05, 0x1d,
	0xc3, 0xc6, 0x29, 0x56, 0x07, 0xde, 0xa9, 0xa2, 0x9d, 0x62, 0xed, 0x8c, 0x1d, 0x3d, 0xe7, 0x64,
	0xe2, 0x63, 0xda, 0xba, 0x4a, 0x1a, 0xcb, 0x85, 0xd3, 0xc9, 0x07, 0xaa, 0xd1, 0xc7, 0x2e, 0x9e,
	0xe1, 0x7a, 0x86, 0xe6, 0xb2, 0x7d, 0xce, 0x1b, 0x73, 0x8c, 0x39, 0x6e, 0x2b, 0x87, 0xfa, 0xa1,
	0x26, 0x6c, 0x98, 0xf8, 0x0b, 0x25, 0x98, 0x3d, 0x0b, 0xd6, 0x6f, 0x2f, 0xf1, 0x90, 0x50, 0x2e,
	0x98, 0xf8, 0x8b, 0x80, 0x42, 0xce, 0x4f, 0x93, 0x07, 0x8b, 0xfe, 0x3b, 0xb2, 0x75, 0x1c, 0xbc,
	0x56, 0x5c, 0x38, 0x8a, 0xe2, 0x9e, 0x5f, 0x59, 0x14, 0xfd, 0x2f, 0x37, 0x46, 0xe5, 0x73, 0x46,
	0xd1, 0x54, 0x94, 0xc8, 0xe2, 0xa3, 0x9e, 0xd8, 0xe9, 0xf2, 0x29, 0x74, 0x1d, 0xae, 0x45, 0x59,
	0x6d, 0xb9, 0x45, 0x0e, 0xca, 0x62, 0x8d, 0x4f, 0xa3, 0x12, 0xec, 0xb2, 0x38, 0xa9, 0xb7, 0x7a,
	0xb5, 0xba, 0xd8, 0x55, 0x3a, 0x5d, 0x3f, 0x82, 0xc6, 0x71, 0x39, 0xe6, 0x34, 0x04, 0xa9, 0xd9,
	0x15, 0x9b, 0x42, 0xb3, 0x2a, 0xf2, 0xd9, 0x49, 0x4f, 0xa1, 0xdd, 0x96, 0x9a, 0x9d, 0xae, 0x72,
	0x2c, 0x0a, 0xf5, 0xee, 0x31, 0xbf, 0x36, 0xd1, 0x65, 0xdc, 0x93, 0x85, 0x65, 0x8e, 0x1c, 0xd5,
	0x7d, 0x16, 0xbd, 0xf4, 0xe4, 0xd7, 0xf7, 0x3f, 0x81, 0x9c, 0x54, 0x23, 0xf3, 0xa5, 0x05, 0x2c,
	0xa9, 0x16, 0x39, 0x2d, 0xae, 0x43, 0x46, 0x6a, 0x88, 0x12, 0xcf, 0x21, 0x80, 0xb5, 0x46, 0x47,
	0xea, 0xd4, 0x48, 0x42, 0x00, 0x58, 0x93, 0xda, 0x42, 0xad, 0x26, 0xf3, 0xe9, 0xfd, 0xef, 0x41,
	0x21, 0xb4, 0x27, 0x20, 0x43, 0xc8, 0x9d, 0xf8, 0x81, 0x53, 0xee, 0x44, 0x6b, 0x60, 0x72, 0x87,
	0x55, 0x06, 0xf6, 0x7f, 0x8f, 0x83, 0xed, 0xa9, 0xa7, 0x42, 0x68, 0x07, 0xb6, 0xfc, 0x17, 0x9e,
	0x4a, 0x5b, 0x96, 0x5a, 0xb2, 0xd4, 0x7d, 0xc2, 0x5f, 0x09, 0x88, 0xf5, 0xd6, 0xe3, 0xc0, 0x8c,
	0xbe, 0xd1, 0x09, 0xb1, 0x7b, 0x2c, 0xb7, 0x7a, 0x47, 0xc7, 0xed, 0x5e, 0x57, 0xa9, 0xb5, 0x1e,
	0x37, 0x95, 0x8e, 0x9f, 0xb5, 0x92, 0x58, 0x0d, 0x3f, 0x6b, 0x25, 0xb1, 0xea, 0x7c, 0x66, 0xff,
	0x2e, 0x3d, 0xdf, 0xc4, 0xde, 0x11, 0xa2, 0x1c, 0xa4, 0xbb, 0xd5, 0x36, 0x7f, 0x85, 0xfc, 0xe8,
	0xd5, 0xda, 0x3c, 0x47, 0x7e, 0x08, 0xcd, 0x27, 0x7c, 0xea, 0xe0, 0x6f, 0xb7, 0xa0, 0xd8, 0x20,
	0x10, 0x15, 0x29, 0x42, 0x05, 0xdb, 0x40, 0xbf, 0xcf, 0x41, 0x31, 0xfa, 0xa7, 0x00, 0x74, 0x77,
	0xc9, 0xbf, 0x74, 0x94, 0xdf, 0x5d, 0xea, 0xff, 0x06, 0x95, 0x1b, 0xbf, 0xf5, 0xaf, 0xff, 0xf5,
	0x87, 0xa9, 0x6b, 0x15, 0x74, 0xf7, 0xe2, 0xbd, 0xbb, 0x0e, 0x6b, 0xe0, 0xd7, 0xb4, 0x1e, 0x70,
	0xfb, 0xe8, 0x77, 0x38, 0xd8, 0x08, 0xc7, 0x27, 0x7a, 0x77, 0xa9, 0x27, 0xf9, 0xe5, 0x65, 0xc2,
	0xbe, 0x72, 0x9d, 0xea, 0xb2, 0x57, 0xe1, 0x89, 0x2e, 0x27, 0x86, 0xa9, 0x07, 0x39, 0x84, 0x68,
	0xf2, 0xa7, 0x1c, 0xec, 0x26, 0x3d, 0x60, 0x47, 0x1f, 0x3e, 0xd7, 0x83, 0xf7, 0xe5, 0x34, 0xfb,
	0x16, 0xd5, 0xec, 0x46, 0xa5, 0x44, 0x34, 0xb3, 0xd9, 0xa8, 0x71, 0x0d, 0xff, 0x86, 0x83, 0xd2,
	0xac, 0x77, 0x95, 0xe8, 0xe3, 0xe7, 0x7e, 0x8b, 0x59, 0x7e, 0x6f, 0xe9, 0x67, 0x81, 0x95, 0xb7,
	0xa8, 0xbe, 0xaf, 0x57, 0x5e, 0x25, 0xfa, 0x9e, 0x5b, 0xae, 0xcd, 0x1a, 0xb1, 0x2d, 0xa6, 0x46,
	0xc7, 0x27, 0x3a, 0xff, 0x43, 0xa2, 0xce, 0xfe, 0x93, 0xac, 0xe5, 0x74, 0x8e, 0x3c, 0xa1, 0x2b,
	0xdf, 0x7f, 0xce, 0x97, 0x65, 0xcf, 0xd2, 0x5c, 0xa7, 0x4d, 0x89, 0xe6, 0x24, 0x56, 0xa2, 0x2f,
	0x64, 0xe6, 0xc5, 0x4a, 0xe2, 0xa3, 0xa8, 0x79, 0xb1, 0x92, 0xf0, 0xf8, 0x26, 0x1a, 0x2b, 0xfe,
	0xf3, 0xac, 0x60, 0x5b, 0x4c, 0x34, 0xfa, 0x29, 0x07, 0x85, 0xa3, 0xf0, 0xc3, 0xff, 0x65, 0x5e,
	0x63, 0x94, 0xf7, 0x17, 0x7f, 0x2f, 0x50, 0x29, 0x53, 0x45, 0x76, 0x2b, 0x5b, 0x44, 0x91, 0x3e,
	0xf6, 0xc2, 0x5a, 0xfc, 0x01, 0x07, 0x45, 0x41, 0xd7, 0x7b, 0x2e, 0x76, 0xba, 0x16, 0xad, 0x53,
	0xa1, 0x7b, 0xcb, 0x96, 0x15, 0xcb, 0x77, 0x96, 0x2b, 0x82, 0x45, 0x2d, 0xa3, 0xea, 0x3a, 0x3d,
	0xb6, 0x5a, 0xb4, 0xc8, 0x46, 0x74, 0xfa, 0x19, 0x07, 0xc5, 0x23, 0xec, 0x85, 0x2e, 0x0e, 0xe7,
	0x19, 0x67, 0xfa, 0x4e, 0x7e, 0x9e, 0x71, 0xe2, 0xb7, 0x91, 0x51, 0x5d, 0xfa, 0xd8, 0x63, 0x57,
	0xb4, 0x03, 0xc3, 0xa5, 0x51, 0xfa, 0x1b, 0xd4, 0x49, 0xc1, 0xa5, 0x0e, 0x7a, 0x7b, 0xe1, 0xcb,
	0xbd, 0xf2, 0x5b, 0x0b, 0xde, 0x11, 0x4d, 0xb9, 0xe7, 0xe4, 0x5c, 0x37, 0x03, 0xf1, 0xbf, 0xe0,
	0xe8, 0x1b, 0xa1, 0x58, 0xd5, 0x7d, 0x9e, 0x8b, 0x92, 0xaf, 0x4b, 0xe6, 0xb9, 0x28, 0xa9, 0xa4,
	0x5f, 0x79, 0x9d, 0x2a, 0x75, 0xbd, 0x72, 0x75, 0x62, 0x96, 0xe0, 0xda, 0x83, 0xe8, 0x47, 0x74,
	0xfb, 0x23, 0x0e, 0xb6, 0x8f, 0xb0, 0x17, 0x3d, 0x11, 0xa3, 0x77, 0x96, 0xa9, 0x51, 0xcd, 0x0b,
	0xa9, 0x84, 0x93, 0x76, 0xe5, 0x16, 0xd5, 0xaa, 0x5c, 0xd9, 0x63, 0x5a, 0x91, 0x88, 0x67, 0x6d,
	0xce, 0x6c, 0xe3, 0x01, 0xb7, 0x7f, 0x8f, 0x43, 0xbf, 0x4b, 0x76, 0x58, 0x9e, 0x83, 0xd5, 0xe1,
	0x64, 0xdf, 0xff, 0xf6, 0xc2, 0xe7, 0xa5, 0xf2, 0xdb, 0x0b, 0x6f, 0x0a, 0x2b, 0x37, 0xa9, 0x36,
	0xa5, 0xca, 0x0e, 0xd1, 0xc6, 0xa5, 0x22, 0xc9, 0x49, 0x9b, 0x1e, 0x0a, 0x1e, 0x70, 0xfb, 0xb7,
	0xb9, 0x7b, 0xdc, 0x0f, 0xf9, 0x2f, 0xff, 0xf3, 0xe6, 0x95, 0x2f, 0xbf, 0xba, 0xc9, 0xfd, 0xf3,
	0x57, 0x37, 0xb9, 0x5f, 0x7e, 0x75, 0x93, 0xfb, 0x7c, 0x8d, 0xfe, 0x57, 0xe0, 0xfd, 0xff, 0x0f,
	0x00, 0x00, 0xff, 0xff, 0xec, 0x5e, 0x69, 0x0c, 0xf4, 0x3a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MatchEngineApiClient is the client API for MatchEngineApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MatchEngineApiClient interface {
	//
	// RegisterClient
	//
	// Registers the client with the closest Distributed Matching Engine (the
	// nearest edge location in the Operator network) and validates the
	// legitimacy of the mobile subscriber. All session information is encrypted.
	RegisterClient(ctx context.Context, in *RegisterClientRequest, opts ...grpc.CallOption) (*RegisterClientReply, error)
	//
	// FindCloudlet
	//
	// Locates the most optimal edge computing footprint and allows the
	// registered application to find the application backend by leveraging the
	// location, application subscription, and service provider agreement. If
	// there are no suitable cloudlet instances available, the client may connect
	// to the application server located in the public cloud.
	FindCloudlet(ctx context.Context, in *FindCloudletRequest, opts ...grpc.CallOption) (*FindCloudletReply, error)
	//
	// PlatformFindCloudlet
	//
	// Similar to FindCloudlet, except uses a token for client data.
	// This API is only applicable for Platform Applications.
	PlatformFindCloudlet(ctx context.Context, in *PlatformFindCloudletRequest, opts ...grpc.CallOption) (*FindCloudletReply, error)
	//
	// QosPrioritySessionCreate
	//
	// Creates a QOS priority session (latency or throughput priority) from the client
	// to the app inst by making a call to the operator's priority session API server.
	QosPrioritySessionCreate(ctx context.Context, in *QosPrioritySessionCreateRequest, opts ...grpc.CallOption) (*QosPrioritySessionReply, error)
	//
	// QosPrioritySessionDelete
	//
	// Deletes a previously created QOS priority session by making a call to the operator's
	// priority session API server.
	QosPrioritySessionDelete(ctx context.Context, in *QosPrioritySessionDeleteRequest, opts ...grpc.CallOption) (*QosPrioritySessionDeleteReply, error)
	//
	// VerifyLocation
	//
	// Verifies that the GPS coordinates accurately report the actual location of the device.
	VerifyLocation(ctx context.Context, in *VerifyLocationRequest, opts ...grpc.CallOption) (*VerifyLocationReply, error)
	GetLocation(ctx context.Context, in *GetLocationRequest, opts ...grpc.CallOption) (*GetLocationReply, error)
	AddUserToGroup(ctx context.Context, in *DynamicLocGroupRequest, opts ...grpc.CallOption) (*DynamicLocGroupReply, error)
	GetAppInstList(ctx context.Context, in *AppInstListRequest, opts ...grpc.CallOption) (*AppInstListReply, error)
	GetFqdnList(ctx context.Context, in *FqdnListRequest, opts ...grpc.CallOption) (*FqdnListReply, error)
	GetAppOfficialFqdn(ctx context.Context, in *AppOfficialFqdnRequest, opts ...grpc.CallOption) (*AppOfficialFqdnReply, error)
	GetQosPositionKpi(ctx context.Context, in *QosPositionRequest, opts ...grpc.CallOption) (MatchEngineApi_GetQosPositionKpiClient, error)
	StreamEdgeEvent(ctx context.Context, opts ...grpc.CallOption) (MatchEngineApi_StreamEdgeEventClient, error)
}

type matchEngineApiClient struct {
	cc *grpc.ClientConn
}

func NewMatchEngineApiClient(cc *grpc.ClientConn) MatchEngineApiClient {
	return &matchEngineApiClient{cc}
}

func (c *matchEngineApiClient) RegisterClient(ctx context.Context, in *RegisterClientRequest, opts ...grpc.CallOption) (*RegisterClientReply, error) {
	out := new(RegisterClientReply)
	err := c.cc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/RegisterClient", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) FindCloudlet(ctx context.Context, in *FindCloudletRequest, opts ...grpc.CallOption) (*FindCloudletReply, error) {
	out := new(FindCloudletReply)
	err := c.cc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/FindCloudlet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) PlatformFindCloudlet(ctx context.Context, in *PlatformFindCloudletRequest, opts ...grpc.CallOption) (*FindCloudletReply, error) {
	out := new(FindCloudletReply)
	err := c.cc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/PlatformFindCloudlet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) QosPrioritySessionCreate(ctx context.Context, in *QosPrioritySessionCreateRequest, opts ...grpc.CallOption) (*QosPrioritySessionReply, error) {
	out := new(QosPrioritySessionReply)
	err := c.cc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/QosPrioritySessionCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) QosPrioritySessionDelete(ctx context.Context, in *QosPrioritySessionDeleteRequest, opts ...grpc.CallOption) (*QosPrioritySessionDeleteReply, error) {
	out := new(QosPrioritySessionDeleteReply)
	err := c.cc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/QosPrioritySessionDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) VerifyLocation(ctx context.Context, in *VerifyLocationRequest, opts ...grpc.CallOption) (*VerifyLocationReply, error) {
	out := new(VerifyLocationReply)
	err := c.cc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/VerifyLocation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) GetLocation(ctx context.Context, in *GetLocationRequest, opts ...grpc.CallOption) (*GetLocationReply, error) {
	out := new(GetLocationReply)
	err := c.cc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/GetLocation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) AddUserToGroup(ctx context.Context, in *DynamicLocGroupRequest, opts ...grpc.CallOption) (*DynamicLocGroupReply, error) {
	out := new(DynamicLocGroupReply)
	err := c.cc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/AddUserToGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) GetAppInstList(ctx context.Context, in *AppInstListRequest, opts ...grpc.CallOption) (*AppInstListReply, error) {
	out := new(AppInstListReply)
	err := c.cc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/GetAppInstList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) GetFqdnList(ctx context.Context, in *FqdnListRequest, opts ...grpc.CallOption) (*FqdnListReply, error) {
	out := new(FqdnListReply)
	err := c.cc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/GetFqdnList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) GetAppOfficialFqdn(ctx context.Context, in *AppOfficialFqdnRequest, opts ...grpc.CallOption) (*AppOfficialFqdnReply, error) {
	out := new(AppOfficialFqdnReply)
	err := c.cc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/GetAppOfficialFqdn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) GetQosPositionKpi(ctx context.Context, in *QosPositionRequest, opts ...grpc.CallOption) (MatchEngineApi_GetQosPositionKpiClient, error) {
	stream, err := c.cc.NewStream(ctx, &_MatchEngineApi_serviceDesc.Streams[0], "/distributed_match_engine.MatchEngineApi/GetQosPositionKpi", opts...)
	if err != nil {
		return nil, err
	}
	x := &matchEngineApiGetQosPositionKpiClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MatchEngineApi_GetQosPositionKpiClient interface {
	Recv() (*QosPositionKpiReply, error)
	grpc.ClientStream
}

type matchEngineApiGetQosPositionKpiClient struct {
	grpc.ClientStream
}

func (x *matchEngineApiGetQosPositionKpiClient) Recv() (*QosPositionKpiReply, error) {
	m := new(QosPositionKpiReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *matchEngineApiClient) StreamEdgeEvent(ctx context.Context, opts ...grpc.CallOption) (MatchEngineApi_StreamEdgeEventClient, error) {
	stream, err := c.cc.NewStream(ctx, &_MatchEngineApi_serviceDesc.Streams[1], "/distributed_match_engine.MatchEngineApi/StreamEdgeEvent", opts...)
	if err != nil {
		return nil, err
	}
	x := &matchEngineApiStreamEdgeEventClient{stream}
	return x, nil
}

type MatchEngineApi_StreamEdgeEventClient interface {
	Send(*ClientEdgeEvent) error
	Recv() (*ServerEdgeEvent, error)
	grpc.ClientStream
}

type matchEngineApiStreamEdgeEventClient struct {
	grpc.ClientStream
}

func (x *matchEngineApiStreamEdgeEventClient) Send(m *ClientEdgeEvent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *matchEngineApiStreamEdgeEventClient) Recv() (*ServerEdgeEvent, error) {
	m := new(ServerEdgeEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// MatchEngineApiServer is the server API for MatchEngineApi service.
type MatchEngineApiServer interface {
	//
	// RegisterClient
	//
	// Registers the client with the closest Distributed Matching Engine (the
	// nearest edge location in the Operator network) and validates the
	// legitimacy of the mobile subscriber. All session information is encrypted.
	RegisterClient(context.Context, *RegisterClientRequest) (*RegisterClientReply, error)
	//
	// FindCloudlet
	//
	// Locates the most optimal edge computing footprint and allows the
	// registered application to find the application backend by leveraging the
	// location, application subscription, and service provider agreement. If
	// there are no suitable cloudlet instances available, the client may connect
	// to the application server located in the public cloud.
	FindCloudlet(context.Context, *FindCloudletRequest) (*FindCloudletReply, error)
	//
	// PlatformFindCloudlet
	//
	// Similar to FindCloudlet, except uses a token for client data.
	// This API is only applicable for Platform Applications.
	PlatformFindCloudlet(context.Context, *PlatformFindCloudletRequest) (*FindCloudletReply, error)
	//
	// QosPrioritySessionCreate
	//
	// Creates a QOS priority session (latency or throughput priority) from the client
	// to the app inst by making a call to the operator's priority session API server.
	QosPrioritySessionCreate(context.Context, *QosPrioritySessionCreateRequest) (*QosPrioritySessionReply, error)
	//
	// QosPrioritySessionDelete
	//
	// Deletes a previously created QOS priority session by making a call to the operator's
	// priority session API server.
	QosPrioritySessionDelete(context.Context, *QosPrioritySessionDeleteRequest) (*QosPrioritySessionDeleteReply, error)
	//
	// VerifyLocation
	//
	// Verifies that the GPS coordinates accurately report the actual location of the device.
	VerifyLocation(context.Context, *VerifyLocationRequest) (*VerifyLocationReply, error)
	GetLocation(context.Context, *GetLocationRequest) (*GetLocationReply, error)
	AddUserToGroup(context.Context, *DynamicLocGroupRequest) (*DynamicLocGroupReply, error)
	GetAppInstList(context.Context, *AppInstListRequest) (*AppInstListReply, error)
	GetFqdnList(context.Context, *FqdnListRequest) (*FqdnListReply, error)
	GetAppOfficialFqdn(context.Context, *AppOfficialFqdnRequest) (*AppOfficialFqdnReply, error)
	GetQosPositionKpi(*QosPositionRequest, MatchEngineApi_GetQosPositionKpiServer) error
	StreamEdgeEvent(MatchEngineApi_StreamEdgeEventServer) error
}

// UnimplementedMatchEngineApiServer can be embedded to have forward compatible implementations.
type UnimplementedMatchEngineApiServer struct {
}

func (*UnimplementedMatchEngineApiServer) RegisterClient(ctx context.Context, req *RegisterClientRequest) (*RegisterClientReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterClient not implemented")
}
func (*UnimplementedMatchEngineApiServer) FindCloudlet(ctx context.Context, req *FindCloudletRequest) (*FindCloudletReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindCloudlet not implemented")
}
func (*UnimplementedMatchEngineApiServer) PlatformFindCloudlet(ctx context.Context, req *PlatformFindCloudletRequest) (*FindCloudletReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlatformFindCloudlet not implemented")
}
func (*UnimplementedMatchEngineApiServer) QosPrioritySessionCreate(ctx context.Context, req *QosPrioritySessionCreateRequest) (*QosPrioritySessionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QosPrioritySessionCreate not implemented")
}
func (*UnimplementedMatchEngineApiServer) QosPrioritySessionDelete(ctx context.Context, req *QosPrioritySessionDeleteRequest) (*QosPrioritySessionDeleteReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QosPrioritySessionDelete not implemented")
}
func (*UnimplementedMatchEngineApiServer) VerifyLocation(ctx context.Context, req *VerifyLocationRequest) (*VerifyLocationReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyLocation not implemented")
}
func (*UnimplementedMatchEngineApiServer) GetLocation(ctx context.Context, req *GetLocationRequest) (*GetLocationReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLocation not implemented")
}
func (*UnimplementedMatchEngineApiServer) AddUserToGroup(ctx context.Context, req *DynamicLocGroupRequest) (*DynamicLocGroupReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUserToGroup not implemented")
}
func (*UnimplementedMatchEngineApiServer) GetAppInstList(ctx context.Context, req *AppInstListRequest) (*AppInstListReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppInstList not implemented")
}
func (*UnimplementedMatchEngineApiServer) GetFqdnList(ctx context.Context, req *FqdnListRequest) (*FqdnListReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFqdnList not implemented")
}
func (*UnimplementedMatchEngineApiServer) GetAppOfficialFqdn(ctx context.Context, req *AppOfficialFqdnRequest) (*AppOfficialFqdnReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppOfficialFqdn not implemented")
}
func (*UnimplementedMatchEngineApiServer) GetQosPositionKpi(req *QosPositionRequest, srv MatchEngineApi_GetQosPositionKpiServer) error {
	return status.Errorf(codes.Unimplemented, "method GetQosPositionKpi not implemented")
}
func (*UnimplementedMatchEngineApiServer) StreamEdgeEvent(srv MatchEngineApi_StreamEdgeEventServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamEdgeEvent not implemented")
}

func RegisterMatchEngineApiServer(s *grpc.Server, srv MatchEngineApiServer) {
	s.RegisterService(&_MatchEngineApi_serviceDesc, srv)
}

func _MatchEngineApi_RegisterClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).RegisterClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/RegisterClient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).RegisterClient(ctx, req.(*RegisterClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_FindCloudlet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindCloudletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).FindCloudlet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/FindCloudlet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).FindCloudlet(ctx, req.(*FindCloudletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_PlatformFindCloudlet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlatformFindCloudletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).PlatformFindCloudlet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/PlatformFindCloudlet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).PlatformFindCloudlet(ctx, req.(*PlatformFindCloudletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_QosPrioritySessionCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosPrioritySessionCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).QosPrioritySessionCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/QosPrioritySessionCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).QosPrioritySessionCreate(ctx, req.(*QosPrioritySessionCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_QosPrioritySessionDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosPrioritySessionDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).QosPrioritySessionDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/QosPrioritySessionDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).QosPrioritySessionDelete(ctx, req.(*QosPrioritySessionDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_VerifyLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).VerifyLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/VerifyLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).VerifyLocation(ctx, req.(*VerifyLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_GetLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).GetLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/GetLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).GetLocation(ctx, req.(*GetLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_AddUserToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DynamicLocGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).AddUserToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/AddUserToGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).AddUserToGroup(ctx, req.(*DynamicLocGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_GetAppInstList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInstListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).GetAppInstList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/GetAppInstList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).GetAppInstList(ctx, req.(*AppInstListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_GetFqdnList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FqdnListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).GetFqdnList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/GetFqdnList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).GetFqdnList(ctx, req.(*FqdnListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_GetAppOfficialFqdn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppOfficialFqdnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).GetAppOfficialFqdn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/GetAppOfficialFqdn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).GetAppOfficialFqdn(ctx, req.(*AppOfficialFqdnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_GetQosPositionKpi_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QosPositionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MatchEngineApiServer).GetQosPositionKpi(m, &matchEngineApiGetQosPositionKpiServer{stream})
}

type MatchEngineApi_GetQosPositionKpiServer interface {
	Send(*QosPositionKpiReply) error
	grpc.ServerStream
}

type matchEngineApiGetQosPositionKpiServer struct {
	grpc.ServerStream
}

func (x *matchEngineApiGetQosPositionKpiServer) Send(m *QosPositionKpiReply) error {
	return x.ServerStream.SendMsg(m)
}

func _MatchEngineApi_StreamEdgeEvent_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MatchEngineApiServer).StreamEdgeEvent(&matchEngineApiStreamEdgeEventServer{stream})
}

type MatchEngineApi_StreamEdgeEventServer interface {
	Send(*ServerEdgeEvent) error
	Recv() (*ClientEdgeEvent, error)
	grpc.ServerStream
}

type matchEngineApiStreamEdgeEventServer struct {
	grpc.ServerStream
}

func (x *matchEngineApiStreamEdgeEventServer) Send(m *ServerEdgeEvent) error {
	return x.ServerStream.SendMsg(m)
}

func (x *matchEngineApiStreamEdgeEventServer) Recv() (*ClientEdgeEvent, error) {
	m := new(ClientEdgeEvent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _MatchEngineApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "distributed_match_engine.MatchEngineApi",
	HandlerType: (*MatchEngineApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterClient",
			Handler:    _MatchEngineApi_RegisterClient_Handler,
		},
		{
			MethodName: "FindCloudlet",
			Handler:    _MatchEngineApi_FindCloudlet_Handler,
		},
		{
			MethodName: "PlatformFindCloudlet",
			Handler:    _MatchEngineApi_PlatformFindCloudlet_Handler,
		},
		{
			MethodName: "QosPrioritySessionCreate",
			Handler:    _MatchEngineApi_QosPrioritySessionCreate_Handler,
		},
		{
			MethodName: "QosPrioritySessionDelete",
			Handler:    _MatchEngineApi_QosPrioritySessionDelete_Handler,
		},
		{
			MethodName: "VerifyLocation",
			Handler:    _MatchEngineApi_VerifyLocation_Handler,
		},
		{
			MethodName: "GetLocation",
			Handler:    _MatchEngineApi_GetLocation_Handler,
		},
		{
			MethodName: "AddUserToGroup",
			Handler:    _MatchEngineApi_AddUserToGroup_Handler,
		},
		{
			MethodName: "GetAppInstList",
			Handler:    _MatchEngineApi_GetAppInstList_Handler,
		},
		{
			MethodName: "GetFqdnList",
			Handler:    _MatchEngineApi_GetFqdnList_Handler,
		},
		{
			MethodName: "GetAppOfficialFqdn",
			Handler:    _MatchEngineApi_GetAppOfficialFqdn_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetQosPositionKpi",
			Handler:       _MatchEngineApi_GetQosPositionKpi_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamEdgeEvent",
			Handler:       _MatchEngineApi_StreamEdgeEvent_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "app-client.proto",
}

func (m *RegisterClientRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterClientRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterClientRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.UniqueId) > 0 {
		i -= len(m.UniqueId)
		copy(dAtA[i:], m.UniqueId)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.UniqueId)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.UniqueIdType) > 0 {
		i -= len(m.UniqueIdType)
		copy(dAtA[i:], m.UniqueIdType)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.UniqueIdType)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.AuthToken) > 0 {
		i -= len(m.AuthToken)
		copy(dAtA[i:], m.AuthToken)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AuthToken)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CarrierName) > 0 {
		i -= len(m.CarrierName)
		copy(dAtA[i:], m.CarrierName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AppVers) > 0 {
		i -= len(m.AppVers)
		copy(dAtA[i:], m.AppVers)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppVers)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AppName) > 0 {
		i -= len(m.AppName)
		copy(dAtA[i:], m.AppName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OrgName) > 0 {
		i -= len(m.OrgName)
		copy(dAtA[i:], m.OrgName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.OrgName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegisterClientReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterClientReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterClientReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.UniqueId) > 0 {
		i -= len(m.UniqueId)
		copy(dAtA[i:], m.UniqueId)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.UniqueId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.UniqueIdType) > 0 {
		i -= len(m.UniqueIdType)
		copy(dAtA[i:], m.UniqueIdType)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.UniqueIdType)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TokenServerUri) > 0 {
		i -= len(m.TokenServerUri)
		copy(dAtA[i:], m.TokenServerUri)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.TokenServerUri)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FindCloudletRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindCloudletRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindCloudletRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.GpsLocation != nil {
		{
			size, err := m.GpsLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.CarrierName) > 0 {
		i -= len(m.CarrierName)
		copy(dAtA[i:], m.CarrierName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlatformFindCloudletRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlatformFindCloudletRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlatformFindCloudletRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.ClientToken) > 0 {
		i -= len(m.ClientToken)
		copy(dAtA[i:], m.ClientToken)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.ClientToken)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CarrierName) > 0 {
		i -= len(m.CarrierName)
		copy(dAtA[i:], m.CarrierName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FindCloudletReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindCloudletReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindCloudletReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.QosErrorMsg) > 0 {
		i -= len(m.QosErrorMsg)
		copy(dAtA[i:], m.QosErrorMsg)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.QosErrorMsg)))
		i--
		dAtA[i] = 0x42
	}
	if m.QosResult != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.QosResult))
		i--
		dAtA[i] = 0x38
	}
	if len(m.EdgeEventsCookie) > 0 {
		i -= len(m.EdgeEventsCookie)
		copy(dAtA[i:], m.EdgeEventsCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.EdgeEventsCookie)))
		i--
		dAtA[i] = 0x32
	}
	if m.CloudletLocation != nil {
		{
			size, err := m.CloudletLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppClient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Fqdn) > 0 {
		i -= len(m.Fqdn)
		copy(dAtA[i:], m.Fqdn)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Fqdn)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QosPrioritySessionCreateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPrioritySessionCreateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QosPrioritySessionCreateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.NotificationAuthToken) > 0 {
		i -= len(m.NotificationAuthToken)
		copy(dAtA[i:], m.NotificationAuthToken)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.NotificationAuthToken)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.NotificationUri) > 0 {
		i -= len(m.NotificationUri)
		copy(dAtA[i:], m.NotificationUri)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.NotificationUri)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Profile != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Profile))
		i--
		dAtA[i] = 0x50
	}
	if m.ProtocolOut != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.ProtocolOut))
		i--
		dAtA[i] = 0x48
	}
	if m.ProtocolIn != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.ProtocolIn))
		i--
		dAtA[i] = 0x40
	}
	if len(m.PortApplicationServer) > 0 {
		i -= len(m.PortApplicationServer)
		copy(dAtA[i:], m.PortApplicationServer)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.PortApplicationServer)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PortUserEquipment) > 0 {
		i -= len(m.PortUserEquipment)
		copy(dAtA[i:], m.PortUserEquipment)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.PortUserEquipment)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.IpApplicationServer) > 0 {
		i -= len(m.IpApplicationServer)
		copy(dAtA[i:], m.IpApplicationServer)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.IpApplicationServer)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.IpUserEquipment) > 0 {
		i -= len(m.IpUserEquipment)
		copy(dAtA[i:], m.IpUserEquipment)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.IpUserEquipment)))
		i--
		dAtA[i] = 0x22
	}
	if m.SessionDuration != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.SessionDuration))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QosPrioritySessionReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPrioritySessionReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QosPrioritySessionReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.HttpStatus != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.HttpStatus))
		i--
		dAtA[i] = 0x38
	}
	if m.ExpiresAt != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.ExpiresAt))
		i--
		dAtA[i] = 0x30
	}
	if m.StartedAt != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.StartedAt))
		i--
		dAtA[i] = 0x28
	}
	if len(m.SessionId) > 0 {
		i -= len(m.SessionId)
		copy(dAtA[i:], m.SessionId)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Profile != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Profile))
		i--
		dAtA[i] = 0x18
	}
	if m.SessionDuration != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.SessionDuration))
		i--
		dAtA[i] = 0x10
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QosPrioritySessionDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPrioritySessionDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QosPrioritySessionDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.SessionId) > 0 {
		i -= len(m.SessionId)
		copy(dAtA[i:], m.SessionId)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Profile != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Profile))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QosPrioritySessionDeleteReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPrioritySessionDeleteReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QosPrioritySessionDeleteReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.Status != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VerifyLocationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyLocationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyLocationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.VerifyLocToken) > 0 {
		i -= len(m.VerifyLocToken)
		copy(dAtA[i:], m.VerifyLocToken)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.VerifyLocToken)))
		i--
		dAtA[i] = 0x2a
	}
	if m.GpsLocation != nil {
		{
			size, err := m.GpsLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.CarrierName) > 0 {
		i -= len(m.CarrierName)
		copy(dAtA[i:], m.CarrierName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VerifyLocationReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyLocationReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyLocationReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.GpsLocationAccuracyKm != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GpsLocationAccuracyKm))))
		i--
		dAtA[i] = 0x21
	}
	if m.GpsLocationStatus != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocationStatus))
		i--
		dAtA[i] = 0x18
	}
	if m.TowerStatus != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.TowerStatus))
		i--
		dAtA[i] = 0x10
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetLocationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLocationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLocationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.CarrierName) > 0 {
		i -= len(m.CarrierName)
		copy(dAtA[i:], m.CarrierName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetLocationReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLocationReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLocationReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.NetworkLocation != nil {
		{
			size, err := m.NetworkLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Tower != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Tower))
		i--
		dAtA[i] = 0x20
	}
	if len(m.CarrierName) > 0 {
		i -= len(m.CarrierName)
		copy(dAtA[i:], m.CarrierName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppInstListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppInstListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.Limit != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x30
	}
	if m.GpsLocation != nil {
		{
			size, err := m.GpsLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.CarrierName) > 0 {
		i -= len(m.CarrierName)
		copy(dAtA[i:], m.CarrierName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Appinstance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Appinstance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Appinstance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EdgeEventsCookie) > 0 {
		i -= len(m.EdgeEventsCookie)
		copy(dAtA[i:], m.EdgeEventsCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.EdgeEventsCookie)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OrgName) > 0 {
		i -= len(m.OrgName)
		copy(dAtA[i:], m.OrgName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.OrgName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppClient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Fqdn) > 0 {
		i -= len(m.Fqdn)
		copy(dAtA[i:], m.Fqdn)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Fqdn)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AppVers) > 0 {
		i -= len(m.AppVers)
		copy(dAtA[i:], m.AppVers)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppVers)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AppName) > 0 {
		i -= len(m.AppName)
		copy(dAtA[i:], m.AppName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudletLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Appinstances) > 0 {
		for iNdEx := len(m.Appinstances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Appinstances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppClient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Distance != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Distance))))
		i--
		dAtA[i] = 0x21
	}
	if m.GpsLocation != nil {
		{
			size, err := m.GpsLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CloudletName) > 0 {
		i -= len(m.CloudletName)
		copy(dAtA[i:], m.CloudletName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CloudletName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CarrierName) > 0 {
		i -= len(m.CarrierName)
		copy(dAtA[i:], m.CarrierName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppInstListReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstListReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppInstListReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.Cloudlets) > 0 {
		for iNdEx := len(m.Cloudlets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cloudlets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppClient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Status != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FqdnListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FqdnListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FqdnListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppFqdn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppFqdn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppFqdn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AndroidPackageName) > 0 {
		i -= len(m.AndroidPackageName)
		copy(dAtA[i:], m.AndroidPackageName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AndroidPackageName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Fqdns) > 0 {
		for iNdEx := len(m.Fqdns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fqdns[iNdEx])
			copy(dAtA[i:], m.Fqdns[iNdEx])
			i = encodeVarintAppClient(dAtA, i, uint64(len(m.Fqdns[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.OrgName) > 0 {
		i -= len(m.OrgName)
		copy(dAtA[i:], m.OrgName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.OrgName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AppVers) > 0 {
		i -= len(m.AppVers)
		copy(dAtA[i:], m.AppVers)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppVers)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AppName) > 0 {
		i -= len(m.AppName)
		copy(dAtA[i:], m.AppName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FqdnListReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FqdnListReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FqdnListReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.Status != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if len(m.AppFqdns) > 0 {
		for iNdEx := len(m.AppFqdns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AppFqdns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppClient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppOfficialFqdnRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppOfficialFqdnRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppOfficialFqdnRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.GpsLocation != nil {
		{
			size, err := m.GpsLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppOfficialFqdnReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppOfficialFqdnReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppOfficialFqdnReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppClient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Status != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ClientToken) > 0 {
		i -= len(m.ClientToken)
		copy(dAtA[i:], m.ClientToken)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.ClientToken)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AppOfficialFqdn) > 0 {
		i -= len(m.AppOfficialFqdn)
		copy(dAtA[i:], m.AppOfficialFqdn)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppOfficialFqdn)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DynamicLocGroupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicLocGroupRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DynamicLocGroupRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.UserData) > 0 {
		i -= len(m.UserData)
		copy(dAtA[i:], m.UserData)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.UserData)))
		i--
		dAtA[i] = 0x62
	}
	if m.CommType != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.CommType))
		i--
		dAtA[i] = 0x58
	}
	if m.LgId != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.LgId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DynamicLocGroupReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicLocGroupReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DynamicLocGroupReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.GroupCookie) > 0 {
		i -= len(m.GroupCookie)
		copy(dAtA[i:], m.GroupCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.GroupCookie)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x18
	}
	if m.Status != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QosPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QosPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GpsLocation != nil {
		{
			size, err := m.GpsLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Positionid != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Positionid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BandSelection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BandSelection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BandSelection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Rat_5G) > 0 {
		for iNdEx := len(m.Rat_5G) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Rat_5G[iNdEx])
			copy(dAtA[i:], m.Rat_5G[iNdEx])
			i = encodeVarintAppClient(dAtA, i, uint64(len(m.Rat_5G[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Rat_4G) > 0 {
		for iNdEx := len(m.Rat_4G) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Rat_4G[iNdEx])
			copy(dAtA[i:], m.Rat_4G[iNdEx])
			i = encodeVarintAppClient(dAtA, i, uint64(len(m.Rat_4G[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Rat_3G) > 0 {
		for iNdEx := len(m.Rat_3G) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Rat_3G[iNdEx])
			copy(dAtA[i:], m.Rat_3G[iNdEx])
			i = encodeVarintAppClient(dAtA, i, uint64(len(m.Rat_3G[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Rat_2G) > 0 {
		for iNdEx := len(m.Rat_2G) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Rat_2G[iNdEx])
			copy(dAtA[i:], m.Rat_2G[iNdEx])
			i = encodeVarintAppClient(dAtA, i, uint64(len(m.Rat_2G[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QosPositionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPositionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QosPositionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.BandSelection != nil {
		{
			size, err := m.BandSelection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.LteCategory != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.LteCategory))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Positions) > 0 {
		for iNdEx := len(m.Positions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Positions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppClient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QosPositionKpiResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPositionKpiResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QosPositionKpiResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LatencyMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LatencyMax))))
		i--
		dAtA[i] = 0x5d
	}
	if m.LatencyAvg != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LatencyAvg))))
		i--
		dAtA[i] = 0x55
	}
	if m.LatencyMin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LatencyMin))))
		i--
		dAtA[i] = 0x4d
	}
	if m.UluserthroughputMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UluserthroughputMax))))
		i--
		dAtA[i] = 0x45
	}
	if m.UluserthroughputAvg != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UluserthroughputAvg))))
		i--
		dAtA[i] = 0x3d
	}
	if m.UluserthroughputMin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UluserthroughputMin))))
		i--
		dAtA[i] = 0x35
	}
	if m.DluserthroughputMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DluserthroughputMax))))
		i--
		dAtA[i] = 0x2d
	}
	if m.DluserthroughputAvg != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DluserthroughputAvg))))
		i--
		dAtA[i] = 0x25
	}
	if m.DluserthroughputMin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DluserthroughputMin))))
		i--
		dAtA[i] = 0x1d
	}
	if m.GpsLocation != nil {
		{
			size, err := m.GpsLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Positionid != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Positionid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QosPositionKpiReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPositionKpiReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QosPositionKpiReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.PositionResults) > 0 {
		for iNdEx := len(m.PositionResults) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PositionResults[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppClient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Status != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClientEdgeEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientEdgeEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientEdgeEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.CustomEvent) > 0 {
		i -= len(m.CustomEvent)
		copy(dAtA[i:], m.CustomEvent)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CustomEvent)))
		i--
		dAtA[i] = 0x42
	}
	if m.DeviceInfoDynamic != nil {
		{
			size, err := m.DeviceInfoDynamic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.DeviceInfoStatic != nil {
		{
			size, err := m.DeviceInfoStatic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Samples) > 0 {
		for iNdEx := len(m.Samples) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Samples[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppClient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.GpsLocation != nil {
		{
			size, err := m.GpsLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.EventType != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.EventType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.EdgeEventsCookie) > 0 {
		i -= len(m.EdgeEventsCookie)
		copy(dAtA[i:], m.EdgeEventsCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.EdgeEventsCookie)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServerEdgeEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerEdgeEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServerEdgeEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.ErrorMsg) > 0 {
		i -= len(m.ErrorMsg)
		copy(dAtA[i:], m.ErrorMsg)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.ErrorMsg)))
		i--
		dAtA[i] = 0x3a
	}
	if m.NewCloudlet != nil {
		{
			size, err := m.NewCloudlet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Statistics != nil {
		{
			size, err := m.Statistics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.HealthCheck != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.HealthCheck))
		i--
		dAtA[i] = 0x20
	}
	if m.MaintenanceState != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.MaintenanceState))
		i--
		dAtA[i] = 0x18
	}
	if m.CloudletState != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.CloudletState))
		i--
		dAtA[i] = 0x10
	}
	if m.EventType != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.EventType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintAppClient(dAtA []byte, offset int, v uint64) int {
	offset -= sovAppClient(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RegisterClientRequest) CopyInFields(src *RegisterClientRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.OrgName != src.OrgName {
		m.OrgName = src.OrgName
		changed++
	}
	if m.AppName != src.AppName {
		m.AppName = src.AppName
		changed++
	}
	if m.AppVers != src.AppVers {
		m.AppVers = src.AppVers
		changed++
	}
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if m.AuthToken != src.AuthToken {
		m.AuthToken = src.AuthToken
		changed++
	}
	if m.UniqueIdType != src.UniqueIdType {
		m.UniqueIdType = src.UniqueIdType
		changed++
	}
	if m.UniqueId != src.UniqueId {
		m.UniqueId = src.UniqueId
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *RegisterClientRequest) DeepCopyIn(src *RegisterClientRequest) {
	m.Ver = src.Ver
	m.OrgName = src.OrgName
	m.AppName = src.AppName
	m.AppVers = src.AppVers
	m.CarrierName = src.CarrierName
	m.AuthToken = src.AuthToken
	m.UniqueIdType = src.UniqueIdType
	m.UniqueId = src.UniqueId
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *RegisterClientRequest) ValidateEnums() error {
	return nil
}

func (s *RegisterClientRequest) ClearTagged(tags map[string]struct{}) {
}

func (m *RegisterClientReply) CopyInFields(src *RegisterClientReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.TokenServerUri != src.TokenServerUri {
		m.TokenServerUri = src.TokenServerUri
		changed++
	}
	if m.UniqueIdType != src.UniqueIdType {
		m.UniqueIdType = src.UniqueIdType
		changed++
	}
	if m.UniqueId != src.UniqueId {
		m.UniqueId = src.UniqueId
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *RegisterClientReply) DeepCopyIn(src *RegisterClientReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	m.SessionCookie = src.SessionCookie
	m.TokenServerUri = src.TokenServerUri
	m.UniqueIdType = src.UniqueIdType
	m.UniqueId = src.UniqueId
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *RegisterClientReply) ValidateEnums() error {
	if _, ok := ReplyStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	return nil
}

func (s *RegisterClientReply) ClearTagged(tags map[string]struct{}) {
}

func (m *FindCloudletRequest) CopyInFields(src *FindCloudletRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if src.GpsLocation != nil {
		if m.GpsLocation == nil {
			m.GpsLocation = &Loc{}
		}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			if m.GpsLocation.Timestamp == nil {
				m.GpsLocation.Timestamp = &Timestamp{}
			}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *FindCloudletRequest) DeepCopyIn(src *FindCloudletRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.CarrierName = src.CarrierName
	if src.GpsLocation != nil {
		var tmp_GpsLocation Loc
		tmp_GpsLocation.DeepCopyIn(src.GpsLocation)
		m.GpsLocation = &tmp_GpsLocation
	} else {
		m.GpsLocation = nil
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *FindCloudletRequest) ValidateEnums() error {
	if m.GpsLocation != nil {
		if err := m.GpsLocation.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *FindCloudletRequest) ClearTagged(tags map[string]struct{}) {
	if s.GpsLocation != nil {
		s.GpsLocation.ClearTagged(tags)
	}
}

func (m *PlatformFindCloudletRequest) CopyInFields(src *PlatformFindCloudletRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if m.ClientToken != src.ClientToken {
		m.ClientToken = src.ClientToken
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *PlatformFindCloudletRequest) DeepCopyIn(src *PlatformFindCloudletRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.CarrierName = src.CarrierName
	m.ClientToken = src.ClientToken
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *PlatformFindCloudletRequest) ValidateEnums() error {
	return nil
}

func (s *PlatformFindCloudletRequest) ClearTagged(tags map[string]struct{}) {
}

func (m *FindCloudletReply) CopyInFields(src *FindCloudletReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if m.Fqdn != src.Fqdn {
		m.Fqdn = src.Fqdn
		changed++
	}
	if src.Ports != nil {
		m.Ports = src.Ports
		changed++
	} else if m.Ports != nil {
		m.Ports = nil
		changed++
	}
	if src.CloudletLocation != nil {
		if m.CloudletLocation == nil {
			m.CloudletLocation = &Loc{}
		}
		if m.CloudletLocation.Latitude != src.CloudletLocation.Latitude {
			m.CloudletLocation.Latitude = src.CloudletLocation.Latitude
			changed++
		}
		if m.CloudletLocation.Longitude != src.CloudletLocation.Longitude {
			m.CloudletLocation.Longitude = src.CloudletLocation.Longitude
			changed++
		}
		if m.CloudletLocation.HorizontalAccuracy != src.CloudletLocation.HorizontalAccuracy {
			m.CloudletLocation.HorizontalAccuracy = src.CloudletLocation.HorizontalAccuracy
			changed++
		}
		if m.CloudletLocation.VerticalAccuracy != src.CloudletLocation.VerticalAccuracy {
			m.CloudletLocation.VerticalAccuracy = src.CloudletLocation.VerticalAccuracy
			changed++
		}
		if m.CloudletLocation.Altitude != src.CloudletLocation.Altitude {
			m.CloudletLocation.Altitude = src.CloudletLocation.Altitude
			changed++
		}
		if m.CloudletLocation.Course != src.CloudletLocation.Course {
			m.CloudletLocation.Course = src.CloudletLocation.Course
			changed++
		}
		if m.CloudletLocation.Speed != src.CloudletLocation.Speed {
			m.CloudletLocation.Speed = src.CloudletLocation.Speed
			changed++
		}
		if src.CloudletLocation.Timestamp != nil {
			if m.CloudletLocation.Timestamp == nil {
				m.CloudletLocation.Timestamp = &Timestamp{}
			}
			if m.CloudletLocation.Timestamp.Seconds != src.CloudletLocation.Timestamp.Seconds {
				m.CloudletLocation.Timestamp.Seconds = src.CloudletLocation.Timestamp.Seconds
				changed++
			}
			if m.CloudletLocation.Timestamp.Nanos != src.CloudletLocation.Timestamp.Nanos {
				m.CloudletLocation.Timestamp.Nanos = src.CloudletLocation.Timestamp.Nanos
				changed++
			}
		} else if m.CloudletLocation.Timestamp != nil {
			m.CloudletLocation.Timestamp = nil
			changed++
		}
	} else if m.CloudletLocation != nil {
		m.CloudletLocation = nil
		changed++
	}
	if m.EdgeEventsCookie != src.EdgeEventsCookie {
		m.EdgeEventsCookie = src.EdgeEventsCookie
		changed++
	}
	if m.QosResult != src.QosResult {
		m.QosResult = src.QosResult
		changed++
	}
	if m.QosErrorMsg != src.QosErrorMsg {
		m.QosErrorMsg = src.QosErrorMsg
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *FindCloudletReply) DeepCopyIn(src *FindCloudletReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	m.Fqdn = src.Fqdn
	if src.Ports != nil {
		m.Ports = make([]*AppPort, len(src.Ports), len(src.Ports))
		for ii, s := range src.Ports {
			var tmp_s AppPort
			tmp_s.DeepCopyIn(s)
			m.Ports[ii] = &tmp_s
		}
	} else {
		m.Ports = nil
	}
	if src.CloudletLocation != nil {
		var tmp_CloudletLocation Loc
		tmp_CloudletLocation.DeepCopyIn(src.CloudletLocation)
		m.CloudletLocation = &tmp_CloudletLocation
	} else {
		m.CloudletLocation = nil
	}
	m.EdgeEventsCookie = src.EdgeEventsCookie
	m.QosResult = src.QosResult
	m.QosErrorMsg = src.QosErrorMsg
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *FindCloudletReply) ValidateEnums() error {
	if _, ok := FindCloudletReply_FindStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	for _, e := range m.Ports {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if m.CloudletLocation != nil {
		if err := m.CloudletLocation.ValidateEnums(); err != nil {
			return err
		}
	}
	if _, ok := FindCloudletReply_QosSessionResult_name[int32(m.QosResult)]; !ok {
		return errors.New("invalid QosResult")
	}
	return nil
}

func (s *FindCloudletReply) ClearTagged(tags map[string]struct{}) {
	if s.Ports != nil {
		for ii := 0; ii < len(s.Ports); ii++ {
			s.Ports[ii].ClearTagged(tags)
		}
	}
	if s.CloudletLocation != nil {
		s.CloudletLocation.ClearTagged(tags)
	}
}

func (m *QosPrioritySessionCreateRequest) CopyInFields(src *QosPrioritySessionCreateRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.SessionDuration != src.SessionDuration {
		m.SessionDuration = src.SessionDuration
		changed++
	}
	if m.IpUserEquipment != src.IpUserEquipment {
		m.IpUserEquipment = src.IpUserEquipment
		changed++
	}
	if m.IpApplicationServer != src.IpApplicationServer {
		m.IpApplicationServer = src.IpApplicationServer
		changed++
	}
	if m.PortUserEquipment != src.PortUserEquipment {
		m.PortUserEquipment = src.PortUserEquipment
		changed++
	}
	if m.PortApplicationServer != src.PortApplicationServer {
		m.PortApplicationServer = src.PortApplicationServer
		changed++
	}
	if m.ProtocolIn != src.ProtocolIn {
		m.ProtocolIn = src.ProtocolIn
		changed++
	}
	if m.ProtocolOut != src.ProtocolOut {
		m.ProtocolOut = src.ProtocolOut
		changed++
	}
	if m.Profile != src.Profile {
		m.Profile = src.Profile
		changed++
	}
	if m.NotificationUri != src.NotificationUri {
		m.NotificationUri = src.NotificationUri
		changed++
	}
	if m.NotificationAuthToken != src.NotificationAuthToken {
		m.NotificationAuthToken = src.NotificationAuthToken
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *QosPrioritySessionCreateRequest) DeepCopyIn(src *QosPrioritySessionCreateRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.SessionDuration = src.SessionDuration
	m.IpUserEquipment = src.IpUserEquipment
	m.IpApplicationServer = src.IpApplicationServer
	m.PortUserEquipment = src.PortUserEquipment
	m.PortApplicationServer = src.PortApplicationServer
	m.ProtocolIn = src.ProtocolIn
	m.ProtocolOut = src.ProtocolOut
	m.Profile = src.Profile
	m.NotificationUri = src.NotificationUri
	m.NotificationAuthToken = src.NotificationAuthToken
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *QosPrioritySessionCreateRequest) ValidateEnums() error {
	if _, ok := QosSessionProtocol_name[int32(m.ProtocolIn)]; !ok {
		return errors.New("invalid ProtocolIn")
	}
	if _, ok := QosSessionProtocol_name[int32(m.ProtocolOut)]; !ok {
		return errors.New("invalid ProtocolOut")
	}
	if _, ok := QosSessionProfile_name[int32(m.Profile)]; !ok {
		return errors.New("invalid Profile")
	}
	return nil
}

func (s *QosPrioritySessionCreateRequest) ClearTagged(tags map[string]struct{}) {
}

func (m *QosPrioritySessionReply) CopyInFields(src *QosPrioritySessionReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionDuration != src.SessionDuration {
		m.SessionDuration = src.SessionDuration
		changed++
	}
	if m.Profile != src.Profile {
		m.Profile = src.Profile
		changed++
	}
	if m.SessionId != src.SessionId {
		m.SessionId = src.SessionId
		changed++
	}
	if m.StartedAt != src.StartedAt {
		m.StartedAt = src.StartedAt
		changed++
	}
	if m.ExpiresAt != src.ExpiresAt {
		m.ExpiresAt = src.ExpiresAt
		changed++
	}
	if m.HttpStatus != src.HttpStatus {
		m.HttpStatus = src.HttpStatus
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *QosPrioritySessionReply) DeepCopyIn(src *QosPrioritySessionReply) {
	m.Ver = src.Ver
	m.SessionDuration = src.SessionDuration
	m.Profile = src.Profile
	m.SessionId = src.SessionId
	m.StartedAt = src.StartedAt
	m.ExpiresAt = src.ExpiresAt
	m.HttpStatus = src.HttpStatus
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *QosPrioritySessionReply) ValidateEnums() error {
	if _, ok := QosSessionProfile_name[int32(m.Profile)]; !ok {
		return errors.New("invalid Profile")
	}
	return nil
}

func (s *QosPrioritySessionReply) ClearTagged(tags map[string]struct{}) {
}

func (m *QosPrioritySessionDeleteRequest) CopyInFields(src *QosPrioritySessionDeleteRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.Profile != src.Profile {
		m.Profile = src.Profile
		changed++
	}
	if m.SessionId != src.SessionId {
		m.SessionId = src.SessionId
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *QosPrioritySessionDeleteRequest) DeepCopyIn(src *QosPrioritySessionDeleteRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.Profile = src.Profile
	m.SessionId = src.SessionId
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *QosPrioritySessionDeleteRequest) ValidateEnums() error {
	if _, ok := QosSessionProfile_name[int32(m.Profile)]; !ok {
		return errors.New("invalid Profile")
	}
	return nil
}

func (s *QosPrioritySessionDeleteRequest) ClearTagged(tags map[string]struct{}) {
}

func (m *QosPrioritySessionDeleteReply) CopyInFields(src *QosPrioritySessionDeleteReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *QosPrioritySessionDeleteReply) DeepCopyIn(src *QosPrioritySessionDeleteReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *QosPrioritySessionDeleteReply) ValidateEnums() error {
	if _, ok := QosPrioritySessionDeleteReply_DeleteStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	return nil
}

func (s *QosPrioritySessionDeleteReply) ClearTagged(tags map[string]struct{}) {
}

func (m *VerifyLocationRequest) CopyInFields(src *VerifyLocationRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if src.GpsLocation != nil {
		if m.GpsLocation == nil {
			m.GpsLocation = &Loc{}
		}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			if m.GpsLocation.Timestamp == nil {
				m.GpsLocation.Timestamp = &Timestamp{}
			}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	if m.VerifyLocToken != src.VerifyLocToken {
		m.VerifyLocToken = src.VerifyLocToken
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *VerifyLocationRequest) DeepCopyIn(src *VerifyLocationRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.CarrierName = src.CarrierName
	if src.GpsLocation != nil {
		var tmp_GpsLocation Loc
		tmp_GpsLocation.DeepCopyIn(src.GpsLocation)
		m.GpsLocation = &tmp_GpsLocation
	} else {
		m.GpsLocation = nil
	}
	m.VerifyLocToken = src.VerifyLocToken
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *VerifyLocationRequest) ValidateEnums() error {
	if m.GpsLocation != nil {
		if err := m.GpsLocation.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *VerifyLocationRequest) ClearTagged(tags map[string]struct{}) {
	if s.GpsLocation != nil {
		s.GpsLocation.ClearTagged(tags)
	}
}

func (m *VerifyLocationReply) CopyInFields(src *VerifyLocationReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.TowerStatus != src.TowerStatus {
		m.TowerStatus = src.TowerStatus
		changed++
	}
	if m.GpsLocationStatus != src.GpsLocationStatus {
		m.GpsLocationStatus = src.GpsLocationStatus
		changed++
	}
	if m.GpsLocationAccuracyKm != src.GpsLocationAccuracyKm {
		m.GpsLocationAccuracyKm = src.GpsLocationAccuracyKm
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *VerifyLocationReply) DeepCopyIn(src *VerifyLocationReply) {
	m.Ver = src.Ver
	m.TowerStatus = src.TowerStatus
	m.GpsLocationStatus = src.GpsLocationStatus
	m.GpsLocationAccuracyKm = src.GpsLocationAccuracyKm
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *VerifyLocationReply) ValidateEnums() error {
	if _, ok := VerifyLocationReply_TowerStatus_name[int32(m.TowerStatus)]; !ok {
		return errors.New("invalid TowerStatus")
	}
	if _, ok := VerifyLocationReply_GPSLocationStatus_name[int32(m.GpsLocationStatus)]; !ok {
		return errors.New("invalid GpsLocationStatus")
	}
	return nil
}

func (s *VerifyLocationReply) ClearTagged(tags map[string]struct{}) {
}

func (m *GetLocationRequest) CopyInFields(src *GetLocationRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *GetLocationRequest) DeepCopyIn(src *GetLocationRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.CarrierName = src.CarrierName
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *GetLocationRequest) ValidateEnums() error {
	return nil
}

func (s *GetLocationRequest) ClearTagged(tags map[string]struct{}) {
}

func (m *GetLocationReply) CopyInFields(src *GetLocationReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if m.Tower != src.Tower {
		m.Tower = src.Tower
		changed++
	}
	if src.NetworkLocation != nil {
		if m.NetworkLocation == nil {
			m.NetworkLocation = &Loc{}
		}
		if m.NetworkLocation.Latitude != src.NetworkLocation.Latitude {
			m.NetworkLocation.Latitude = src.NetworkLocation.Latitude
			changed++
		}
		if m.NetworkLocation.Longitude != src.NetworkLocation.Longitude {
			m.NetworkLocation.Longitude = src.NetworkLocation.Longitude
			changed++
		}
		if m.NetworkLocation.HorizontalAccuracy != src.NetworkLocation.HorizontalAccuracy {
			m.NetworkLocation.HorizontalAccuracy = src.NetworkLocation.HorizontalAccuracy
			changed++
		}
		if m.NetworkLocation.VerticalAccuracy != src.NetworkLocation.VerticalAccuracy {
			m.NetworkLocation.VerticalAccuracy = src.NetworkLocation.VerticalAccuracy
			changed++
		}
		if m.NetworkLocation.Altitude != src.NetworkLocation.Altitude {
			m.NetworkLocation.Altitude = src.NetworkLocation.Altitude
			changed++
		}
		if m.NetworkLocation.Course != src.NetworkLocation.Course {
			m.NetworkLocation.Course = src.NetworkLocation.Course
			changed++
		}
		if m.NetworkLocation.Speed != src.NetworkLocation.Speed {
			m.NetworkLocation.Speed = src.NetworkLocation.Speed
			changed++
		}
		if src.NetworkLocation.Timestamp != nil {
			if m.NetworkLocation.Timestamp == nil {
				m.NetworkLocation.Timestamp = &Timestamp{}
			}
			if m.NetworkLocation.Timestamp.Seconds != src.NetworkLocation.Timestamp.Seconds {
				m.NetworkLocation.Timestamp.Seconds = src.NetworkLocation.Timestamp.Seconds
				changed++
			}
			if m.NetworkLocation.Timestamp.Nanos != src.NetworkLocation.Timestamp.Nanos {
				m.NetworkLocation.Timestamp.Nanos = src.NetworkLocation.Timestamp.Nanos
				changed++
			}
		} else if m.NetworkLocation.Timestamp != nil {
			m.NetworkLocation.Timestamp = nil
			changed++
		}
	} else if m.NetworkLocation != nil {
		m.NetworkLocation = nil
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *GetLocationReply) DeepCopyIn(src *GetLocationReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	m.CarrierName = src.CarrierName
	m.Tower = src.Tower
	if src.NetworkLocation != nil {
		var tmp_NetworkLocation Loc
		tmp_NetworkLocation.DeepCopyIn(src.NetworkLocation)
		m.NetworkLocation = &tmp_NetworkLocation
	} else {
		m.NetworkLocation = nil
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *GetLocationReply) ValidateEnums() error {
	if _, ok := GetLocationReply_LocStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	if m.NetworkLocation != nil {
		if err := m.NetworkLocation.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *GetLocationReply) ClearTagged(tags map[string]struct{}) {
	if s.NetworkLocation != nil {
		s.NetworkLocation.ClearTagged(tags)
	}
}

func (m *AppInstListRequest) CopyInFields(src *AppInstListRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if src.GpsLocation != nil {
		if m.GpsLocation == nil {
			m.GpsLocation = &Loc{}
		}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			if m.GpsLocation.Timestamp == nil {
				m.GpsLocation.Timestamp = &Timestamp{}
			}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	if m.Limit != src.Limit {
		m.Limit = src.Limit
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *AppInstListRequest) DeepCopyIn(src *AppInstListRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.CarrierName = src.CarrierName
	if src.GpsLocation != nil {
		var tmp_GpsLocation Loc
		tmp_GpsLocation.DeepCopyIn(src.GpsLocation)
		m.GpsLocation = &tmp_GpsLocation
	} else {
		m.GpsLocation = nil
	}
	m.Limit = src.Limit
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *AppInstListRequest) ValidateEnums() error {
	if m.GpsLocation != nil {
		if err := m.GpsLocation.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *AppInstListRequest) ClearTagged(tags map[string]struct{}) {
	if s.GpsLocation != nil {
		s.GpsLocation.ClearTagged(tags)
	}
}

func (m *Appinstance) CopyInFields(src *Appinstance) int {
	changed := 0
	if m.AppName != src.AppName {
		m.AppName = src.AppName
		changed++
	}
	if m.AppVers != src.AppVers {
		m.AppVers = src.AppVers
		changed++
	}
	if m.Fqdn != src.Fqdn {
		m.Fqdn = src.Fqdn
		changed++
	}
	if src.Ports != nil {
		m.Ports = src.Ports
		changed++
	} else if m.Ports != nil {
		m.Ports = nil
		changed++
	}
	if m.OrgName != src.OrgName {
		m.OrgName = src.OrgName
		changed++
	}
	if m.EdgeEventsCookie != src.EdgeEventsCookie {
		m.EdgeEventsCookie = src.EdgeEventsCookie
		changed++
	}
	return changed
}

func (m *Appinstance) DeepCopyIn(src *Appinstance) {
	m.AppName = src.AppName
	m.AppVers = src.AppVers
	m.Fqdn = src.Fqdn
	if src.Ports != nil {
		m.Ports = make([]*AppPort, len(src.Ports), len(src.Ports))
		for ii, s := range src.Ports {
			var tmp_s AppPort
			tmp_s.DeepCopyIn(s)
			m.Ports[ii] = &tmp_s
		}
	} else {
		m.Ports = nil
	}
	m.OrgName = src.OrgName
	m.EdgeEventsCookie = src.EdgeEventsCookie
}

// Helper method to check that enums have valid values
func (m *Appinstance) ValidateEnums() error {
	for _, e := range m.Ports {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *Appinstance) ClearTagged(tags map[string]struct{}) {
	if s.Ports != nil {
		for ii := 0; ii < len(s.Ports); ii++ {
			s.Ports[ii].ClearTagged(tags)
		}
	}
}

func (m *CloudletLocation) CopyInFields(src *CloudletLocation) int {
	changed := 0
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if m.CloudletName != src.CloudletName {
		m.CloudletName = src.CloudletName
		changed++
	}
	if src.GpsLocation != nil {
		if m.GpsLocation == nil {
			m.GpsLocation = &Loc{}
		}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			if m.GpsLocation.Timestamp == nil {
				m.GpsLocation.Timestamp = &Timestamp{}
			}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	if m.Distance != src.Distance {
		m.Distance = src.Distance
		changed++
	}
	if src.Appinstances != nil {
		m.Appinstances = src.Appinstances
		changed++
	} else if m.Appinstances != nil {
		m.Appinstances = nil
		changed++
	}
	return changed
}

func (m *CloudletLocation) DeepCopyIn(src *CloudletLocation) {
	m.CarrierName = src.CarrierName
	m.CloudletName = src.CloudletName
	if src.GpsLocation != nil {
		var tmp_GpsLocation Loc
		tmp_GpsLocation.DeepCopyIn(src.GpsLocation)
		m.GpsLocation = &tmp_GpsLocation
	} else {
		m.GpsLocation = nil
	}
	m.Distance = src.Distance
	if src.Appinstances != nil {
		m.Appinstances = make([]*Appinstance, len(src.Appinstances), len(src.Appinstances))
		for ii, s := range src.Appinstances {
			var tmp_s Appinstance
			tmp_s.DeepCopyIn(s)
			m.Appinstances[ii] = &tmp_s
		}
	} else {
		m.Appinstances = nil
	}
}

// Helper method to check that enums have valid values
func (m *CloudletLocation) ValidateEnums() error {
	if m.GpsLocation != nil {
		if err := m.GpsLocation.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.Appinstances {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *CloudletLocation) ClearTagged(tags map[string]struct{}) {
	if s.GpsLocation != nil {
		s.GpsLocation.ClearTagged(tags)
	}
	if s.Appinstances != nil {
		for ii := 0; ii < len(s.Appinstances); ii++ {
			s.Appinstances[ii].ClearTagged(tags)
		}
	}
}

func (m *AppInstListReply) CopyInFields(src *AppInstListReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if src.Cloudlets != nil {
		m.Cloudlets = src.Cloudlets
		changed++
	} else if m.Cloudlets != nil {
		m.Cloudlets = nil
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *AppInstListReply) DeepCopyIn(src *AppInstListReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	if src.Cloudlets != nil {
		m.Cloudlets = make([]*CloudletLocation, len(src.Cloudlets), len(src.Cloudlets))
		for ii, s := range src.Cloudlets {
			var tmp_s CloudletLocation
			tmp_s.DeepCopyIn(s)
			m.Cloudlets[ii] = &tmp_s
		}
	} else {
		m.Cloudlets = nil
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *AppInstListReply) ValidateEnums() error {
	if _, ok := AppInstListReply_AIStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	for _, e := range m.Cloudlets {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *AppInstListReply) ClearTagged(tags map[string]struct{}) {
	if s.Cloudlets != nil {
		for ii := 0; ii < len(s.Cloudlets); ii++ {
			s.Cloudlets[ii].ClearTagged(tags)
		}
	}
}

func (m *FqdnListRequest) CopyInFields(src *FqdnListRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *FqdnListRequest) DeepCopyIn(src *FqdnListRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *FqdnListRequest) ValidateEnums() error {
	return nil
}

func (s *FqdnListRequest) ClearTagged(tags map[string]struct{}) {
}

func (m *AppFqdn) CopyInFields(src *AppFqdn) int {
	changed := 0
	if m.AppName != src.AppName {
		m.AppName = src.AppName
		changed++
	}
	if m.AppVers != src.AppVers {
		m.AppVers = src.AppVers
		changed++
	}
	if m.OrgName != src.OrgName {
		m.OrgName = src.OrgName
		changed++
	}
	if src.Fqdns != nil {
		m.Fqdns = src.Fqdns
		changed++
	} else if m.Fqdns != nil {
		m.Fqdns = nil
		changed++
	}
	if m.AndroidPackageName != src.AndroidPackageName {
		m.AndroidPackageName = src.AndroidPackageName
		changed++
	}
	return changed
}

func (m *AppFqdn) DeepCopyIn(src *AppFqdn) {
	m.AppName = src.AppName
	m.AppVers = src.AppVers
	m.OrgName = src.OrgName
	if src.Fqdns != nil {
		m.Fqdns = make([]string, len(src.Fqdns), len(src.Fqdns))
		for ii, s := range src.Fqdns {
			m.Fqdns[ii] = s
		}
	} else {
		m.Fqdns = nil
	}
	m.AndroidPackageName = src.AndroidPackageName
}

// Helper method to check that enums have valid values
func (m *AppFqdn) ValidateEnums() error {
	return nil
}

func (s *AppFqdn) ClearTagged(tags map[string]struct{}) {
}

func (m *FqdnListReply) CopyInFields(src *FqdnListReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if src.AppFqdns != nil {
		m.AppFqdns = src.AppFqdns
		changed++
	} else if m.AppFqdns != nil {
		m.AppFqdns = nil
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *FqdnListReply) DeepCopyIn(src *FqdnListReply) {
	m.Ver = src.Ver
	if src.AppFqdns != nil {
		m.AppFqdns = make([]*AppFqdn, len(src.AppFqdns), len(src.AppFqdns))
		for ii, s := range src.AppFqdns {
			var tmp_s AppFqdn
			tmp_s.DeepCopyIn(s)
			m.AppFqdns[ii] = &tmp_s
		}
	} else {
		m.AppFqdns = nil
	}
	m.Status = src.Status
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *FqdnListReply) ValidateEnums() error {
	for _, e := range m.AppFqdns {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if _, ok := FqdnListReply_FLStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	return nil
}

func (s *FqdnListReply) ClearTagged(tags map[string]struct{}) {
	if s.AppFqdns != nil {
		for ii := 0; ii < len(s.AppFqdns); ii++ {
			s.AppFqdns[ii].ClearTagged(tags)
		}
	}
}

func (m *AppOfficialFqdnRequest) CopyInFields(src *AppOfficialFqdnRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if src.GpsLocation != nil {
		if m.GpsLocation == nil {
			m.GpsLocation = &Loc{}
		}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			if m.GpsLocation.Timestamp == nil {
				m.GpsLocation.Timestamp = &Timestamp{}
			}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *AppOfficialFqdnRequest) DeepCopyIn(src *AppOfficialFqdnRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	if src.GpsLocation != nil {
		var tmp_GpsLocation Loc
		tmp_GpsLocation.DeepCopyIn(src.GpsLocation)
		m.GpsLocation = &tmp_GpsLocation
	} else {
		m.GpsLocation = nil
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *AppOfficialFqdnRequest) ValidateEnums() error {
	if m.GpsLocation != nil {
		if err := m.GpsLocation.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *AppOfficialFqdnRequest) ClearTagged(tags map[string]struct{}) {
	if s.GpsLocation != nil {
		s.GpsLocation.ClearTagged(tags)
	}
}

func (m *AppOfficialFqdnReply) CopyInFields(src *AppOfficialFqdnReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.AppOfficialFqdn != src.AppOfficialFqdn {
		m.AppOfficialFqdn = src.AppOfficialFqdn
		changed++
	}
	if m.ClientToken != src.ClientToken {
		m.ClientToken = src.ClientToken
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if src.Ports != nil {
		m.Ports = src.Ports
		changed++
	} else if m.Ports != nil {
		m.Ports = nil
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *AppOfficialFqdnReply) DeepCopyIn(src *AppOfficialFqdnReply) {
	m.Ver = src.Ver
	m.AppOfficialFqdn = src.AppOfficialFqdn
	m.ClientToken = src.ClientToken
	m.Status = src.Status
	if src.Ports != nil {
		m.Ports = make([]*AppPort, len(src.Ports), len(src.Ports))
		for ii, s := range src.Ports {
			var tmp_s AppPort
			tmp_s.DeepCopyIn(s)
			m.Ports[ii] = &tmp_s
		}
	} else {
		m.Ports = nil
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *AppOfficialFqdnReply) ValidateEnums() error {
	if _, ok := AppOfficialFqdnReply_AOFStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	for _, e := range m.Ports {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *AppOfficialFqdnReply) ClearTagged(tags map[string]struct{}) {
	if s.Ports != nil {
		for ii := 0; ii < len(s.Ports); ii++ {
			s.Ports[ii].ClearTagged(tags)
		}
	}
}

func (m *DynamicLocGroupRequest) CopyInFields(src *DynamicLocGroupRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.LgId != src.LgId {
		m.LgId = src.LgId
		changed++
	}
	if m.CommType != src.CommType {
		m.CommType = src.CommType
		changed++
	}
	if m.UserData != src.UserData {
		m.UserData = src.UserData
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *DynamicLocGroupRequest) DeepCopyIn(src *DynamicLocGroupRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.LgId = src.LgId
	m.CommType = src.CommType
	m.UserData = src.UserData
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *DynamicLocGroupRequest) ValidateEnums() error {
	if _, ok := DynamicLocGroupRequest_DlgCommType_name[int32(m.CommType)]; !ok {
		return errors.New("invalid CommType")
	}
	return nil
}

func (s *DynamicLocGroupRequest) ClearTagged(tags map[string]struct{}) {
}

func (m *DynamicLocGroupReply) CopyInFields(src *DynamicLocGroupReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if m.ErrorCode != src.ErrorCode {
		m.ErrorCode = src.ErrorCode
		changed++
	}
	if m.GroupCookie != src.GroupCookie {
		m.GroupCookie = src.GroupCookie
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *DynamicLocGroupReply) DeepCopyIn(src *DynamicLocGroupReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	m.ErrorCode = src.ErrorCode
	m.GroupCookie = src.GroupCookie
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *DynamicLocGroupReply) ValidateEnums() error {
	if _, ok := ReplyStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	return nil
}

func (s *DynamicLocGroupReply) ClearTagged(tags map[string]struct{}) {
}

func (m *QosPosition) CopyInFields(src *QosPosition) int {
	changed := 0
	if m.Positionid != src.Positionid {
		m.Positionid = src.Positionid
		changed++
	}
	if src.GpsLocation != nil {
		if m.GpsLocation == nil {
			m.GpsLocation = &Loc{}
		}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			if m.GpsLocation.Timestamp == nil {
				m.GpsLocation.Timestamp = &Timestamp{}
			}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	return changed
}

func (m *QosPosition) DeepCopyIn(src *QosPosition) {
	m.Positionid = src.Positionid
	if src.GpsLocation != nil {
		var tmp_GpsLocation Loc
		tmp_GpsLocation.DeepCopyIn(src.GpsLocation)
		m.GpsLocation = &tmp_GpsLocation
	} else {
		m.GpsLocation = nil
	}
}

// Helper method to check that enums have valid values
func (m *QosPosition) ValidateEnums() error {
	if m.GpsLocation != nil {
		if err := m.GpsLocation.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *QosPosition) ClearTagged(tags map[string]struct{}) {
	if s.GpsLocation != nil {
		s.GpsLocation.ClearTagged(tags)
	}
}

func (m *BandSelection) CopyInFields(src *BandSelection) int {
	changed := 0
	if src.Rat_2G != nil {
		m.Rat_2G = src.Rat_2G
		changed++
	} else if m.Rat_2G != nil {
		m.Rat_2G = nil
		changed++
	}
	if src.Rat_3G != nil {
		m.Rat_3G = src.Rat_3G
		changed++
	} else if m.Rat_3G != nil {
		m.Rat_3G = nil
		changed++
	}
	if src.Rat_4G != nil {
		m.Rat_4G = src.Rat_4G
		changed++
	} else if m.Rat_4G != nil {
		m.Rat_4G = nil
		changed++
	}
	if src.Rat_5G != nil {
		m.Rat_5G = src.Rat_5G
		changed++
	} else if m.Rat_5G != nil {
		m.Rat_5G = nil
		changed++
	}
	return changed
}

func (m *BandSelection) DeepCopyIn(src *BandSelection) {
	if src.Rat_2G != nil {
		m.Rat_2G = make([]string, len(src.Rat_2G), len(src.Rat_2G))
		for ii, s := range src.Rat_2G {
			m.Rat_2G[ii] = s
		}
	} else {
		m.Rat_2G = nil
	}
	if src.Rat_3G != nil {
		m.Rat_3G = make([]string, len(src.Rat_3G), len(src.Rat_3G))
		for ii, s := range src.Rat_3G {
			m.Rat_3G[ii] = s
		}
	} else {
		m.Rat_3G = nil
	}
	if src.Rat_4G != nil {
		m.Rat_4G = make([]string, len(src.Rat_4G), len(src.Rat_4G))
		for ii, s := range src.Rat_4G {
			m.Rat_4G[ii] = s
		}
	} else {
		m.Rat_4G = nil
	}
	if src.Rat_5G != nil {
		m.Rat_5G = make([]string, len(src.Rat_5G), len(src.Rat_5G))
		for ii, s := range src.Rat_5G {
			m.Rat_5G[ii] = s
		}
	} else {
		m.Rat_5G = nil
	}
}

// Helper method to check that enums have valid values
func (m *BandSelection) ValidateEnums() error {
	return nil
}

func (s *BandSelection) ClearTagged(tags map[string]struct{}) {
}

func (m *QosPositionRequest) CopyInFields(src *QosPositionRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if src.Positions != nil {
		m.Positions = src.Positions
		changed++
	} else if m.Positions != nil {
		m.Positions = nil
		changed++
	}
	if m.LteCategory != src.LteCategory {
		m.LteCategory = src.LteCategory
		changed++
	}
	if src.BandSelection != nil {
		if m.BandSelection == nil {
			m.BandSelection = &BandSelection{}
		}
		if src.BandSelection.Rat_2G != nil {
			m.BandSelection.Rat_2G = src.BandSelection.Rat_2G
			changed++
		} else if m.BandSelection.Rat_2G != nil {
			m.BandSelection.Rat_2G = nil
			changed++
		}
		if src.BandSelection.Rat_3G != nil {
			m.BandSelection.Rat_3G = src.BandSelection.Rat_3G
			changed++
		} else if m.BandSelection.Rat_3G != nil {
			m.BandSelection.Rat_3G = nil
			changed++
		}
		if src.BandSelection.Rat_4G != nil {
			m.BandSelection.Rat_4G = src.BandSelection.Rat_4G
			changed++
		} else if m.BandSelection.Rat_4G != nil {
			m.BandSelection.Rat_4G = nil
			changed++
		}
		if src.BandSelection.Rat_5G != nil {
			m.BandSelection.Rat_5G = src.BandSelection.Rat_5G
			changed++
		} else if m.BandSelection.Rat_5G != nil {
			m.BandSelection.Rat_5G = nil
			changed++
		}
	} else if m.BandSelection != nil {
		m.BandSelection = nil
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *QosPositionRequest) DeepCopyIn(src *QosPositionRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	if src.Positions != nil {
		m.Positions = make([]*QosPosition, len(src.Positions), len(src.Positions))
		for ii, s := range src.Positions {
			var tmp_s QosPosition
			tmp_s.DeepCopyIn(s)
			m.Positions[ii] = &tmp_s
		}
	} else {
		m.Positions = nil
	}
	m.LteCategory = src.LteCategory
	if src.BandSelection != nil {
		var tmp_BandSelection BandSelection
		tmp_BandSelection.DeepCopyIn(src.BandSelection)
		m.BandSelection = &tmp_BandSelection
	} else {
		m.BandSelection = nil
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *QosPositionRequest) ValidateEnums() error {
	for _, e := range m.Positions {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if m.BandSelection != nil {
		if err := m.BandSelection.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *QosPositionRequest) ClearTagged(tags map[string]struct{}) {
	if s.Positions != nil {
		for ii := 0; ii < len(s.Positions); ii++ {
			s.Positions[ii].ClearTagged(tags)
		}
	}
	if s.BandSelection != nil {
		s.BandSelection.ClearTagged(tags)
	}
}

func (m *QosPositionKpiResult) CopyInFields(src *QosPositionKpiResult) int {
	changed := 0
	if m.Positionid != src.Positionid {
		m.Positionid = src.Positionid
		changed++
	}
	if src.GpsLocation != nil {
		if m.GpsLocation == nil {
			m.GpsLocation = &Loc{}
		}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			if m.GpsLocation.Timestamp == nil {
				m.GpsLocation.Timestamp = &Timestamp{}
			}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	if m.DluserthroughputMin != src.DluserthroughputMin {
		m.DluserthroughputMin = src.DluserthroughputMin
		changed++
	}
	if m.DluserthroughputAvg != src.DluserthroughputAvg {
		m.DluserthroughputAvg = src.DluserthroughputAvg
		changed++
	}
	if m.DluserthroughputMax != src.DluserthroughputMax {
		m.DluserthroughputMax = src.DluserthroughputMax
		changed++
	}
	if m.UluserthroughputMin != src.UluserthroughputMin {
		m.UluserthroughputMin = src.UluserthroughputMin
		changed++
	}
	if m.UluserthroughputAvg != src.UluserthroughputAvg {
		m.UluserthroughputAvg = src.UluserthroughputAvg
		changed++
	}
	if m.UluserthroughputMax != src.UluserthroughputMax {
		m.UluserthroughputMax = src.UluserthroughputMax
		changed++
	}
	if m.LatencyMin != src.LatencyMin {
		m.LatencyMin = src.LatencyMin
		changed++
	}
	if m.LatencyAvg != src.LatencyAvg {
		m.LatencyAvg = src.LatencyAvg
		changed++
	}
	if m.LatencyMax != src.LatencyMax {
		m.LatencyMax = src.LatencyMax
		changed++
	}
	return changed
}

func (m *QosPositionKpiResult) DeepCopyIn(src *QosPositionKpiResult) {
	m.Positionid = src.Positionid
	if src.GpsLocation != nil {
		var tmp_GpsLocation Loc
		tmp_GpsLocation.DeepCopyIn(src.GpsLocation)
		m.GpsLocation = &tmp_GpsLocation
	} else {
		m.GpsLocation = nil
	}
	m.DluserthroughputMin = src.DluserthroughputMin
	m.DluserthroughputAvg = src.DluserthroughputAvg
	m.DluserthroughputMax = src.DluserthroughputMax
	m.UluserthroughputMin = src.UluserthroughputMin
	m.UluserthroughputAvg = src.UluserthroughputAvg
	m.UluserthroughputMax = src.UluserthroughputMax
	m.LatencyMin = src.LatencyMin
	m.LatencyAvg = src.LatencyAvg
	m.LatencyMax = src.LatencyMax
}

// Helper method to check that enums have valid values
func (m *QosPositionKpiResult) ValidateEnums() error {
	if m.GpsLocation != nil {
		if err := m.GpsLocation.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *QosPositionKpiResult) ClearTagged(tags map[string]struct{}) {
	if s.GpsLocation != nil {
		s.GpsLocation.ClearTagged(tags)
	}
}

func (m *QosPositionKpiReply) CopyInFields(src *QosPositionKpiReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if src.PositionResults != nil {
		m.PositionResults = src.PositionResults
		changed++
	} else if m.PositionResults != nil {
		m.PositionResults = nil
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *QosPositionKpiReply) DeepCopyIn(src *QosPositionKpiReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	if src.PositionResults != nil {
		m.PositionResults = make([]*QosPositionKpiResult, len(src.PositionResults), len(src.PositionResults))
		for ii, s := range src.PositionResults {
			var tmp_s QosPositionKpiResult
			tmp_s.DeepCopyIn(s)
			m.PositionResults[ii] = &tmp_s
		}
	} else {
		m.PositionResults = nil
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *QosPositionKpiReply) ValidateEnums() error {
	if _, ok := ReplyStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	for _, e := range m.PositionResults {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *QosPositionKpiReply) ClearTagged(tags map[string]struct{}) {
	if s.PositionResults != nil {
		for ii := 0; ii < len(s.PositionResults); ii++ {
			s.PositionResults[ii].ClearTagged(tags)
		}
	}
}

func (m *ClientEdgeEvent) CopyInFields(src *ClientEdgeEvent) int {
	changed := 0
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.EdgeEventsCookie != src.EdgeEventsCookie {
		m.EdgeEventsCookie = src.EdgeEventsCookie
		changed++
	}
	if m.EventType != src.EventType {
		m.EventType = src.EventType
		changed++
	}
	if src.GpsLocation != nil {
		if m.GpsLocation == nil {
			m.GpsLocation = &Loc{}
		}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			if m.GpsLocation.Timestamp == nil {
				m.GpsLocation.Timestamp = &Timestamp{}
			}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	if src.Samples != nil {
		m.Samples = src.Samples
		changed++
	} else if m.Samples != nil {
		m.Samples = nil
		changed++
	}
	if src.DeviceInfoStatic != nil {
		if m.DeviceInfoStatic == nil {
			m.DeviceInfoStatic = &DeviceInfoStatic{}
		}
		if m.DeviceInfoStatic.DeviceOs != src.DeviceInfoStatic.DeviceOs {
			m.DeviceInfoStatic.DeviceOs = src.DeviceInfoStatic.DeviceOs
			changed++
		}
		if m.DeviceInfoStatic.DeviceModel != src.DeviceInfoStatic.DeviceModel {
			m.DeviceInfoStatic.DeviceModel = src.DeviceInfoStatic.DeviceModel
			changed++
		}
	} else if m.DeviceInfoStatic != nil {
		m.DeviceInfoStatic = nil
		changed++
	}
	if src.DeviceInfoDynamic != nil {
		if m.DeviceInfoDynamic == nil {
			m.DeviceInfoDynamic = &DeviceInfoDynamic{}
		}
		if m.DeviceInfoDynamic.DataNetworkType != src.DeviceInfoDynamic.DataNetworkType {
			m.DeviceInfoDynamic.DataNetworkType = src.DeviceInfoDynamic.DataNetworkType
			changed++
		}
		if m.DeviceInfoDynamic.SignalStrength != src.DeviceInfoDynamic.SignalStrength {
			m.DeviceInfoDynamic.SignalStrength = src.DeviceInfoDynamic.SignalStrength
			changed++
		}
		if m.DeviceInfoDynamic.CarrierName != src.DeviceInfoDynamic.CarrierName {
			m.DeviceInfoDynamic.CarrierName = src.DeviceInfoDynamic.CarrierName
			changed++
		}
	} else if m.DeviceInfoDynamic != nil {
		m.DeviceInfoDynamic = nil
		changed++
	}
	if m.CustomEvent != src.CustomEvent {
		m.CustomEvent = src.CustomEvent
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *ClientEdgeEvent) DeepCopyIn(src *ClientEdgeEvent) {
	m.SessionCookie = src.SessionCookie
	m.EdgeEventsCookie = src.EdgeEventsCookie
	m.EventType = src.EventType
	if src.GpsLocation != nil {
		var tmp_GpsLocation Loc
		tmp_GpsLocation.DeepCopyIn(src.GpsLocation)
		m.GpsLocation = &tmp_GpsLocation
	} else {
		m.GpsLocation = nil
	}
	if src.Samples != nil {
		m.Samples = make([]*Sample, len(src.Samples), len(src.Samples))
		for ii, s := range src.Samples {
			var tmp_s Sample
			tmp_s.DeepCopyIn(s)
			m.Samples[ii] = &tmp_s
		}
	} else {
		m.Samples = nil
	}
	if src.DeviceInfoStatic != nil {
		var tmp_DeviceInfoStatic DeviceInfoStatic
		tmp_DeviceInfoStatic.DeepCopyIn(src.DeviceInfoStatic)
		m.DeviceInfoStatic = &tmp_DeviceInfoStatic
	} else {
		m.DeviceInfoStatic = nil
	}
	if src.DeviceInfoDynamic != nil {
		var tmp_DeviceInfoDynamic DeviceInfoDynamic
		tmp_DeviceInfoDynamic.DeepCopyIn(src.DeviceInfoDynamic)
		m.DeviceInfoDynamic = &tmp_DeviceInfoDynamic
	} else {
		m.DeviceInfoDynamic = nil
	}
	m.CustomEvent = src.CustomEvent
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *ClientEdgeEvent) ValidateEnums() error {
	if _, ok := ClientEdgeEvent_ClientEventType_name[int32(m.EventType)]; !ok {
		return errors.New("invalid EventType")
	}
	if m.GpsLocation != nil {
		if err := m.GpsLocation.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.Samples {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if m.DeviceInfoStatic != nil {
		if err := m.DeviceInfoStatic.ValidateEnums(); err != nil {
			return err
		}
	}
	if m.DeviceInfoDynamic != nil {
		if err := m.DeviceInfoDynamic.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *ClientEdgeEvent) ClearTagged(tags map[string]struct{}) {
	if s.GpsLocation != nil {
		s.GpsLocation.ClearTagged(tags)
	}
	if s.Samples != nil {
		for ii := 0; ii < len(s.Samples); ii++ {
			s.Samples[ii].ClearTagged(tags)
		}
	}
	if s.DeviceInfoStatic != nil {
		s.DeviceInfoStatic.ClearTagged(tags)
	}
	if s.DeviceInfoDynamic != nil {
		s.DeviceInfoDynamic.ClearTagged(tags)
	}
}

func (m *ServerEdgeEvent) CopyInFields(src *ServerEdgeEvent) int {
	changed := 0
	if m.EventType != src.EventType {
		m.EventType = src.EventType
		changed++
	}
	if m.CloudletState != src.CloudletState {
		m.CloudletState = src.CloudletState
		changed++
	}
	if m.MaintenanceState != src.MaintenanceState {
		m.MaintenanceState = src.MaintenanceState
		changed++
	}
	if m.HealthCheck != src.HealthCheck {
		m.HealthCheck = src.HealthCheck
		changed++
	}
	if src.Statistics != nil {
		if m.Statistics == nil {
			m.Statistics = &Statistics{}
		}
		if m.Statistics.Avg != src.Statistics.Avg {
			m.Statistics.Avg = src.Statistics.Avg
			changed++
		}
		if m.Statistics.Min != src.Statistics.Min {
			m.Statistics.Min = src.Statistics.Min
			changed++
		}
		if m.Statistics.Max != src.Statistics.Max {
			m.Statistics.Max = src.Statistics.Max
			changed++
		}
		if m.Statistics.StdDev != src.Statistics.StdDev {
			m.Statistics.StdDev = src.Statistics.StdDev
			changed++
		}
		if m.Statistics.Variance != src.Statistics.Variance {
			m.Statistics.Variance = src.Statistics.Variance
			changed++
		}
		if m.Statistics.NumSamples != src.Statistics.NumSamples {
			m.Statistics.NumSamples = src.Statistics.NumSamples
			changed++
		}
		if src.Statistics.Timestamp != nil {
			if m.Statistics.Timestamp == nil {
				m.Statistics.Timestamp = &Timestamp{}
			}
			if m.Statistics.Timestamp.Seconds != src.Statistics.Timestamp.Seconds {
				m.Statistics.Timestamp.Seconds = src.Statistics.Timestamp.Seconds
				changed++
			}
			if m.Statistics.Timestamp.Nanos != src.Statistics.Timestamp.Nanos {
				m.Statistics.Timestamp.Nanos = src.Statistics.Timestamp.Nanos
				changed++
			}
		} else if m.Statistics.Timestamp != nil {
			m.Statistics.Timestamp = nil
			changed++
		}
	} else if m.Statistics != nil {
		m.Statistics = nil
		changed++
	}
	if src.NewCloudlet != nil {
		if m.NewCloudlet == nil {
			m.NewCloudlet = &FindCloudletReply{}
		}
		if m.NewCloudlet.Ver != src.NewCloudlet.Ver {
			m.NewCloudlet.Ver = src.NewCloudlet.Ver
			changed++
		}
		if m.NewCloudlet.Status != src.NewCloudlet.Status {
			m.NewCloudlet.Status = src.NewCloudlet.Status
			changed++
		}
		if m.NewCloudlet.Fqdn != src.NewCloudlet.Fqdn {
			m.NewCloudlet.Fqdn = src.NewCloudlet.Fqdn
			changed++
		}
		if src.NewCloudlet.Ports != nil {
			m.NewCloudlet.Ports = src.NewCloudlet.Ports
			changed++
		} else if m.NewCloudlet.Ports != nil {
			m.NewCloudlet.Ports = nil
			changed++
		}
		if src.NewCloudlet.CloudletLocation != nil {
			if m.NewCloudlet.CloudletLocation == nil {
				m.NewCloudlet.CloudletLocation = &Loc{}
			}
			if m.NewCloudlet.CloudletLocation.Latitude != src.NewCloudlet.CloudletLocation.Latitude {
				m.NewCloudlet.CloudletLocation.Latitude = src.NewCloudlet.CloudletLocation.Latitude
				changed++
			}
			if m.NewCloudlet.CloudletLocation.Longitude != src.NewCloudlet.CloudletLocation.Longitude {
				m.NewCloudlet.CloudletLocation.Longitude = src.NewCloudlet.CloudletLocation.Longitude
				changed++
			}
			if m.NewCloudlet.CloudletLocation.HorizontalAccuracy != src.NewCloudlet.CloudletLocation.HorizontalAccuracy {
				m.NewCloudlet.CloudletLocation.HorizontalAccuracy = src.NewCloudlet.CloudletLocation.HorizontalAccuracy
				changed++
			}
			if m.NewCloudlet.CloudletLocation.VerticalAccuracy != src.NewCloudlet.CloudletLocation.VerticalAccuracy {
				m.NewCloudlet.CloudletLocation.VerticalAccuracy = src.NewCloudlet.CloudletLocation.VerticalAccuracy
				changed++
			}
			if m.NewCloudlet.CloudletLocation.Altitude != src.NewCloudlet.CloudletLocation.Altitude {
				m.NewCloudlet.CloudletLocation.Altitude = src.NewCloudlet.CloudletLocation.Altitude
				changed++
			}
			if m.NewCloudlet.CloudletLocation.Course != src.NewCloudlet.CloudletLocation.Course {
				m.NewCloudlet.CloudletLocation.Course = src.NewCloudlet.CloudletLocation.Course
				changed++
			}
			if m.NewCloudlet.CloudletLocation.Speed != src.NewCloudlet.CloudletLocation.Speed {
				m.NewCloudlet.CloudletLocation.Speed = src.NewCloudlet.CloudletLocation.Speed
				changed++
			}
			if src.NewCloudlet.CloudletLocation.Timestamp != nil {
				if m.NewCloudlet.CloudletLocation.Timestamp == nil {
					m.NewCloudlet.CloudletLocation.Timestamp = &Timestamp{}
				}
				if m.NewCloudlet.CloudletLocation.Timestamp.Seconds != src.NewCloudlet.CloudletLocation.Timestamp.Seconds {
					m.NewCloudlet.CloudletLocation.Timestamp.Seconds = src.NewCloudlet.CloudletLocation.Timestamp.Seconds
					changed++
				}
				if m.NewCloudlet.CloudletLocation.Timestamp.Nanos != src.NewCloudlet.CloudletLocation.Timestamp.Nanos {
					m.NewCloudlet.CloudletLocation.Timestamp.Nanos = src.NewCloudlet.CloudletLocation.Timestamp.Nanos
					changed++
				}
			} else if m.NewCloudlet.CloudletLocation.Timestamp != nil {
				m.NewCloudlet.CloudletLocation.Timestamp = nil
				changed++
			}
		} else if m.NewCloudlet.CloudletLocation != nil {
			m.NewCloudlet.CloudletLocation = nil
			changed++
		}
		if m.NewCloudlet.EdgeEventsCookie != src.NewCloudlet.EdgeEventsCookie {
			m.NewCloudlet.EdgeEventsCookie = src.NewCloudlet.EdgeEventsCookie
			changed++
		}
		if m.NewCloudlet.QosResult != src.NewCloudlet.QosResult {
			m.NewCloudlet.QosResult = src.NewCloudlet.QosResult
			changed++
		}
		if m.NewCloudlet.QosErrorMsg != src.NewCloudlet.QosErrorMsg {
			m.NewCloudlet.QosErrorMsg = src.NewCloudlet.QosErrorMsg
			changed++
		}
		if src.NewCloudlet.Tags != nil {
			m.NewCloudlet.Tags = make(map[string]string)
			for k1, _ := range src.NewCloudlet.Tags {
				m.NewCloudlet.Tags[k1] = src.NewCloudlet.Tags[k1]
				changed++
			}
		} else if m.NewCloudlet.Tags != nil {
			m.NewCloudlet.Tags = nil
			changed++
		}
	} else if m.NewCloudlet != nil {
		m.NewCloudlet = nil
		changed++
	}
	if m.ErrorMsg != src.ErrorMsg {
		m.ErrorMsg = src.ErrorMsg
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *ServerEdgeEvent) DeepCopyIn(src *ServerEdgeEvent) {
	m.EventType = src.EventType
	m.CloudletState = src.CloudletState
	m.MaintenanceState = src.MaintenanceState
	m.HealthCheck = src.HealthCheck
	if src.Statistics != nil {
		var tmp_Statistics Statistics
		tmp_Statistics.DeepCopyIn(src.Statistics)
		m.Statistics = &tmp_Statistics
	} else {
		m.Statistics = nil
	}
	if src.NewCloudlet != nil {
		var tmp_NewCloudlet FindCloudletReply
		tmp_NewCloudlet.DeepCopyIn(src.NewCloudlet)
		m.NewCloudlet = &tmp_NewCloudlet
	} else {
		m.NewCloudlet = nil
	}
	m.ErrorMsg = src.ErrorMsg
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *ServerEdgeEvent) ValidateEnums() error {
	if _, ok := ServerEdgeEvent_ServerEventType_name[int32(m.EventType)]; !ok {
		return errors.New("invalid EventType")
	}
	if _, ok := CloudletState_name[int32(m.CloudletState)]; !ok {
		return errors.New("invalid CloudletState")
	}
	if _, ok := MaintenanceState_name[int32(m.MaintenanceState)]; !ok {
		return errors.New("invalid MaintenanceState")
	}
	if _, ok := HealthCheck_name[int32(m.HealthCheck)]; !ok {
		return errors.New("invalid HealthCheck")
	}
	if m.Statistics != nil {
		if err := m.Statistics.ValidateEnums(); err != nil {
			return err
		}
	}
	if m.NewCloudlet != nil {
		if err := m.NewCloudlet.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *ServerEdgeEvent) ClearTagged(tags map[string]struct{}) {
	if s.Statistics != nil {
		s.Statistics.ClearTagged(tags)
	}
	if s.NewCloudlet != nil {
		s.NewCloudlet.ClearTagged(tags)
	}
}

var IDTypesStrings = []string{
	"ID_UNDEFINED",
	"IMEI",
	"MSISDN",
	"IPADDR",
}

const (
	IDTypesID_UNDEFINED uint64 = 1 << 0
	IDTypesIMEI         uint64 = 1 << 1
	IDTypesMSISDN       uint64 = 1 << 2
	IDTypesIPADDR       uint64 = 1 << 3
)

var IDTypes_CamelName = map[int32]string{
	// ID_UNDEFINED -> IdUndefined
	0: "IdUndefined",
	// IMEI -> Imei
	1: "Imei",
	// MSISDN -> Msisdn
	2: "Msisdn",
	// IPADDR -> Ipaddr
	3: "Ipaddr",
}
var IDTypes_CamelValue = map[string]int32{
	"IdUndefined": 0,
	"Imei":        1,
	"Msisdn":      2,
	"Ipaddr":      3,
}

func ParseIDTypes(data interface{}) (IDTypes, error) {
	if val, ok := data.(IDTypes); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := IDTypes_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = IDTypes_CamelName[val]
			}
		}
		if !ok {
			return IDTypes(0), fmt.Errorf("Invalid IDTypes value %q", str)
		}
		return IDTypes(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := IDTypes_CamelName[ival]; ok {
			return IDTypes(ival), nil
		} else {
			return IDTypes(0), fmt.Errorf("Invalid IDTypes value %d", ival)
		}
	}
	return IDTypes(0), fmt.Errorf("Invalid IDTypes value %v", data)
}

func (e *IDTypes) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseIDTypes(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e IDTypes) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(IDTypes_CamelName, int32(e))
	return str, nil
}

// custom JSON encoding/decoding
func (e *IDTypes) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseIDTypes(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(IDTypes(0)),
			}
		}
		*e = IDTypes(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseIDTypes(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(IDTypes(0)),
	}
}

func (e IDTypes) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(IDTypes_CamelName, int32(e))
	return json.Marshal(str)
}

var ReplyStatusStrings = []string{
	"RS_UNDEFINED",
	"RS_SUCCESS",
	"RS_FAIL",
}

const (
	ReplyStatusRS_UNDEFINED uint64 = 1 << 0
	ReplyStatusRS_SUCCESS   uint64 = 1 << 1
	ReplyStatusRS_FAIL      uint64 = 1 << 2
)

var ReplyStatus_CamelName = map[int32]string{
	// RS_UNDEFINED -> RsUndefined
	0: "RsUndefined",
	// RS_SUCCESS -> RsSuccess
	1: "RsSuccess",
	// RS_FAIL -> RsFail
	2: "RsFail",
}
var ReplyStatus_CamelValue = map[string]int32{
	"RsUndefined": 0,
	"RsSuccess":   1,
	"RsFail":      2,
}

func ParseReplyStatus(data interface{}) (ReplyStatus, error) {
	if val, ok := data.(ReplyStatus); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := ReplyStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = ReplyStatus_CamelValue["Rs"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = ReplyStatus_CamelName[val]
			}
		}
		if !ok {
			return ReplyStatus(0), fmt.Errorf("Invalid ReplyStatus value %q", str)
		}
		return ReplyStatus(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := ReplyStatus_CamelName[ival]; ok {
			return ReplyStatus(ival), nil
		} else {
			return ReplyStatus(0), fmt.Errorf("Invalid ReplyStatus value %d", ival)
		}
	}
	return ReplyStatus(0), fmt.Errorf("Invalid ReplyStatus value %v", data)
}

func (e *ReplyStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseReplyStatus(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e ReplyStatus) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(ReplyStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Rs")
	return str, nil
}

// custom JSON encoding/decoding
func (e *ReplyStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseReplyStatus(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(ReplyStatus(0)),
			}
		}
		*e = ReplyStatus(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseReplyStatus(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(ReplyStatus(0)),
	}
}

func (e ReplyStatus) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(ReplyStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Rs")
	return json.Marshal(str)
}

var ReplyStatusCommonPrefix = "Rs"

var QosSessionProfileStrings = []string{
	"QOS_NO_PRIORITY",
	"QOS_LOW_LATENCY",
	"QOS_THROUGHPUT_DOWN_S",
	"QOS_THROUGHPUT_DOWN_M",
	"QOS_THROUGHPUT_DOWN_L",
}

const (
	QosSessionProfileQOS_NO_PRIORITY       uint64 = 1 << 0
	QosSessionProfileQOS_LOW_LATENCY       uint64 = 1 << 1
	QosSessionProfileQOS_THROUGHPUT_DOWN_S uint64 = 1 << 2
	QosSessionProfileQOS_THROUGHPUT_DOWN_M uint64 = 1 << 3
	QosSessionProfileQOS_THROUGHPUT_DOWN_L uint64 = 1 << 4
)

var QosSessionProfile_CamelName = map[int32]string{
	// QOS_NO_PRIORITY -> QosNoPriority
	0: "QosNoPriority",
	// QOS_LOW_LATENCY -> QosLowLatency
	1: "QosLowLatency",
	// QOS_THROUGHPUT_DOWN_S -> QosThroughputDownS
	2: "QosThroughputDownS",
	// QOS_THROUGHPUT_DOWN_M -> QosThroughputDownM
	3: "QosThroughputDownM",
	// QOS_THROUGHPUT_DOWN_L -> QosThroughputDownL
	4: "QosThroughputDownL",
}
var QosSessionProfile_CamelValue = map[string]int32{
	"QosNoPriority":      0,
	"QosLowLatency":      1,
	"QosThroughputDownS": 2,
	"QosThroughputDownM": 3,
	"QosThroughputDownL": 4,
}

func ParseQosSessionProfile(data interface{}) (QosSessionProfile, error) {
	if val, ok := data.(QosSessionProfile); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := QosSessionProfile_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = QosSessionProfile_CamelValue["Qos"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = QosSessionProfile_CamelName[val]
			}
		}
		if !ok {
			return QosSessionProfile(0), fmt.Errorf("Invalid QosSessionProfile value %q", str)
		}
		return QosSessionProfile(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := QosSessionProfile_CamelName[ival]; ok {
			return QosSessionProfile(ival), nil
		} else {
			return QosSessionProfile(0), fmt.Errorf("Invalid QosSessionProfile value %d", ival)
		}
	}
	return QosSessionProfile(0), fmt.Errorf("Invalid QosSessionProfile value %v", data)
}

func (e *QosSessionProfile) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseQosSessionProfile(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e QosSessionProfile) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(QosSessionProfile_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Qos")
	return str, nil
}

// custom JSON encoding/decoding
func (e *QosSessionProfile) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseQosSessionProfile(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(QosSessionProfile(0)),
			}
		}
		*e = QosSessionProfile(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseQosSessionProfile(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(QosSessionProfile(0)),
	}
}

func (e QosSessionProfile) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(QosSessionProfile_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Qos")
	return json.Marshal(str)
}

var QosSessionProfileCommonPrefix = "Qos"

var QosSessionProtocolStrings = []string{
	"TCP",
	"UDP",
	"ANY",
}

const (
	QosSessionProtocolTCP uint64 = 1 << 0
	QosSessionProtocolUDP uint64 = 1 << 1
	QosSessionProtocolANY uint64 = 1 << 2
)

var QosSessionProtocol_CamelName = map[int32]string{
	// TCP -> Tcp
	0: "Tcp",
	// UDP -> Udp
	1: "Udp",
	// ANY -> Any
	2: "Any",
}
var QosSessionProtocol_CamelValue = map[string]int32{
	"Tcp": 0,
	"Udp": 1,
	"Any": 2,
}

func ParseQosSessionProtocol(data interface{}) (QosSessionProtocol, error) {
	if val, ok := data.(QosSessionProtocol); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := QosSessionProtocol_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = QosSessionProtocol_CamelName[val]
			}
		}
		if !ok {
			return QosSessionProtocol(0), fmt.Errorf("Invalid QosSessionProtocol value %q", str)
		}
		return QosSessionProtocol(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := QosSessionProtocol_CamelName[ival]; ok {
			return QosSessionProtocol(ival), nil
		} else {
			return QosSessionProtocol(0), fmt.Errorf("Invalid QosSessionProtocol value %d", ival)
		}
	}
	return QosSessionProtocol(0), fmt.Errorf("Invalid QosSessionProtocol value %v", data)
}

func (e *QosSessionProtocol) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseQosSessionProtocol(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e QosSessionProtocol) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(QosSessionProtocol_CamelName, int32(e))
	return str, nil
}

// custom JSON encoding/decoding
func (e *QosSessionProtocol) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseQosSessionProtocol(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(QosSessionProtocol(0)),
			}
		}
		*e = QosSessionProtocol(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseQosSessionProtocol(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(QosSessionProtocol(0)),
	}
}

func (e QosSessionProtocol) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(QosSessionProtocol_CamelName, int32(e))
	return json.Marshal(str)
}

var FindStatusStrings = []string{
	"FIND_UNKNOWN",
	"FIND_FOUND",
	"FIND_NOTFOUND",
}

const (
	FindStatusFIND_UNKNOWN  uint64 = 1 << 0
	FindStatusFIND_FOUND    uint64 = 1 << 1
	FindStatusFIND_NOTFOUND uint64 = 1 << 2
)

var FindCloudletReply_FindStatus_CamelName = map[int32]string{
	// FIND_UNKNOWN -> FindUnknown
	0: "FindUnknown",
	// FIND_FOUND -> FindFound
	1: "FindFound",
	// FIND_NOTFOUND -> FindNotfound
	2: "FindNotfound",
}
var FindCloudletReply_FindStatus_CamelValue = map[string]int32{
	"FindUnknown":  0,
	"FindFound":    1,
	"FindNotfound": 2,
}

func ParseFindCloudletReply_FindStatus(data interface{}) (FindCloudletReply_FindStatus, error) {
	if val, ok := data.(FindCloudletReply_FindStatus); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := FindCloudletReply_FindStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = FindCloudletReply_FindStatus_CamelValue["Find"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = FindCloudletReply_FindStatus_CamelName[val]
			}
		}
		if !ok {
			return FindCloudletReply_FindStatus(0), fmt.Errorf("Invalid FindCloudletReply_FindStatus value %q", str)
		}
		return FindCloudletReply_FindStatus(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := FindCloudletReply_FindStatus_CamelName[ival]; ok {
			return FindCloudletReply_FindStatus(ival), nil
		} else {
			return FindCloudletReply_FindStatus(0), fmt.Errorf("Invalid FindCloudletReply_FindStatus value %d", ival)
		}
	}
	return FindCloudletReply_FindStatus(0), fmt.Errorf("Invalid FindCloudletReply_FindStatus value %v", data)
}

func (e *FindCloudletReply_FindStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseFindCloudletReply_FindStatus(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e FindCloudletReply_FindStatus) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(FindCloudletReply_FindStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Find")
	return str, nil
}

// custom JSON encoding/decoding
func (e *FindCloudletReply_FindStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseFindCloudletReply_FindStatus(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(FindCloudletReply_FindStatus(0)),
			}
		}
		*e = FindCloudletReply_FindStatus(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseFindCloudletReply_FindStatus(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(FindCloudletReply_FindStatus(0)),
	}
}

func (e FindCloudletReply_FindStatus) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(FindCloudletReply_FindStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Find")
	return json.Marshal(str)
}

var FindStatusCommonPrefix = "Find"

var QosSessionResultStrings = []string{
	"QOS_NOT_ATTEMPTED",
	"QOS_SESSION_CREATED",
	"QOS_SESSION_FAILED",
}

const (
	QosSessionResultQOS_NOT_ATTEMPTED   uint64 = 1 << 0
	QosSessionResultQOS_SESSION_CREATED uint64 = 1 << 1
	QosSessionResultQOS_SESSION_FAILED  uint64 = 1 << 2
)

var FindCloudletReply_QosSessionResult_CamelName = map[int32]string{
	// QOS_NOT_ATTEMPTED -> QosNotAttempted
	0: "QosNotAttempted",
	// QOS_SESSION_CREATED -> QosSessionCreated
	1: "QosSessionCreated",
	// QOS_SESSION_FAILED -> QosSessionFailed
	2: "QosSessionFailed",
}
var FindCloudletReply_QosSessionResult_CamelValue = map[string]int32{
	"QosNotAttempted":   0,
	"QosSessionCreated": 1,
	"QosSessionFailed":  2,
}

func ParseFindCloudletReply_QosSessionResult(data interface{}) (FindCloudletReply_QosSessionResult, error) {
	if val, ok := data.(FindCloudletReply_QosSessionResult); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := FindCloudletReply_QosSessionResult_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = FindCloudletReply_QosSessionResult_CamelValue["Qos"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = FindCloudletReply_QosSessionResult_CamelName[val]
			}
		}
		if !ok {
			return FindCloudletReply_QosSessionResult(0), fmt.Errorf("Invalid FindCloudletReply_QosSessionResult value %q", str)
		}
		return FindCloudletReply_QosSessionResult(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := FindCloudletReply_QosSessionResult_CamelName[ival]; ok {
			return FindCloudletReply_QosSessionResult(ival), nil
		} else {
			return FindCloudletReply_QosSessionResult(0), fmt.Errorf("Invalid FindCloudletReply_QosSessionResult value %d", ival)
		}
	}
	return FindCloudletReply_QosSessionResult(0), fmt.Errorf("Invalid FindCloudletReply_QosSessionResult value %v", data)
}

func (e *FindCloudletReply_QosSessionResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseFindCloudletReply_QosSessionResult(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e FindCloudletReply_QosSessionResult) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(FindCloudletReply_QosSessionResult_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Qos")
	return str, nil
}

// custom JSON encoding/decoding
func (e *FindCloudletReply_QosSessionResult) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseFindCloudletReply_QosSessionResult(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(FindCloudletReply_QosSessionResult(0)),
			}
		}
		*e = FindCloudletReply_QosSessionResult(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseFindCloudletReply_QosSessionResult(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(FindCloudletReply_QosSessionResult(0)),
	}
}

func (e FindCloudletReply_QosSessionResult) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(FindCloudletReply_QosSessionResult_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Qos")
	return json.Marshal(str)
}

var QosSessionResultCommonPrefix = "Qos"

var DeleteStatusStrings = []string{
	"QDEL_UNKNOWN",
	"QDEL_DELETED",
	"QDEL_NOT_FOUND",
}

const (
	DeleteStatusQDEL_UNKNOWN   uint64 = 1 << 0
	DeleteStatusQDEL_DELETED   uint64 = 1 << 1
	DeleteStatusQDEL_NOT_FOUND uint64 = 1 << 2
)

var QosPrioritySessionDeleteReply_DeleteStatus_CamelName = map[int32]string{
	// QDEL_UNKNOWN -> QdelUnknown
	0: "QdelUnknown",
	// QDEL_DELETED -> QdelDeleted
	1: "QdelDeleted",
	// QDEL_NOT_FOUND -> QdelNotFound
	2: "QdelNotFound",
}
var QosPrioritySessionDeleteReply_DeleteStatus_CamelValue = map[string]int32{
	"QdelUnknown":  0,
	"QdelDeleted":  1,
	"QdelNotFound": 2,
}

func ParseQosPrioritySessionDeleteReply_DeleteStatus(data interface{}) (QosPrioritySessionDeleteReply_DeleteStatus, error) {
	if val, ok := data.(QosPrioritySessionDeleteReply_DeleteStatus); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := QosPrioritySessionDeleteReply_DeleteStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = QosPrioritySessionDeleteReply_DeleteStatus_CamelValue["Qdel"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = QosPrioritySessionDeleteReply_DeleteStatus_CamelName[val]
			}
		}
		if !ok {
			return QosPrioritySessionDeleteReply_DeleteStatus(0), fmt.Errorf("Invalid QosPrioritySessionDeleteReply_DeleteStatus value %q", str)
		}
		return QosPrioritySessionDeleteReply_DeleteStatus(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := QosPrioritySessionDeleteReply_DeleteStatus_CamelName[ival]; ok {
			return QosPrioritySessionDeleteReply_DeleteStatus(ival), nil
		} else {
			return QosPrioritySessionDeleteReply_DeleteStatus(0), fmt.Errorf("Invalid QosPrioritySessionDeleteReply_DeleteStatus value %d", ival)
		}
	}
	return QosPrioritySessionDeleteReply_DeleteStatus(0), fmt.Errorf("Invalid QosPrioritySessionDeleteReply_DeleteStatus value %v", data)
}

func (e *QosPrioritySessionDeleteReply_DeleteStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseQosPrioritySessionDeleteReply_DeleteStatus(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e QosPrioritySessionDeleteReply_DeleteStatus) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(QosPrioritySessionDeleteReply_DeleteStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Qdel")
	return str, nil
}

// custom JSON encoding/decoding
func (e *QosPrioritySessionDeleteReply_DeleteStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseQosPrioritySessionDeleteReply_DeleteStatus(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(QosPrioritySessionDeleteReply_DeleteStatus(0)),
			}
		}
		*e = QosPrioritySessionDeleteReply_DeleteStatus(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseQosPrioritySessionDeleteReply_DeleteStatus(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(QosPrioritySessionDeleteReply_DeleteStatus(0)),
	}
}

func (e QosPrioritySessionDeleteReply_DeleteStatus) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(QosPrioritySessionDeleteReply_DeleteStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Qdel")
	return json.Marshal(str)
}

var DeleteStatusCommonPrefix = "Qdel"

var TowerStatusStrings = []string{
	"TOWER_UNKNOWN",
	"CONNECTED_TO_SPECIFIED_TOWER",
	"NOT_CONNECTED_TO_SPECIFIED_TOWER",
}

const (
	TowerStatusTOWER_UNKNOWN                    uint64 = 1 << 0
	TowerStatusCONNECTED_TO_SPECIFIED_TOWER     uint64 = 1 << 1
	TowerStatusNOT_CONNECTED_TO_SPECIFIED_TOWER uint64 = 1 << 2
)

var VerifyLocationReply_TowerStatus_CamelName = map[int32]string{
	// TOWER_UNKNOWN -> TowerUnknown
	0: "TowerUnknown",
	// CONNECTED_TO_SPECIFIED_TOWER -> ConnectedToSpecifiedTower
	1: "ConnectedToSpecifiedTower",
	// NOT_CONNECTED_TO_SPECIFIED_TOWER -> NotConnectedToSpecifiedTower
	2: "NotConnectedToSpecifiedTower",
}
var VerifyLocationReply_TowerStatus_CamelValue = map[string]int32{
	"TowerUnknown":                 0,
	"ConnectedToSpecifiedTower":    1,
	"NotConnectedToSpecifiedTower": 2,
}

func ParseVerifyLocationReply_TowerStatus(data interface{}) (VerifyLocationReply_TowerStatus, error) {
	if val, ok := data.(VerifyLocationReply_TowerStatus); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := VerifyLocationReply_TowerStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = VerifyLocationReply_TowerStatus_CamelName[val]
			}
		}
		if !ok {
			return VerifyLocationReply_TowerStatus(0), fmt.Errorf("Invalid VerifyLocationReply_TowerStatus value %q", str)
		}
		return VerifyLocationReply_TowerStatus(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := VerifyLocationReply_TowerStatus_CamelName[ival]; ok {
			return VerifyLocationReply_TowerStatus(ival), nil
		} else {
			return VerifyLocationReply_TowerStatus(0), fmt.Errorf("Invalid VerifyLocationReply_TowerStatus value %d", ival)
		}
	}
	return VerifyLocationReply_TowerStatus(0), fmt.Errorf("Invalid VerifyLocationReply_TowerStatus value %v", data)
}

func (e *VerifyLocationReply_TowerStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseVerifyLocationReply_TowerStatus(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e VerifyLocationReply_TowerStatus) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(VerifyLocationReply_TowerStatus_CamelName, int32(e))
	return str, nil
}

// custom JSON encoding/decoding
func (e *VerifyLocationReply_TowerStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseVerifyLocationReply_TowerStatus(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(VerifyLocationReply_TowerStatus(0)),
			}
		}
		*e = VerifyLocationReply_TowerStatus(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseVerifyLocationReply_TowerStatus(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(VerifyLocationReply_TowerStatus(0)),
	}
}

func (e VerifyLocationReply_TowerStatus) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(VerifyLocationReply_TowerStatus_CamelName, int32(e))
	return json.Marshal(str)
}

var GPSLocationStatusStrings = []string{
	"LOC_UNKNOWN",
	"LOC_VERIFIED",
	"LOC_MISMATCH_SAME_COUNTRY",
	"LOC_MISMATCH_OTHER_COUNTRY",
	"LOC_ROAMING_COUNTRY_MATCH",
	"LOC_ROAMING_COUNTRY_MISMATCH",
	"LOC_ERROR_UNAUTHORIZED",
	"LOC_ERROR_OTHER",
}

const (
	GPSLocationStatusLOC_UNKNOWN                  uint64 = 1 << 0
	GPSLocationStatusLOC_VERIFIED                 uint64 = 1 << 1
	GPSLocationStatusLOC_MISMATCH_SAME_COUNTRY    uint64 = 1 << 2
	GPSLocationStatusLOC_MISMATCH_OTHER_COUNTRY   uint64 = 1 << 3
	GPSLocationStatusLOC_ROAMING_COUNTRY_MATCH    uint64 = 1 << 4
	GPSLocationStatusLOC_ROAMING_COUNTRY_MISMATCH uint64 = 1 << 5
	GPSLocationStatusLOC_ERROR_UNAUTHORIZED       uint64 = 1 << 6
	GPSLocationStatusLOC_ERROR_OTHER              uint64 = 1 << 7
)

var VerifyLocationReply_GPSLocationStatus_CamelName = map[int32]string{
	// LOC_UNKNOWN -> LocUnknown
	0: "LocUnknown",
	// LOC_VERIFIED -> LocVerified
	1: "LocVerified",
	// LOC_MISMATCH_SAME_COUNTRY -> LocMismatchSameCountry
	2: "LocMismatchSameCountry",
	// LOC_MISMATCH_OTHER_COUNTRY -> LocMismatchOtherCountry
	3: "LocMismatchOtherCountry",
	// LOC_ROAMING_COUNTRY_MATCH -> LocRoamingCountryMatch
	4: "LocRoamingCountryMatch",
	// LOC_ROAMING_COUNTRY_MISMATCH -> LocRoamingCountryMismatch
	5: "LocRoamingCountryMismatch",
	// LOC_ERROR_UNAUTHORIZED -> LocErrorUnauthorized
	6: "LocErrorUnauthorized",
	// LOC_ERROR_OTHER -> LocErrorOther
	7: "LocErrorOther",
}
var VerifyLocationReply_GPSLocationStatus_CamelValue = map[string]int32{
	"LocUnknown":                0,
	"LocVerified":               1,
	"LocMismatchSameCountry":    2,
	"LocMismatchOtherCountry":   3,
	"LocRoamingCountryMatch":    4,
	"LocRoamingCountryMismatch": 5,
	"LocErrorUnauthorized":      6,
	"LocErrorOther":             7,
}

func ParseVerifyLocationReply_GPSLocationStatus(data interface{}) (VerifyLocationReply_GPSLocationStatus, error) {
	if val, ok := data.(VerifyLocationReply_GPSLocationStatus); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := VerifyLocationReply_GPSLocationStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = VerifyLocationReply_GPSLocationStatus_CamelValue["Loc"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = VerifyLocationReply_GPSLocationStatus_CamelName[val]
			}
		}
		if !ok {
			return VerifyLocationReply_GPSLocationStatus(0), fmt.Errorf("Invalid VerifyLocationReply_GPSLocationStatus value %q", str)
		}
		return VerifyLocationReply_GPSLocationStatus(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := VerifyLocationReply_GPSLocationStatus_CamelName[ival]; ok {
			return VerifyLocationReply_GPSLocationStatus(ival), nil
		} else {
			return VerifyLocationReply_GPSLocationStatus(0), fmt.Errorf("Invalid VerifyLocationReply_GPSLocationStatus value %d", ival)
		}
	}
	return VerifyLocationReply_GPSLocationStatus(0), fmt.Errorf("Invalid VerifyLocationReply_GPSLocationStatus value %v", data)
}

func (e *VerifyLocationReply_GPSLocationStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseVerifyLocationReply_GPSLocationStatus(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e VerifyLocationReply_GPSLocationStatus) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(VerifyLocationReply_GPSLocationStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Loc")
	return str, nil
}

// custom JSON encoding/decoding
func (e *VerifyLocationReply_GPSLocationStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseVerifyLocationReply_GPSLocationStatus(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(VerifyLocationReply_GPSLocationStatus(0)),
			}
		}
		*e = VerifyLocationReply_GPSLocationStatus(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseVerifyLocationReply_GPSLocationStatus(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(VerifyLocationReply_GPSLocationStatus(0)),
	}
}

func (e VerifyLocationReply_GPSLocationStatus) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(VerifyLocationReply_GPSLocationStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Loc")
	return json.Marshal(str)
}

var GPSLocationStatusCommonPrefix = "Loc"

var LocStatusStrings = []string{
	"LOC_UNKNOWN",
	"LOC_FOUND",
	"LOC_DENIED",
}

const (
	LocStatusLOC_UNKNOWN uint64 = 1 << 0
	LocStatusLOC_FOUND   uint64 = 1 << 1
	LocStatusLOC_DENIED  uint64 = 1 << 2
)

var GetLocationReply_LocStatus_CamelName = map[int32]string{
	// LOC_UNKNOWN -> LocUnknown
	0: "LocUnknown",
	// LOC_FOUND -> LocFound
	1: "LocFound",
	// LOC_DENIED -> LocDenied
	2: "LocDenied",
}
var GetLocationReply_LocStatus_CamelValue = map[string]int32{
	"LocUnknown": 0,
	"LocFound":   1,
	"LocDenied":  2,
}

func ParseGetLocationReply_LocStatus(data interface{}) (GetLocationReply_LocStatus, error) {
	if val, ok := data.(GetLocationReply_LocStatus); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := GetLocationReply_LocStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = GetLocationReply_LocStatus_CamelValue["Loc"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = GetLocationReply_LocStatus_CamelName[val]
			}
		}
		if !ok {
			return GetLocationReply_LocStatus(0), fmt.Errorf("Invalid GetLocationReply_LocStatus value %q", str)
		}
		return GetLocationReply_LocStatus(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := GetLocationReply_LocStatus_CamelName[ival]; ok {
			return GetLocationReply_LocStatus(ival), nil
		} else {
			return GetLocationReply_LocStatus(0), fmt.Errorf("Invalid GetLocationReply_LocStatus value %d", ival)
		}
	}
	return GetLocationReply_LocStatus(0), fmt.Errorf("Invalid GetLocationReply_LocStatus value %v", data)
}

func (e *GetLocationReply_LocStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseGetLocationReply_LocStatus(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e GetLocationReply_LocStatus) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(GetLocationReply_LocStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Loc")
	return str, nil
}

// custom JSON encoding/decoding
func (e *GetLocationReply_LocStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseGetLocationReply_LocStatus(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(GetLocationReply_LocStatus(0)),
			}
		}
		*e = GetLocationReply_LocStatus(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseGetLocationReply_LocStatus(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(GetLocationReply_LocStatus(0)),
	}
}

func (e GetLocationReply_LocStatus) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(GetLocationReply_LocStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Loc")
	return json.Marshal(str)
}

var LocStatusCommonPrefix = "Loc"

var AIStatusStrings = []string{
	"AI_UNDEFINED",
	"AI_SUCCESS",
	"AI_FAIL",
}

const (
	AIStatusAI_UNDEFINED uint64 = 1 << 0
	AIStatusAI_SUCCESS   uint64 = 1 << 1
	AIStatusAI_FAIL      uint64 = 1 << 2
)

var AppInstListReply_AIStatus_CamelName = map[int32]string{
	// AI_UNDEFINED -> AiUndefined
	0: "AiUndefined",
	// AI_SUCCESS -> AiSuccess
	1: "AiSuccess",
	// AI_FAIL -> AiFail
	2: "AiFail",
}
var AppInstListReply_AIStatus_CamelValue = map[string]int32{
	"AiUndefined": 0,
	"AiSuccess":   1,
	"AiFail":      2,
}

func ParseAppInstListReply_AIStatus(data interface{}) (AppInstListReply_AIStatus, error) {
	if val, ok := data.(AppInstListReply_AIStatus); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := AppInstListReply_AIStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = AppInstListReply_AIStatus_CamelValue["Ai"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = AppInstListReply_AIStatus_CamelName[val]
			}
		}
		if !ok {
			return AppInstListReply_AIStatus(0), fmt.Errorf("Invalid AppInstListReply_AIStatus value %q", str)
		}
		return AppInstListReply_AIStatus(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := AppInstListReply_AIStatus_CamelName[ival]; ok {
			return AppInstListReply_AIStatus(ival), nil
		} else {
			return AppInstListReply_AIStatus(0), fmt.Errorf("Invalid AppInstListReply_AIStatus value %d", ival)
		}
	}
	return AppInstListReply_AIStatus(0), fmt.Errorf("Invalid AppInstListReply_AIStatus value %v", data)
}

func (e *AppInstListReply_AIStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseAppInstListReply_AIStatus(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e AppInstListReply_AIStatus) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(AppInstListReply_AIStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Ai")
	return str, nil
}

// custom JSON encoding/decoding
func (e *AppInstListReply_AIStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseAppInstListReply_AIStatus(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(AppInstListReply_AIStatus(0)),
			}
		}
		*e = AppInstListReply_AIStatus(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseAppInstListReply_AIStatus(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(AppInstListReply_AIStatus(0)),
	}
}

func (e AppInstListReply_AIStatus) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(AppInstListReply_AIStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Ai")
	return json.Marshal(str)
}

var AIStatusCommonPrefix = "Ai"

var FLStatusStrings = []string{
	"FL_UNDEFINED",
	"FL_SUCCESS",
	"FL_FAIL",
}

const (
	FLStatusFL_UNDEFINED uint64 = 1 << 0
	FLStatusFL_SUCCESS   uint64 = 1 << 1
	FLStatusFL_FAIL      uint64 = 1 << 2
)

var FqdnListReply_FLStatus_CamelName = map[int32]string{
	// FL_UNDEFINED -> FlUndefined
	0: "FlUndefined",
	// FL_SUCCESS -> FlSuccess
	1: "FlSuccess",
	// FL_FAIL -> FlFail
	2: "FlFail",
}
var FqdnListReply_FLStatus_CamelValue = map[string]int32{
	"FlUndefined": 0,
	"FlSuccess":   1,
	"FlFail":      2,
}

func ParseFqdnListReply_FLStatus(data interface{}) (FqdnListReply_FLStatus, error) {
	if val, ok := data.(FqdnListReply_FLStatus); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := FqdnListReply_FLStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = FqdnListReply_FLStatus_CamelValue["Fl"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = FqdnListReply_FLStatus_CamelName[val]
			}
		}
		if !ok {
			return FqdnListReply_FLStatus(0), fmt.Errorf("Invalid FqdnListReply_FLStatus value %q", str)
		}
		return FqdnListReply_FLStatus(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := FqdnListReply_FLStatus_CamelName[ival]; ok {
			return FqdnListReply_FLStatus(ival), nil
		} else {
			return FqdnListReply_FLStatus(0), fmt.Errorf("Invalid FqdnListReply_FLStatus value %d", ival)
		}
	}
	return FqdnListReply_FLStatus(0), fmt.Errorf("Invalid FqdnListReply_FLStatus value %v", data)
}

func (e *FqdnListReply_FLStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseFqdnListReply_FLStatus(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e FqdnListReply_FLStatus) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(FqdnListReply_FLStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Fl")
	return str, nil
}

// custom JSON encoding/decoding
func (e *FqdnListReply_FLStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseFqdnListReply_FLStatus(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(FqdnListReply_FLStatus(0)),
			}
		}
		*e = FqdnListReply_FLStatus(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseFqdnListReply_FLStatus(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(FqdnListReply_FLStatus(0)),
	}
}

func (e FqdnListReply_FLStatus) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(FqdnListReply_FLStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Fl")
	return json.Marshal(str)
}

var FLStatusCommonPrefix = "Fl"

var AOFStatusStrings = []string{
	"AOF_UNDEFINED",
	"AOF_SUCCESS",
	"AOF_FAIL",
}

const (
	AOFStatusAOF_UNDEFINED uint64 = 1 << 0
	AOFStatusAOF_SUCCESS   uint64 = 1 << 1
	AOFStatusAOF_FAIL      uint64 = 1 << 2
)

var AppOfficialFqdnReply_AOFStatus_CamelName = map[int32]string{
	// AOF_UNDEFINED -> AofUndefined
	0: "AofUndefined",
	// AOF_SUCCESS -> AofSuccess
	1: "AofSuccess",
	// AOF_FAIL -> AofFail
	2: "AofFail",
}
var AppOfficialFqdnReply_AOFStatus_CamelValue = map[string]int32{
	"AofUndefined": 0,
	"AofSuccess":   1,
	"AofFail":      2,
}

func ParseAppOfficialFqdnReply_AOFStatus(data interface{}) (AppOfficialFqdnReply_AOFStatus, error) {
	if val, ok := data.(AppOfficialFqdnReply_AOFStatus); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := AppOfficialFqdnReply_AOFStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = AppOfficialFqdnReply_AOFStatus_CamelValue["Aof"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = AppOfficialFqdnReply_AOFStatus_CamelName[val]
			}
		}
		if !ok {
			return AppOfficialFqdnReply_AOFStatus(0), fmt.Errorf("Invalid AppOfficialFqdnReply_AOFStatus value %q", str)
		}
		return AppOfficialFqdnReply_AOFStatus(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := AppOfficialFqdnReply_AOFStatus_CamelName[ival]; ok {
			return AppOfficialFqdnReply_AOFStatus(ival), nil
		} else {
			return AppOfficialFqdnReply_AOFStatus(0), fmt.Errorf("Invalid AppOfficialFqdnReply_AOFStatus value %d", ival)
		}
	}
	return AppOfficialFqdnReply_AOFStatus(0), fmt.Errorf("Invalid AppOfficialFqdnReply_AOFStatus value %v", data)
}

func (e *AppOfficialFqdnReply_AOFStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseAppOfficialFqdnReply_AOFStatus(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e AppOfficialFqdnReply_AOFStatus) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(AppOfficialFqdnReply_AOFStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Aof")
	return str, nil
}

// custom JSON encoding/decoding
func (e *AppOfficialFqdnReply_AOFStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseAppOfficialFqdnReply_AOFStatus(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(AppOfficialFqdnReply_AOFStatus(0)),
			}
		}
		*e = AppOfficialFqdnReply_AOFStatus(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseAppOfficialFqdnReply_AOFStatus(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(AppOfficialFqdnReply_AOFStatus(0)),
	}
}

func (e AppOfficialFqdnReply_AOFStatus) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(AppOfficialFqdnReply_AOFStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Aof")
	return json.Marshal(str)
}

var AOFStatusCommonPrefix = "Aof"

var DlgCommTypeStrings = []string{
	"DLG_UNDEFINED",
	"DLG_SECURE",
	"DLG_OPEN",
}

const (
	DlgCommTypeDLG_UNDEFINED uint64 = 1 << 0
	DlgCommTypeDLG_SECURE    uint64 = 1 << 1
	DlgCommTypeDLG_OPEN      uint64 = 1 << 2
)

var DynamicLocGroupRequest_DlgCommType_CamelName = map[int32]string{
	// DLG_UNDEFINED -> DlgUndefined
	0: "DlgUndefined",
	// DLG_SECURE -> DlgSecure
	1: "DlgSecure",
	// DLG_OPEN -> DlgOpen
	2: "DlgOpen",
}
var DynamicLocGroupRequest_DlgCommType_CamelValue = map[string]int32{
	"DlgUndefined": 0,
	"DlgSecure":    1,
	"DlgOpen":      2,
}

func ParseDynamicLocGroupRequest_DlgCommType(data interface{}) (DynamicLocGroupRequest_DlgCommType, error) {
	if val, ok := data.(DynamicLocGroupRequest_DlgCommType); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := DynamicLocGroupRequest_DlgCommType_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = DynamicLocGroupRequest_DlgCommType_CamelValue["Dlg"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = DynamicLocGroupRequest_DlgCommType_CamelName[val]
			}
		}
		if !ok {
			return DynamicLocGroupRequest_DlgCommType(0), fmt.Errorf("Invalid DynamicLocGroupRequest_DlgCommType value %q", str)
		}
		return DynamicLocGroupRequest_DlgCommType(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := DynamicLocGroupRequest_DlgCommType_CamelName[ival]; ok {
			return DynamicLocGroupRequest_DlgCommType(ival), nil
		} else {
			return DynamicLocGroupRequest_DlgCommType(0), fmt.Errorf("Invalid DynamicLocGroupRequest_DlgCommType value %d", ival)
		}
	}
	return DynamicLocGroupRequest_DlgCommType(0), fmt.Errorf("Invalid DynamicLocGroupRequest_DlgCommType value %v", data)
}

func (e *DynamicLocGroupRequest_DlgCommType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseDynamicLocGroupRequest_DlgCommType(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e DynamicLocGroupRequest_DlgCommType) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(DynamicLocGroupRequest_DlgCommType_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Dlg")
	return str, nil
}

// custom JSON encoding/decoding
func (e *DynamicLocGroupRequest_DlgCommType) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseDynamicLocGroupRequest_DlgCommType(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(DynamicLocGroupRequest_DlgCommType(0)),
			}
		}
		*e = DynamicLocGroupRequest_DlgCommType(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseDynamicLocGroupRequest_DlgCommType(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(DynamicLocGroupRequest_DlgCommType(0)),
	}
}

func (e DynamicLocGroupRequest_DlgCommType) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(DynamicLocGroupRequest_DlgCommType_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Dlg")
	return json.Marshal(str)
}

var DlgCommTypeCommonPrefix = "Dlg"

var ClientEventTypeStrings = []string{
	"EVENT_UNKNOWN",
	"EVENT_INIT_CONNECTION",
	"EVENT_TERMINATE_CONNECTION",
	"EVENT_LATENCY_SAMPLES",
	"EVENT_LOCATION_UPDATE",
	"EVENT_CUSTOM_EVENT",
}

const (
	ClientEventTypeEVENT_UNKNOWN              uint64 = 1 << 0
	ClientEventTypeEVENT_INIT_CONNECTION      uint64 = 1 << 1
	ClientEventTypeEVENT_TERMINATE_CONNECTION uint64 = 1 << 2
	ClientEventTypeEVENT_LATENCY_SAMPLES      uint64 = 1 << 3
	ClientEventTypeEVENT_LOCATION_UPDATE      uint64 = 1 << 4
	ClientEventTypeEVENT_CUSTOM_EVENT         uint64 = 1 << 5
)

var ClientEdgeEvent_ClientEventType_CamelName = map[int32]string{
	// EVENT_UNKNOWN -> EventUnknown
	0: "EventUnknown",
	// EVENT_INIT_CONNECTION -> EventInitConnection
	1: "EventInitConnection",
	// EVENT_TERMINATE_CONNECTION -> EventTerminateConnection
	2: "EventTerminateConnection",
	// EVENT_LATENCY_SAMPLES -> EventLatencySamples
	3: "EventLatencySamples",
	// EVENT_LOCATION_UPDATE -> EventLocationUpdate
	4: "EventLocationUpdate",
	// EVENT_CUSTOM_EVENT -> EventCustomEvent
	5: "EventCustomEvent",
}
var ClientEdgeEvent_ClientEventType_CamelValue = map[string]int32{
	"EventUnknown":             0,
	"EventInitConnection":      1,
	"EventTerminateConnection": 2,
	"EventLatencySamples":      3,
	"EventLocationUpdate":      4,
	"EventCustomEvent":         5,
}

func ParseClientEdgeEvent_ClientEventType(data interface{}) (ClientEdgeEvent_ClientEventType, error) {
	if val, ok := data.(ClientEdgeEvent_ClientEventType); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := ClientEdgeEvent_ClientEventType_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = ClientEdgeEvent_ClientEventType_CamelValue["Event"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = ClientEdgeEvent_ClientEventType_CamelName[val]
			}
		}
		if !ok {
			return ClientEdgeEvent_ClientEventType(0), fmt.Errorf("Invalid ClientEdgeEvent_ClientEventType value %q", str)
		}
		return ClientEdgeEvent_ClientEventType(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := ClientEdgeEvent_ClientEventType_CamelName[ival]; ok {
			return ClientEdgeEvent_ClientEventType(ival), nil
		} else {
			return ClientEdgeEvent_ClientEventType(0), fmt.Errorf("Invalid ClientEdgeEvent_ClientEventType value %d", ival)
		}
	}
	return ClientEdgeEvent_ClientEventType(0), fmt.Errorf("Invalid ClientEdgeEvent_ClientEventType value %v", data)
}

func (e *ClientEdgeEvent_ClientEventType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseClientEdgeEvent_ClientEventType(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e ClientEdgeEvent_ClientEventType) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(ClientEdgeEvent_ClientEventType_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Event")
	return str, nil
}

// custom JSON encoding/decoding
func (e *ClientEdgeEvent_ClientEventType) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseClientEdgeEvent_ClientEventType(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(ClientEdgeEvent_ClientEventType(0)),
			}
		}
		*e = ClientEdgeEvent_ClientEventType(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseClientEdgeEvent_ClientEventType(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(ClientEdgeEvent_ClientEventType(0)),
	}
}

func (e ClientEdgeEvent_ClientEventType) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(ClientEdgeEvent_ClientEventType_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Event")
	return json.Marshal(str)
}

var ClientEventTypeCommonPrefix = "Event"

var ServerEventTypeStrings = []string{
	"EVENT_UNKNOWN",
	"EVENT_INIT_CONNECTION",
	"EVENT_LATENCY_REQUEST",
	"EVENT_LATENCY_PROCESSED",
	"EVENT_CLOUDLET_STATE",
	"EVENT_CLOUDLET_MAINTENANCE",
	"EVENT_APPINST_HEALTH",
	"EVENT_CLOUDLET_UPDATE",
	"EVENT_ERROR",
}

const (
	ServerEventTypeEVENT_UNKNOWN              uint64 = 1 << 0
	ServerEventTypeEVENT_INIT_CONNECTION      uint64 = 1 << 1
	ServerEventTypeEVENT_LATENCY_REQUEST      uint64 = 1 << 2
	ServerEventTypeEVENT_LATENCY_PROCESSED    uint64 = 1 << 3
	ServerEventTypeEVENT_CLOUDLET_STATE       uint64 = 1 << 4
	ServerEventTypeEVENT_CLOUDLET_MAINTENANCE uint64 = 1 << 5
	ServerEventTypeEVENT_APPINST_HEALTH       uint64 = 1 << 6
	ServerEventTypeEVENT_CLOUDLET_UPDATE      uint64 = 1 << 7
	ServerEventTypeEVENT_ERROR                uint64 = 1 << 8
)

var ServerEdgeEvent_ServerEventType_CamelName = map[int32]string{
	// EVENT_UNKNOWN -> EventUnknown
	0: "EventUnknown",
	// EVENT_INIT_CONNECTION -> EventInitConnection
	1: "EventInitConnection",
	// EVENT_LATENCY_REQUEST -> EventLatencyRequest
	2: "EventLatencyRequest",
	// EVENT_LATENCY_PROCESSED -> EventLatencyProcessed
	3: "EventLatencyProcessed",
	// EVENT_CLOUDLET_STATE -> EventCloudletState
	4: "EventCloudletState",
	// EVENT_CLOUDLET_MAINTENANCE -> EventCloudletMaintenance
	5: "EventCloudletMaintenance",
	// EVENT_APPINST_HEALTH -> EventAppinstHealth
	6: "EventAppinstHealth",
	// EVENT_CLOUDLET_UPDATE -> EventCloudletUpdate
	7: "EventCloudletUpdate",
	// EVENT_ERROR -> EventError
	8: "EventError",
}
var ServerEdgeEvent_ServerEventType_CamelValue = map[string]int32{
	"EventUnknown":             0,
	"EventInitConnection":      1,
	"EventLatencyRequest":      2,
	"EventLatencyProcessed":    3,
	"EventCloudletState":       4,
	"EventCloudletMaintenance": 5,
	"EventAppinstHealth":       6,
	"EventCloudletUpdate":      7,
	"EventError":               8,
}

func ParseServerEdgeEvent_ServerEventType(data interface{}) (ServerEdgeEvent_ServerEventType, error) {
	if val, ok := data.(ServerEdgeEvent_ServerEventType); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := ServerEdgeEvent_ServerEventType_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = ServerEdgeEvent_ServerEventType_CamelValue["Event"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = ServerEdgeEvent_ServerEventType_CamelName[val]
			}
		}
		if !ok {
			return ServerEdgeEvent_ServerEventType(0), fmt.Errorf("Invalid ServerEdgeEvent_ServerEventType value %q", str)
		}
		return ServerEdgeEvent_ServerEventType(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := ServerEdgeEvent_ServerEventType_CamelName[ival]; ok {
			return ServerEdgeEvent_ServerEventType(ival), nil
		} else {
			return ServerEdgeEvent_ServerEventType(0), fmt.Errorf("Invalid ServerEdgeEvent_ServerEventType value %d", ival)
		}
	}
	return ServerEdgeEvent_ServerEventType(0), fmt.Errorf("Invalid ServerEdgeEvent_ServerEventType value %v", data)
}

func (e *ServerEdgeEvent_ServerEventType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseServerEdgeEvent_ServerEventType(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e ServerEdgeEvent_ServerEventType) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(ServerEdgeEvent_ServerEventType_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Event")
	return str, nil
}

// custom JSON encoding/decoding
func (e *ServerEdgeEvent_ServerEventType) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseServerEdgeEvent_ServerEventType(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(ServerEdgeEvent_ServerEventType(0)),
			}
		}
		*e = ServerEdgeEvent_ServerEventType(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseServerEdgeEvent_ServerEventType(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(ServerEdgeEvent_ServerEventType(0)),
	}
}

func (e ServerEdgeEvent_ServerEventType) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(ServerEdgeEvent_ServerEventType_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Event")
	return json.Marshal(str)
}

var ServerEventTypeCommonPrefix = "Event"

func (m *RegisterClientRequest) IsValidArgsForRegisterClient() error {
	return nil
}

func (m *FindCloudletRequest) IsValidArgsForFindCloudlet() error {
	return nil
}

func (m *PlatformFindCloudletRequest) IsValidArgsForPlatformFindCloudlet() error {
	return nil
}

func (m *QosPrioritySessionCreateRequest) IsValidArgsForQosPrioritySessionCreate() error {
	return nil
}

func (m *QosPrioritySessionDeleteRequest) IsValidArgsForQosPrioritySessionDelete() error {
	return nil
}

func (m *VerifyLocationRequest) IsValidArgsForVerifyLocation() error {
	return nil
}

func (m *GetLocationRequest) IsValidArgsForGetLocation() error {
	return nil
}

func (m *DynamicLocGroupRequest) IsValidArgsForAddUserToGroup() error {
	return nil
}

func (m *AppInstListRequest) IsValidArgsForGetAppInstList() error {
	return nil
}

func (m *FqdnListRequest) IsValidArgsForGetFqdnList() error {
	return nil
}

func (m *AppOfficialFqdnRequest) IsValidArgsForGetAppOfficialFqdn() error {
	return nil
}

func (m *QosPositionRequest) IsValidArgsForGetQosPositionKpi() error {
	return nil
}

func (m *ClientEdgeEvent) IsValidArgsForStreamEdgeEvent() error {
	return nil
}

type MatchOptions struct {
	// Filter will ignore 0 or nil fields on the passed in object
	Filter bool
	// IgnoreBackend will ignore fields that were marked backend in .proto
	IgnoreBackend bool
	// Sort repeated (arrays) of Key objects so matching does not
	// fail due to order.
	SortArrayedKeys bool
}

type MatchOpt func(*MatchOptions)

func MatchFilter() MatchOpt {
	return func(opts *MatchOptions) {
		opts.Filter = true
	}
}

func MatchIgnoreBackend() MatchOpt {
	return func(opts *MatchOptions) {
		opts.IgnoreBackend = true
	}
}

func MatchSortArrayedKeys() MatchOpt {
	return func(opts *MatchOptions) {
		opts.SortArrayedKeys = true
	}
}

func applyMatchOptions(opts *MatchOptions, args ...MatchOpt) {
	for _, f := range args {
		f(opts)
	}
}

// DecodeHook for use with the mapstructure package.
// Allows decoding to handle protobuf enums that are
// represented as strings.
func EnumDecodeHook(from, to reflect.Type, data interface{}) (interface{}, error) {
	switch to {
	case reflect.TypeOf(LProto(0)):
		return ParseLProto(data)
	case reflect.TypeOf(HealthCheck(0)):
		return ParseHealthCheck(data)
	case reflect.TypeOf(CloudletState(0)):
		return ParseCloudletState(data)
	case reflect.TypeOf(MaintenanceState(0)):
		return ParseMaintenanceState(data)
	case reflect.TypeOf(IDTypes(0)):
		return ParseIDTypes(data)
	case reflect.TypeOf(ReplyStatus(0)):
		return ParseReplyStatus(data)
	case reflect.TypeOf(QosSessionProfile(0)):
		return ParseQosSessionProfile(data)
	case reflect.TypeOf(QosSessionProtocol(0)):
		return ParseQosSessionProtocol(data)
	}
	return data, nil
}

// GetEnumParseHelp gets end-user specific messages for
// enum parse errors.
// It returns the enum type name, a help message with
// valid values, and a bool that indicates if a type was matched.
func GetEnumParseHelp(t reflect.Type) (string, string, bool) {
	switch t {
	case reflect.TypeOf(LProto(0)):
		return "LProto", ", valid values are one of Unknown, Tcp, Udp, or 0, 1, 2", true
	case reflect.TypeOf(HealthCheck(0)):
		return "HealthCheck", ", valid values are one of Unknown, RootlbOffline, ServerFail, Ok, CloudletOffline, or 0, 1, 2, 3, 4", true
	case reflect.TypeOf(CloudletState(0)):
		return "CloudletState", ", valid values are one of Unknown, Errors, Ready, Offline, NotPresent, Init, Upgrade, NeedSync, or 0, 1, 2, 3, 4, 5, 6, 7", true
	case reflect.TypeOf(MaintenanceState(0)):
		return "MaintenanceState", ", valid values are one of NormalOperation, MaintenanceStart, FailoverRequested, FailoverDone, FailoverError, MaintenanceStartNoFailover, CrmRequested, CrmUnderMaintenance, CrmError, NormalOperationInit, UnderMaintenance, or 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 31", true
	case reflect.TypeOf(IDTypes(0)):
		return "IDTypes", ", valid values are one of IdUndefined, Imei, Msisdn, Ipaddr, or 0, 1, 2, 3", true
	case reflect.TypeOf(ReplyStatus(0)):
		return "ReplyStatus", ", valid values are one of Undefined, Success, Fail, or 0, 1, 2", true
	case reflect.TypeOf(QosSessionProfile(0)):
		return "QosSessionProfile", ", valid values are one of NoPriority, LowLatency, ThroughputDownS, ThroughputDownM, ThroughputDownL, or 0, 1, 2, 3, 4", true
	case reflect.TypeOf(QosSessionProtocol(0)):
		return "QosSessionProtocol", ", valid values are one of Tcp, Udp, Any, or 0, 1, 2", true
	}
	return "", "", false
}

var ShowMethodNames = map[string]struct{}{}

func IsShow(cmd string) bool {
	_, found := ShowMethodNames[cmd]
	return found
}

func (m *RegisterClientRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.OrgName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppVers)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AuthToken)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.UniqueIdType)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.UniqueId)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RegisterClientReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.TokenServerUri)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.UniqueIdType)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.UniqueId)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FindCloudletRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlatformFindCloudletRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.ClientToken)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FindCloudletReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	l = len(m.Fqdn)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if m.CloudletLocation != nil {
		l = m.CloudletLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.EdgeEventsCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.QosResult != 0 {
		n += 1 + sovAppClient(uint64(m.QosResult))
	}
	l = len(m.QosErrorMsg)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QosPrioritySessionCreateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.SessionDuration != 0 {
		n += 1 + sovAppClient(uint64(m.SessionDuration))
	}
	l = len(m.IpUserEquipment)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.IpApplicationServer)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.PortUserEquipment)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.PortApplicationServer)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.ProtocolIn != 0 {
		n += 1 + sovAppClient(uint64(m.ProtocolIn))
	}
	if m.ProtocolOut != 0 {
		n += 1 + sovAppClient(uint64(m.ProtocolOut))
	}
	if m.Profile != 0 {
		n += 1 + sovAppClient(uint64(m.Profile))
	}
	l = len(m.NotificationUri)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.NotificationAuthToken)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QosPrioritySessionReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.SessionDuration != 0 {
		n += 1 + sovAppClient(uint64(m.SessionDuration))
	}
	if m.Profile != 0 {
		n += 1 + sovAppClient(uint64(m.Profile))
	}
	l = len(m.SessionId)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.StartedAt != 0 {
		n += 1 + sovAppClient(uint64(m.StartedAt))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovAppClient(uint64(m.ExpiresAt))
	}
	if m.HttpStatus != 0 {
		n += 1 + sovAppClient(uint64(m.HttpStatus))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QosPrioritySessionDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Profile != 0 {
		n += 1 + sovAppClient(uint64(m.Profile))
	}
	l = len(m.SessionId)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QosPrioritySessionDeleteReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyLocationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.VerifyLocToken)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyLocationReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.TowerStatus != 0 {
		n += 1 + sovAppClient(uint64(m.TowerStatus))
	}
	if m.GpsLocationStatus != 0 {
		n += 1 + sovAppClient(uint64(m.GpsLocationStatus))
	}
	if m.GpsLocationAccuracyKm != 0 {
		n += 9
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetLocationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetLocationReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Tower != 0 {
		n += 1 + sovAppClient(uint64(m.Tower))
	}
	if m.NetworkLocation != nil {
		l = m.NetworkLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppInstListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovAppClient(uint64(m.Limit))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Appinstance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppVers)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.Fqdn)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	l = len(m.OrgName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.EdgeEventsCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CloudletLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CloudletName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Distance != 0 {
		n += 9
	}
	if len(m.Appinstances) > 0 {
		for _, e := range m.Appinstances {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppInstListReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	if len(m.Cloudlets) > 0 {
		for _, e := range m.Cloudlets {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FqdnListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppFqdn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppVers)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.OrgName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Fqdns) > 0 {
		for _, s := range m.Fqdns {
			l = len(s)
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	l = len(m.AndroidPackageName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FqdnListReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if len(m.AppFqdns) > 0 {
		for _, e := range m.AppFqdns {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppOfficialFqdnRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppOfficialFqdnReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.AppOfficialFqdn)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.ClientToken)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DynamicLocGroupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.LgId != 0 {
		n += 1 + sovAppClient(uint64(m.LgId))
	}
	if m.CommType != 0 {
		n += 1 + sovAppClient(uint64(m.CommType))
	}
	l = len(m.UserData)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DynamicLocGroupReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAppClient(uint64(m.ErrorCode))
	}
	l = len(m.GroupCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QosPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Positionid != 0 {
		n += 1 + sovAppClient(uint64(m.Positionid))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BandSelection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rat_2G) > 0 {
		for _, s := range m.Rat_2G {
			l = len(s)
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if len(m.Rat_3G) > 0 {
		for _, s := range m.Rat_3G {
			l = len(s)
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if len(m.Rat_4G) > 0 {
		for _, s := range m.Rat_4G {
			l = len(s)
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if len(m.Rat_5G) > 0 {
		for _, s := range m.Rat_5G {
			l = len(s)
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QosPositionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Positions) > 0 {
		for _, e := range m.Positions {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if m.LteCategory != 0 {
		n += 1 + sovAppClient(uint64(m.LteCategory))
	}
	if m.BandSelection != nil {
		l = m.BandSelection.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QosPositionKpiResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Positionid != 0 {
		n += 1 + sovAppClient(uint64(m.Positionid))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.DluserthroughputMin != 0 {
		n += 5
	}
	if m.DluserthroughputAvg != 0 {
		n += 5
	}
	if m.DluserthroughputMax != 0 {
		n += 5
	}
	if m.UluserthroughputMin != 0 {
		n += 5
	}
	if m.UluserthroughputAvg != 0 {
		n += 5
	}
	if m.UluserthroughputMax != 0 {
		n += 5
	}
	if m.LatencyMin != 0 {
		n += 5
	}
	if m.LatencyAvg != 0 {
		n += 5
	}
	if m.LatencyMax != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QosPositionKpiReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	if len(m.PositionResults) > 0 {
		for _, e := range m.PositionResults {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientEdgeEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.EdgeEventsCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.EventType != 0 {
		n += 1 + sovAppClient(uint64(m.EventType))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Samples) > 0 {
		for _, e := range m.Samples {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if m.DeviceInfoStatic != nil {
		l = m.DeviceInfoStatic.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.DeviceInfoDynamic != nil {
		l = m.DeviceInfoDynamic.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CustomEvent)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerEdgeEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovAppClient(uint64(m.EventType))
	}
	if m.CloudletState != 0 {
		n += 1 + sovAppClient(uint64(m.CloudletState))
	}
	if m.MaintenanceState != 0 {
		n += 1 + sovAppClient(uint64(m.MaintenanceState))
	}
	if m.HealthCheck != 0 {
		n += 1 + sovAppClient(uint64(m.HealthCheck))
	}
	if m.Statistics != nil {
		l = m.Statistics.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.NewCloudlet != nil {
		l = m.NewCloudlet.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.ErrorMsg)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAppClient(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAppClient(x uint64) (n int) {
	return sovAppClient(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RegisterClientRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterClientRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterClientRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueIdType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueIdType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterClientReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterClientReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterClientReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ReplyStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenServerUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenServerUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueIdType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueIdType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindCloudletRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindCloudletRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindCloudletRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlatformFindCloudletRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlatformFindCloudletRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlatformFindCloudletRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindCloudletReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindCloudletReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindCloudletReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= FindCloudletReply_FindStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fqdn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fqdn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &AppPort{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloudletLocation == nil {
				m.CloudletLocation = &Loc{}
			}
			if err := m.CloudletLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeEventsCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeEventsCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosResult", wireType)
			}
			m.QosResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QosResult |= FindCloudletReply_QosSessionResult(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosErrorMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QosErrorMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPrioritySessionCreateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPrioritySessionCreateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPrioritySessionCreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionDuration", wireType)
			}
			m.SessionDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionDuration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpUserEquipment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpUserEquipment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpApplicationServer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpApplicationServer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortUserEquipment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortUserEquipment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortApplicationServer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortApplicationServer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolIn", wireType)
			}
			m.ProtocolIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolIn |= QosSessionProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolOut", wireType)
			}
			m.ProtocolOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolOut |= QosSessionProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			m.Profile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Profile |= QosSessionProfile(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotificationUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotificationUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotificationAuthToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotificationAuthToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPrioritySessionReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPrioritySessionReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPrioritySessionReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionDuration", wireType)
			}
			m.SessionDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionDuration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			m.Profile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Profile |= QosSessionProfile(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			m.StartedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartedAt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpStatus", wireType)
			}
			m.HttpStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HttpStatus |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPrioritySessionDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPrioritySessionDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPrioritySessionDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			m.Profile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Profile |= QosSessionProfile(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPrioritySessionDeleteReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPrioritySessionDeleteReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPrioritySessionDeleteReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= QosPrioritySessionDeleteReply_DeleteStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyLocationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyLocationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyLocationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyLocToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifyLocToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyLocationReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyLocationReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyLocationReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TowerStatus", wireType)
			}
			m.TowerStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TowerStatus |= VerifyLocationReply_TowerStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocationStatus", wireType)
			}
			m.GpsLocationStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpsLocationStatus |= VerifyLocationReply_GPSLocationStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocationAccuracyKm", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GpsLocationAccuracyKm = float64(math.Float64frombits(v))
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLocationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLocationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLocationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLocationReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLocationReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLocationReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= GetLocationReply_LocStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tower", wireType)
			}
			m.Tower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkLocation == nil {
				m.NetworkLocation = &Loc{}
			}
			if err := m.NetworkLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Appinstance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Appinstance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Appinstance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fqdn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fqdn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &AppPort{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeEventsCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeEventsCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudletName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Distance = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appinstances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Appinstances = append(m.Appinstances, &Appinstance{})
			if err := m.Appinstances[len(m.Appinstances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstListReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstListReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstListReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= AppInstListReply_AIStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cloudlets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cloudlets = append(m.Cloudlets, &CloudletLocation{})
			if err := m.Cloudlets[len(m.Cloudlets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FqdnListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FqdnListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FqdnListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppFqdn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppFqdn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppFqdn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fqdns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fqdns = append(m.Fqdns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AndroidPackageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AndroidPackageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FqdnListReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FqdnListReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FqdnListReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppFqdns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppFqdns = append(m.AppFqdns, &AppFqdn{})
			if err := m.AppFqdns[len(m.AppFqdns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= FqdnListReply_FLStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppOfficialFqdnRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppOfficialFqdnRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppOfficialFqdnRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppOfficialFqdnReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppOfficialFqdnReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppOfficialFqdnReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppOfficialFqdn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppOfficialFqdn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= AppOfficialFqdnReply_AOFStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &AppPort{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicLocGroupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicLocGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicLocGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LgId", wireType)
			}
			m.LgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LgId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommType", wireType)
			}
			m.CommType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommType |= DynamicLocGroupRequest_DlgCommType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicLocGroupReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicLocGroupReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicLocGroupReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ReplyStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positionid", wireType)
			}
			m.Positionid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Positionid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BandSelection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BandSelection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BandSelection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rat_2G", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rat_2G = append(m.Rat_2G, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rat_3G", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rat_3G = append(m.Rat_3G, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rat_4G", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rat_4G = append(m.Rat_4G, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rat_5G", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rat_5G = append(m.Rat_5G, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPositionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPositionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPositionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Positions = append(m.Positions, &QosPosition{})
			if err := m.Positions[len(m.Positions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LteCategory", wireType)
			}
			m.LteCategory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LteCategory |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BandSelection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BandSelection == nil {
				m.BandSelection = &BandSelection{}
			}
			if err := m.BandSelection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPositionKpiResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPositionKpiResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPositionKpiResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positionid", wireType)
			}
			m.Positionid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Positionid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DluserthroughputMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DluserthroughputMin = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DluserthroughputAvg", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DluserthroughputAvg = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DluserthroughputMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DluserthroughputMax = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UluserthroughputMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UluserthroughputMin = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UluserthroughputAvg", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UluserthroughputAvg = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UluserthroughputMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UluserthroughputMax = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LatencyMin = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyAvg", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LatencyAvg = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LatencyMax = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPositionKpiReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPositionKpiReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPositionKpiReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ReplyStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PositionResults = append(m.PositionResults, &QosPositionKpiResult{})
			if err := m.PositionResults[len(m.PositionResults)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientEdgeEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientEdgeEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientEdgeEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeEventsCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeEventsCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= ClientEdgeEvent_ClientEventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Samples", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Samples = append(m.Samples, &Sample{})
			if err := m.Samples[len(m.Samples)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceInfoStatic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceInfoStatic == nil {
				m.DeviceInfoStatic = &DeviceInfoStatic{}
			}
			if err := m.DeviceInfoStatic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceInfoDynamic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceInfoDynamic == nil {
				m.DeviceInfoDynamic = &DeviceInfoDynamic{}
			}
			if err := m.DeviceInfoDynamic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomEvent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomEvent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerEdgeEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerEdgeEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerEdgeEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= ServerEdgeEvent_ServerEventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletState", wireType)
			}
			m.CloudletState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloudletState |= CloudletState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceState", wireType)
			}
			m.MaintenanceState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaintenanceState |= MaintenanceState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheck", wireType)
			}
			m.HealthCheck = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HealthCheck |= HealthCheck(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statistics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Statistics == nil {
				m.Statistics = &Statistics{}
			}
			if err := m.Statistics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewCloudlet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewCloudlet == nil {
				m.NewCloudlet = &FindCloudletReply{}
			}
			if err := m.NewCloudlet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAppClient(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAppClient
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAppClient
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAppClient
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAppClient        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAppClient          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAppClient = fmt.Errorf("proto: unexpected end of group")
)
