// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app-client.proto

/*
	Package distributed_match_engine is a generated protocol buffer package.

	It is generated from these files:
		app-client.proto
		appcommon.proto
		dynamic-location-group.proto
		loc.proto

	It has these top-level messages:
		Match_Engine_Request
		Match_Engine_Reply
		Match_Engine_Loc_Verify
		Match_Engine_Loc
		Match_Engine_Status
		Appinstance
		CloudletLocation
		Match_Engine_AppInst_List
		DynamicLocGroupAdd
		AppPort
		DlgMessage
		DlgReply
		Loc
*/
package distributed_match_engine

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import binary "encoding/binary"

import "errors"
import "strconv"
import google_protobuf "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type IDTypes int32

const (
	IDTypes_ID_UNDEFINED IDTypes = 0
	IDTypes_IMEI         IDTypes = 1
	IDTypes_MSISDN       IDTypes = 2
	IDTypes_IPADDR       IDTypes = 3
)

var IDTypes_name = map[int32]string{
	0: "ID_UNDEFINED",
	1: "IMEI",
	2: "MSISDN",
	3: "IPADDR",
}
var IDTypes_value = map[string]int32{
	"ID_UNDEFINED": 0,
	"IMEI":         1,
	"MSISDN":       2,
	"IPADDR":       3,
}

func (x IDTypes) String() string {
	return proto.EnumName(IDTypes_name, int32(x))
}
func (IDTypes) EnumDescriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{0} }

type Match_Engine_Reply_Find_Status int32

const (
	Match_Engine_Reply_FIND_UNKNOWN  Match_Engine_Reply_Find_Status = 0
	Match_Engine_Reply_FIND_FOUND    Match_Engine_Reply_Find_Status = 1
	Match_Engine_Reply_FIND_NOTFOUND Match_Engine_Reply_Find_Status = 2
)

var Match_Engine_Reply_Find_Status_name = map[int32]string{
	0: "FIND_UNKNOWN",
	1: "FIND_FOUND",
	2: "FIND_NOTFOUND",
}
var Match_Engine_Reply_Find_Status_value = map[string]int32{
	"FIND_UNKNOWN":  0,
	"FIND_FOUND":    1,
	"FIND_NOTFOUND": 2,
}

func (x Match_Engine_Reply_Find_Status) String() string {
	return proto.EnumName(Match_Engine_Reply_Find_Status_name, int32(x))
}
func (Match_Engine_Reply_Find_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{1, 0}
}

// Status of the reply
type Match_Engine_Loc_Verify_Tower_Status int32

const (
	Match_Engine_Loc_Verify_TOWER_UNKNOWN                    Match_Engine_Loc_Verify_Tower_Status = 0
	Match_Engine_Loc_Verify_CONNECTED_TO_SPECIFIED_TOWER     Match_Engine_Loc_Verify_Tower_Status = 1
	Match_Engine_Loc_Verify_NOT_CONNECTED_TO_SPECIFIED_TOWER Match_Engine_Loc_Verify_Tower_Status = 2
)

var Match_Engine_Loc_Verify_Tower_Status_name = map[int32]string{
	0: "TOWER_UNKNOWN",
	1: "CONNECTED_TO_SPECIFIED_TOWER",
	2: "NOT_CONNECTED_TO_SPECIFIED_TOWER",
}
var Match_Engine_Loc_Verify_Tower_Status_value = map[string]int32{
	"TOWER_UNKNOWN":                    0,
	"CONNECTED_TO_SPECIFIED_TOWER":     1,
	"NOT_CONNECTED_TO_SPECIFIED_TOWER": 2,
}

func (x Match_Engine_Loc_Verify_Tower_Status) String() string {
	return proto.EnumName(Match_Engine_Loc_Verify_Tower_Status_name, int32(x))
}
func (Match_Engine_Loc_Verify_Tower_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{2, 0}
}

type Match_Engine_Loc_Verify_GPS_Location_Status int32

const (
	Match_Engine_Loc_Verify_LOC_UNKNOWN                  Match_Engine_Loc_Verify_GPS_Location_Status = 0
	Match_Engine_Loc_Verify_LOC_VERIFIED                 Match_Engine_Loc_Verify_GPS_Location_Status = 1
	Match_Engine_Loc_Verify_LOC_MISMATCH_SAME_COUNTRY    Match_Engine_Loc_Verify_GPS_Location_Status = 2
	Match_Engine_Loc_Verify_LOC_MISMATCH_OTHER_COUNTRY   Match_Engine_Loc_Verify_GPS_Location_Status = 3
	Match_Engine_Loc_Verify_LOC_ROAMING_COUNTRY_MATCH    Match_Engine_Loc_Verify_GPS_Location_Status = 4
	Match_Engine_Loc_Verify_LOC_ROAMING_COUNTRY_MISMATCH Match_Engine_Loc_Verify_GPS_Location_Status = 5
	Match_Engine_Loc_Verify_LOC_ERROR_UNAUTHORIZED       Match_Engine_Loc_Verify_GPS_Location_Status = 6
	Match_Engine_Loc_Verify_LOC_ERROR_OTHER              Match_Engine_Loc_Verify_GPS_Location_Status = 7
)

var Match_Engine_Loc_Verify_GPS_Location_Status_name = map[int32]string{
	0: "LOC_UNKNOWN",
	1: "LOC_VERIFIED",
	2: "LOC_MISMATCH_SAME_COUNTRY",
	3: "LOC_MISMATCH_OTHER_COUNTRY",
	4: "LOC_ROAMING_COUNTRY_MATCH",
	5: "LOC_ROAMING_COUNTRY_MISMATCH",
	6: "LOC_ERROR_UNAUTHORIZED",
	7: "LOC_ERROR_OTHER",
}
var Match_Engine_Loc_Verify_GPS_Location_Status_value = map[string]int32{
	"LOC_UNKNOWN":                  0,
	"LOC_VERIFIED":                 1,
	"LOC_MISMATCH_SAME_COUNTRY":    2,
	"LOC_MISMATCH_OTHER_COUNTRY":   3,
	"LOC_ROAMING_COUNTRY_MATCH":    4,
	"LOC_ROAMING_COUNTRY_MISMATCH": 5,
	"LOC_ERROR_UNAUTHORIZED":       6,
	"LOC_ERROR_OTHER":              7,
}

func (x Match_Engine_Loc_Verify_GPS_Location_Status) String() string {
	return proto.EnumName(Match_Engine_Loc_Verify_GPS_Location_Status_name, int32(x))
}
func (Match_Engine_Loc_Verify_GPS_Location_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{2, 1}
}

// Status of the reply
type Match_Engine_Loc_Loc_Status int32

const (
	Match_Engine_Loc_LOC_UNKNOWN Match_Engine_Loc_Loc_Status = 0
	Match_Engine_Loc_LOC_FOUND   Match_Engine_Loc_Loc_Status = 1
	// The user does not allow his location to be tracked
	Match_Engine_Loc_LOC_DENIED Match_Engine_Loc_Loc_Status = 2
)

var Match_Engine_Loc_Loc_Status_name = map[int32]string{
	0: "LOC_UNKNOWN",
	1: "LOC_FOUND",
	2: "LOC_DENIED",
}
var Match_Engine_Loc_Loc_Status_value = map[string]int32{
	"LOC_UNKNOWN": 0,
	"LOC_FOUND":   1,
	"LOC_DENIED":  2,
}

func (x Match_Engine_Loc_Loc_Status) String() string {
	return proto.EnumName(Match_Engine_Loc_Loc_Status_name, int32(x))
}
func (Match_Engine_Loc_Loc_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{3, 0}
}

// Status of the reply
type Match_Engine_Status_ME_Status int32

const (
	Match_Engine_Status_ME_UNDEFINED Match_Engine_Status_ME_Status = 0
	Match_Engine_Status_ME_SUCCESS   Match_Engine_Status_ME_Status = 1
	Match_Engine_Status_ME_FAIL      Match_Engine_Status_ME_Status = 2
)

var Match_Engine_Status_ME_Status_name = map[int32]string{
	0: "ME_UNDEFINED",
	1: "ME_SUCCESS",
	2: "ME_FAIL",
}
var Match_Engine_Status_ME_Status_value = map[string]int32{
	"ME_UNDEFINED": 0,
	"ME_SUCCESS":   1,
	"ME_FAIL":      2,
}

func (x Match_Engine_Status_ME_Status) String() string {
	return proto.EnumName(Match_Engine_Status_ME_Status_name, int32(x))
}
func (Match_Engine_Status_ME_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{4, 0}
}

// Status of the reply
type Match_Engine_AppInst_List_AI_Status int32

const (
	Match_Engine_AppInst_List_AI_UNDEFINED Match_Engine_AppInst_List_AI_Status = 0
	Match_Engine_AppInst_List_AI_SUCCESS   Match_Engine_AppInst_List_AI_Status = 1
	Match_Engine_AppInst_List_AI_FAIL      Match_Engine_AppInst_List_AI_Status = 2
)

var Match_Engine_AppInst_List_AI_Status_name = map[int32]string{
	0: "AI_UNDEFINED",
	1: "AI_SUCCESS",
	2: "AI_FAIL",
}
var Match_Engine_AppInst_List_AI_Status_value = map[string]int32{
	"AI_UNDEFINED": 0,
	"AI_SUCCESS":   1,
	"AI_FAIL":      2,
}

func (x Match_Engine_AppInst_List_AI_Status) String() string {
	return proto.EnumName(Match_Engine_AppInst_List_AI_Status_name, int32(x))
}
func (Match_Engine_AppInst_List_AI_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{7, 0}
}

// Use Secure communication or Open with the group
type DynamicLocGroupAdd_DlgCommType int32

const (
	DynamicLocGroupAdd_DlgUndefined DynamicLocGroupAdd_DlgCommType = 0
	DynamicLocGroupAdd_DlgSecure    DynamicLocGroupAdd_DlgCommType = 1
	DynamicLocGroupAdd_DlgOpen      DynamicLocGroupAdd_DlgCommType = 2
)

var DynamicLocGroupAdd_DlgCommType_name = map[int32]string{
	0: "DlgUndefined",
	1: "DlgSecure",
	2: "DlgOpen",
}
var DynamicLocGroupAdd_DlgCommType_value = map[string]int32{
	"DlgUndefined": 0,
	"DlgSecure":    1,
	"DlgOpen":      2,
}

func (x DynamicLocGroupAdd_DlgCommType) String() string {
	return proto.EnumName(DynamicLocGroupAdd_DlgCommType_name, int32(x))
}
func (DynamicLocGroupAdd_DlgCommType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{8, 0}
}

type Match_Engine_Request struct {
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// User ID type - IMEI, MSISDN etc
	IdType IDTypes `protobuf:"varint,2,opt,name=IdType,proto3,enum=distributed_match_engine.IDTypes" json:"IdType,omitempty"`
	// Actual ID
	Id string `protobuf:"bytes,3,opt,name=Id,proto3" json:"Id,omitempty"`
	// App/OS generated ID
	Uuid string `protobuf:"bytes,4,opt,name=Uuid,proto3" json:"Uuid,omitempty"`
	// The carrier ID that user is connected to ("Mobile Country Code")
	CarrierID uint64 `protobuf:"varint,5,opt,name=CarrierID,proto3" json:"CarrierID,omitempty"`
	// The carrier name that user is connected to ("Cellular Carrier Name")
	CarrierName string `protobuf:"bytes,6,opt,name=CarrierName,proto3" json:"CarrierName,omitempty"`
	// The tower that user is currently connected to
	Tower uint64 `protobuf:"varint,7,opt,name=Tower,proto3" json:"Tower,omitempty"`
	// The GPS location of the user
	GpsLocation *Loc `protobuf:"bytes,8,opt,name=GpsLocation" json:"GpsLocation,omitempty"`
	// Edge-cloud assigned application ID
	AppId uint64 `protobuf:"varint,9,opt,name=AppId,proto3" json:"AppId,omitempty"`
	// Protocol application uses
	Protocol []byte `protobuf:"bytes,10,opt,name=Protocol,proto3" json:"Protocol,omitempty"`
	// The protocol port on the server side
	ServerPort []byte `protobuf:"bytes,11,opt,name=ServerPort,proto3" json:"ServerPort,omitempty"`
	// App Developer Name
	DevName string `protobuf:"bytes,12,opt,name=DevName,proto3" json:"DevName,omitempty"`
	// App Name
	AppName string `protobuf:"bytes,13,opt,name=AppName,proto3" json:"AppName,omitempty"`
	// App Version
	AppVers string `protobuf:"bytes,14,opt,name=AppVers,proto3" json:"AppVers,omitempty"`
	// DME Session Cookie; Not used for Register
	SessionCookie string `protobuf:"bytes,15,opt,name=SessionCookie,proto3" json:"SessionCookie,omitempty"`
	// token used for location verification
	VerifyLocToken string `protobuf:"bytes,16,opt,name=VerifyLocToken,proto3" json:"VerifyLocToken,omitempty"`
}

func (m *Match_Engine_Request) Reset()                    { *m = Match_Engine_Request{} }
func (m *Match_Engine_Request) String() string            { return proto.CompactTextString(m) }
func (*Match_Engine_Request) ProtoMessage()               {}
func (*Match_Engine_Request) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{0} }

type Match_Engine_Reply struct {
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// domain name
	Uri string `protobuf:"bytes,2,opt,name=uri,proto3" json:"uri,omitempty"`
	// ip of the app service
	ServiceIp []byte `protobuf:"bytes,3,opt,name=service_ip,json=serviceIp,proto3" json:"service_ip,omitempty"`
	// port of the app service?
	ServicePort uint32 `protobuf:"varint,4,opt,name=service_port,json=servicePort,proto3" json:"service_port,omitempty"`
	// location of the cloudlet?
	CloudletLocation *Loc `protobuf:"bytes,5,opt,name=cloudlet_location,json=cloudletLocation" json:"cloudlet_location,omitempty"`
	// list of ports and L7 paths
	Ports []*AppPort `protobuf:"bytes,8,rep,name=ports" json:"ports,omitempty"`
	// Status return
	Status        Match_Engine_Reply_Find_Status `protobuf:"varint,6,opt,name=Status,proto3,enum=distributed_match_engine.Match_Engine_Reply_Find_Status" json:"Status,omitempty"`
	SessionCookie string                         `protobuf:"bytes,7,opt,name=SessionCookie,proto3" json:"SessionCookie,omitempty"`
}

func (m *Match_Engine_Reply) Reset()                    { *m = Match_Engine_Reply{} }
func (m *Match_Engine_Reply) String() string            { return proto.CompactTextString(m) }
func (*Match_Engine_Reply) ProtoMessage()               {}
func (*Match_Engine_Reply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{1} }

type Match_Engine_Loc_Verify struct {
	Ver               uint32                                      `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	TowerStatus       Match_Engine_Loc_Verify_Tower_Status        `protobuf:"varint,2,opt,name=tower_status,json=towerStatus,proto3,enum=distributed_match_engine.Match_Engine_Loc_Verify_Tower_Status" json:"tower_status,omitempty"`
	GpsLocationStatus Match_Engine_Loc_Verify_GPS_Location_Status `protobuf:"varint,3,opt,name=gps_location_status,json=gpsLocationStatus,proto3,enum=distributed_match_engine.Match_Engine_Loc_Verify_GPS_Location_Status" json:"gps_location_status,omitempty"`
	// location accuracy, the location is verified to
	// be within this number of kilometers.  Negative value
	// means no verification was done
	GPS_Location_Accuracy_KM float64 `protobuf:"fixed64,4,opt,name=GPS_Location_Accuracy_KM,json=GPSLocationAccuracyKM,proto3" json:"GPS_Location_Accuracy_KM,omitempty"`
}

func (m *Match_Engine_Loc_Verify) Reset()                    { *m = Match_Engine_Loc_Verify{} }
func (m *Match_Engine_Loc_Verify) String() string            { return proto.CompactTextString(m) }
func (*Match_Engine_Loc_Verify) ProtoMessage()               {}
func (*Match_Engine_Loc_Verify) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{2} }

type Match_Engine_Loc struct {
	Ver    uint32                      `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	Status Match_Engine_Loc_Loc_Status `protobuf:"varint,2,opt,name=Status,proto3,enum=distributed_match_engine.Match_Engine_Loc_Loc_Status" json:"Status,omitempty"`
	// The carrier name that user is connected to ("Cellular Carrier Name")
	CarrierName string `protobuf:"bytes,3,opt,name=CarrierName,proto3" json:"CarrierName,omitempty"`
	// The tower that user is currently connected to
	Tower uint64 `protobuf:"varint,4,opt,name=Tower,proto3" json:"Tower,omitempty"`
	// The GPS location of the user
	NetworkLocation *Loc `protobuf:"bytes,5,opt,name=NetworkLocation" json:"NetworkLocation,omitempty"`
	// DME Session Cookie
	SessionCookie string `protobuf:"bytes,6,opt,name=SessionCookie,proto3" json:"SessionCookie,omitempty"`
}

func (m *Match_Engine_Loc) Reset()                    { *m = Match_Engine_Loc{} }
func (m *Match_Engine_Loc) String() string            { return proto.CompactTextString(m) }
func (*Match_Engine_Loc) ProtoMessage()               {}
func (*Match_Engine_Loc) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{3} }

type Match_Engine_Status struct {
	Ver    uint32                        `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	Status Match_Engine_Status_ME_Status `protobuf:"varint,2,opt,name=Status,proto3,enum=distributed_match_engine.Match_Engine_Status_ME_Status" json:"Status,omitempty"`
	// Error Code based on Failure
	ErrorCode uint32 `protobuf:"varint,3,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	// DME Session Cookie
	SessionCookie string `protobuf:"bytes,4,opt,name=SessionCookie,proto3" json:"SessionCookie,omitempty"`
	// Group Cookie for Secure Group Communication
	GroupCookie string `protobuf:"bytes,5,opt,name=GroupCookie,proto3" json:"GroupCookie,omitempty"`
	// URI for Token Server
	TokenServerURI string `protobuf:"bytes,6,opt,name=TokenServerURI,proto3" json:"TokenServerURI,omitempty"`
}

func (m *Match_Engine_Status) Reset()                    { *m = Match_Engine_Status{} }
func (m *Match_Engine_Status) String() string            { return proto.CompactTextString(m) }
func (*Match_Engine_Status) ProtoMessage()               {}
func (*Match_Engine_Status) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{4} }

type Appinstance struct {
	Appname    string `protobuf:"bytes,1,opt,name=Appname,proto3" json:"Appname,omitempty"`
	Appversion string `protobuf:"bytes,2,opt,name=Appversion,proto3" json:"Appversion,omitempty"`
	Uri        string `protobuf:"bytes,3,opt,name=Uri,proto3" json:"Uri,omitempty"`
}

func (m *Appinstance) Reset()                    { *m = Appinstance{} }
func (m *Appinstance) String() string            { return proto.CompactTextString(m) }
func (*Appinstance) ProtoMessage()               {}
func (*Appinstance) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{5} }

type CloudletLocation struct {
	CarrierName  string `protobuf:"bytes,1,opt,name=CarrierName,proto3" json:"CarrierName,omitempty"`
	CloudletName string `protobuf:"bytes,2,opt,name=CloudletName,proto3" json:"CloudletName,omitempty"`
	GpsLocation  *Loc   `protobuf:"bytes,3,opt,name=GpsLocation" json:"GpsLocation,omitempty"`
	// distance of cloudlet vs loc in request
	Distance     float64        `protobuf:"fixed64,4,opt,name=Distance,proto3" json:"Distance,omitempty"`
	Appinstances []*Appinstance `protobuf:"bytes,5,rep,name=Appinstances" json:"Appinstances,omitempty"`
}

func (m *CloudletLocation) Reset()                    { *m = CloudletLocation{} }
func (m *CloudletLocation) String() string            { return proto.CompactTextString(m) }
func (*CloudletLocation) ProtoMessage()               {}
func (*CloudletLocation) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{6} }

type Match_Engine_AppInst_List struct {
	Ver       uint32                              `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	Status    Match_Engine_AppInst_List_AI_Status `protobuf:"varint,2,opt,name=Status,proto3,enum=distributed_match_engine.Match_Engine_AppInst_List_AI_Status" json:"Status,omitempty"`
	Cloudlets []*CloudletLocation                 `protobuf:"bytes,3,rep,name=Cloudlets" json:"Cloudlets,omitempty"`
}

func (m *Match_Engine_AppInst_List) Reset()         { *m = Match_Engine_AppInst_List{} }
func (m *Match_Engine_AppInst_List) String() string { return proto.CompactTextString(m) }
func (*Match_Engine_AppInst_List) ProtoMessage()    {}
func (*Match_Engine_AppInst_List) Descriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{7}
}

type DynamicLocGroupAdd struct {
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// User ID type - IMEI, MSISDN etc
	IdType IDTypes `protobuf:"varint,2,opt,name=IdType,proto3,enum=distributed_match_engine.IDTypes" json:"IdType,omitempty"`
	// Actual ID
	Id string `protobuf:"bytes,3,opt,name=Id,proto3" json:"Id,omitempty"`
	// App/OS generated ID
	Uuid string `protobuf:"bytes,4,opt,name=Uuid,proto3" json:"Uuid,omitempty"`
	// The carrier ID that user is connected to ("Mobile Country Code")
	CarrierID uint64 `protobuf:"varint,5,opt,name=CarrierID,proto3" json:"CarrierID,omitempty"`
	// The carrier name that user is connected to ("Cellular Carrier Name")
	CarrierName string `protobuf:"bytes,6,opt,name=CarrierName,proto3" json:"CarrierName,omitempty"`
	// The tower that user is currently connected to
	Tower uint64 `protobuf:"varint,7,opt,name=Tower,proto3" json:"Tower,omitempty"`
	// The GPS location of the user
	GpsLocation *Loc `protobuf:"bytes,8,opt,name=GpsLocation" json:"GpsLocation,omitempty"`
	// Dynamic Location Group Id
	LgId uint64 `protobuf:"varint,9,opt,name=LgId,proto3" json:"LgId,omitempty"`
	// DME Session Cookie
	SessionCookie string                         `protobuf:"bytes,10,opt,name=SessionCookie,proto3" json:"SessionCookie,omitempty"`
	CommType      DynamicLocGroupAdd_DlgCommType `protobuf:"varint,11,opt,name=CommType,proto3,enum=distributed_match_engine.DynamicLocGroupAdd_DlgCommType" json:"CommType,omitempty"`
	// Unused
	UserData string `protobuf:"bytes,12,opt,name=UserData,proto3" json:"UserData,omitempty"`
}

func (m *DynamicLocGroupAdd) Reset()                    { *m = DynamicLocGroupAdd{} }
func (m *DynamicLocGroupAdd) String() string            { return proto.CompactTextString(m) }
func (*DynamicLocGroupAdd) ProtoMessage()               {}
func (*DynamicLocGroupAdd) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{8} }

func init() {
	proto.RegisterType((*Match_Engine_Request)(nil), "distributed_match_engine.Match_Engine_Request")
	proto.RegisterType((*Match_Engine_Reply)(nil), "distributed_match_engine.Match_Engine_Reply")
	proto.RegisterType((*Match_Engine_Loc_Verify)(nil), "distributed_match_engine.Match_Engine_Loc_Verify")
	proto.RegisterType((*Match_Engine_Loc)(nil), "distributed_match_engine.Match_Engine_Loc")
	proto.RegisterType((*Match_Engine_Status)(nil), "distributed_match_engine.Match_Engine_Status")
	proto.RegisterType((*Appinstance)(nil), "distributed_match_engine.Appinstance")
	proto.RegisterType((*CloudletLocation)(nil), "distributed_match_engine.CloudletLocation")
	proto.RegisterType((*Match_Engine_AppInst_List)(nil), "distributed_match_engine.Match_Engine_AppInst_List")
	proto.RegisterType((*DynamicLocGroupAdd)(nil), "distributed_match_engine.DynamicLocGroupAdd")
	proto.RegisterEnum("distributed_match_engine.IDTypes", IDTypes_name, IDTypes_value)
	proto.RegisterEnum("distributed_match_engine.Match_Engine_Reply_Find_Status", Match_Engine_Reply_Find_Status_name, Match_Engine_Reply_Find_Status_value)
	proto.RegisterEnum("distributed_match_engine.Match_Engine_Loc_Verify_Tower_Status", Match_Engine_Loc_Verify_Tower_Status_name, Match_Engine_Loc_Verify_Tower_Status_value)
	proto.RegisterEnum("distributed_match_engine.Match_Engine_Loc_Verify_GPS_Location_Status", Match_Engine_Loc_Verify_GPS_Location_Status_name, Match_Engine_Loc_Verify_GPS_Location_Status_value)
	proto.RegisterEnum("distributed_match_engine.Match_Engine_Loc_Loc_Status", Match_Engine_Loc_Loc_Status_name, Match_Engine_Loc_Loc_Status_value)
	proto.RegisterEnum("distributed_match_engine.Match_Engine_Status_ME_Status", Match_Engine_Status_ME_Status_name, Match_Engine_Status_ME_Status_value)
	proto.RegisterEnum("distributed_match_engine.Match_Engine_AppInst_List_AI_Status", Match_Engine_AppInst_List_AI_Status_name, Match_Engine_AppInst_List_AI_Status_value)
	proto.RegisterEnum("distributed_match_engine.DynamicLocGroupAdd_DlgCommType", DynamicLocGroupAdd_DlgCommType_name, DynamicLocGroupAdd_DlgCommType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Match_Engine_Api service

type Match_Engine_ApiClient interface {
	FindCloudlet(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Reply, error)
	VerifyLocation(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Loc_Verify, error)
	GetLocation(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Loc, error)
	RegisterClient(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Status, error)
	AddUserToGroup(ctx context.Context, in *DynamicLocGroupAdd, opts ...grpc.CallOption) (*Match_Engine_Status, error)
	GetAppInstList(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_AppInst_List, error)
}

type match_Engine_ApiClient struct {
	cc *grpc.ClientConn
}

func NewMatch_Engine_ApiClient(cc *grpc.ClientConn) Match_Engine_ApiClient {
	return &match_Engine_ApiClient{cc}
}

func (c *match_Engine_ApiClient) FindCloudlet(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Reply, error) {
	out := new(Match_Engine_Reply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/FindCloudlet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *match_Engine_ApiClient) VerifyLocation(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Loc_Verify, error) {
	out := new(Match_Engine_Loc_Verify)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/VerifyLocation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *match_Engine_ApiClient) GetLocation(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Loc, error) {
	out := new(Match_Engine_Loc)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/GetLocation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *match_Engine_ApiClient) RegisterClient(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Status, error) {
	out := new(Match_Engine_Status)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/RegisterClient", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *match_Engine_ApiClient) AddUserToGroup(ctx context.Context, in *DynamicLocGroupAdd, opts ...grpc.CallOption) (*Match_Engine_Status, error) {
	out := new(Match_Engine_Status)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/AddUserToGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *match_Engine_ApiClient) GetAppInstList(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_AppInst_List, error) {
	out := new(Match_Engine_AppInst_List)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/GetAppInstList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Match_Engine_Api service

type Match_Engine_ApiServer interface {
	FindCloudlet(context.Context, *Match_Engine_Request) (*Match_Engine_Reply, error)
	VerifyLocation(context.Context, *Match_Engine_Request) (*Match_Engine_Loc_Verify, error)
	GetLocation(context.Context, *Match_Engine_Request) (*Match_Engine_Loc, error)
	RegisterClient(context.Context, *Match_Engine_Request) (*Match_Engine_Status, error)
	AddUserToGroup(context.Context, *DynamicLocGroupAdd) (*Match_Engine_Status, error)
	GetAppInstList(context.Context, *Match_Engine_Request) (*Match_Engine_AppInst_List, error)
}

func RegisterMatch_Engine_ApiServer(s *grpc.Server, srv Match_Engine_ApiServer) {
	s.RegisterService(&_Match_Engine_Api_serviceDesc, srv)
}

func _Match_Engine_Api_FindCloudlet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Match_Engine_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).FindCloudlet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/FindCloudlet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).FindCloudlet(ctx, req.(*Match_Engine_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_Engine_Api_VerifyLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Match_Engine_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).VerifyLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/VerifyLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).VerifyLocation(ctx, req.(*Match_Engine_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_Engine_Api_GetLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Match_Engine_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).GetLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/GetLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).GetLocation(ctx, req.(*Match_Engine_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_Engine_Api_RegisterClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Match_Engine_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).RegisterClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/RegisterClient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).RegisterClient(ctx, req.(*Match_Engine_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_Engine_Api_AddUserToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DynamicLocGroupAdd)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).AddUserToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/AddUserToGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).AddUserToGroup(ctx, req.(*DynamicLocGroupAdd))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_Engine_Api_GetAppInstList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Match_Engine_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).GetAppInstList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/GetAppInstList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).GetAppInstList(ctx, req.(*Match_Engine_Request))
	}
	return interceptor(ctx, in, info, handler)
}

var _Match_Engine_Api_serviceDesc = grpc.ServiceDesc{
	ServiceName: "distributed_match_engine.Match_Engine_Api",
	HandlerType: (*Match_Engine_ApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FindCloudlet",
			Handler:    _Match_Engine_Api_FindCloudlet_Handler,
		},
		{
			MethodName: "VerifyLocation",
			Handler:    _Match_Engine_Api_VerifyLocation_Handler,
		},
		{
			MethodName: "GetLocation",
			Handler:    _Match_Engine_Api_GetLocation_Handler,
		},
		{
			MethodName: "RegisterClient",
			Handler:    _Match_Engine_Api_RegisterClient_Handler,
		},
		{
			MethodName: "AddUserToGroup",
			Handler:    _Match_Engine_Api_AddUserToGroup_Handler,
		},
		{
			MethodName: "GetAppInstList",
			Handler:    _Match_Engine_Api_GetAppInstList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app-client.proto",
}

func (m *Match_Engine_Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match_Engine_Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.IdType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.IdType))
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Uuid) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if m.CarrierID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CarrierID))
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if m.Tower != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Tower))
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n1, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.AppId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.AppId))
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if len(m.ServerPort) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.ServerPort)))
		i += copy(dAtA[i:], m.ServerPort)
	}
	if len(m.DevName) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.DevName)))
		i += copy(dAtA[i:], m.DevName)
	}
	if len(m.AppName) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppName)))
		i += copy(dAtA[i:], m.AppName)
	}
	if len(m.AppVers) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppVers)))
		i += copy(dAtA[i:], m.AppVers)
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if len(m.VerifyLocToken) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.VerifyLocToken)))
		i += copy(dAtA[i:], m.VerifyLocToken)
	}
	return i, nil
}

func (m *Match_Engine_Reply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match_Engine_Reply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.Uri) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	if len(m.ServiceIp) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.ServiceIp)))
		i += copy(dAtA[i:], m.ServiceIp)
	}
	if m.ServicePort != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.ServicePort))
	}
	if m.CloudletLocation != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CloudletLocation.Size()))
		n2, err := m.CloudletLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Status != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x42
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Match_Engine_Loc_Verify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match_Engine_Loc_Verify) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.TowerStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.TowerStatus))
	}
	if m.GpsLocationStatus != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocationStatus))
	}
	if m.GPS_Location_Accuracy_KM != 0 {
		dAtA[i] = 0x21
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GPS_Location_Accuracy_KM))))
		i += 8
	}
	return i, nil
}

func (m *Match_Engine_Loc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match_Engine_Loc) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if m.Tower != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Tower))
	}
	if m.NetworkLocation != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.NetworkLocation.Size()))
		n3, err := m.NetworkLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	return i, nil
}

func (m *Match_Engine_Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match_Engine_Status) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if len(m.GroupCookie) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.GroupCookie)))
		i += copy(dAtA[i:], m.GroupCookie)
	}
	if len(m.TokenServerURI) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.TokenServerURI)))
		i += copy(dAtA[i:], m.TokenServerURI)
	}
	return i, nil
}

func (m *Appinstance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Appinstance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Appname) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Appname)))
		i += copy(dAtA[i:], m.Appname)
	}
	if len(m.Appversion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Appversion)))
		i += copy(dAtA[i:], m.Appversion)
	}
	if len(m.Uri) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	return i, nil
}

func (m *CloudletLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletLocation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if len(m.CloudletName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CloudletName)))
		i += copy(dAtA[i:], m.CloudletName)
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n4, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Distance != 0 {
		dAtA[i] = 0x21
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Distance))))
		i += 8
	}
	if len(m.Appinstances) > 0 {
		for _, msg := range m.Appinstances {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Match_Engine_AppInst_List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match_Engine_AppInst_List) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if len(m.Cloudlets) > 0 {
		for _, msg := range m.Cloudlets {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DynamicLocGroupAdd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicLocGroupAdd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.IdType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.IdType))
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Uuid) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if m.CarrierID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CarrierID))
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if m.Tower != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Tower))
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n5, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.LgId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.LgId))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if m.CommType != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CommType))
	}
	if len(m.UserData) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.UserData)))
		i += copy(dAtA[i:], m.UserData)
	}
	return i, nil
}

func encodeVarintAppClient(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Match_Engine_Request) CopyInFields(src *Match_Engine_Request) {
	m.Ver = src.Ver
	m.IdType = src.IdType
	m.Id = src.Id
	m.Uuid = src.Uuid
	m.CarrierID = src.CarrierID
	m.CarrierName = src.CarrierName
	m.Tower = src.Tower
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		m.GpsLocation.Lat = src.GpsLocation.Lat
		m.GpsLocation.Long = src.GpsLocation.Long
		m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
		m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
		m.GpsLocation.Altitude = src.GpsLocation.Altitude
		m.GpsLocation.Course = src.GpsLocation.Course
		m.GpsLocation.Speed = src.GpsLocation.Speed
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &google_protobuf.Timestamp{}
			m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
			m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
		}
	}
	m.AppId = src.AppId
	if m.Protocol == nil || len(m.Protocol) != len(src.Protocol) {
		m.Protocol = make([]byte, len(src.Protocol))
	}
	copy(m.Protocol, src.Protocol)
	if m.ServerPort == nil || len(m.ServerPort) != len(src.ServerPort) {
		m.ServerPort = make([]byte, len(src.ServerPort))
	}
	copy(m.ServerPort, src.ServerPort)
	m.DevName = src.DevName
	m.AppName = src.AppName
	m.AppVers = src.AppVers
	m.SessionCookie = src.SessionCookie
	m.VerifyLocToken = src.VerifyLocToken
}

func (m *Match_Engine_Request) ValidateEnums() error {
	var ok bool
	_, ok = IDTypes_name[int32(m.IdType)]
	if !ok {
		return errors.New("invalid IdType")
	}
	return nil
}

func (m *Match_Engine_Reply) CopyInFields(src *Match_Engine_Reply) {
	m.Ver = src.Ver
	m.Uri = src.Uri
	if m.ServiceIp == nil || len(m.ServiceIp) != len(src.ServiceIp) {
		m.ServiceIp = make([]byte, len(src.ServiceIp))
	}
	copy(m.ServiceIp, src.ServiceIp)
	m.ServicePort = src.ServicePort
	if src.CloudletLocation != nil {
		m.CloudletLocation = &Loc{}
		m.CloudletLocation.Lat = src.CloudletLocation.Lat
		m.CloudletLocation.Long = src.CloudletLocation.Long
		m.CloudletLocation.HorizontalAccuracy = src.CloudletLocation.HorizontalAccuracy
		m.CloudletLocation.VerticalAccuracy = src.CloudletLocation.VerticalAccuracy
		m.CloudletLocation.Altitude = src.CloudletLocation.Altitude
		m.CloudletLocation.Course = src.CloudletLocation.Course
		m.CloudletLocation.Speed = src.CloudletLocation.Speed
		if src.CloudletLocation.Timestamp != nil {
			m.CloudletLocation.Timestamp = &google_protobuf.Timestamp{}
			m.CloudletLocation.Timestamp.Seconds = src.CloudletLocation.Timestamp.Seconds
			m.CloudletLocation.Timestamp.Nanos = src.CloudletLocation.Timestamp.Nanos
		}
	}
	m.Status = src.Status
	m.SessionCookie = src.SessionCookie
	if src.Ports != nil {
		if m.Ports == nil || len(m.Ports) != len(src.Ports) {
			m.Ports = make([]*AppPort, len(src.Ports))
		}
		for i0 := 0; i0 < len(src.Ports); i0++ {
			m.Ports[i0] = &AppPort{}
			m.Ports[i0].Proto = src.Ports[i0].Proto
			m.Ports[i0].InternalPort = src.Ports[i0].InternalPort
			m.Ports[i0].PublicPort = src.Ports[i0].PublicPort
			m.Ports[i0].PublicPath = src.Ports[i0].PublicPath
		}
	}
}

func (m *Match_Engine_Reply) ValidateEnums() error {
	var ok bool
	_, ok = Match_Engine_Reply_Find_Status_name[int32(m.Status)]
	if !ok {
		return errors.New("invalid Status")
	}
	return nil
}

func (m *Match_Engine_Loc_Verify) CopyInFields(src *Match_Engine_Loc_Verify) {
	m.Ver = src.Ver
	m.TowerStatus = src.TowerStatus
	m.GpsLocationStatus = src.GpsLocationStatus
	m.GPS_Location_Accuracy_KM = src.GPS_Location_Accuracy_KM
}

func (m *Match_Engine_Loc_Verify) ValidateEnums() error {
	var ok bool
	_, ok = Match_Engine_Loc_Verify_Tower_Status_name[int32(m.TowerStatus)]
	if !ok {
		return errors.New("invalid TowerStatus")
	}
	_, ok = Match_Engine_Loc_Verify_GPS_Location_Status_name[int32(m.GpsLocationStatus)]
	if !ok {
		return errors.New("invalid GpsLocationStatus")
	}
	return nil
}

func (m *Match_Engine_Loc) CopyInFields(src *Match_Engine_Loc) {
	m.Ver = src.Ver
	m.Status = src.Status
	m.CarrierName = src.CarrierName
	m.Tower = src.Tower
	if src.NetworkLocation != nil {
		m.NetworkLocation = &Loc{}
		m.NetworkLocation.Lat = src.NetworkLocation.Lat
		m.NetworkLocation.Long = src.NetworkLocation.Long
		m.NetworkLocation.HorizontalAccuracy = src.NetworkLocation.HorizontalAccuracy
		m.NetworkLocation.VerticalAccuracy = src.NetworkLocation.VerticalAccuracy
		m.NetworkLocation.Altitude = src.NetworkLocation.Altitude
		m.NetworkLocation.Course = src.NetworkLocation.Course
		m.NetworkLocation.Speed = src.NetworkLocation.Speed
		if src.NetworkLocation.Timestamp != nil {
			m.NetworkLocation.Timestamp = &google_protobuf.Timestamp{}
			m.NetworkLocation.Timestamp.Seconds = src.NetworkLocation.Timestamp.Seconds
			m.NetworkLocation.Timestamp.Nanos = src.NetworkLocation.Timestamp.Nanos
		}
	}
	m.SessionCookie = src.SessionCookie
}

func (m *Match_Engine_Loc) ValidateEnums() error {
	var ok bool
	_, ok = Match_Engine_Loc_Loc_Status_name[int32(m.Status)]
	if !ok {
		return errors.New("invalid Status")
	}
	return nil
}

func (m *Match_Engine_Status) CopyInFields(src *Match_Engine_Status) {
	m.Ver = src.Ver
	m.Status = src.Status
	m.ErrorCode = src.ErrorCode
	m.SessionCookie = src.SessionCookie
	m.GroupCookie = src.GroupCookie
	m.TokenServerURI = src.TokenServerURI
}

func (m *Match_Engine_Status) ValidateEnums() error {
	var ok bool
	_, ok = Match_Engine_Status_ME_Status_name[int32(m.Status)]
	if !ok {
		return errors.New("invalid Status")
	}
	return nil
}

func (m *Appinstance) CopyInFields(src *Appinstance) {
	m.Appname = src.Appname
	m.Appversion = src.Appversion
	m.Uri = src.Uri
}

func (m *CloudletLocation) CopyInFields(src *CloudletLocation) {
	m.CarrierName = src.CarrierName
	m.CloudletName = src.CloudletName
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		m.GpsLocation.Lat = src.GpsLocation.Lat
		m.GpsLocation.Long = src.GpsLocation.Long
		m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
		m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
		m.GpsLocation.Altitude = src.GpsLocation.Altitude
		m.GpsLocation.Course = src.GpsLocation.Course
		m.GpsLocation.Speed = src.GpsLocation.Speed
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &google_protobuf.Timestamp{}
			m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
			m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
		}
	}
	m.Distance = src.Distance
	if src.Appinstances != nil {
		if m.Appinstances == nil || len(m.Appinstances) != len(src.Appinstances) {
			m.Appinstances = make([]*Appinstance, len(src.Appinstances))
		}
		for i0 := 0; i0 < len(src.Appinstances); i0++ {
			m.Appinstances[i0] = &Appinstance{}
			m.Appinstances[i0].Appname = src.Appinstances[i0].Appname
			m.Appinstances[i0].Appversion = src.Appinstances[i0].Appversion
			m.Appinstances[i0].Uri = src.Appinstances[i0].Uri
		}
	}
}

func (m *Match_Engine_AppInst_List) CopyInFields(src *Match_Engine_AppInst_List) {
	m.Ver = src.Ver
	m.Status = src.Status
	if src.Cloudlets != nil {
		if m.Cloudlets == nil || len(m.Cloudlets) != len(src.Cloudlets) {
			m.Cloudlets = make([]*CloudletLocation, len(src.Cloudlets))
		}
		for i0 := 0; i0 < len(src.Cloudlets); i0++ {
			m.Cloudlets[i0] = &CloudletLocation{}
			m.Cloudlets[i0].CarrierName = src.Cloudlets[i0].CarrierName
			m.Cloudlets[i0].CloudletName = src.Cloudlets[i0].CloudletName
			if src.Cloudlets[i0].GpsLocation != nil {
				m.Cloudlets[i0].GpsLocation = &Loc{}
				m.Cloudlets[i0].GpsLocation.Lat = src.Cloudlets[i0].GpsLocation.Lat
				m.Cloudlets[i0].GpsLocation.Long = src.Cloudlets[i0].GpsLocation.Long
				m.Cloudlets[i0].GpsLocation.HorizontalAccuracy = src.Cloudlets[i0].GpsLocation.HorizontalAccuracy
				m.Cloudlets[i0].GpsLocation.VerticalAccuracy = src.Cloudlets[i0].GpsLocation.VerticalAccuracy
				m.Cloudlets[i0].GpsLocation.Altitude = src.Cloudlets[i0].GpsLocation.Altitude
				m.Cloudlets[i0].GpsLocation.Course = src.Cloudlets[i0].GpsLocation.Course
				m.Cloudlets[i0].GpsLocation.Speed = src.Cloudlets[i0].GpsLocation.Speed
				if src.Cloudlets[i0].GpsLocation.Timestamp != nil {
					m.Cloudlets[i0].GpsLocation.Timestamp = &google_protobuf.Timestamp{}
					m.Cloudlets[i0].GpsLocation.Timestamp.Seconds = src.Cloudlets[i0].GpsLocation.Timestamp.Seconds
					m.Cloudlets[i0].GpsLocation.Timestamp.Nanos = src.Cloudlets[i0].GpsLocation.Timestamp.Nanos
				}
			}
			m.Cloudlets[i0].Distance = src.Cloudlets[i0].Distance
			if src.Cloudlets[i0].Appinstances != nil {
				if m.Cloudlets[i0].Appinstances == nil || len(m.Cloudlets[i0].Appinstances) != len(src.Cloudlets[i0].Appinstances) {
					m.Cloudlets[i0].Appinstances = make([]*Appinstance, len(src.Cloudlets[i0].Appinstances))
				}
				for i1 := 0; i1 < len(src.Cloudlets[i0].Appinstances); i1++ {
					m.Cloudlets[i0].Appinstances[i1] = &Appinstance{}
					m.Cloudlets[i0].Appinstances[i1].Appname = src.Cloudlets[i0].Appinstances[i1].Appname
					m.Cloudlets[i0].Appinstances[i1].Appversion = src.Cloudlets[i0].Appinstances[i1].Appversion
					m.Cloudlets[i0].Appinstances[i1].Uri = src.Cloudlets[i0].Appinstances[i1].Uri
				}
			}
		}
	}
}

func (m *Match_Engine_AppInst_List) ValidateEnums() error {
	var ok bool
	_, ok = Match_Engine_AppInst_List_AI_Status_name[int32(m.Status)]
	if !ok {
		return errors.New("invalid Status")
	}
	return nil
}

func (m *DynamicLocGroupAdd) CopyInFields(src *DynamicLocGroupAdd) {
	m.Ver = src.Ver
	m.IdType = src.IdType
	m.Id = src.Id
	m.Uuid = src.Uuid
	m.CarrierID = src.CarrierID
	m.CarrierName = src.CarrierName
	m.Tower = src.Tower
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		m.GpsLocation.Lat = src.GpsLocation.Lat
		m.GpsLocation.Long = src.GpsLocation.Long
		m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
		m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
		m.GpsLocation.Altitude = src.GpsLocation.Altitude
		m.GpsLocation.Course = src.GpsLocation.Course
		m.GpsLocation.Speed = src.GpsLocation.Speed
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &google_protobuf.Timestamp{}
			m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
			m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
		}
	}
	m.LgId = src.LgId
	m.SessionCookie = src.SessionCookie
	m.CommType = src.CommType
	m.UserData = src.UserData
}

func (m *DynamicLocGroupAdd) ValidateEnums() error {
	var ok bool
	_, ok = IDTypes_name[int32(m.IdType)]
	if !ok {
		return errors.New("invalid IdType")
	}
	_, ok = DynamicLocGroupAdd_DlgCommType_name[int32(m.CommType)]
	if !ok {
		return errors.New("invalid CommType")
	}
	return nil
}

var IDTypesStrings = []string{
	"ID_UNDEFINED",
	"IMEI",
	"MSISDN",
	"IPADDR",
}

const (
	IDTypesID_UNDEFINED uint64 = 1 << 0
	IDTypesIMEI         uint64 = 1 << 1
	IDTypesMSISDN       uint64 = 1 << 2
	IDTypesIPADDR       uint64 = 1 << 3
)

func (e *IDTypes) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := IDTypes_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = IDTypes_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = IDTypes(val)
	return nil
}

func (e IDTypes) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

var Find_StatusStrings = []string{
	"FIND_UNKNOWN",
	"FIND_FOUND",
	"FIND_NOTFOUND",
}

const (
	Find_StatusFIND_UNKNOWN  uint64 = 1 << 0
	Find_StatusFIND_FOUND    uint64 = 1 << 1
	Find_StatusFIND_NOTFOUND uint64 = 1 << 2
)

func (e *Match_Engine_Reply_Find_Status) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := Match_Engine_Reply_Find_Status_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = Match_Engine_Reply_Find_Status_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = Match_Engine_Reply_Find_Status(val)
	return nil
}

func (e Match_Engine_Reply_Find_Status) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

var Tower_StatusStrings = []string{
	"TOWER_UNKNOWN",
	"CONNECTED_TO_SPECIFIED_TOWER",
	"NOT_CONNECTED_TO_SPECIFIED_TOWER",
}

const (
	Tower_StatusTOWER_UNKNOWN                    uint64 = 1 << 0
	Tower_StatusCONNECTED_TO_SPECIFIED_TOWER     uint64 = 1 << 1
	Tower_StatusNOT_CONNECTED_TO_SPECIFIED_TOWER uint64 = 1 << 2
)

func (e *Match_Engine_Loc_Verify_Tower_Status) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := Match_Engine_Loc_Verify_Tower_Status_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = Match_Engine_Loc_Verify_Tower_Status_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = Match_Engine_Loc_Verify_Tower_Status(val)
	return nil
}

func (e Match_Engine_Loc_Verify_Tower_Status) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

var GPS_Location_StatusStrings = []string{
	"LOC_UNKNOWN",
	"LOC_VERIFIED",
	"LOC_MISMATCH_SAME_COUNTRY",
	"LOC_MISMATCH_OTHER_COUNTRY",
	"LOC_ROAMING_COUNTRY_MATCH",
	"LOC_ROAMING_COUNTRY_MISMATCH",
	"LOC_ERROR_UNAUTHORIZED",
	"LOC_ERROR_OTHER",
}

const (
	GPS_Location_StatusLOC_UNKNOWN                  uint64 = 1 << 0
	GPS_Location_StatusLOC_VERIFIED                 uint64 = 1 << 1
	GPS_Location_StatusLOC_MISMATCH_SAME_COUNTRY    uint64 = 1 << 2
	GPS_Location_StatusLOC_MISMATCH_OTHER_COUNTRY   uint64 = 1 << 3
	GPS_Location_StatusLOC_ROAMING_COUNTRY_MATCH    uint64 = 1 << 4
	GPS_Location_StatusLOC_ROAMING_COUNTRY_MISMATCH uint64 = 1 << 5
	GPS_Location_StatusLOC_ERROR_UNAUTHORIZED       uint64 = 1 << 6
	GPS_Location_StatusLOC_ERROR_OTHER              uint64 = 1 << 7
)

func (e *Match_Engine_Loc_Verify_GPS_Location_Status) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := Match_Engine_Loc_Verify_GPS_Location_Status_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = Match_Engine_Loc_Verify_GPS_Location_Status_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = Match_Engine_Loc_Verify_GPS_Location_Status(val)
	return nil
}

func (e Match_Engine_Loc_Verify_GPS_Location_Status) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

var Loc_StatusStrings = []string{
	"LOC_UNKNOWN",
	"LOC_FOUND",
	"LOC_DENIED",
}

const (
	Loc_StatusLOC_UNKNOWN uint64 = 1 << 0
	Loc_StatusLOC_FOUND   uint64 = 1 << 1
	Loc_StatusLOC_DENIED  uint64 = 1 << 2
)

func (e *Match_Engine_Loc_Loc_Status) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := Match_Engine_Loc_Loc_Status_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = Match_Engine_Loc_Loc_Status_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = Match_Engine_Loc_Loc_Status(val)
	return nil
}

func (e Match_Engine_Loc_Loc_Status) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

var ME_StatusStrings = []string{
	"ME_UNDEFINED",
	"ME_SUCCESS",
	"ME_FAIL",
}

const (
	ME_StatusME_UNDEFINED uint64 = 1 << 0
	ME_StatusME_SUCCESS   uint64 = 1 << 1
	ME_StatusME_FAIL      uint64 = 1 << 2
)

func (e *Match_Engine_Status_ME_Status) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := Match_Engine_Status_ME_Status_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = Match_Engine_Status_ME_Status_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = Match_Engine_Status_ME_Status(val)
	return nil
}

func (e Match_Engine_Status_ME_Status) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

var AI_StatusStrings = []string{
	"AI_UNDEFINED",
	"AI_SUCCESS",
	"AI_FAIL",
}

const (
	AI_StatusAI_UNDEFINED uint64 = 1 << 0
	AI_StatusAI_SUCCESS   uint64 = 1 << 1
	AI_StatusAI_FAIL      uint64 = 1 << 2
)

func (e *Match_Engine_AppInst_List_AI_Status) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := Match_Engine_AppInst_List_AI_Status_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = Match_Engine_AppInst_List_AI_Status_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = Match_Engine_AppInst_List_AI_Status(val)
	return nil
}

func (e Match_Engine_AppInst_List_AI_Status) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

var DlgCommTypeStrings = []string{
	"DlgUndefined",
	"DlgSecure",
	"DlgOpen",
}

const (
	DlgCommTypeDlgUndefined uint64 = 1 << 0
	DlgCommTypeDlgSecure    uint64 = 1 << 1
	DlgCommTypeDlgOpen      uint64 = 1 << 2
)

func (e *DynamicLocGroupAdd_DlgCommType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := DynamicLocGroupAdd_DlgCommType_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = DynamicLocGroupAdd_DlgCommType_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = DynamicLocGroupAdd_DlgCommType(val)
	return nil
}

func (e DynamicLocGroupAdd_DlgCommType) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

type MatchOptions struct {
	// Filter will ignore 0 or nil fields on the passed in object
	Filter bool
	// IgnoreBackend will ignore fields that were marked backend in .proto
	IgnoreBackend bool
	// Sort repeated (arrays) of Key objects so matching does not
	// fail due to order.
	SortArrayedKeys bool
}

type MatchOpt func(*MatchOptions)

func MatchFilter() MatchOpt {
	return func(opts *MatchOptions) {
		opts.Filter = true
	}
}

func MatchIgnoreBackend() MatchOpt {
	return func(opts *MatchOptions) {
		opts.IgnoreBackend = true
	}
}

func MatchSortArrayedKeys() MatchOpt {
	return func(opts *MatchOptions) {
		opts.SortArrayedKeys = true
	}
}

func applyMatchOptions(opts *MatchOptions, args ...MatchOpt) {
	for _, f := range args {
		f(opts)
	}
}

func (m *Match_Engine_Request) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.IdType != 0 {
		n += 1 + sovAppClient(uint64(m.IdType))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.CarrierID != 0 {
		n += 1 + sovAppClient(uint64(m.CarrierID))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Tower != 0 {
		n += 1 + sovAppClient(uint64(m.Tower))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.AppId != 0 {
		n += 1 + sovAppClient(uint64(m.AppId))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.ServerPort)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.DevName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppVers)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.VerifyLocToken)
	if l > 0 {
		n += 2 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *Match_Engine_Reply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.ServiceIp)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.ServicePort != 0 {
		n += 1 + sovAppClient(uint64(m.ServicePort))
	}
	if m.CloudletLocation != nil {
		l = m.CloudletLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *Match_Engine_Loc_Verify) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.TowerStatus != 0 {
		n += 1 + sovAppClient(uint64(m.TowerStatus))
	}
	if m.GpsLocationStatus != 0 {
		n += 1 + sovAppClient(uint64(m.GpsLocationStatus))
	}
	if m.GPS_Location_Accuracy_KM != 0 {
		n += 9
	}
	return n
}

func (m *Match_Engine_Loc) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Tower != 0 {
		n += 1 + sovAppClient(uint64(m.Tower))
	}
	if m.NetworkLocation != nil {
		l = m.NetworkLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *Match_Engine_Status) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAppClient(uint64(m.ErrorCode))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.GroupCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.TokenServerURI)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *Appinstance) Size() (n int) {
	var l int
	_ = l
	l = len(m.Appname)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.Appversion)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *CloudletLocation) Size() (n int) {
	var l int
	_ = l
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CloudletName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Distance != 0 {
		n += 9
	}
	if len(m.Appinstances) > 0 {
		for _, e := range m.Appinstances {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *Match_Engine_AppInst_List) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	if len(m.Cloudlets) > 0 {
		for _, e := range m.Cloudlets {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *DynamicLocGroupAdd) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.IdType != 0 {
		n += 1 + sovAppClient(uint64(m.IdType))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.CarrierID != 0 {
		n += 1 + sovAppClient(uint64(m.CarrierID))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Tower != 0 {
		n += 1 + sovAppClient(uint64(m.Tower))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.LgId != 0 {
		n += 1 + sovAppClient(uint64(m.LgId))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.CommType != 0 {
		n += 1 + sovAppClient(uint64(m.CommType))
	}
	l = len(m.UserData)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func sovAppClient(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAppClient(x uint64) (n int) {
	return sovAppClient(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Match_Engine_Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match_Engine_Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match_Engine_Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdType", wireType)
			}
			m.IdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdType |= (IDTypes(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierID", wireType)
			}
			m.CarrierID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CarrierID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tower", wireType)
			}
			m.Tower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tower |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = append(m.Protocol[:0], dAtA[iNdEx:postIndex]...)
			if m.Protocol == nil {
				m.Protocol = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerPort", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerPort = append(m.ServerPort[:0], dAtA[iNdEx:postIndex]...)
			if m.ServerPort == nil {
				m.ServerPort = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyLocToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifyLocToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Match_Engine_Reply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match_Engine_Reply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match_Engine_Reply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceIp", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceIp = append(m.ServiceIp[:0], dAtA[iNdEx:postIndex]...)
			if m.ServiceIp == nil {
				m.ServiceIp = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicePort", wireType)
			}
			m.ServicePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServicePort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloudletLocation == nil {
				m.CloudletLocation = &Loc{}
			}
			if err := m.CloudletLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Match_Engine_Reply_Find_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &AppPort{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Match_Engine_Loc_Verify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match_Engine_Loc_Verify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match_Engine_Loc_Verify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TowerStatus", wireType)
			}
			m.TowerStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TowerStatus |= (Match_Engine_Loc_Verify_Tower_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocationStatus", wireType)
			}
			m.GpsLocationStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpsLocationStatus |= (Match_Engine_Loc_Verify_GPS_Location_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GPS_Location_Accuracy_KM", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GPS_Location_Accuracy_KM = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Match_Engine_Loc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match_Engine_Loc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match_Engine_Loc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Match_Engine_Loc_Loc_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tower", wireType)
			}
			m.Tower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tower |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkLocation == nil {
				m.NetworkLocation = &Loc{}
			}
			if err := m.NetworkLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Match_Engine_Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match_Engine_Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match_Engine_Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Match_Engine_Status_ME_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenServerURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenServerURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Appinstance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Appinstance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Appinstance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Appname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appversion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Appversion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudletName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Distance = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appinstances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Appinstances = append(m.Appinstances, &Appinstance{})
			if err := m.Appinstances[len(m.Appinstances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Match_Engine_AppInst_List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match_Engine_AppInst_List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match_Engine_AppInst_List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Match_Engine_AppInst_List_AI_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cloudlets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cloudlets = append(m.Cloudlets, &CloudletLocation{})
			if err := m.Cloudlets[len(m.Cloudlets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicLocGroupAdd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicLocGroupAdd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicLocGroupAdd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdType", wireType)
			}
			m.IdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdType |= (IDTypes(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierID", wireType)
			}
			m.CarrierID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CarrierID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tower", wireType)
			}
			m.Tower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tower |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LgId", wireType)
			}
			m.LgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LgId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommType", wireType)
			}
			m.CommType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommType |= (DynamicLocGroupAdd_DlgCommType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAppClient(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAppClient
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAppClient(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAppClient = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAppClient   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("app-client.proto", fileDescriptorAppClient) }

var fileDescriptorAppClient = []byte{
	// 1460 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0xcb, 0x6f, 0xdb, 0x46,
	0x13, 0x37, 0xf5, 0xb0, 0xad, 0xa1, 0x2c, 0x33, 0xeb, 0x7c, 0xdf, 0xc7, 0x18, 0x89, 0xa1, 0x10,
	0xf9, 0x0a, 0x23, 0x48, 0x04, 0xd4, 0x41, 0x91, 0xbe, 0xd2, 0x82, 0x11, 0x69, 0x99, 0x8d, 0x44,
	0x1a, 0x2b, 0x2a, 0x41, 0x7a, 0x21, 0x14, 0x72, 0xa3, 0x12, 0x96, 0x49, 0x86, 0xa4, 0x1c, 0xf8,
	0xd6, 0x4b, 0x2f, 0x45, 0xaf, 0xfd, 0x6b, 0x7a, 0x6b, 0x2f, 0x39, 0xf6, 0xd8, 0x63, 0x9b, 0x5b,
	0xff, 0x8b, 0x62, 0x97, 0x0f, 0x53, 0x94, 0xec, 0x5a, 0x3d, 0xf7, 0xb6, 0xf3, 0xd6, 0xcc, 0xfc,
	0x76, 0x66, 0x29, 0x10, 0xc6, 0x41, 0xf0, 0xd0, 0x9e, 0xba, 0xc4, 0x8b, 0x3b, 0x41, 0xe8, 0xc7,
	0x3e, 0x12, 0x1d, 0x37, 0x8a, 0x43, 0xf7, 0xd5, 0x2c, 0x26, 0x8e, 0x75, 0x3a, 0x8e, 0xed, 0x6f,
	0x2c, 0xe2, 0x4d, 0x5c, 0x8f, 0xec, 0x36, 0xa6, 0xbe, 0x9d, 0x28, 0xed, 0x6e, 0x8f, 0x83, 0xc0,
	0xf6, 0x4f, 0x4f, 0x7d, 0x2f, 0x61, 0x48, 0x3f, 0xd4, 0xe0, 0xe6, 0x80, 0x29, 0xab, 0x4c, 0xd9,
	0xc2, 0xe4, 0xcd, 0x8c, 0x44, 0x31, 0x12, 0xa0, 0x7a, 0x46, 0x42, 0x91, 0x6b, 0x73, 0xfb, 0x5b,
	0x98, 0x1e, 0xd1, 0x27, 0xb0, 0xae, 0x39, 0xe6, 0x79, 0x40, 0xc4, 0x4a, 0x9b, 0xdb, 0x6f, 0x1d,
	0xdc, 0xed, 0x5c, 0x16, 0xb1, 0xa3, 0x29, 0x54, 0x2f, 0xc2, 0xa9, 0x01, 0x6a, 0x41, 0x45, 0x73,
	0xc4, 0x6a, 0x9b, 0xdb, 0x6f, 0xe0, 0x8a, 0xe6, 0x20, 0x04, 0xb5, 0xd1, 0xcc, 0x75, 0xc4, 0x1a,
	0xe3, 0xb0, 0x33, 0xba, 0x0d, 0x8d, 0xee, 0x38, 0x0c, 0x5d, 0x12, 0x6a, 0x8a, 0x58, 0x6f, 0x73,
	0xfb, 0x35, 0x7c, 0xc1, 0x40, 0x6d, 0xe0, 0x53, 0x42, 0x1f, 0x9f, 0x12, 0x71, 0x9d, 0x19, 0x16,
	0x59, 0xe8, 0x26, 0xd4, 0x4d, 0xff, 0x2d, 0x09, 0xc5, 0x0d, 0x66, 0x9b, 0x10, 0xe8, 0x4b, 0xe0,
	0x7b, 0x41, 0xd4, 0xf7, 0xed, 0x71, 0xec, 0xfa, 0x9e, 0xb8, 0xd9, 0xe6, 0xf6, 0xf9, 0x83, 0x3b,
	0x97, 0xff, 0xf2, 0xbe, 0x6f, 0xe3, 0xa2, 0x05, 0x75, 0x2b, 0x07, 0x81, 0xe6, 0x88, 0x8d, 0xc4,
	0x2d, 0x23, 0xd0, 0x2e, 0x6c, 0x1e, 0xd3, 0xfa, 0xd9, 0xfe, 0x54, 0x84, 0x36, 0xb7, 0xdf, 0xc4,
	0x39, 0x8d, 0xf6, 0x00, 0x86, 0x24, 0x3c, 0x23, 0xe1, 0xb1, 0x1f, 0xc6, 0x22, 0xcf, 0xa4, 0x05,
	0x0e, 0x12, 0x61, 0x43, 0x21, 0x67, 0x2c, 0x8d, 0x26, 0x4b, 0x23, 0x23, 0xa9, 0x44, 0x0e, 0x02,
	0x26, 0xd9, 0x4a, 0x24, 0x29, 0x99, 0x4a, 0x9e, 0x93, 0x30, 0x12, 0x5b, 0xb9, 0x84, 0x92, 0xe8,
	0x1e, 0x6c, 0x0d, 0x49, 0x14, 0xb9, 0xbe, 0xd7, 0xf5, 0xfd, 0x13, 0x97, 0x88, 0xdb, 0x4c, 0x3e,
	0xcf, 0x44, 0x1f, 0x40, 0xeb, 0x39, 0x09, 0xdd, 0xd7, 0xe7, 0x7d, 0xdf, 0x36, 0xfd, 0x13, 0xe2,
	0x89, 0x02, 0x53, 0x2b, 0x71, 0xa5, 0x9f, 0xaa, 0x80, 0x4a, 0x70, 0x08, 0xa6, 0xe7, 0x4b, 0xc0,
	0x20, 0x40, 0x75, 0x16, 0xba, 0x0c, 0x09, 0x0d, 0x4c, 0x8f, 0xe8, 0x0e, 0x40, 0x44, 0xc2, 0x33,
	0xd7, 0x26, 0x96, 0x1b, 0xb0, 0x5e, 0x37, 0x71, 0x23, 0xe5, 0x68, 0x01, 0xba, 0x0b, 0xcd, 0x4c,
	0x1c, 0xd0, 0xba, 0xd4, 0x98, 0x2f, 0x3e, 0xe5, 0xb1, 0xc2, 0x7c, 0x05, 0x37, 0xec, 0xa9, 0x3f,
	0x73, 0xa6, 0x24, 0xb6, 0xa6, 0x59, 0xc7, 0xea, 0xd7, 0xe9, 0x98, 0x90, 0xd9, 0xe5, 0x6d, 0x3b,
	0x86, 0xf5, 0x61, 0x3c, 0x8e, 0x67, 0x11, 0x83, 0x4a, 0xeb, 0xe0, 0xe3, 0xcb, 0x1d, 0x2c, 0xe6,
	0xdb, 0x39, 0x74, 0x3d, 0xc7, 0x4a, 0xec, 0x71, 0xea, 0x67, 0xb1, 0xd0, 0x1b, 0xcb, 0x0a, 0xfd,
	0x18, 0xea, 0x34, 0xbd, 0x48, 0xdc, 0x6c, 0x57, 0xf7, 0xf9, 0xab, 0xee, 0x88, 0x1c, 0x04, 0x34,
	0x6b, 0x9c, 0xe8, 0x4b, 0x4f, 0x81, 0x2f, 0x44, 0x45, 0x02, 0x34, 0x0f, 0x35, 0x5d, 0xb1, 0x46,
	0xfa, 0x33, 0xdd, 0x78, 0xa1, 0x0b, 0x6b, 0xa8, 0x05, 0xc0, 0x38, 0x87, 0xc6, 0x48, 0x57, 0x04,
	0x0e, 0xdd, 0x80, 0x2d, 0x46, 0xeb, 0x86, 0x99, 0xb0, 0x2a, 0xd2, 0x8f, 0x75, 0xf8, 0xdf, 0x5c,
	0x36, 0x7d, 0xdf, 0xb6, 0x92, 0x0e, 0x2f, 0x69, 0xe1, 0x18, 0x9a, 0x31, 0xbd, 0x23, 0x56, 0x94,
	0x14, 0x2a, 0xb9, 0xd5, 0x5f, 0x5c, 0xb3, 0x50, 0x17, 0xae, 0x3b, 0xec, 0xa6, 0x65, 0xe5, 0xe2,
	0x99, 0xcf, 0x34, 0x8b, 0x19, 0xec, 0x4c, 0x82, 0x28, 0x6f, 0x66, 0x16, 0xa9, 0xca, 0x22, 0xa9,
	0xab, 0x47, 0xea, 0x1d, 0x0f, 0xad, 0xac, 0xc5, 0x59, 0xc0, 0x1b, 0x93, 0x8b, 0xdb, 0x9a, 0x86,
	0x7d, 0x0c, 0xe2, 0x9c, 0xa6, 0x6c, 0xdb, 0xb3, 0x70, 0x6c, 0x9f, 0x5b, 0xcf, 0x06, 0x0c, 0x77,
	0x1c, 0xfe, 0x4f, 0xef, 0x78, 0x98, 0x89, 0x33, 0xe9, 0xb3, 0x81, 0xe4, 0x42, 0xb3, 0x98, 0x0c,
	0xad, 0xb1, 0x69, 0xbc, 0x50, 0x71, 0xa1, 0x0d, 0x6d, 0xb8, 0xdd, 0x35, 0x74, 0x5d, 0xed, 0x9a,
	0xaa, 0x62, 0x99, 0x86, 0x35, 0x3c, 0x56, 0xbb, 0xda, 0xa1, 0xc6, 0x88, 0x17, 0x2a, 0x16, 0x38,
	0x74, 0x0f, 0xda, 0xba, 0x61, 0x5a, 0x57, 0x6a, 0x55, 0xa4, 0x3f, 0x39, 0xd8, 0x59, 0x92, 0x0e,
	0xda, 0x06, 0xbe, 0x6f, 0x74, 0x0b, 0x01, 0x05, 0x68, 0x52, 0xc6, 0x73, 0x15, 0x33, 0x07, 0x02,
	0x87, 0xee, 0xc0, 0x2d, 0xca, 0x19, 0x68, 0xc3, 0x81, 0x6c, 0x76, 0x8f, 0xac, 0xa1, 0x3c, 0x50,
	0xad, 0xae, 0x31, 0xd2, 0x4d, 0xfc, 0x52, 0xa8, 0xa0, 0x3d, 0xd8, 0x9d, 0x13, 0x1b, 0xe6, 0x91,
	0x8a, 0x73, 0x79, 0x35, 0x33, 0xc7, 0x86, 0x3c, 0xd0, 0xf4, 0x5e, 0x26, 0xb0, 0x98, 0xb2, 0x50,
	0xa3, 0x09, 0x2e, 0x15, 0xa7, 0xee, 0x84, 0x3a, 0xda, 0x85, 0xff, 0x52, 0x0d, 0x15, 0x63, 0x83,
	0x56, 0x46, 0x1e, 0x99, 0x47, 0x06, 0xd6, 0xbe, 0x56, 0x15, 0x61, 0x1d, 0xed, 0xc0, 0xf6, 0x85,
	0x8c, 0x45, 0x16, 0x36, 0xa4, 0xdf, 0x2a, 0x20, 0x94, 0x5b, 0xba, 0x04, 0x90, 0x83, 0xfc, 0xce,
	0x26, 0x50, 0xfc, 0xe8, 0xfa, 0x00, 0xa1, 0x53, 0xa0, 0x7c, 0x61, 0x4b, 0x2b, 0xa3, 0x7a, 0xc5,
	0xca, 0xa8, 0x15, 0x57, 0x46, 0x0f, 0xb6, 0x75, 0x12, 0xbf, 0xf5, 0xc3, 0x93, 0xfe, 0x4a, 0x43,
	0xa8, 0x6c, 0xb5, 0x38, 0x31, 0xd6, 0x97, 0x4c, 0x0c, 0xe9, 0x73, 0x80, 0x8b, 0x1f, 0xbf, 0xd8,
	0xfe, 0x2d, 0x68, 0x50, 0x46, 0x76, 0xeb, 0x5b, 0x00, 0x94, 0x54, 0x54, 0x9d, 0x62, 0xa1, 0x22,
	0xfd, 0x5c, 0x81, 0x9d, 0xb9, 0x62, 0xe4, 0xf3, 0xa3, 0x5c, 0x5d, 0xa3, 0x54, 0xdd, 0xc7, 0xd7,
	0xac, 0x6e, 0x62, 0xd4, 0x19, 0xa8, 0xe5, 0xfa, 0xde, 0x86, 0x86, 0x1a, 0x86, 0x7e, 0xd8, 0xf5,
	0x9d, 0xa4, 0xba, 0x5b, 0xf8, 0x82, 0xb1, 0x98, 0x7c, 0x6d, 0xd9, 0xb8, 0x6c, 0x03, 0xdf, 0x0b,
	0xfd, 0x59, 0x90, 0xea, 0xd4, 0x93, 0x1e, 0x15, 0x58, 0x74, 0x73, 0xb1, 0xd5, 0x94, 0x2c, 0xd0,
	0x11, 0xd6, 0xd2, 0x2a, 0x96, 0xb8, 0xd2, 0xa7, 0xd0, 0xc8, 0x7f, 0x22, 0xbd, 0x33, 0x03, 0xd5,
	0x1a, 0xe9, 0x8a, 0x7a, 0xa8, 0xe9, 0xaa, 0x92, 0x4c, 0x4f, 0x2a, 0x1e, 0x75, 0xbb, 0xea, 0x70,
	0x28, 0x70, 0x88, 0x87, 0x8d, 0x81, 0x6a, 0x1d, 0xca, 0x5a, 0x5f, 0xa8, 0x48, 0x2f, 0x81, 0x97,
	0x83, 0xc0, 0xf5, 0xa2, 0x78, 0xec, 0xd9, 0xd9, 0xb2, 0xf5, 0x28, 0x68, 0xb8, 0x7c, 0xd9, 0x52,
	0x92, 0xae, 0x76, 0x39, 0x08, 0xce, 0x48, 0x48, 0x53, 0x48, 0x97, 0x5f, 0x81, 0x43, 0xab, 0x3e,
	0x0a, 0xdd, 0x14, 0x6a, 0xf4, 0x28, 0x7d, 0x5b, 0x01, 0xa1, 0x5b, 0x5e, 0x4e, 0x25, 0x64, 0x72,
	0x8b, 0xc8, 0x94, 0xa0, 0x99, 0x59, 0x31, 0x95, 0x24, 0xd4, 0x1c, 0xaf, 0xfc, 0xb4, 0xa9, 0xae,
	0xfc, 0xb4, 0xd9, 0x85, 0x4d, 0xc5, 0x4d, 0x72, 0x4e, 0xc7, 0x62, 0x4e, 0x23, 0x0d, 0x9a, 0x85,
	0x92, 0x44, 0x62, 0x9d, 0xad, 0xb3, 0xff, 0x5f, 0xb9, 0xce, 0x32, 0x6d, 0x3c, 0x67, 0x2a, 0x7d,
	0x5f, 0x81, 0x5b, 0x73, 0x88, 0xa2, 0x4f, 0x28, 0x2f, 0x8a, 0xad, 0xbe, 0xbb, 0xf4, 0x9d, 0x39,
	0x2a, 0x01, 0xf5, 0xc9, 0x35, 0x81, 0x5a, 0x74, 0xdb, 0x91, 0xb5, 0x32, 0x5c, 0x8f, 0xa0, 0x91,
	0x95, 0x8f, 0x6e, 0x20, 0x9a, 0xce, 0xfd, 0xcb, 0x3d, 0x97, 0x7b, 0x86, 0x2f, 0x8c, 0x29, 0xd4,
	0x72, 0xf7, 0x14, 0x6a, 0xb2, 0x56, 0x86, 0x1a, 0x15, 0x17, 0xa1, 0x26, 0x6b, 0x19, 0xd4, 0xbe,
	0xab, 0x01, 0x52, 0xce, 0xbd, 0xf1, 0xa9, 0x6b, 0xf7, 0x7d, 0x9b, 0x01, 0x5d, 0x76, 0x9c, 0x7f,
	0x5f, 0xdb, 0x29, 0x24, 0x11, 0xd4, 0xfa, 0x93, 0xfc, 0xb1, 0xcd, 0xce, 0x8b, 0x93, 0x04, 0x96,
	0x4d, 0x12, 0x13, 0x36, 0xbb, 0xfe, 0xe9, 0x29, 0xab, 0x18, 0xff, 0x77, 0x4f, 0xbe, 0xc5, 0x0e,
	0x74, 0x94, 0xe9, 0x24, 0xb3, 0xc7, 0xb9, 0x27, 0x7a, 0x45, 0x46, 0x11, 0x09, 0x95, 0x71, 0x3c,
	0x4e, 0x1f, 0xeb, 0x39, 0x2d, 0x7d, 0x06, 0x7c, 0xc1, 0x88, 0x02, 0x41, 0x99, 0x4e, 0x46, 0x9e,
	0x43, 0x5e, 0xbb, 0x1e, 0x71, 0x92, 0xd1, 0xad, 0x4c, 0x27, 0x43, 0x62, 0xcf, 0x42, 0x92, 0xe0,
	0x40, 0x99, 0x4e, 0x8c, 0x80, 0x78, 0x42, 0xe5, 0xfe, 0x13, 0xd8, 0x48, 0xdb, 0x46, 0x0d, 0x35,
	0x65, 0x0e, 0x41, 0x9b, 0x50, 0xd3, 0x06, 0xaa, 0x26, 0x70, 0x08, 0x60, 0x7d, 0x30, 0xd4, 0x86,
	0x8a, 0x2e, 0x54, 0xe8, 0x59, 0x3b, 0x96, 0x15, 0x05, 0x0b, 0xd5, 0x83, 0x5f, 0xea, 0xa5, 0x8d,
	0x2a, 0x07, 0x2e, 0xf2, 0xa0, 0x49, 0x9f, 0x90, 0x19, 0x50, 0x51, 0xe7, 0xda, 0x6f, 0x5e, 0xf6,
	0xc9, 0xb7, 0xfb, 0x60, 0x95, 0x37, 0xb2, 0xb4, 0x86, 0x66, 0x85, 0x8f, 0x8a, 0xa4, 0x7d, 0xab,
	0x46, 0xfc, 0x70, 0xe5, 0x27, 0xa0, 0xb4, 0x86, 0x4e, 0x80, 0xef, 0x15, 0x86, 0xe9, 0xaa, 0x31,
	0xef, 0x5f, 0x3f, 0xa6, 0xb4, 0x86, 0xde, 0x40, 0x0b, 0x93, 0x89, 0x1b, 0xc5, 0x24, 0xec, 0xb2,
	0xaf, 0xed, 0x95, 0xe3, 0x3d, 0x5c, 0x69, 0xcf, 0x4a, 0x6b, 0xc8, 0x87, 0x96, 0xec, 0x38, 0x14,
	0x66, 0xa6, 0xcf, 0xe0, 0x89, 0x1e, 0xac, 0x82, 0xe4, 0xd5, 0x03, 0xbe, 0x85, 0x56, 0x8f, 0xc4,
	0xe9, 0xf8, 0x64, 0x43, 0x79, 0xd5, 0x1c, 0x1f, 0xfd, 0x83, 0x11, 0x2d, 0xad, 0x3d, 0x15, 0xde,
	0xfd, 0xb1, 0xb7, 0xf6, 0xee, 0xfd, 0x1e, 0xf7, 0xeb, 0xfb, 0x3d, 0xee, 0xf7, 0xf7, 0x7b, 0xdc,
	0xab, 0x75, 0xf6, 0xaf, 0xc4, 0xa3, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0xa6, 0xd1, 0xa1, 0x37,
	0xdf, 0x10, 0x00, 0x00,
}
