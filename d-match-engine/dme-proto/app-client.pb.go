// Code generated by protoc-gen-go. DO NOT EDIT.
// source: app-client.proto

/*
Package distributed_match_engine is a generated protocol buffer package.

It is generated from these files:
	app-client.proto

It has these top-level messages:
	Loc
	Match_Engine_Request
	Match_Engine_Reply
	Match_Engine_Loc_Verify
*/
package distributed_match_engine

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// User ID type - IMEI, MSISDN etc
type Match_Engine_Request_IDType int32

const (
	Match_Engine_Request_IMEI   Match_Engine_Request_IDType = 0
	Match_Engine_Request_MSISDN Match_Engine_Request_IDType = 1
)

var Match_Engine_Request_IDType_name = map[int32]string{
	0: "IMEI",
	1: "MSISDN",
}
var Match_Engine_Request_IDType_value = map[string]int32{
	"IMEI":   0,
	"MSISDN": 1,
}

func (x Match_Engine_Request_IDType) String() string {
	return proto.EnumName(Match_Engine_Request_IDType_name, int32(x))
}
func (Match_Engine_Request_IDType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{1, 0}
}

// Status of the reply
type Match_Engine_Loc_Verify_Tower_Status int32

const (
	Match_Engine_Loc_Verify_UNKNOWN                          Match_Engine_Loc_Verify_Tower_Status = 0
	Match_Engine_Loc_Verify_CONNECTED_TO_SPECIFIED_TOWER     Match_Engine_Loc_Verify_Tower_Status = 1
	Match_Engine_Loc_Verify_NOT_CONNECTED_TO_SPECIFIED_TOWER Match_Engine_Loc_Verify_Tower_Status = 2
)

var Match_Engine_Loc_Verify_Tower_Status_name = map[int32]string{
	0: "UNKNOWN",
	1: "CONNECTED_TO_SPECIFIED_TOWER",
	2: "NOT_CONNECTED_TO_SPECIFIED_TOWER",
}
var Match_Engine_Loc_Verify_Tower_Status_value = map[string]int32{
	"UNKNOWN":                          0,
	"CONNECTED_TO_SPECIFIED_TOWER":     1,
	"NOT_CONNECTED_TO_SPECIFIED_TOWER": 2,
}

func (x Match_Engine_Loc_Verify_Tower_Status) String() string {
	return proto.EnumName(Match_Engine_Loc_Verify_Tower_Status_name, int32(x))
}
func (Match_Engine_Loc_Verify_Tower_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{3, 0}
}

type Match_Engine_Loc_Verify_GPS_Location_Status int32

const (
	Match_Engine_Loc_Verify_LOC_UNKNOWN    Match_Engine_Loc_Verify_GPS_Location_Status = 0
	Match_Engine_Loc_Verify_LOC_WITHIN_1M  Match_Engine_Loc_Verify_GPS_Location_Status = 1
	Match_Engine_Loc_Verify_LOC_WITHIN_10M Match_Engine_Loc_Verify_GPS_Location_Status = 2
)

var Match_Engine_Loc_Verify_GPS_Location_Status_name = map[int32]string{
	0: "LOC_UNKNOWN",
	1: "LOC_WITHIN_1M",
	2: "LOC_WITHIN_10M",
}
var Match_Engine_Loc_Verify_GPS_Location_Status_value = map[string]int32{
	"LOC_UNKNOWN":    0,
	"LOC_WITHIN_1M":  1,
	"LOC_WITHIN_10M": 2,
}

func (x Match_Engine_Loc_Verify_GPS_Location_Status) String() string {
	return proto.EnumName(Match_Engine_Loc_Verify_GPS_Location_Status_name, int32(x))
}
func (Match_Engine_Loc_Verify_GPS_Location_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{3, 1}
}

type Loc struct {
	// latitude in WGS 84 coordinates
	Lat float64 `protobuf:"fixed64,1,opt,name=lat" json:"lat,omitempty"`
	// longitude in WGS 84 coordinates
	Long float64 `protobuf:"fixed64,2,opt,name=long" json:"long,omitempty"`
	// horizontal accuracy (radius in meters)
	HorizontalAccuracy float64 `protobuf:"fixed64,3,opt,name=horizontal_accuracy,json=horizontalAccuracy" json:"horizontal_accuracy,omitempty"`
	// veritical accuracy (meters)
	VerticalAccuracy float64 `protobuf:"fixed64,4,opt,name=vertical_accuracy,json=verticalAccuracy" json:"vertical_accuracy,omitempty"`
	// On android only lat and long are guaranteed to be supplied
	// altitude in meters
	Altitude float64 `protobuf:"fixed64,5,opt,name=altitude" json:"altitude,omitempty"`
	// course (IOS) / bearing (Android) (degrees east relative to true north)
	Course float64 `protobuf:"fixed64,6,opt,name=course" json:"course,omitempty"`
	// speed (IOS) / velocity (Android) (meters/sec)
	Speed float64 `protobuf:"fixed64,7,opt,name=speed" json:"speed,omitempty"`
}

func (m *Loc) Reset()                    { *m = Loc{} }
func (m *Loc) String() string            { return proto.CompactTextString(m) }
func (*Loc) ProtoMessage()               {}
func (*Loc) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Loc) GetLat() float64 {
	if m != nil {
		return m.Lat
	}
	return 0
}

func (m *Loc) GetLong() float64 {
	if m != nil {
		return m.Long
	}
	return 0
}

func (m *Loc) GetHorizontalAccuracy() float64 {
	if m != nil {
		return m.HorizontalAccuracy
	}
	return 0
}

func (m *Loc) GetVerticalAccuracy() float64 {
	if m != nil {
		return m.VerticalAccuracy
	}
	return 0
}

func (m *Loc) GetAltitude() float64 {
	if m != nil {
		return m.Altitude
	}
	return 0
}

func (m *Loc) GetCourse() float64 {
	if m != nil {
		return m.Course
	}
	return 0
}

func (m *Loc) GetSpeed() float64 {
	if m != nil {
		return m.Speed
	}
	return 0
}

type Match_Engine_Request struct {
	Ver    uint32                      `protobuf:"varint,1,opt,name=ver" json:"ver,omitempty"`
	IdType Match_Engine_Request_IDType `protobuf:"varint,2,opt,name=id_type,json=idType,enum=distributed_match_engine.Match_Engine_Request_IDType" json:"id_type,omitempty"`
	// Actual ID
	Id string `protobuf:"bytes,3,opt,name=id" json:"id,omitempty"`
	// The carrier that user is connected to
	Carrier uint64 `protobuf:"varint,4,opt,name=carrier" json:"carrier,omitempty"`
	// The tower that user is currently connected to
	Tower uint64 `protobuf:"varint,5,opt,name=tower" json:"tower,omitempty"`
	// The GPS location of the user
	GpsLocation *Loc `protobuf:"bytes,6,opt,name=gps_location,json=gpsLocation" json:"gps_location,omitempty"`
	// Edge-cloud assigned application ID
	AppId uint64 `protobuf:"varint,7,opt,name=app_id,json=appId" json:"app_id,omitempty"`
	// Protocol application uses
	Protocol []byte `protobuf:"bytes,8,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// The protocol port on the server side
	ServerPort []byte `protobuf:"bytes,9,opt,name=server_port,json=serverPort,proto3" json:"server_port,omitempty"`
}

func (m *Match_Engine_Request) Reset()                    { *m = Match_Engine_Request{} }
func (m *Match_Engine_Request) String() string            { return proto.CompactTextString(m) }
func (*Match_Engine_Request) ProtoMessage()               {}
func (*Match_Engine_Request) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Match_Engine_Request) GetVer() uint32 {
	if m != nil {
		return m.Ver
	}
	return 0
}

func (m *Match_Engine_Request) GetIdType() Match_Engine_Request_IDType {
	if m != nil {
		return m.IdType
	}
	return Match_Engine_Request_IMEI
}

func (m *Match_Engine_Request) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Match_Engine_Request) GetCarrier() uint64 {
	if m != nil {
		return m.Carrier
	}
	return 0
}

func (m *Match_Engine_Request) GetTower() uint64 {
	if m != nil {
		return m.Tower
	}
	return 0
}

func (m *Match_Engine_Request) GetGpsLocation() *Loc {
	if m != nil {
		return m.GpsLocation
	}
	return nil
}

func (m *Match_Engine_Request) GetAppId() uint64 {
	if m != nil {
		return m.AppId
	}
	return 0
}

func (m *Match_Engine_Request) GetProtocol() []byte {
	if m != nil {
		return m.Protocol
	}
	return nil
}

func (m *Match_Engine_Request) GetServerPort() []byte {
	if m != nil {
		return m.ServerPort
	}
	return nil
}

type Match_Engine_Reply struct {
	Ver uint32 `protobuf:"varint,1,opt,name=ver" json:"ver,omitempty"`
	// ip of the app service
	ServiceIp []byte `protobuf:"bytes,2,opt,name=service_ip,json=serviceIp,proto3" json:"service_ip,omitempty"`
	// port of the app service?
	ServerPort uint32 `protobuf:"varint,3,opt,name=server_port,json=serverPort" json:"server_port,omitempty"`
	// location of the cloudlet?
	CloudletLocation *Loc `protobuf:"bytes,4,opt,name=cloudlet_location,json=cloudletLocation" json:"cloudlet_location,omitempty"`
}

func (m *Match_Engine_Reply) Reset()                    { *m = Match_Engine_Reply{} }
func (m *Match_Engine_Reply) String() string            { return proto.CompactTextString(m) }
func (*Match_Engine_Reply) ProtoMessage()               {}
func (*Match_Engine_Reply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Match_Engine_Reply) GetVer() uint32 {
	if m != nil {
		return m.Ver
	}
	return 0
}

func (m *Match_Engine_Reply) GetServiceIp() []byte {
	if m != nil {
		return m.ServiceIp
	}
	return nil
}

func (m *Match_Engine_Reply) GetServerPort() uint32 {
	if m != nil {
		return m.ServerPort
	}
	return 0
}

func (m *Match_Engine_Reply) GetCloudletLocation() *Loc {
	if m != nil {
		return m.CloudletLocation
	}
	return nil
}

type Match_Engine_Loc_Verify struct {
	Ver               uint32                                      `protobuf:"varint,1,opt,name=ver" json:"ver,omitempty"`
	TowerStatus       Match_Engine_Loc_Verify_Tower_Status        `protobuf:"varint,2,opt,name=tower_status,json=towerStatus,enum=distributed_match_engine.Match_Engine_Loc_Verify_Tower_Status" json:"tower_status,omitempty"`
	GpsLocationStatus Match_Engine_Loc_Verify_GPS_Location_Status `protobuf:"varint,3,opt,name=gps_location_status,json=gpsLocationStatus,enum=distributed_match_engine.Match_Engine_Loc_Verify_GPS_Location_Status" json:"gps_location_status,omitempty"`
}

func (m *Match_Engine_Loc_Verify) Reset()                    { *m = Match_Engine_Loc_Verify{} }
func (m *Match_Engine_Loc_Verify) String() string            { return proto.CompactTextString(m) }
func (*Match_Engine_Loc_Verify) ProtoMessage()               {}
func (*Match_Engine_Loc_Verify) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Match_Engine_Loc_Verify) GetVer() uint32 {
	if m != nil {
		return m.Ver
	}
	return 0
}

func (m *Match_Engine_Loc_Verify) GetTowerStatus() Match_Engine_Loc_Verify_Tower_Status {
	if m != nil {
		return m.TowerStatus
	}
	return Match_Engine_Loc_Verify_UNKNOWN
}

func (m *Match_Engine_Loc_Verify) GetGpsLocationStatus() Match_Engine_Loc_Verify_GPS_Location_Status {
	if m != nil {
		return m.GpsLocationStatus
	}
	return Match_Engine_Loc_Verify_LOC_UNKNOWN
}

func init() {
	proto.RegisterType((*Loc)(nil), "distributed_match_engine.Loc")
	proto.RegisterType((*Match_Engine_Request)(nil), "distributed_match_engine.Match_Engine_Request")
	proto.RegisterType((*Match_Engine_Reply)(nil), "distributed_match_engine.Match_Engine_Reply")
	proto.RegisterType((*Match_Engine_Loc_Verify)(nil), "distributed_match_engine.Match_Engine_Loc_Verify")
	proto.RegisterEnum("distributed_match_engine.Match_Engine_Request_IDType", Match_Engine_Request_IDType_name, Match_Engine_Request_IDType_value)
	proto.RegisterEnum("distributed_match_engine.Match_Engine_Loc_Verify_Tower_Status", Match_Engine_Loc_Verify_Tower_Status_name, Match_Engine_Loc_Verify_Tower_Status_value)
	proto.RegisterEnum("distributed_match_engine.Match_Engine_Loc_Verify_GPS_Location_Status", Match_Engine_Loc_Verify_GPS_Location_Status_name, Match_Engine_Loc_Verify_GPS_Location_Status_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Match_Engine_Api service

type Match_Engine_ApiClient interface {
	FindCloudlet(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Reply, error)
	VerifyLocation(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Loc_Verify, error)
}

type match_Engine_ApiClient struct {
	cc *grpc.ClientConn
}

func NewMatch_Engine_ApiClient(cc *grpc.ClientConn) Match_Engine_ApiClient {
	return &match_Engine_ApiClient{cc}
}

func (c *match_Engine_ApiClient) FindCloudlet(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Reply, error) {
	out := new(Match_Engine_Reply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/FindCloudlet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *match_Engine_ApiClient) VerifyLocation(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Loc_Verify, error) {
	out := new(Match_Engine_Loc_Verify)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/VerifyLocation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Match_Engine_Api service

type Match_Engine_ApiServer interface {
	FindCloudlet(context.Context, *Match_Engine_Request) (*Match_Engine_Reply, error)
	VerifyLocation(context.Context, *Match_Engine_Request) (*Match_Engine_Loc_Verify, error)
}

func RegisterMatch_Engine_ApiServer(s *grpc.Server, srv Match_Engine_ApiServer) {
	s.RegisterService(&_Match_Engine_Api_serviceDesc, srv)
}

func _Match_Engine_Api_FindCloudlet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Match_Engine_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).FindCloudlet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/FindCloudlet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).FindCloudlet(ctx, req.(*Match_Engine_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_Engine_Api_VerifyLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Match_Engine_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).VerifyLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/VerifyLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).VerifyLocation(ctx, req.(*Match_Engine_Request))
	}
	return interceptor(ctx, in, info, handler)
}

var _Match_Engine_Api_serviceDesc = grpc.ServiceDesc{
	ServiceName: "distributed_match_engine.Match_Engine_Api",
	HandlerType: (*Match_Engine_ApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FindCloudlet",
			Handler:    _Match_Engine_Api_FindCloudlet_Handler,
		},
		{
			MethodName: "VerifyLocation",
			Handler:    _Match_Engine_Api_VerifyLocation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app-client.proto",
}

func init() { proto.RegisterFile("app-client.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 672 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x53, 0x4f, 0x6f, 0xd3, 0x4e,
	0x10, 0x8d, 0x93, 0x34, 0x69, 0x27, 0x69, 0x7e, 0xce, 0xb4, 0x3f, 0xb0, 0x2a, 0xaa, 0x46, 0x16,
	0x87, 0x4a, 0x40, 0xa0, 0x45, 0xe2, 0x88, 0xa8, 0xd2, 0x14, 0x0c, 0x89, 0x53, 0x39, 0x81, 0x1e,
	0x57, 0xee, 0x7a, 0x49, 0x57, 0x32, 0xde, 0x65, 0xbd, 0x2e, 0x0a, 0x1f, 0x8b, 0x1b, 0x9f, 0x83,
	0x2f, 0xc2, 0x95, 0x1b, 0xca, 0xe6, 0x6f, 0xab, 0x14, 0x35, 0xb7, 0x7d, 0x33, 0xb3, 0x33, 0xef,
	0xbd, 0x9d, 0x05, 0x3b, 0x94, 0xf2, 0x19, 0x8d, 0x39, 0x4b, 0x74, 0x53, 0x2a, 0xa1, 0x05, 0x3a,
	0x11, 0x4f, 0xb5, 0xe2, 0x97, 0x99, 0x66, 0x11, 0xf9, 0x12, 0x6a, 0x7a, 0x45, 0x58, 0x32, 0xe4,
	0x09, 0x73, 0x7f, 0x59, 0x50, 0xe8, 0x08, 0x8a, 0x36, 0x14, 0xe2, 0x50, 0x3b, 0x56, 0xc3, 0x3a,
	0xb4, 0x82, 0xf1, 0x11, 0x11, 0x8a, 0xb1, 0x48, 0x86, 0x4e, 0xde, 0x84, 0xcc, 0x19, 0x9f, 0xc3,
	0xce, 0x95, 0x50, 0xfc, 0xbb, 0x48, 0x74, 0x18, 0x93, 0x90, 0xd2, 0x4c, 0x85, 0x74, 0xe4, 0x14,
	0x4c, 0x09, 0x2e, 0x52, 0x27, 0xd3, 0x0c, 0x3e, 0x81, 0xfa, 0x35, 0x53, 0x9a, 0xd3, 0xe5, 0xf2,
	0xa2, 0x29, 0xb7, 0x67, 0x89, 0x79, 0xf1, 0x1e, 0x6c, 0x86, 0xb1, 0xe6, 0x3a, 0x8b, 0x98, 0xb3,
	0x61, 0x6a, 0xe6, 0x18, 0x1f, 0x40, 0x89, 0x8a, 0x4c, 0xa5, 0xcc, 0x29, 0x99, 0xcc, 0x14, 0xe1,
	0x2e, 0x6c, 0xa4, 0x92, 0xb1, 0xc8, 0x29, 0x9b, 0xf0, 0x04, 0xb8, 0xbf, 0xf3, 0xb0, 0xdb, 0x35,
	0x32, 0xdb, 0x46, 0x26, 0x09, 0xd8, 0xd7, 0x8c, 0xa5, 0x7a, 0x2c, 0xf3, 0x9a, 0x29, 0x23, 0x73,
	0x3b, 0x18, 0x1f, 0xb1, 0x07, 0x65, 0x1e, 0x11, 0x3d, 0x92, 0xcc, 0x28, 0xad, 0x1d, 0xbf, 0x6a,
	0xde, 0x65, 0x56, 0x73, 0x55, 0xcb, 0xa6, 0x77, 0x6a, 0x6e, 0x07, 0x25, 0x1e, 0x0d, 0x46, 0x92,
	0x61, 0x0d, 0xf2, 0x3c, 0x32, 0x96, 0x6c, 0x05, 0x79, 0x1e, 0xa1, 0x03, 0x65, 0x1a, 0x2a, 0xc5,
	0x99, 0x32, 0xc2, 0x8b, 0xc1, 0x0c, 0x8e, 0xb9, 0x6b, 0xf1, 0x8d, 0x29, 0x23, 0xb6, 0x18, 0x4c,
	0x00, 0xbe, 0x81, 0xea, 0x50, 0xa6, 0x24, 0x16, 0x34, 0xd4, 0x5c, 0x24, 0x46, 0x6f, 0xe5, 0x78,
	0xff, 0x6e, 0x56, 0x1d, 0x41, 0x83, 0xca, 0x50, 0xa6, 0x9d, 0xe9, 0x0d, 0xfc, 0x1f, 0x4a, 0xa1,
	0x94, 0x84, 0x4f, 0x4c, 0x29, 0x06, 0x1b, 0xa1, 0x94, 0x5e, 0x34, 0xb6, 0xd7, 0x6c, 0x03, 0x15,
	0xb1, 0xb3, 0xd9, 0xb0, 0x0e, 0xab, 0xc1, 0x1c, 0xe3, 0x01, 0x54, 0x52, 0xa6, 0xae, 0x99, 0x22,
	0x52, 0x28, 0xed, 0x6c, 0x99, 0x34, 0x4c, 0x42, 0xe7, 0x42, 0x69, 0xf7, 0x00, 0xca, 0x53, 0xa1,
	0xb8, 0x09, 0x45, 0xaf, 0xdb, 0xf6, 0xec, 0x1c, 0x02, 0x94, 0xba, 0x7d, 0xaf, 0x7f, 0xea, 0xdb,
	0x96, 0xfb, 0xc3, 0x02, 0xbc, 0xe5, 0x8f, 0x8c, 0x47, 0x2b, 0x0c, 0xdf, 0x07, 0xd3, 0x97, 0x53,
	0x46, 0xb8, 0x34, 0x9e, 0x57, 0x83, 0xad, 0x69, 0xc4, 0x93, 0xb7, 0x99, 0x14, 0xcc, 0xc5, 0x25,
	0x26, 0xf8, 0x1e, 0xea, 0x34, 0x16, 0x59, 0x14, 0x33, 0xbd, 0x30, 0xa9, 0x78, 0x1f, 0x93, 0xec,
	0xd9, 0xbd, 0x99, 0x53, 0xee, 0xcf, 0x02, 0x3c, 0xbc, 0x41, 0xba, 0x23, 0x28, 0xf9, 0xc4, 0x14,
	0xff, 0xbc, 0x8a, 0x79, 0x08, 0x55, 0xf3, 0x44, 0x24, 0xd5, 0xa1, 0xce, 0xd2, 0xe9, 0xbe, 0xbc,
	0xbe, 0xe7, 0xbe, 0x2c, 0x5a, 0x37, 0x07, 0xa6, 0x4b, 0xdf, 0x74, 0x09, 0x2a, 0xa6, 0xe7, 0x04,
	0x60, 0x06, 0x3b, 0xcb, 0x8f, 0x3f, 0x9b, 0x54, 0x30, 0x93, 0xda, 0xeb, 0x4f, 0x7a, 0x7b, 0xde,
	0x27, 0x33, 0xb5, 0xb3, 0x81, 0xf5, 0xa5, 0x5d, 0x99, 0x84, 0x5c, 0x0a, 0xd5, 0x65, 0x4e, 0x58,
	0x81, 0xf2, 0x47, 0xff, 0x83, 0xdf, 0xbb, 0xf0, 0xed, 0x1c, 0x36, 0xe0, 0x51, 0xab, 0xe7, 0xfb,
	0xed, 0xd6, 0xa0, 0x7d, 0x4a, 0x06, 0x3d, 0xd2, 0x3f, 0x6f, 0xb7, 0xbc, 0x33, 0xcf, 0x80, 0x8b,
	0x76, 0x60, 0x5b, 0xf8, 0x18, 0x1a, 0x7e, 0x6f, 0x40, 0xfe, 0x59, 0x95, 0x77, 0xbb, 0xb0, 0xb3,
	0x82, 0x0e, 0xfe, 0x07, 0x95, 0x4e, 0xaf, 0x45, 0x16, 0xf3, 0xea, 0xb0, 0x3d, 0x0e, 0x5c, 0x78,
	0x83, 0x77, 0x9e, 0x4f, 0x8e, 0xba, 0xb6, 0x85, 0x08, 0xb5, 0xe5, 0xd0, 0x8b, 0xae, 0x9d, 0x3f,
	0xfe, 0x63, 0x81, 0x7d, 0x43, 0xf6, 0x89, 0xe4, 0x98, 0x40, 0xf5, 0x8c, 0x27, 0x51, 0x6b, 0xfa,
	0xd0, 0xd8, 0x5c, 0xef, 0x33, 0xef, 0x3d, 0xbd, 0x77, 0xbd, 0x8c, 0x47, 0x6e, 0x0e, 0x33, 0xa8,
	0x4d, 0x9c, 0x9e, 0x7f, 0xbe, 0x75, 0x27, 0x1e, 0xad, 0xfd, 0xa8, 0x6e, 0xee, 0xb2, 0x64, 0x3e,
	0xee, 0xcb, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xf8, 0x4a, 0x93, 0x6f, 0xea, 0x05, 0x00, 0x00,
}
