// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app-client.proto

/*
	Package distributed_match_engine is a generated protocol buffer package.

	It is generated from these files:
		app-client.proto
		appcommon.proto
		dynamic-location-group.proto
		loc.proto

	It has these top-level messages:
		RegisterClientRequest
		RegisterClientReply
		FindCloudletRequest
		FindCloudletReply
		VerifyLocationRequest
		VerifyLocationReply
		GetLocationRequest
		GetLocationReply
		AppInstListRequest
		Appinstance
		CloudletLocation
		AppInstListReply
		FqdnListRequest
		AppFqdn
		FqdnListReply
		DynamicLocGroupRequest
		DynamicLocGroupReply
		AppPort
		DlgMessage
		DlgReply
		Timestamp
		Loc
*/
package distributed_match_engine

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import binary "encoding/binary"

import "errors"
import "strconv"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type IDTypes int32

const (
	IDTypes_ID_UNDEFINED IDTypes = 0
	IDTypes_IMEI         IDTypes = 1
	IDTypes_MSISDN       IDTypes = 2
	IDTypes_IPADDR       IDTypes = 3
)

var IDTypes_name = map[int32]string{
	0: "ID_UNDEFINED",
	1: "IMEI",
	2: "MSISDN",
	3: "IPADDR",
}
var IDTypes_value = map[string]int32{
	"ID_UNDEFINED": 0,
	"IMEI":         1,
	"MSISDN":       2,
	"IPADDR":       3,
}

func (x IDTypes) String() string {
	return proto.EnumName(IDTypes_name, int32(x))
}
func (IDTypes) EnumDescriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{0} }

type ReplyStatus int32

const (
	ReplyStatus_RS_UNDEFINED ReplyStatus = 0
	ReplyStatus_RS_SUCCESS   ReplyStatus = 1
	ReplyStatus_RS_FAIL      ReplyStatus = 2
)

var ReplyStatus_name = map[int32]string{
	0: "RS_UNDEFINED",
	1: "RS_SUCCESS",
	2: "RS_FAIL",
}
var ReplyStatus_value = map[string]int32{
	"RS_UNDEFINED": 0,
	"RS_SUCCESS":   1,
	"RS_FAIL":      2,
}

func (x ReplyStatus) String() string {
	return proto.EnumName(ReplyStatus_name, int32(x))
}
func (ReplyStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{1} }

type FindCloudletReply_FindStatus int32

const (
	FindCloudletReply_FIND_UNKNOWN  FindCloudletReply_FindStatus = 0
	FindCloudletReply_FIND_FOUND    FindCloudletReply_FindStatus = 1
	FindCloudletReply_FIND_NOTFOUND FindCloudletReply_FindStatus = 2
)

var FindCloudletReply_FindStatus_name = map[int32]string{
	0: "FIND_UNKNOWN",
	1: "FIND_FOUND",
	2: "FIND_NOTFOUND",
}
var FindCloudletReply_FindStatus_value = map[string]int32{
	"FIND_UNKNOWN":  0,
	"FIND_FOUND":    1,
	"FIND_NOTFOUND": 2,
}

func (x FindCloudletReply_FindStatus) String() string {
	return proto.EnumName(FindCloudletReply_FindStatus_name, int32(x))
}
func (FindCloudletReply_FindStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{3, 0}
}

// Status of the reply
type VerifyLocationReply_Tower_Status int32

const (
	VerifyLocationReply_TOWER_UNKNOWN                    VerifyLocationReply_Tower_Status = 0
	VerifyLocationReply_CONNECTED_TO_SPECIFIED_TOWER     VerifyLocationReply_Tower_Status = 1
	VerifyLocationReply_NOT_CONNECTED_TO_SPECIFIED_TOWER VerifyLocationReply_Tower_Status = 2
)

var VerifyLocationReply_Tower_Status_name = map[int32]string{
	0: "TOWER_UNKNOWN",
	1: "CONNECTED_TO_SPECIFIED_TOWER",
	2: "NOT_CONNECTED_TO_SPECIFIED_TOWER",
}
var VerifyLocationReply_Tower_Status_value = map[string]int32{
	"TOWER_UNKNOWN":                    0,
	"CONNECTED_TO_SPECIFIED_TOWER":     1,
	"NOT_CONNECTED_TO_SPECIFIED_TOWER": 2,
}

func (x VerifyLocationReply_Tower_Status) String() string {
	return proto.EnumName(VerifyLocationReply_Tower_Status_name, int32(x))
}
func (VerifyLocationReply_Tower_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{5, 0}
}

type VerifyLocationReply_GPS_Location_Status int32

const (
	VerifyLocationReply_LOC_UNKNOWN                  VerifyLocationReply_GPS_Location_Status = 0
	VerifyLocationReply_LOC_VERIFIED                 VerifyLocationReply_GPS_Location_Status = 1
	VerifyLocationReply_LOC_MISMATCH_SAME_COUNTRY    VerifyLocationReply_GPS_Location_Status = 2
	VerifyLocationReply_LOC_MISMATCH_OTHER_COUNTRY   VerifyLocationReply_GPS_Location_Status = 3
	VerifyLocationReply_LOC_ROAMING_COUNTRY_MATCH    VerifyLocationReply_GPS_Location_Status = 4
	VerifyLocationReply_LOC_ROAMING_COUNTRY_MISMATCH VerifyLocationReply_GPS_Location_Status = 5
	VerifyLocationReply_LOC_ERROR_UNAUTHORIZED       VerifyLocationReply_GPS_Location_Status = 6
	VerifyLocationReply_LOC_ERROR_OTHER              VerifyLocationReply_GPS_Location_Status = 7
)

var VerifyLocationReply_GPS_Location_Status_name = map[int32]string{
	0: "LOC_UNKNOWN",
	1: "LOC_VERIFIED",
	2: "LOC_MISMATCH_SAME_COUNTRY",
	3: "LOC_MISMATCH_OTHER_COUNTRY",
	4: "LOC_ROAMING_COUNTRY_MATCH",
	5: "LOC_ROAMING_COUNTRY_MISMATCH",
	6: "LOC_ERROR_UNAUTHORIZED",
	7: "LOC_ERROR_OTHER",
}
var VerifyLocationReply_GPS_Location_Status_value = map[string]int32{
	"LOC_UNKNOWN":                  0,
	"LOC_VERIFIED":                 1,
	"LOC_MISMATCH_SAME_COUNTRY":    2,
	"LOC_MISMATCH_OTHER_COUNTRY":   3,
	"LOC_ROAMING_COUNTRY_MATCH":    4,
	"LOC_ROAMING_COUNTRY_MISMATCH": 5,
	"LOC_ERROR_UNAUTHORIZED":       6,
	"LOC_ERROR_OTHER":              7,
}

func (x VerifyLocationReply_GPS_Location_Status) String() string {
	return proto.EnumName(VerifyLocationReply_GPS_Location_Status_name, int32(x))
}
func (VerifyLocationReply_GPS_Location_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{5, 1}
}

// Status of the reply
type GetLocationReply_Loc_Status int32

const (
	GetLocationReply_LOC_UNKNOWN GetLocationReply_Loc_Status = 0
	GetLocationReply_LOC_FOUND   GetLocationReply_Loc_Status = 1
	// The user does not allow his location to be tracked
	GetLocationReply_LOC_DENIED GetLocationReply_Loc_Status = 2
)

var GetLocationReply_Loc_Status_name = map[int32]string{
	0: "LOC_UNKNOWN",
	1: "LOC_FOUND",
	2: "LOC_DENIED",
}
var GetLocationReply_Loc_Status_value = map[string]int32{
	"LOC_UNKNOWN": 0,
	"LOC_FOUND":   1,
	"LOC_DENIED":  2,
}

func (x GetLocationReply_Loc_Status) String() string {
	return proto.EnumName(GetLocationReply_Loc_Status_name, int32(x))
}
func (GetLocationReply_Loc_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{7, 0}
}

// Status of the reply
type AppInstListReply_AI_Status int32

const (
	AppInstListReply_AI_UNDEFINED AppInstListReply_AI_Status = 0
	AppInstListReply_AI_SUCCESS   AppInstListReply_AI_Status = 1
	AppInstListReply_AI_FAIL      AppInstListReply_AI_Status = 2
)

var AppInstListReply_AI_Status_name = map[int32]string{
	0: "AI_UNDEFINED",
	1: "AI_SUCCESS",
	2: "AI_FAIL",
}
var AppInstListReply_AI_Status_value = map[string]int32{
	"AI_UNDEFINED": 0,
	"AI_SUCCESS":   1,
	"AI_FAIL":      2,
}

func (x AppInstListReply_AI_Status) String() string {
	return proto.EnumName(AppInstListReply_AI_Status_name, int32(x))
}
func (AppInstListReply_AI_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{11, 0}
}

// Status of the reply
type FqdnListReply_FL_Status int32

const (
	FqdnListReply_FL_UNDEFINED FqdnListReply_FL_Status = 0
	FqdnListReply_FL_SUCCESS   FqdnListReply_FL_Status = 1
	FqdnListReply_FL_FAIL      FqdnListReply_FL_Status = 2
)

var FqdnListReply_FL_Status_name = map[int32]string{
	0: "FL_UNDEFINED",
	1: "FL_SUCCESS",
	2: "FL_FAIL",
}
var FqdnListReply_FL_Status_value = map[string]int32{
	"FL_UNDEFINED": 0,
	"FL_SUCCESS":   1,
	"FL_FAIL":      2,
}

func (x FqdnListReply_FL_Status) String() string {
	return proto.EnumName(FqdnListReply_FL_Status_name, int32(x))
}
func (FqdnListReply_FL_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{14, 0}
}

// Use Secure communication or Open with the group
type DynamicLocGroupRequest_DlgCommType int32

const (
	DynamicLocGroupRequest_DlgUndefined DynamicLocGroupRequest_DlgCommType = 0
	DynamicLocGroupRequest_DlgSecure    DynamicLocGroupRequest_DlgCommType = 1
	DynamicLocGroupRequest_DlgOpen      DynamicLocGroupRequest_DlgCommType = 2
)

var DynamicLocGroupRequest_DlgCommType_name = map[int32]string{
	0: "DlgUndefined",
	1: "DlgSecure",
	2: "DlgOpen",
}
var DynamicLocGroupRequest_DlgCommType_value = map[string]int32{
	"DlgUndefined": 0,
	"DlgSecure":    1,
	"DlgOpen":      2,
}

func (x DynamicLocGroupRequest_DlgCommType) String() string {
	return proto.EnumName(DynamicLocGroupRequest_DlgCommType_name, int32(x))
}
func (DynamicLocGroupRequest_DlgCommType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{15, 0}
}

type RegisterClientRequest struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=Ver,proto3" json:"Ver,omitempty"`
	// App Developer Name
	DevName string `protobuf:"bytes,2,opt,name=DevName,proto3" json:"DevName,omitempty"`
	// App Name
	AppName string `protobuf:"bytes,3,opt,name=AppName,proto3" json:"AppName,omitempty"`
	// App Version
	AppVers string `protobuf:"bytes,4,opt,name=AppVers,proto3" json:"AppVers,omitempty"`
	// carrier name, not currently used
	CarrierName string `protobuf:"bytes,5,opt,name=CarrierName,proto3" json:"CarrierName,omitempty"`
	// authentication token
	AuthToken string `protobuf:"bytes,6,opt,name=AuthToken,proto3" json:"AuthToken,omitempty"`
}

func (m *RegisterClientRequest) Reset()                    { *m = RegisterClientRequest{} }
func (m *RegisterClientRequest) String() string            { return proto.CompactTextString(m) }
func (*RegisterClientRequest) ProtoMessage()               {}
func (*RegisterClientRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{0} }

type RegisterClientReply struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=Ver,proto3" json:"Ver,omitempty"`
	// Status of the reply
	Status ReplyStatus `protobuf:"varint,2,opt,name=Status,proto3,enum=distributed_match_engine.ReplyStatus" json:"Status,omitempty"`
	// Session Cookie to be used in later API calls
	SessionCookie string `protobuf:"bytes,3,opt,name=SessionCookie,proto3" json:"SessionCookie,omitempty"`
	// URI for Token Server
	TokenServerURI string `protobuf:"bytes,4,opt,name=TokenServerURI,proto3" json:"TokenServerURI,omitempty"`
}

func (m *RegisterClientReply) Reset()                    { *m = RegisterClientReply{} }
func (m *RegisterClientReply) String() string            { return proto.CompactTextString(m) }
func (*RegisterClientReply) ProtoMessage()               {}
func (*RegisterClientReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{1} }

type FindCloudletRequest struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=Ver,proto3" json:"Ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=SessionCookie,proto3" json:"SessionCookie,omitempty"`
	// The carrier name that user is connected to ("Cellular Carrier Name")
	CarrierName string `protobuf:"bytes,3,opt,name=CarrierName,proto3" json:"CarrierName,omitempty"`
	// The GPS location of the user
	GpsLocation *Loc `protobuf:"bytes,4,opt,name=GpsLocation" json:"GpsLocation,omitempty"`
}

func (m *FindCloudletRequest) Reset()                    { *m = FindCloudletRequest{} }
func (m *FindCloudletRequest) String() string            { return proto.CompactTextString(m) }
func (*FindCloudletRequest) ProtoMessage()               {}
func (*FindCloudletRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{2} }

type FindCloudletReply struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=Ver,proto3" json:"Ver,omitempty"`
	// Status return
	Status FindCloudletReply_FindStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.FindCloudletReply_FindStatus" json:"status,omitempty"`
	// Full Qualified Domain Name of Closest App instance
	FQDN string `protobuf:"bytes,3,opt,name=FQDN,proto3" json:"FQDN,omitempty"`
	// List of Service Endpoints for AppInst
	Ports []*AppPort `protobuf:"bytes,4,rep,name=ports" json:"ports,omitempty"`
	// Location of the cloudlet
	CloudletLocation *Loc `protobuf:"bytes,5,opt,name=cloudlet_location,json=cloudletLocation" json:"cloudlet_location,omitempty"`
}

func (m *FindCloudletReply) Reset()                    { *m = FindCloudletReply{} }
func (m *FindCloudletReply) String() string            { return proto.CompactTextString(m) }
func (*FindCloudletReply) ProtoMessage()               {}
func (*FindCloudletReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{3} }

type VerifyLocationRequest struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=Ver,proto3" json:"Ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=SessionCookie,proto3" json:"SessionCookie,omitempty"`
	// The carrier name that user is connected to ("Cellular Carrier Name")
	CarrierName string `protobuf:"bytes,3,opt,name=CarrierName,proto3" json:"CarrierName,omitempty"`
	// The GPS location to verify
	GpsLocation *Loc `protobuf:"bytes,4,opt,name=GpsLocation" json:"GpsLocation,omitempty"`
	// token used for location verification, app must retrieve from TokenServerURI
	VerifyLocToken string `protobuf:"bytes,5,opt,name=VerifyLocToken,proto3" json:"VerifyLocToken,omitempty"`
}

func (m *VerifyLocationRequest) Reset()                    { *m = VerifyLocationRequest{} }
func (m *VerifyLocationRequest) String() string            { return proto.CompactTextString(m) }
func (*VerifyLocationRequest) ProtoMessage()               {}
func (*VerifyLocationRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{4} }

type VerifyLocationReply struct {
	// API version
	Ver               uint32                                  `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	TowerStatus       VerifyLocationReply_Tower_Status        `protobuf:"varint,2,opt,name=tower_status,json=towerStatus,proto3,enum=distributed_match_engine.VerifyLocationReply_Tower_Status" json:"tower_status,omitempty"`
	GpsLocationStatus VerifyLocationReply_GPS_Location_Status `protobuf:"varint,3,opt,name=gps_location_status,json=gpsLocationStatus,proto3,enum=distributed_match_engine.VerifyLocationReply_GPS_Location_Status" json:"gps_location_status,omitempty"`
	// location accuracy, the location is verified to
	// be within this number of kilometers.  Negative value
	// means no verification was done
	GPS_Location_Accuracy_KM float64 `protobuf:"fixed64,4,opt,name=GPS_Location_Accuracy_KM,json=GPSLocationAccuracyKM,proto3" json:"GPS_Location_Accuracy_KM,omitempty"`
}

func (m *VerifyLocationReply) Reset()                    { *m = VerifyLocationReply{} }
func (m *VerifyLocationReply) String() string            { return proto.CompactTextString(m) }
func (*VerifyLocationReply) ProtoMessage()               {}
func (*VerifyLocationReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{5} }

type GetLocationRequest struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=Ver,proto3" json:"Ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=SessionCookie,proto3" json:"SessionCookie,omitempty"`
	// The carrier name that user is connected to ("Cellular Carrier Name")
	CarrierName string `protobuf:"bytes,3,opt,name=CarrierName,proto3" json:"CarrierName,omitempty"`
}

func (m *GetLocationRequest) Reset()                    { *m = GetLocationRequest{} }
func (m *GetLocationRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLocationRequest) ProtoMessage()               {}
func (*GetLocationRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{6} }

type GetLocationReply struct {
	Ver    uint32                      `protobuf:"varint,1,opt,name=Ver,proto3" json:"Ver,omitempty"`
	Status GetLocationReply_Loc_Status `protobuf:"varint,2,opt,name=Status,proto3,enum=distributed_match_engine.GetLocationReply_Loc_Status" json:"Status,omitempty"`
	// The carrier name that user is connected to ("Cellular Carrier Name")
	CarrierName string `protobuf:"bytes,3,opt,name=CarrierName,proto3" json:"CarrierName,omitempty"`
	// The tower that user is currently connected to
	Tower uint64 `protobuf:"varint,4,opt,name=Tower,proto3" json:"Tower,omitempty"`
	// The GPS location of the user
	NetworkLocation *Loc `protobuf:"bytes,5,opt,name=NetworkLocation" json:"NetworkLocation,omitempty"`
}

func (m *GetLocationReply) Reset()                    { *m = GetLocationReply{} }
func (m *GetLocationReply) String() string            { return proto.CompactTextString(m) }
func (*GetLocationReply) ProtoMessage()               {}
func (*GetLocationReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{7} }

type AppInstListRequest struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=Ver,proto3" json:"Ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=SessionCookie,proto3" json:"SessionCookie,omitempty"`
	// The carrier name that user is connected to ("Cellular Carrier Name")
	CarrierName string `protobuf:"bytes,3,opt,name=CarrierName,proto3" json:"CarrierName,omitempty"`
	// The GPS location of the user
	GpsLocation *Loc `protobuf:"bytes,4,opt,name=GpsLocation" json:"GpsLocation,omitempty"`
}

func (m *AppInstListRequest) Reset()                    { *m = AppInstListRequest{} }
func (m *AppInstListRequest) String() string            { return proto.CompactTextString(m) }
func (*AppInstListRequest) ProtoMessage()               {}
func (*AppInstListRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{8} }

type Appinstance struct {
	// App Instance Name
	AppName string `protobuf:"bytes,1,opt,name=AppName,proto3" json:"AppName,omitempty"`
	// App Instance Version
	AppVers string `protobuf:"bytes,2,opt,name=AppVers,proto3" json:"AppVers,omitempty"`
	// App Instance FQDN
	FQDN string `protobuf:"bytes,3,opt,name=FQDN,proto3" json:"FQDN,omitempty"`
	// ports to access app
	Ports []*AppPort `protobuf:"bytes,4,rep,name=ports" json:"ports,omitempty"`
}

func (m *Appinstance) Reset()                    { *m = Appinstance{} }
func (m *Appinstance) String() string            { return proto.CompactTextString(m) }
func (*Appinstance) ProtoMessage()               {}
func (*Appinstance) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{9} }

type CloudletLocation struct {
	// The carrier name that user is connected to ("Cellular Carrier Name")
	CarrierName string `protobuf:"bytes,1,opt,name=CarrierName,proto3" json:"CarrierName,omitempty"`
	// Cloudlet Name
	CloudletName string `protobuf:"bytes,2,opt,name=CloudletName,proto3" json:"CloudletName,omitempty"`
	// The GPS Location of the user
	GpsLocation *Loc `protobuf:"bytes,3,opt,name=GpsLocation" json:"GpsLocation,omitempty"`
	// Distance of cloudlet vs loc in request
	Distance float64 `protobuf:"fixed64,4,opt,name=Distance,proto3" json:"Distance,omitempty"`
	// App instances
	Appinstances []*Appinstance `protobuf:"bytes,5,rep,name=Appinstances" json:"Appinstances,omitempty"`
}

func (m *CloudletLocation) Reset()                    { *m = CloudletLocation{} }
func (m *CloudletLocation) String() string            { return proto.CompactTextString(m) }
func (*CloudletLocation) ProtoMessage()               {}
func (*CloudletLocation) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{10} }

type AppInstListReply struct {
	// API version
	Ver       uint32                     `protobuf:"varint,1,opt,name=Ver,proto3" json:"Ver,omitempty"`
	Status    AppInstListReply_AI_Status `protobuf:"varint,2,opt,name=Status,proto3,enum=distributed_match_engine.AppInstListReply_AI_Status" json:"Status,omitempty"`
	Cloudlets []*CloudletLocation        `protobuf:"bytes,3,rep,name=Cloudlets" json:"Cloudlets,omitempty"`
}

func (m *AppInstListReply) Reset()                    { *m = AppInstListReply{} }
func (m *AppInstListReply) String() string            { return proto.CompactTextString(m) }
func (*AppInstListReply) ProtoMessage()               {}
func (*AppInstListReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{11} }

type FqdnListRequest struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=Ver,proto3" json:"Ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=SessionCookie,proto3" json:"SessionCookie,omitempty"`
}

func (m *FqdnListRequest) Reset()                    { *m = FqdnListRequest{} }
func (m *FqdnListRequest) String() string            { return proto.CompactTextString(m) }
func (*FqdnListRequest) ProtoMessage()               {}
func (*FqdnListRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{12} }

type AppFqdn struct {
	// App  Name
	AppName string `protobuf:"bytes,1,opt,name=AppName,proto3" json:"AppName,omitempty"`
	// App Version
	AppVers string `protobuf:"bytes,2,opt,name=AppVers,proto3" json:"AppVers,omitempty"`
	// developer name
	DevName string `protobuf:"bytes,3,opt,name=DevName,proto3" json:"DevName,omitempty"`
	// App FQDN
	FQDN string `protobuf:"bytes,4,opt,name=FQDN,proto3" json:"FQDN,omitempty"`
}

func (m *AppFqdn) Reset()                    { *m = AppFqdn{} }
func (m *AppFqdn) String() string            { return proto.CompactTextString(m) }
func (*AppFqdn) ProtoMessage()               {}
func (*AppFqdn) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{13} }

type FqdnListReply struct {
	// API version
	Ver      uint32                  `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	AppFqdns []*AppFqdn              `protobuf:"bytes,3,rep,name=AppFqdns" json:"AppFqdns,omitempty"`
	Status   FqdnListReply_FL_Status `protobuf:"varint,4,opt,name=Status,proto3,enum=distributed_match_engine.FqdnListReply_FL_Status" json:"Status,omitempty"`
}

func (m *FqdnListReply) Reset()                    { *m = FqdnListReply{} }
func (m *FqdnListReply) String() string            { return proto.CompactTextString(m) }
func (*FqdnListReply) ProtoMessage()               {}
func (*FqdnListReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{14} }

type DynamicLocGroupRequest struct {
	Ver uint32 `protobuf:"varint,1,opt,name=Ver,proto3" json:"Ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=SessionCookie,proto3" json:"SessionCookie,omitempty"`
	// Dynamic Location Group Id
	LgId     uint64                             `protobuf:"varint,3,opt,name=LgId,proto3" json:"LgId,omitempty"`
	CommType DynamicLocGroupRequest_DlgCommType `protobuf:"varint,11,opt,name=CommType,proto3,enum=distributed_match_engine.DynamicLocGroupRequest_DlgCommType" json:"CommType,omitempty"`
	// Unused
	UserData string `protobuf:"bytes,12,opt,name=UserData,proto3" json:"UserData,omitempty"`
}

func (m *DynamicLocGroupRequest) Reset()                    { *m = DynamicLocGroupRequest{} }
func (m *DynamicLocGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*DynamicLocGroupRequest) ProtoMessage()               {}
func (*DynamicLocGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{15} }

type DynamicLocGroupReply struct {
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Status of the reply
	Status ReplyStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.ReplyStatus" json:"status,omitempty"`
	// Error Code based on Failure
	ErrorCode uint32 `protobuf:"varint,3,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	// Group Cookie for Secure Group Communication
	GroupCookie string `protobuf:"bytes,5,opt,name=GroupCookie,proto3" json:"GroupCookie,omitempty"`
}

func (m *DynamicLocGroupReply) Reset()                    { *m = DynamicLocGroupReply{} }
func (m *DynamicLocGroupReply) String() string            { return proto.CompactTextString(m) }
func (*DynamicLocGroupReply) ProtoMessage()               {}
func (*DynamicLocGroupReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{16} }

func init() {
	proto.RegisterType((*RegisterClientRequest)(nil), "distributed_match_engine.RegisterClientRequest")
	proto.RegisterType((*RegisterClientReply)(nil), "distributed_match_engine.RegisterClientReply")
	proto.RegisterType((*FindCloudletRequest)(nil), "distributed_match_engine.FindCloudletRequest")
	proto.RegisterType((*FindCloudletReply)(nil), "distributed_match_engine.FindCloudletReply")
	proto.RegisterType((*VerifyLocationRequest)(nil), "distributed_match_engine.VerifyLocationRequest")
	proto.RegisterType((*VerifyLocationReply)(nil), "distributed_match_engine.VerifyLocationReply")
	proto.RegisterType((*GetLocationRequest)(nil), "distributed_match_engine.GetLocationRequest")
	proto.RegisterType((*GetLocationReply)(nil), "distributed_match_engine.GetLocationReply")
	proto.RegisterType((*AppInstListRequest)(nil), "distributed_match_engine.AppInstListRequest")
	proto.RegisterType((*Appinstance)(nil), "distributed_match_engine.Appinstance")
	proto.RegisterType((*CloudletLocation)(nil), "distributed_match_engine.CloudletLocation")
	proto.RegisterType((*AppInstListReply)(nil), "distributed_match_engine.AppInstListReply")
	proto.RegisterType((*FqdnListRequest)(nil), "distributed_match_engine.FqdnListRequest")
	proto.RegisterType((*AppFqdn)(nil), "distributed_match_engine.AppFqdn")
	proto.RegisterType((*FqdnListReply)(nil), "distributed_match_engine.FqdnListReply")
	proto.RegisterType((*DynamicLocGroupRequest)(nil), "distributed_match_engine.DynamicLocGroupRequest")
	proto.RegisterType((*DynamicLocGroupReply)(nil), "distributed_match_engine.DynamicLocGroupReply")
	proto.RegisterEnum("distributed_match_engine.IDTypes", IDTypes_name, IDTypes_value)
	proto.RegisterEnum("distributed_match_engine.ReplyStatus", ReplyStatus_name, ReplyStatus_value)
	proto.RegisterEnum("distributed_match_engine.FindCloudletReply_FindStatus", FindCloudletReply_FindStatus_name, FindCloudletReply_FindStatus_value)
	proto.RegisterEnum("distributed_match_engine.VerifyLocationReply_Tower_Status", VerifyLocationReply_Tower_Status_name, VerifyLocationReply_Tower_Status_value)
	proto.RegisterEnum("distributed_match_engine.VerifyLocationReply_GPS_Location_Status", VerifyLocationReply_GPS_Location_Status_name, VerifyLocationReply_GPS_Location_Status_value)
	proto.RegisterEnum("distributed_match_engine.GetLocationReply_Loc_Status", GetLocationReply_Loc_Status_name, GetLocationReply_Loc_Status_value)
	proto.RegisterEnum("distributed_match_engine.AppInstListReply_AI_Status", AppInstListReply_AI_Status_name, AppInstListReply_AI_Status_value)
	proto.RegisterEnum("distributed_match_engine.FqdnListReply_FL_Status", FqdnListReply_FL_Status_name, FqdnListReply_FL_Status_value)
	proto.RegisterEnum("distributed_match_engine.DynamicLocGroupRequest_DlgCommType", DynamicLocGroupRequest_DlgCommType_name, DynamicLocGroupRequest_DlgCommType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Match_Engine_Api service

type Match_Engine_ApiClient interface {
	RegisterClient(ctx context.Context, in *RegisterClientRequest, opts ...grpc.CallOption) (*RegisterClientReply, error)
	FindCloudlet(ctx context.Context, in *FindCloudletRequest, opts ...grpc.CallOption) (*FindCloudletReply, error)
	VerifyLocation(ctx context.Context, in *VerifyLocationRequest, opts ...grpc.CallOption) (*VerifyLocationReply, error)
	GetLocation(ctx context.Context, in *GetLocationRequest, opts ...grpc.CallOption) (*GetLocationReply, error)
	AddUserToGroup(ctx context.Context, in *DynamicLocGroupRequest, opts ...grpc.CallOption) (*DynamicLocGroupReply, error)
	GetAppInstList(ctx context.Context, in *AppInstListRequest, opts ...grpc.CallOption) (*AppInstListReply, error)
	GetFqdnList(ctx context.Context, in *FqdnListRequest, opts ...grpc.CallOption) (*FqdnListReply, error)
}

type match_Engine_ApiClient struct {
	cc *grpc.ClientConn
}

func NewMatch_Engine_ApiClient(cc *grpc.ClientConn) Match_Engine_ApiClient {
	return &match_Engine_ApiClient{cc}
}

func (c *match_Engine_ApiClient) RegisterClient(ctx context.Context, in *RegisterClientRequest, opts ...grpc.CallOption) (*RegisterClientReply, error) {
	out := new(RegisterClientReply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/RegisterClient", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *match_Engine_ApiClient) FindCloudlet(ctx context.Context, in *FindCloudletRequest, opts ...grpc.CallOption) (*FindCloudletReply, error) {
	out := new(FindCloudletReply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/FindCloudlet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *match_Engine_ApiClient) VerifyLocation(ctx context.Context, in *VerifyLocationRequest, opts ...grpc.CallOption) (*VerifyLocationReply, error) {
	out := new(VerifyLocationReply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/VerifyLocation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *match_Engine_ApiClient) GetLocation(ctx context.Context, in *GetLocationRequest, opts ...grpc.CallOption) (*GetLocationReply, error) {
	out := new(GetLocationReply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/GetLocation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *match_Engine_ApiClient) AddUserToGroup(ctx context.Context, in *DynamicLocGroupRequest, opts ...grpc.CallOption) (*DynamicLocGroupReply, error) {
	out := new(DynamicLocGroupReply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/AddUserToGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *match_Engine_ApiClient) GetAppInstList(ctx context.Context, in *AppInstListRequest, opts ...grpc.CallOption) (*AppInstListReply, error) {
	out := new(AppInstListReply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/GetAppInstList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *match_Engine_ApiClient) GetFqdnList(ctx context.Context, in *FqdnListRequest, opts ...grpc.CallOption) (*FqdnListReply, error) {
	out := new(FqdnListReply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/GetFqdnList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Match_Engine_Api service

type Match_Engine_ApiServer interface {
	RegisterClient(context.Context, *RegisterClientRequest) (*RegisterClientReply, error)
	FindCloudlet(context.Context, *FindCloudletRequest) (*FindCloudletReply, error)
	VerifyLocation(context.Context, *VerifyLocationRequest) (*VerifyLocationReply, error)
	GetLocation(context.Context, *GetLocationRequest) (*GetLocationReply, error)
	AddUserToGroup(context.Context, *DynamicLocGroupRequest) (*DynamicLocGroupReply, error)
	GetAppInstList(context.Context, *AppInstListRequest) (*AppInstListReply, error)
	GetFqdnList(context.Context, *FqdnListRequest) (*FqdnListReply, error)
}

func RegisterMatch_Engine_ApiServer(s *grpc.Server, srv Match_Engine_ApiServer) {
	s.RegisterService(&_Match_Engine_Api_serviceDesc, srv)
}

func _Match_Engine_Api_RegisterClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).RegisterClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/RegisterClient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).RegisterClient(ctx, req.(*RegisterClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_Engine_Api_FindCloudlet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindCloudletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).FindCloudlet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/FindCloudlet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).FindCloudlet(ctx, req.(*FindCloudletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_Engine_Api_VerifyLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).VerifyLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/VerifyLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).VerifyLocation(ctx, req.(*VerifyLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_Engine_Api_GetLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).GetLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/GetLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).GetLocation(ctx, req.(*GetLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_Engine_Api_AddUserToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DynamicLocGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).AddUserToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/AddUserToGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).AddUserToGroup(ctx, req.(*DynamicLocGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_Engine_Api_GetAppInstList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInstListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).GetAppInstList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/GetAppInstList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).GetAppInstList(ctx, req.(*AppInstListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_Engine_Api_GetFqdnList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FqdnListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).GetFqdnList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/GetFqdnList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).GetFqdnList(ctx, req.(*FqdnListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Match_Engine_Api_serviceDesc = grpc.ServiceDesc{
	ServiceName: "distributed_match_engine.Match_Engine_Api",
	HandlerType: (*Match_Engine_ApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterClient",
			Handler:    _Match_Engine_Api_RegisterClient_Handler,
		},
		{
			MethodName: "FindCloudlet",
			Handler:    _Match_Engine_Api_FindCloudlet_Handler,
		},
		{
			MethodName: "VerifyLocation",
			Handler:    _Match_Engine_Api_VerifyLocation_Handler,
		},
		{
			MethodName: "GetLocation",
			Handler:    _Match_Engine_Api_GetLocation_Handler,
		},
		{
			MethodName: "AddUserToGroup",
			Handler:    _Match_Engine_Api_AddUserToGroup_Handler,
		},
		{
			MethodName: "GetAppInstList",
			Handler:    _Match_Engine_Api_GetAppInstList_Handler,
		},
		{
			MethodName: "GetFqdnList",
			Handler:    _Match_Engine_Api_GetFqdnList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app-client.proto",
}

func (m *RegisterClientRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterClientRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.DevName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.DevName)))
		i += copy(dAtA[i:], m.DevName)
	}
	if len(m.AppName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppName)))
		i += copy(dAtA[i:], m.AppName)
	}
	if len(m.AppVers) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppVers)))
		i += copy(dAtA[i:], m.AppVers)
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if len(m.AuthToken) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AuthToken)))
		i += copy(dAtA[i:], m.AuthToken)
	}
	return i, nil
}

func (m *RegisterClientReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterClientReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if len(m.TokenServerURI) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.TokenServerURI)))
		i += copy(dAtA[i:], m.TokenServerURI)
	}
	return i, nil
}

func (m *FindCloudletRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindCloudletRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n1, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *FindCloudletReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindCloudletReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if len(m.FQDN) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.FQDN)))
		i += copy(dAtA[i:], m.FQDN)
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CloudletLocation != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CloudletLocation.Size()))
		n2, err := m.CloudletLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *VerifyLocationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyLocationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n3, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.VerifyLocToken) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.VerifyLocToken)))
		i += copy(dAtA[i:], m.VerifyLocToken)
	}
	return i, nil
}

func (m *VerifyLocationReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyLocationReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.TowerStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.TowerStatus))
	}
	if m.GpsLocationStatus != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocationStatus))
	}
	if m.GPS_Location_Accuracy_KM != 0 {
		dAtA[i] = 0x21
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GPS_Location_Accuracy_KM))))
		i += 8
	}
	return i, nil
}

func (m *GetLocationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLocationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	return i, nil
}

func (m *GetLocationReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLocationReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if m.Tower != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Tower))
	}
	if m.NetworkLocation != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.NetworkLocation.Size()))
		n4, err := m.NetworkLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *AppInstListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n5, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *Appinstance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Appinstance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppName)))
		i += copy(dAtA[i:], m.AppName)
	}
	if len(m.AppVers) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppVers)))
		i += copy(dAtA[i:], m.AppVers)
	}
	if len(m.FQDN) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.FQDN)))
		i += copy(dAtA[i:], m.FQDN)
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CloudletLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletLocation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if len(m.CloudletName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CloudletName)))
		i += copy(dAtA[i:], m.CloudletName)
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n6, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Distance != 0 {
		dAtA[i] = 0x21
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Distance))))
		i += 8
	}
	if len(m.Appinstances) > 0 {
		for _, msg := range m.Appinstances {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AppInstListReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstListReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if len(m.Cloudlets) > 0 {
		for _, msg := range m.Cloudlets {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FqdnListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FqdnListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	return i, nil
}

func (m *AppFqdn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppFqdn) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppName)))
		i += copy(dAtA[i:], m.AppName)
	}
	if len(m.AppVers) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppVers)))
		i += copy(dAtA[i:], m.AppVers)
	}
	if len(m.DevName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.DevName)))
		i += copy(dAtA[i:], m.DevName)
	}
	if len(m.FQDN) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.FQDN)))
		i += copy(dAtA[i:], m.FQDN)
	}
	return i, nil
}

func (m *FqdnListReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FqdnListReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.AppFqdns) > 0 {
		for _, msg := range m.AppFqdns {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Status != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *DynamicLocGroupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicLocGroupRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if m.LgId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.LgId))
	}
	if m.CommType != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CommType))
	}
	if len(m.UserData) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.UserData)))
		i += copy(dAtA[i:], m.UserData)
	}
	return i, nil
}

func (m *DynamicLocGroupReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicLocGroupReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.GroupCookie) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.GroupCookie)))
		i += copy(dAtA[i:], m.GroupCookie)
	}
	return i, nil
}

func encodeVarintAppClient(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RegisterClientRequest) CopyInFields(src *RegisterClientRequest) {
	m.Ver = src.Ver
	m.DevName = src.DevName
	m.AppName = src.AppName
	m.AppVers = src.AppVers
	m.CarrierName = src.CarrierName
	m.AuthToken = src.AuthToken
}

// Helper method to check that enums have valid values
func (m *RegisterClientRequest) ValidateEnums() error {
	return nil
}

func (m *RegisterClientReply) CopyInFields(src *RegisterClientReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	m.SessionCookie = src.SessionCookie
	m.TokenServerURI = src.TokenServerURI
}

// Helper method to check that enums have valid values
func (m *RegisterClientReply) ValidateEnums() error {
	if _, ok := ReplyStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	return nil
}

func (m *FindCloudletRequest) CopyInFields(src *FindCloudletRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.CarrierName = src.CarrierName
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		m.GpsLocation.Lat = src.GpsLocation.Lat
		m.GpsLocation.Long = src.GpsLocation.Long
		m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
		m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
		m.GpsLocation.Altitude = src.GpsLocation.Altitude
		m.GpsLocation.Course = src.GpsLocation.Course
		m.GpsLocation.Speed = src.GpsLocation.Speed
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &Timestamp{}
			m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
			m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
		}
	}
}

// Helper method to check that enums have valid values
func (m *FindCloudletRequest) ValidateEnums() error {
	if err := m.GpsLocation.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *FindCloudletReply) CopyInFields(src *FindCloudletReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	m.FQDN = src.FQDN
	if src.Ports != nil {
		if m.Ports == nil || len(m.Ports) != len(src.Ports) {
			m.Ports = make([]*AppPort, len(src.Ports))
		}
		for i0 := 0; i0 < len(src.Ports); i0++ {
			m.Ports[i0] = &AppPort{}
			m.Ports[i0].Proto = src.Ports[i0].Proto
			m.Ports[i0].InternalPort = src.Ports[i0].InternalPort
			m.Ports[i0].PublicPort = src.Ports[i0].PublicPort
			m.Ports[i0].PublicPath = src.Ports[i0].PublicPath
			m.Ports[i0].FQDNPrefix = src.Ports[i0].FQDNPrefix
		}
	}
	if src.CloudletLocation != nil {
		m.CloudletLocation = &Loc{}
		m.CloudletLocation.Lat = src.CloudletLocation.Lat
		m.CloudletLocation.Long = src.CloudletLocation.Long
		m.CloudletLocation.HorizontalAccuracy = src.CloudletLocation.HorizontalAccuracy
		m.CloudletLocation.VerticalAccuracy = src.CloudletLocation.VerticalAccuracy
		m.CloudletLocation.Altitude = src.CloudletLocation.Altitude
		m.CloudletLocation.Course = src.CloudletLocation.Course
		m.CloudletLocation.Speed = src.CloudletLocation.Speed
		if src.CloudletLocation.Timestamp != nil {
			m.CloudletLocation.Timestamp = &Timestamp{}
			m.CloudletLocation.Timestamp.Seconds = src.CloudletLocation.Timestamp.Seconds
			m.CloudletLocation.Timestamp.Nanos = src.CloudletLocation.Timestamp.Nanos
		}
	}
}

// Helper method to check that enums have valid values
func (m *FindCloudletReply) ValidateEnums() error {
	if _, ok := FindCloudletReply_FindStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	for _, e := range m.Ports {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if err := m.CloudletLocation.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *VerifyLocationRequest) CopyInFields(src *VerifyLocationRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.CarrierName = src.CarrierName
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		m.GpsLocation.Lat = src.GpsLocation.Lat
		m.GpsLocation.Long = src.GpsLocation.Long
		m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
		m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
		m.GpsLocation.Altitude = src.GpsLocation.Altitude
		m.GpsLocation.Course = src.GpsLocation.Course
		m.GpsLocation.Speed = src.GpsLocation.Speed
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &Timestamp{}
			m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
			m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
		}
	}
	m.VerifyLocToken = src.VerifyLocToken
}

// Helper method to check that enums have valid values
func (m *VerifyLocationRequest) ValidateEnums() error {
	if err := m.GpsLocation.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *VerifyLocationReply) CopyInFields(src *VerifyLocationReply) {
	m.Ver = src.Ver
	m.TowerStatus = src.TowerStatus
	m.GpsLocationStatus = src.GpsLocationStatus
	m.GPS_Location_Accuracy_KM = src.GPS_Location_Accuracy_KM
}

// Helper method to check that enums have valid values
func (m *VerifyLocationReply) ValidateEnums() error {
	if _, ok := VerifyLocationReply_Tower_Status_name[int32(m.TowerStatus)]; !ok {
		return errors.New("invalid TowerStatus")
	}
	if _, ok := VerifyLocationReply_GPS_Location_Status_name[int32(m.GpsLocationStatus)]; !ok {
		return errors.New("invalid GpsLocationStatus")
	}
	return nil
}

func (m *GetLocationRequest) CopyInFields(src *GetLocationRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.CarrierName = src.CarrierName
}

// Helper method to check that enums have valid values
func (m *GetLocationRequest) ValidateEnums() error {
	return nil
}

func (m *GetLocationReply) CopyInFields(src *GetLocationReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	m.CarrierName = src.CarrierName
	m.Tower = src.Tower
	if src.NetworkLocation != nil {
		m.NetworkLocation = &Loc{}
		m.NetworkLocation.Lat = src.NetworkLocation.Lat
		m.NetworkLocation.Long = src.NetworkLocation.Long
		m.NetworkLocation.HorizontalAccuracy = src.NetworkLocation.HorizontalAccuracy
		m.NetworkLocation.VerticalAccuracy = src.NetworkLocation.VerticalAccuracy
		m.NetworkLocation.Altitude = src.NetworkLocation.Altitude
		m.NetworkLocation.Course = src.NetworkLocation.Course
		m.NetworkLocation.Speed = src.NetworkLocation.Speed
		if src.NetworkLocation.Timestamp != nil {
			m.NetworkLocation.Timestamp = &Timestamp{}
			m.NetworkLocation.Timestamp.Seconds = src.NetworkLocation.Timestamp.Seconds
			m.NetworkLocation.Timestamp.Nanos = src.NetworkLocation.Timestamp.Nanos
		}
	}
}

// Helper method to check that enums have valid values
func (m *GetLocationReply) ValidateEnums() error {
	if _, ok := GetLocationReply_Loc_Status_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	if err := m.NetworkLocation.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *AppInstListRequest) CopyInFields(src *AppInstListRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.CarrierName = src.CarrierName
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		m.GpsLocation.Lat = src.GpsLocation.Lat
		m.GpsLocation.Long = src.GpsLocation.Long
		m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
		m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
		m.GpsLocation.Altitude = src.GpsLocation.Altitude
		m.GpsLocation.Course = src.GpsLocation.Course
		m.GpsLocation.Speed = src.GpsLocation.Speed
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &Timestamp{}
			m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
			m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
		}
	}
}

// Helper method to check that enums have valid values
func (m *AppInstListRequest) ValidateEnums() error {
	if err := m.GpsLocation.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *Appinstance) CopyInFields(src *Appinstance) {
	m.AppName = src.AppName
	m.AppVers = src.AppVers
	m.FQDN = src.FQDN
	if src.Ports != nil {
		if m.Ports == nil || len(m.Ports) != len(src.Ports) {
			m.Ports = make([]*AppPort, len(src.Ports))
		}
		for i0 := 0; i0 < len(src.Ports); i0++ {
			m.Ports[i0] = &AppPort{}
			m.Ports[i0].Proto = src.Ports[i0].Proto
			m.Ports[i0].InternalPort = src.Ports[i0].InternalPort
			m.Ports[i0].PublicPort = src.Ports[i0].PublicPort
			m.Ports[i0].PublicPath = src.Ports[i0].PublicPath
			m.Ports[i0].FQDNPrefix = src.Ports[i0].FQDNPrefix
		}
	}
}

// Helper method to check that enums have valid values
func (m *Appinstance) ValidateEnums() error {
	for _, e := range m.Ports {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *CloudletLocation) CopyInFields(src *CloudletLocation) {
	m.CarrierName = src.CarrierName
	m.CloudletName = src.CloudletName
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		m.GpsLocation.Lat = src.GpsLocation.Lat
		m.GpsLocation.Long = src.GpsLocation.Long
		m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
		m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
		m.GpsLocation.Altitude = src.GpsLocation.Altitude
		m.GpsLocation.Course = src.GpsLocation.Course
		m.GpsLocation.Speed = src.GpsLocation.Speed
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &Timestamp{}
			m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
			m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
		}
	}
	m.Distance = src.Distance
	if src.Appinstances != nil {
		if m.Appinstances == nil || len(m.Appinstances) != len(src.Appinstances) {
			m.Appinstances = make([]*Appinstance, len(src.Appinstances))
		}
		for i0 := 0; i0 < len(src.Appinstances); i0++ {
			m.Appinstances[i0] = &Appinstance{}
			m.Appinstances[i0].AppName = src.Appinstances[i0].AppName
			m.Appinstances[i0].AppVers = src.Appinstances[i0].AppVers
			m.Appinstances[i0].FQDN = src.Appinstances[i0].FQDN
			if src.Appinstances[i0].Ports != nil {
				if m.Appinstances[i0].Ports == nil || len(m.Appinstances[i0].Ports) != len(src.Appinstances[i0].Ports) {
					m.Appinstances[i0].Ports = make([]*AppPort, len(src.Appinstances[i0].Ports))
				}
				for i1 := 0; i1 < len(src.Appinstances[i0].Ports); i1++ {
					m.Appinstances[i0].Ports[i1] = &AppPort{}
					m.Appinstances[i0].Ports[i1].Proto = src.Appinstances[i0].Ports[i1].Proto
					m.Appinstances[i0].Ports[i1].InternalPort = src.Appinstances[i0].Ports[i1].InternalPort
					m.Appinstances[i0].Ports[i1].PublicPort = src.Appinstances[i0].Ports[i1].PublicPort
					m.Appinstances[i0].Ports[i1].PublicPath = src.Appinstances[i0].Ports[i1].PublicPath
					m.Appinstances[i0].Ports[i1].FQDNPrefix = src.Appinstances[i0].Ports[i1].FQDNPrefix
				}
			}
		}
	}
}

// Helper method to check that enums have valid values
func (m *CloudletLocation) ValidateEnums() error {
	if err := m.GpsLocation.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.Appinstances {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *AppInstListReply) CopyInFields(src *AppInstListReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	if src.Cloudlets != nil {
		if m.Cloudlets == nil || len(m.Cloudlets) != len(src.Cloudlets) {
			m.Cloudlets = make([]*CloudletLocation, len(src.Cloudlets))
		}
		for i0 := 0; i0 < len(src.Cloudlets); i0++ {
			m.Cloudlets[i0] = &CloudletLocation{}
			m.Cloudlets[i0].CarrierName = src.Cloudlets[i0].CarrierName
			m.Cloudlets[i0].CloudletName = src.Cloudlets[i0].CloudletName
			if src.Cloudlets[i0].GpsLocation != nil {
				m.Cloudlets[i0].GpsLocation = &Loc{}
				m.Cloudlets[i0].GpsLocation.Lat = src.Cloudlets[i0].GpsLocation.Lat
				m.Cloudlets[i0].GpsLocation.Long = src.Cloudlets[i0].GpsLocation.Long
				m.Cloudlets[i0].GpsLocation.HorizontalAccuracy = src.Cloudlets[i0].GpsLocation.HorizontalAccuracy
				m.Cloudlets[i0].GpsLocation.VerticalAccuracy = src.Cloudlets[i0].GpsLocation.VerticalAccuracy
				m.Cloudlets[i0].GpsLocation.Altitude = src.Cloudlets[i0].GpsLocation.Altitude
				m.Cloudlets[i0].GpsLocation.Course = src.Cloudlets[i0].GpsLocation.Course
				m.Cloudlets[i0].GpsLocation.Speed = src.Cloudlets[i0].GpsLocation.Speed
				if src.Cloudlets[i0].GpsLocation.Timestamp != nil {
					m.Cloudlets[i0].GpsLocation.Timestamp = &Timestamp{}
					m.Cloudlets[i0].GpsLocation.Timestamp.Seconds = src.Cloudlets[i0].GpsLocation.Timestamp.Seconds
					m.Cloudlets[i0].GpsLocation.Timestamp.Nanos = src.Cloudlets[i0].GpsLocation.Timestamp.Nanos
				}
			}
			m.Cloudlets[i0].Distance = src.Cloudlets[i0].Distance
			if src.Cloudlets[i0].Appinstances != nil {
				if m.Cloudlets[i0].Appinstances == nil || len(m.Cloudlets[i0].Appinstances) != len(src.Cloudlets[i0].Appinstances) {
					m.Cloudlets[i0].Appinstances = make([]*Appinstance, len(src.Cloudlets[i0].Appinstances))
				}
				for i1 := 0; i1 < len(src.Cloudlets[i0].Appinstances); i1++ {
					m.Cloudlets[i0].Appinstances[i1] = &Appinstance{}
					m.Cloudlets[i0].Appinstances[i1].AppName = src.Cloudlets[i0].Appinstances[i1].AppName
					m.Cloudlets[i0].Appinstances[i1].AppVers = src.Cloudlets[i0].Appinstances[i1].AppVers
					m.Cloudlets[i0].Appinstances[i1].FQDN = src.Cloudlets[i0].Appinstances[i1].FQDN
					if src.Cloudlets[i0].Appinstances[i1].Ports != nil {
						if m.Cloudlets[i0].Appinstances[i1].Ports == nil || len(m.Cloudlets[i0].Appinstances[i1].Ports) != len(src.Cloudlets[i0].Appinstances[i1].Ports) {
							m.Cloudlets[i0].Appinstances[i1].Ports = make([]*AppPort, len(src.Cloudlets[i0].Appinstances[i1].Ports))
						}
						for i2 := 0; i2 < len(src.Cloudlets[i0].Appinstances[i1].Ports); i2++ {
							m.Cloudlets[i0].Appinstances[i1].Ports[i2] = &AppPort{}
							m.Cloudlets[i0].Appinstances[i1].Ports[i2].Proto = src.Cloudlets[i0].Appinstances[i1].Ports[i2].Proto
							m.Cloudlets[i0].Appinstances[i1].Ports[i2].InternalPort = src.Cloudlets[i0].Appinstances[i1].Ports[i2].InternalPort
							m.Cloudlets[i0].Appinstances[i1].Ports[i2].PublicPort = src.Cloudlets[i0].Appinstances[i1].Ports[i2].PublicPort
							m.Cloudlets[i0].Appinstances[i1].Ports[i2].PublicPath = src.Cloudlets[i0].Appinstances[i1].Ports[i2].PublicPath
							m.Cloudlets[i0].Appinstances[i1].Ports[i2].FQDNPrefix = src.Cloudlets[i0].Appinstances[i1].Ports[i2].FQDNPrefix
						}
					}
				}
			}
		}
	}
}

// Helper method to check that enums have valid values
func (m *AppInstListReply) ValidateEnums() error {
	if _, ok := AppInstListReply_AI_Status_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	for _, e := range m.Cloudlets {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *FqdnListRequest) CopyInFields(src *FqdnListRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
}

// Helper method to check that enums have valid values
func (m *FqdnListRequest) ValidateEnums() error {
	return nil
}

func (m *AppFqdn) CopyInFields(src *AppFqdn) {
	m.AppName = src.AppName
	m.AppVers = src.AppVers
	m.DevName = src.DevName
	m.FQDN = src.FQDN
}

// Helper method to check that enums have valid values
func (m *AppFqdn) ValidateEnums() error {
	return nil
}

func (m *FqdnListReply) CopyInFields(src *FqdnListReply) {
	m.Ver = src.Ver
	if src.AppFqdns != nil {
		if m.AppFqdns == nil || len(m.AppFqdns) != len(src.AppFqdns) {
			m.AppFqdns = make([]*AppFqdn, len(src.AppFqdns))
		}
		for i0 := 0; i0 < len(src.AppFqdns); i0++ {
			m.AppFqdns[i0] = &AppFqdn{}
			m.AppFqdns[i0].AppName = src.AppFqdns[i0].AppName
			m.AppFqdns[i0].AppVers = src.AppFqdns[i0].AppVers
			m.AppFqdns[i0].DevName = src.AppFqdns[i0].DevName
			m.AppFqdns[i0].FQDN = src.AppFqdns[i0].FQDN
		}
	}
	m.Status = src.Status
}

// Helper method to check that enums have valid values
func (m *FqdnListReply) ValidateEnums() error {
	for _, e := range m.AppFqdns {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if _, ok := FqdnListReply_FL_Status_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	return nil
}

func (m *DynamicLocGroupRequest) CopyInFields(src *DynamicLocGroupRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.LgId = src.LgId
	m.CommType = src.CommType
	m.UserData = src.UserData
}

// Helper method to check that enums have valid values
func (m *DynamicLocGroupRequest) ValidateEnums() error {
	if _, ok := DynamicLocGroupRequest_DlgCommType_name[int32(m.CommType)]; !ok {
		return errors.New("invalid CommType")
	}
	return nil
}

func (m *DynamicLocGroupReply) CopyInFields(src *DynamicLocGroupReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	m.ErrorCode = src.ErrorCode
	m.GroupCookie = src.GroupCookie
}

// Helper method to check that enums have valid values
func (m *DynamicLocGroupReply) ValidateEnums() error {
	if _, ok := ReplyStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	return nil
}

var IDTypesStrings = []string{
	"ID_UNDEFINED",
	"IMEI",
	"MSISDN",
	"IPADDR",
}

const (
	IDTypesID_UNDEFINED uint64 = 1 << 0
	IDTypesIMEI         uint64 = 1 << 1
	IDTypesMSISDN       uint64 = 1 << 2
	IDTypesIPADDR       uint64 = 1 << 3
)

func (e *IDTypes) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := IDTypes_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = IDTypes_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = IDTypes(val)
	return nil
}

func (e IDTypes) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

var ReplyStatusStrings = []string{
	"RS_UNDEFINED",
	"RS_SUCCESS",
	"RS_FAIL",
}

const (
	ReplyStatusRS_UNDEFINED uint64 = 1 << 0
	ReplyStatusRS_SUCCESS   uint64 = 1 << 1
	ReplyStatusRS_FAIL      uint64 = 1 << 2
)

func (e *ReplyStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := ReplyStatus_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = ReplyStatus_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = ReplyStatus(val)
	return nil
}

func (e ReplyStatus) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

var FindStatusStrings = []string{
	"FIND_UNKNOWN",
	"FIND_FOUND",
	"FIND_NOTFOUND",
}

const (
	FindStatusFIND_UNKNOWN  uint64 = 1 << 0
	FindStatusFIND_FOUND    uint64 = 1 << 1
	FindStatusFIND_NOTFOUND uint64 = 1 << 2
)

func (e *FindCloudletReply_FindStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := FindCloudletReply_FindStatus_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = FindCloudletReply_FindStatus_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = FindCloudletReply_FindStatus(val)
	return nil
}

func (e FindCloudletReply_FindStatus) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

var Tower_StatusStrings = []string{
	"TOWER_UNKNOWN",
	"CONNECTED_TO_SPECIFIED_TOWER",
	"NOT_CONNECTED_TO_SPECIFIED_TOWER",
}

const (
	Tower_StatusTOWER_UNKNOWN                    uint64 = 1 << 0
	Tower_StatusCONNECTED_TO_SPECIFIED_TOWER     uint64 = 1 << 1
	Tower_StatusNOT_CONNECTED_TO_SPECIFIED_TOWER uint64 = 1 << 2
)

func (e *VerifyLocationReply_Tower_Status) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := VerifyLocationReply_Tower_Status_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = VerifyLocationReply_Tower_Status_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = VerifyLocationReply_Tower_Status(val)
	return nil
}

func (e VerifyLocationReply_Tower_Status) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

var GPS_Location_StatusStrings = []string{
	"LOC_UNKNOWN",
	"LOC_VERIFIED",
	"LOC_MISMATCH_SAME_COUNTRY",
	"LOC_MISMATCH_OTHER_COUNTRY",
	"LOC_ROAMING_COUNTRY_MATCH",
	"LOC_ROAMING_COUNTRY_MISMATCH",
	"LOC_ERROR_UNAUTHORIZED",
	"LOC_ERROR_OTHER",
}

const (
	GPS_Location_StatusLOC_UNKNOWN                  uint64 = 1 << 0
	GPS_Location_StatusLOC_VERIFIED                 uint64 = 1 << 1
	GPS_Location_StatusLOC_MISMATCH_SAME_COUNTRY    uint64 = 1 << 2
	GPS_Location_StatusLOC_MISMATCH_OTHER_COUNTRY   uint64 = 1 << 3
	GPS_Location_StatusLOC_ROAMING_COUNTRY_MATCH    uint64 = 1 << 4
	GPS_Location_StatusLOC_ROAMING_COUNTRY_MISMATCH uint64 = 1 << 5
	GPS_Location_StatusLOC_ERROR_UNAUTHORIZED       uint64 = 1 << 6
	GPS_Location_StatusLOC_ERROR_OTHER              uint64 = 1 << 7
)

func (e *VerifyLocationReply_GPS_Location_Status) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := VerifyLocationReply_GPS_Location_Status_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = VerifyLocationReply_GPS_Location_Status_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = VerifyLocationReply_GPS_Location_Status(val)
	return nil
}

func (e VerifyLocationReply_GPS_Location_Status) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

var Loc_StatusStrings = []string{
	"LOC_UNKNOWN",
	"LOC_FOUND",
	"LOC_DENIED",
}

const (
	Loc_StatusLOC_UNKNOWN uint64 = 1 << 0
	Loc_StatusLOC_FOUND   uint64 = 1 << 1
	Loc_StatusLOC_DENIED  uint64 = 1 << 2
)

func (e *GetLocationReply_Loc_Status) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := GetLocationReply_Loc_Status_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = GetLocationReply_Loc_Status_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = GetLocationReply_Loc_Status(val)
	return nil
}

func (e GetLocationReply_Loc_Status) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

var AI_StatusStrings = []string{
	"AI_UNDEFINED",
	"AI_SUCCESS",
	"AI_FAIL",
}

const (
	AI_StatusAI_UNDEFINED uint64 = 1 << 0
	AI_StatusAI_SUCCESS   uint64 = 1 << 1
	AI_StatusAI_FAIL      uint64 = 1 << 2
)

func (e *AppInstListReply_AI_Status) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := AppInstListReply_AI_Status_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = AppInstListReply_AI_Status_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = AppInstListReply_AI_Status(val)
	return nil
}

func (e AppInstListReply_AI_Status) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

var FL_StatusStrings = []string{
	"FL_UNDEFINED",
	"FL_SUCCESS",
	"FL_FAIL",
}

const (
	FL_StatusFL_UNDEFINED uint64 = 1 << 0
	FL_StatusFL_SUCCESS   uint64 = 1 << 1
	FL_StatusFL_FAIL      uint64 = 1 << 2
)

func (e *FqdnListReply_FL_Status) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := FqdnListReply_FL_Status_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = FqdnListReply_FL_Status_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = FqdnListReply_FL_Status(val)
	return nil
}

func (e FqdnListReply_FL_Status) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

var DlgCommTypeStrings = []string{
	"DlgUndefined",
	"DlgSecure",
	"DlgOpen",
}

const (
	DlgCommTypeDlgUndefined uint64 = 1 << 0
	DlgCommTypeDlgSecure    uint64 = 1 << 1
	DlgCommTypeDlgOpen      uint64 = 1 << 2
)

func (e *DynamicLocGroupRequest_DlgCommType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := DynamicLocGroupRequest_DlgCommType_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = DynamicLocGroupRequest_DlgCommType_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = DynamicLocGroupRequest_DlgCommType(val)
	return nil
}

func (e DynamicLocGroupRequest_DlgCommType) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

type MatchOptions struct {
	// Filter will ignore 0 or nil fields on the passed in object
	Filter bool
	// IgnoreBackend will ignore fields that were marked backend in .proto
	IgnoreBackend bool
	// Sort repeated (arrays) of Key objects so matching does not
	// fail due to order.
	SortArrayedKeys bool
}

type MatchOpt func(*MatchOptions)

func MatchFilter() MatchOpt {
	return func(opts *MatchOptions) {
		opts.Filter = true
	}
}

func MatchIgnoreBackend() MatchOpt {
	return func(opts *MatchOptions) {
		opts.IgnoreBackend = true
	}
}

func MatchSortArrayedKeys() MatchOpt {
	return func(opts *MatchOptions) {
		opts.SortArrayedKeys = true
	}
}

func applyMatchOptions(opts *MatchOptions, args ...MatchOpt) {
	for _, f := range args {
		f(opts)
	}
}

func (m *RegisterClientRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.DevName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppVers)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AuthToken)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *RegisterClientReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.TokenServerURI)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *FindCloudletRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *FindCloudletReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	l = len(m.FQDN)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if m.CloudletLocation != nil {
		l = m.CloudletLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *VerifyLocationRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.VerifyLocToken)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *VerifyLocationReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.TowerStatus != 0 {
		n += 1 + sovAppClient(uint64(m.TowerStatus))
	}
	if m.GpsLocationStatus != 0 {
		n += 1 + sovAppClient(uint64(m.GpsLocationStatus))
	}
	if m.GPS_Location_Accuracy_KM != 0 {
		n += 9
	}
	return n
}

func (m *GetLocationRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *GetLocationReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Tower != 0 {
		n += 1 + sovAppClient(uint64(m.Tower))
	}
	if m.NetworkLocation != nil {
		l = m.NetworkLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *AppInstListRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *Appinstance) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppVers)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.FQDN)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *CloudletLocation) Size() (n int) {
	var l int
	_ = l
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CloudletName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Distance != 0 {
		n += 9
	}
	if len(m.Appinstances) > 0 {
		for _, e := range m.Appinstances {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *AppInstListReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	if len(m.Cloudlets) > 0 {
		for _, e := range m.Cloudlets {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *FqdnListRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *AppFqdn) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppVers)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.DevName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.FQDN)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *FqdnListReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if len(m.AppFqdns) > 0 {
		for _, e := range m.AppFqdns {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	return n
}

func (m *DynamicLocGroupRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.LgId != 0 {
		n += 1 + sovAppClient(uint64(m.LgId))
	}
	if m.CommType != 0 {
		n += 1 + sovAppClient(uint64(m.CommType))
	}
	l = len(m.UserData)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *DynamicLocGroupReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAppClient(uint64(m.ErrorCode))
	}
	l = len(m.GroupCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func sovAppClient(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAppClient(x uint64) (n int) {
	return sovAppClient(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RegisterClientRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterClientRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterClientRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterClientReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterClientReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterClientReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (ReplyStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenServerURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenServerURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindCloudletRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindCloudletRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindCloudletRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindCloudletReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindCloudletReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindCloudletReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (FindCloudletReply_FindStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FQDN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FQDN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &AppPort{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloudletLocation == nil {
				m.CloudletLocation = &Loc{}
			}
			if err := m.CloudletLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyLocationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyLocationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyLocationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyLocToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifyLocToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyLocationReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyLocationReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyLocationReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TowerStatus", wireType)
			}
			m.TowerStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TowerStatus |= (VerifyLocationReply_Tower_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocationStatus", wireType)
			}
			m.GpsLocationStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpsLocationStatus |= (VerifyLocationReply_GPS_Location_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GPS_Location_Accuracy_KM", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GPS_Location_Accuracy_KM = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLocationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLocationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLocationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLocationReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLocationReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLocationReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (GetLocationReply_Loc_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tower", wireType)
			}
			m.Tower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tower |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkLocation == nil {
				m.NetworkLocation = &Loc{}
			}
			if err := m.NetworkLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Appinstance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Appinstance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Appinstance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FQDN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FQDN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &AppPort{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudletName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Distance = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appinstances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Appinstances = append(m.Appinstances, &Appinstance{})
			if err := m.Appinstances[len(m.Appinstances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstListReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstListReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstListReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (AppInstListReply_AI_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cloudlets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cloudlets = append(m.Cloudlets, &CloudletLocation{})
			if err := m.Cloudlets[len(m.Cloudlets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FqdnListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FqdnListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FqdnListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppFqdn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppFqdn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppFqdn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FQDN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FQDN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FqdnListReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FqdnListReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FqdnListReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppFqdns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppFqdns = append(m.AppFqdns, &AppFqdn{})
			if err := m.AppFqdns[len(m.AppFqdns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (FqdnListReply_FL_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicLocGroupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicLocGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicLocGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LgId", wireType)
			}
			m.LgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LgId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommType", wireType)
			}
			m.CommType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommType |= (DynamicLocGroupRequest_DlgCommType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicLocGroupReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicLocGroupReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicLocGroupReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (ReplyStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAppClient(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAppClient
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAppClient(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAppClient = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAppClient   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("app-client.proto", fileDescriptorAppClient) }

var fileDescriptorAppClient = []byte{
	// 1606 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0xdf, 0x6f, 0xdb, 0xd4,
	0x17, 0x9f, 0x93, 0xf4, 0xd7, 0x49, 0xda, 0xba, 0xb7, 0xeb, 0xbe, 0xf9, 0x86, 0xae, 0x2a, 0xd6,
	0x06, 0xa3, 0xb0, 0x94, 0x95, 0x1f, 0x93, 0xc6, 0x26, 0x64, 0x62, 0x27, 0x35, 0x4b, 0x9c, 0x62,
	0x27, 0x1d, 0x20, 0x21, 0xcb, 0x4b, 0x6e, 0x33, 0xab, 0xa9, 0xed, 0xda, 0x4e, 0xa7, 0x3e, 0x20,
	0x21, 0x78, 0x40, 0x7b, 0x01, 0x21, 0x1e, 0xf8, 0x13, 0x78, 0x04, 0x21, 0x24, 0xfe, 0x85, 0x3d,
	0x82, 0x78, 0xe3, 0x09, 0x26, 0x10, 0xe2, 0x3f, 0xe0, 0x11, 0xdd, 0x6b, 0x3b, 0xb1, 0x9d, 0x1f,
	0xa4, 0x30, 0x24, 0x78, 0xf3, 0x3d, 0xe7, 0xde, 0x73, 0x3e, 0xe7, 0x73, 0xcf, 0xbd, 0xf7, 0x1c,
	0x03, 0xab, 0xdb, 0xf6, 0xd5, 0x56, 0xd7, 0xc0, 0xa6, 0x57, 0xb4, 0x1d, 0xcb, 0xb3, 0x50, 0xbe,
	0x6d, 0xb8, 0x9e, 0x63, 0xdc, 0xed, 0x79, 0xb8, 0xad, 0x1d, 0xe9, 0x5e, 0xeb, 0x9e, 0x86, 0xcd,
	0x8e, 0x61, 0xe2, 0xc2, 0x7a, 0xc7, 0xb2, 0x3a, 0x5d, 0xbc, 0xad, 0xdb, 0xc6, 0xb6, 0x6e, 0x9a,
	0x96, 0xa7, 0x7b, 0x86, 0x65, 0xba, 0xfe, 0xba, 0xc2, 0x42, 0xd7, 0x6a, 0x05, 0x9f, 0xcb, 0xba,
	0x6d, 0xb7, 0xac, 0xa3, 0x23, 0xcb, 0xf4, 0x05, 0xdc, 0x37, 0x0c, 0xac, 0x29, 0xb8, 0x63, 0xb8,
	0x1e, 0x76, 0x4a, 0xd4, 0x99, 0x82, 0x8f, 0x7b, 0xd8, 0xf5, 0x10, 0x0b, 0xe9, 0x7d, 0xec, 0xe4,
	0x99, 0x4d, 0xe6, 0xca, 0xa2, 0x42, 0x3e, 0x51, 0x1e, 0xe6, 0x04, 0x7c, 0x22, 0xeb, 0x47, 0x38,
	0x9f, 0xda, 0x64, 0xae, 0x2c, 0x28, 0xe1, 0x90, 0x68, 0x78, 0xdb, 0xa6, 0x9a, 0xb4, 0xaf, 0x09,
	0x86, 0x81, 0x66, 0x1f, 0x3b, 0x6e, 0x3e, 0xd3, 0xd7, 0x90, 0x21, 0xda, 0x84, 0x6c, 0x49, 0x77,
	0x1c, 0x03, 0x3b, 0x74, 0xdd, 0x0c, 0xd5, 0x46, 0x45, 0x68, 0x1d, 0x16, 0xf8, 0x9e, 0x77, 0xaf,
	0x61, 0x1d, 0x62, 0x33, 0x3f, 0x4b, 0xf5, 0x03, 0x01, 0xf7, 0x35, 0x03, 0xab, 0x49, 0xe4, 0x76,
	0xf7, 0x74, 0x04, 0xee, 0x5b, 0x30, 0xab, 0x7a, 0xba, 0xd7, 0x73, 0x29, 0xec, 0xa5, 0x9d, 0xcb,
	0xc5, 0x71, 0x44, 0x16, 0xa9, 0x09, 0x7f, 0xb2, 0x12, 0x2c, 0x42, 0x97, 0x60, 0x51, 0xc5, 0xae,
	0x6b, 0x58, 0x66, 0xc9, 0xb2, 0x0e, 0x8d, 0x30, 0xc4, 0xb8, 0x10, 0x3d, 0x05, 0x4b, 0x14, 0x97,
	0x8a, 0x9d, 0x13, 0xec, 0x34, 0x15, 0x29, 0x88, 0x37, 0x21, 0xe5, 0xbe, 0x64, 0x60, 0xb5, 0x6c,
	0x98, 0xed, 0x52, 0xd7, 0xea, 0xb5, 0xbb, 0x78, 0x02, 0xdd, 0x43, 0x7e, 0x53, 0xa3, 0xfc, 0x26,
	0x68, 0x4c, 0x0f, 0xd3, 0xf8, 0x2a, 0x64, 0x2b, 0xb6, 0x5b, 0xb5, 0x5a, 0x34, 0x29, 0x28, 0xac,
	0xec, 0xce, 0xc5, 0xf1, 0x1c, 0x54, 0xad, 0x96, 0x12, 0x5d, 0xc1, 0x7d, 0x97, 0x82, 0x95, 0x38,
	0xe4, 0xd1, 0x3c, 0xcb, 0x30, 0xeb, 0x46, 0x79, 0x7e, 0x79, 0xbc, 0x8f, 0x21, 0x73, 0x54, 0x12,
	0x12, 0xef, 0x5b, 0x41, 0x08, 0x32, 0xe5, 0x37, 0x04, 0x39, 0x88, 0x89, 0x7e, 0xa3, 0xeb, 0x30,
	0x63, 0x5b, 0x8e, 0x47, 0xb2, 0x29, 0x7d, 0x25, 0xbb, 0xf3, 0xe4, 0x78, 0x17, 0xbc, 0x6d, 0xef,
	0x59, 0x8e, 0xa7, 0xf8, 0xf3, 0xd1, 0xeb, 0xb0, 0xd2, 0x0a, 0x1c, 0x6a, 0xdd, 0x90, 0x8b, 0x99,
	0x69, 0xb8, 0x60, 0xc3, 0x75, 0x7d, 0x42, 0x78, 0x80, 0x01, 0x5c, 0xc4, 0x42, 0xae, 0x2c, 0xc9,
	0x82, 0xd6, 0x94, 0x6f, 0xcb, 0xf5, 0x3b, 0x32, 0x7b, 0x0e, 0x2d, 0x01, 0x50, 0x49, 0xb9, 0xde,
	0x94, 0x05, 0x96, 0x41, 0x2b, 0xb0, 0x48, 0xc7, 0x72, 0xbd, 0xe1, 0x8b, 0x52, 0xdc, 0x0f, 0x0c,
	0xac, 0xed, 0x63, 0xc7, 0x38, 0x38, 0x0d, 0xad, 0xfe, 0xfb, 0x13, 0x81, 0xe4, 0x78, 0x1f, 0xb3,
	0x7f, 0x2a, 0xfd, 0x53, 0x9b, 0x90, 0x72, 0x0f, 0x66, 0x60, 0x35, 0x19, 0x5c, 0x90, 0x32, 0x27,
	0x83, 0xd0, 0x4e, 0xb0, 0x83, 0xde, 0x81, 0x9c, 0x67, 0xdd, 0xc7, 0x8e, 0x16, 0x4b, 0x9c, 0x1b,
	0xe3, 0x31, 0x8d, 0x30, 0x5b, 0x6c, 0x50, 0x0b, 0x41, 0xf2, 0x64, 0xa9, 0xbd, 0x60, 0x6b, 0x8e,
	0x61, 0xb5, 0x63, 0xbb, 0xfd, 0xfd, 0x0e, 0xbd, 0xa4, 0xa9, 0x17, 0xfe, 0x6c, 0x5e, 0x2a, 0x7b,
	0xaa, 0x16, 0x4a, 0x42, 0x67, 0x2b, 0x9d, 0x01, 0x3b, 0x81, 0xcb, 0xeb, 0x90, 0x8f, 0xcd, 0xe4,
	0x5b, 0xad, 0x9e, 0xa3, 0xb7, 0x4e, 0xb5, 0xdb, 0x35, 0xca, 0x38, 0xa3, 0xac, 0x55, 0xf6, 0xd4,
	0x50, 0x1d, 0x6a, 0x6f, 0xd7, 0x38, 0x03, 0x72, 0xd1, 0x40, 0x48, 0xd2, 0x34, 0xea, 0x77, 0x44,
	0x25, 0x92, 0x57, 0x9b, 0xb0, 0x5e, 0xaa, 0xcb, 0xb2, 0x58, 0x6a, 0x88, 0x82, 0xd6, 0xa8, 0x6b,
	0xea, 0x9e, 0x58, 0x92, 0xca, 0x12, 0x1d, 0xdc, 0x11, 0x15, 0x96, 0x41, 0x97, 0x60, 0x53, 0xae,
	0x37, 0xb4, 0x89, 0xb3, 0x52, 0xdc, 0x6f, 0x0c, 0xac, 0x8e, 0x08, 0x07, 0x2d, 0x43, 0xb6, 0x5a,
	0x2f, 0x45, 0x1c, 0xb2, 0x90, 0x23, 0x82, 0x7d, 0x51, 0xa1, 0x06, 0x58, 0x06, 0x5d, 0x84, 0xff,
	0x13, 0x49, 0x4d, 0x52, 0x6b, 0x7c, 0xa3, 0xb4, 0xab, 0xa9, 0x7c, 0x4d, 0xd4, 0x4a, 0xf5, 0xa6,
	0xdc, 0x50, 0xde, 0x62, 0x53, 0x68, 0x03, 0x0a, 0x31, 0x75, 0xbd, 0xb1, 0x2b, 0x2a, 0x7d, 0x7d,
	0x3a, 0x5c, 0xae, 0xd4, 0xf9, 0x9a, 0x24, 0x57, 0x42, 0x85, 0x46, 0x27, 0xb3, 0x19, 0x12, 0xe0,
	0x48, 0x75, 0x60, 0x8e, 0x9d, 0x41, 0x05, 0xb8, 0x40, 0x66, 0x88, 0x8a, 0x52, 0x27, 0xcc, 0xf0,
	0xcd, 0xc6, 0x6e, 0x5d, 0x91, 0xde, 0x16, 0x05, 0x76, 0x16, 0xad, 0xc2, 0xf2, 0x40, 0x47, 0x3d,
	0xb3, 0x73, 0x9c, 0x09, 0xa8, 0x32, 0x38, 0xba, 0xff, 0xf8, 0x21, 0xe3, 0xbe, 0x4a, 0x01, 0x1b,
	0x73, 0x38, 0xfa, 0xae, 0xac, 0x25, 0xde, 0xa4, 0x97, 0xc6, 0x27, 0x63, 0xd2, 0x1a, 0x39, 0x97,
	0x5a, 0xe2, 0x8d, 0xfa, 0xf3, 0xc3, 0x7f, 0x1e, 0x66, 0x68, 0x7a, 0xd1, 0x24, 0xcc, 0x28, 0xfe,
	0x00, 0x55, 0x60, 0x59, 0xc6, 0xde, 0x7d, 0xcb, 0x39, 0xac, 0x9e, 0xe9, 0x4e, 0x4c, 0xae, 0xe2,
	0x6e, 0x02, 0x0c, 0x60, 0x0d, 0x27, 0xd2, 0x22, 0x2c, 0x10, 0x41, 0x78, 0x21, 0x2e, 0x01, 0x90,
	0xa1, 0x20, 0xca, 0x24, 0xab, 0x52, 0xdc, 0x17, 0x0c, 0x20, 0xde, 0xb6, 0x25, 0xd3, 0xf5, 0xaa,
	0x86, 0xfb, 0x5f, 0x78, 0x13, 0x3f, 0x62, 0x20, 0xcb, 0xdb, 0xb6, 0x61, 0xba, 0x9e, 0x6e, 0xb6,
	0x62, 0x15, 0x10, 0x33, 0xb6, 0x02, 0x4a, 0xc5, 0x2b, 0xa0, 0xc7, 0xf9, 0xbe, 0x71, 0xef, 0xa5,
	0x80, 0x2d, 0x25, 0x1e, 0xaa, 0x24, 0x11, 0xcc, 0x30, 0x11, 0x1c, 0xe4, 0xc2, 0x55, 0x91, 0xc2,
	0x2e, 0x26, 0x4b, 0x92, 0x95, 0x3e, 0xf3, 0xbb, 0x51, 0x80, 0x79, 0xc1, 0xf0, 0x89, 0x0a, 0xee,
	0xc0, 0xfe, 0x18, 0x49, 0x90, 0x8b, 0xf0, 0xe8, 0xe6, 0x67, 0x68, 0xdc, 0x97, 0x27, 0xc6, 0x1d,
	0xce, 0x56, 0x62, 0x4b, 0xb9, 0xdf, 0x19, 0x60, 0x63, 0x59, 0x34, 0xfa, 0xe8, 0x55, 0x13, 0x47,
	0xef, 0xc5, 0x89, 0xbe, 0x62, 0xd6, 0x8a, 0xbc, 0x94, 0x3c, 0x79, 0xbb, 0xb0, 0x10, 0x92, 0x45,
	0x1e, 0x16, 0x02, 0x7e, 0x6b, 0xbc, 0xc1, 0xe4, 0x0e, 0x29, 0x83, 0xc5, 0xdc, 0x0d, 0x58, 0xe8,
	0x9b, 0x27, 0x37, 0x2f, 0x2f, 0x69, 0x4d, 0x59, 0x10, 0xcb, 0x92, 0x2c, 0x0a, 0x7e, 0x51, 0x41,
	0xd4, 0xcd, 0x52, 0x49, 0x54, 0x55, 0x96, 0x41, 0x59, 0x98, 0xe3, 0x25, 0xad, 0xcc, 0x4b, 0x55,
	0x36, 0xc5, 0x49, 0xb0, 0x5c, 0x3e, 0x6e, 0x9b, 0x8f, 0xe1, 0xf0, 0x70, 0x87, 0x34, 0x5f, 0x89,
	0xb5, 0xbf, 0x94, 0xd4, 0x91, 0x26, 0x21, 0x1d, 0x6f, 0x12, 0xc2, 0x74, 0xcf, 0x0c, 0xd2, 0x9d,
	0xfb, 0x95, 0x81, 0xc5, 0x01, 0xf0, 0xd1, 0x35, 0xc2, 0x2d, 0x98, 0x0f, 0x00, 0x85, 0x04, 0x4f,
	0x3e, 0x15, 0x64, 0xa6, 0xd2, 0x5f, 0x82, 0xa4, 0xfe, 0x76, 0x67, 0xe8, 0x76, 0x5f, 0x9b, 0x50,
	0x95, 0x46, 0x91, 0x14, 0xcb, 0xd5, 0xc4, 0x5e, 0x93, 0x1d, 0xea, 0x0b, 0x69, 0xd9, 0x57, 0x4d,
	0xee, 0x10, 0x51, 0x47, 0x77, 0xa8, 0x5c, 0x0d, 0x77, 0xe8, 0xb3, 0x14, 0x5c, 0x10, 0x4e, 0x4d,
	0xfd, 0xc8, 0x68, 0x55, 0xad, 0x56, 0xc5, 0xb1, 0x7a, 0xf6, 0xdf, 0xbd, 0xe6, 0x10, 0x64, 0xaa,
	0x1d, 0xa9, 0x4d, 0x79, 0xce, 0x28, 0xf4, 0x1b, 0xbd, 0x09, 0xf3, 0x25, 0xeb, 0xe8, 0xa8, 0x71,
	0x6a, 0xe3, 0x7c, 0x96, 0xc6, 0x7b, 0x73, 0x7c, 0xbc, 0xa3, 0xf1, 0x14, 0x85, 0x6e, 0x27, 0xb4,
	0xa1, 0xf4, 0xad, 0x91, 0x43, 0xdc, 0x74, 0xb1, 0x23, 0xe8, 0x9e, 0x9e, 0xcf, 0x51, 0x38, 0xfd,
	0x31, 0xf7, 0x0a, 0x64, 0x23, 0x8b, 0x08, 0x35, 0x42, 0xb7, 0xd3, 0x34, 0xdb, 0xf8, 0xc0, 0x30,
	0x71, 0xdb, 0xbf, 0xff, 0x85, 0x6e, 0x47, 0xc5, 0xad, 0x9e, 0x83, 0x7d, 0x66, 0x84, 0x6e, 0xa7,
	0x6e, 0x63, 0x93, 0x4d, 0x71, 0x9f, 0x33, 0x70, 0x7e, 0x08, 0xc9, 0xb8, 0x54, 0x88, 0x77, 0x18,
	0xd3, 0x76, 0x72, 0x41, 0x43, 0xb1, 0x0e, 0x0b, 0xa2, 0xe3, 0x58, 0x4e, 0xc9, 0x6a, 0xfb, 0xd9,
	0xb9, 0xa8, 0x0c, 0x04, 0xe4, 0xb2, 0xa4, 0xce, 0x03, 0xca, 0x83, 0x86, 0x34, 0x22, 0xda, 0xba,
	0x05, 0x73, 0x92, 0x40, 0x22, 0xa4, 0xbb, 0x2f, 0x09, 0xb1, 0xdd, 0x9f, 0x87, 0x8c, 0x54, 0x13,
	0x25, 0x96, 0x41, 0x00, 0xb3, 0x35, 0x55, 0x52, 0x05, 0x99, 0x4d, 0x91, 0x6f, 0x69, 0x8f, 0x17,
	0x04, 0x85, 0x4d, 0x6f, 0xdd, 0x84, 0x6c, 0x04, 0x15, 0x31, 0xa1, 0xa8, 0xc9, 0x04, 0x52, 0xd4,
	0x78, 0x02, 0x29, 0x6a, 0x90, 0x40, 0x3b, 0xbf, 0xcc, 0x01, 0x5b, 0xa3, 0x11, 0x8a, 0x34, 0x42,
	0x8d, 0xb7, 0x0d, 0xf4, 0x31, 0x03, 0x4b, 0xf1, 0x26, 0x18, 0x6d, 0x4f, 0xe2, 0x64, 0x44, 0xa3,
	0x5f, 0xb8, 0x3a, 0xfd, 0x02, 0xbb, 0x7b, 0xca, 0x5d, 0x7c, 0xff, 0xfb, 0x9f, 0x3f, 0x4d, 0xfd,
	0x8f, 0x43, 0xdb, 0x27, 0xd7, 0xb6, 0x9d, 0x60, 0x82, 0xff, 0x9f, 0xe2, 0x06, 0xb3, 0x85, 0x3e,
	0x64, 0x20, 0x17, 0xed, 0xee, 0xd0, 0xd5, 0x69, 0xbb, 0x40, 0x1f, 0xcd, 0xb3, 0x67, 0x68, 0x1a,
	0xb9, 0x27, 0x28, 0x96, 0x35, 0x8e, 0x25, 0x58, 0x0e, 0x0c, 0xb3, 0x1d, 0xb6, 0x6a, 0x04, 0x09,
	0xe1, 0x26, 0x5e, 0xc8, 0x4f, 0xe2, 0x66, 0x64, 0x33, 0x36, 0x89, 0x9b, 0x11, 0x3d, 0x42, 0x9c,
	0x9b, 0x13, 0x3a, 0x21, 0xec, 0x3d, 0x08, 0xa2, 0x0f, 0x18, 0xc8, 0x46, 0xaa, 0x39, 0xf4, 0xdc,
	0x94, 0x45, 0x9f, 0x8f, 0x65, 0x6b, 0xfa, 0x12, 0x91, 0x2b, 0x50, 0x20, 0xe7, 0xb9, 0x65, 0x02,
	0xa4, 0x83, 0xbd, 0x28, 0x8a, 0x4f, 0x18, 0x58, 0xe2, 0xdb, 0x6d, 0x72, 0x78, 0x1b, 0x16, 0x4d,
	0x6f, 0xf4, 0xfc, 0x59, 0xef, 0x88, 0x42, 0xf1, 0x0c, 0x2b, 0x86, 0x98, 0xd1, 0xdb, 0xed, 0x9e,
	0x8b, 0x1d, 0xcf, 0xea, 0x90, 0x09, 0x04, 0xd3, 0x03, 0x06, 0x96, 0x2a, 0xd8, 0x8b, 0xbc, 0xb7,
	0x93, 0xc8, 0x19, 0x2e, 0x15, 0x27, 0x91, 0x93, 0x7c, 0xc4, 0xe3, 0x58, 0x3a, 0xd8, 0xd3, 0xfd,
	0x22, 0xa2, 0x6b, 0xb8, 0x34, 0x6f, 0xde, 0xa5, 0x9b, 0x14, 0xbe, 0x05, 0xe8, 0x99, 0x69, 0xde,
	0x0b, 0x1f, 0xc4, 0xd3, 0x53, 0x3e, 0x2d, 0x43, 0xdb, 0x73, 0x70, 0xdc, 0x36, 0x03, 0xf7, 0xaf,
	0xb1, 0x0f, 0x7f, 0xda, 0x38, 0xf7, 0xf0, 0xd1, 0x06, 0xf3, 0xed, 0xa3, 0x0d, 0xe6, 0xc7, 0x47,
	0x1b, 0xcc, 0xdd, 0x59, 0xfa, 0xab, 0xee, 0x85, 0x3f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x9b, 0x13,
	0x8a, 0x71, 0x12, 0x14, 0x00, 0x00,
}
