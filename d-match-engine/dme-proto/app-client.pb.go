// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app-client.proto

/*
	Package distributed_match_engine is a generated protocol buffer package.

	It is generated from these files:
		app-client.proto
		loc.proto

	It has these top-level messages:
		Match_Engine_Request
		Match_Engine_Reply
		Match_Engine_Loc_Verify
		Match_Engine_Loc
		Match_Engine_Status
		Loc
*/
package distributed_match_engine

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import "errors"
import "strconv"
import google_protobuf "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// User ID type - IMEI, MSISDN etc
type Match_Engine_Request_IDType int32

const (
	Match_Engine_Request_IMEI   Match_Engine_Request_IDType = 0
	Match_Engine_Request_MSISDN Match_Engine_Request_IDType = 1
	Match_Engine_Request_IPADDR Match_Engine_Request_IDType = 2
)

var Match_Engine_Request_IDType_name = map[int32]string{
	0: "IMEI",
	1: "MSISDN",
	2: "IPADDR",
}
var Match_Engine_Request_IDType_value = map[string]int32{
	"IMEI":   0,
	"MSISDN": 1,
	"IPADDR": 2,
}

func (x Match_Engine_Request_IDType) String() string {
	return proto.EnumName(Match_Engine_Request_IDType_name, int32(x))
}
func (Match_Engine_Request_IDType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{0, 0}
}

// Status of the reply
type Match_Engine_Loc_Verify_Tower_Status int32

const (
	Match_Engine_Loc_Verify_UNKNOWN                          Match_Engine_Loc_Verify_Tower_Status = 0
	Match_Engine_Loc_Verify_CONNECTED_TO_SPECIFIED_TOWER     Match_Engine_Loc_Verify_Tower_Status = 1
	Match_Engine_Loc_Verify_NOT_CONNECTED_TO_SPECIFIED_TOWER Match_Engine_Loc_Verify_Tower_Status = 2
)

var Match_Engine_Loc_Verify_Tower_Status_name = map[int32]string{
	0: "UNKNOWN",
	1: "CONNECTED_TO_SPECIFIED_TOWER",
	2: "NOT_CONNECTED_TO_SPECIFIED_TOWER",
}
var Match_Engine_Loc_Verify_Tower_Status_value = map[string]int32{
	"UNKNOWN":                          0,
	"CONNECTED_TO_SPECIFIED_TOWER":     1,
	"NOT_CONNECTED_TO_SPECIFIED_TOWER": 2,
}

func (x Match_Engine_Loc_Verify_Tower_Status) String() string {
	return proto.EnumName(Match_Engine_Loc_Verify_Tower_Status_name, int32(x))
}
func (Match_Engine_Loc_Verify_Tower_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{2, 0}
}

type Match_Engine_Loc_Verify_GPS_Location_Status int32

const (
	Match_Engine_Loc_Verify_LOC_UNKNOWN       Match_Engine_Loc_Verify_GPS_Location_Status = 0
	Match_Engine_Loc_Verify_LOC_WITHIN_2KM    Match_Engine_Loc_Verify_GPS_Location_Status = 1
	Match_Engine_Loc_Verify_LOC_WITHIN_10KM   Match_Engine_Loc_Verify_GPS_Location_Status = 2
	Match_Engine_Loc_Verify_LOC_WITHIN_100KM  Match_Engine_Loc_Verify_GPS_Location_Status = 3
	Match_Engine_Loc_Verify_LOC_MISMATCH      Match_Engine_Loc_Verify_GPS_Location_Status = 4
	Match_Engine_Loc_Verify_LOC_OTHER_COUNTRY Match_Engine_Loc_Verify_GPS_Location_Status = 5
)

var Match_Engine_Loc_Verify_GPS_Location_Status_name = map[int32]string{
	0: "LOC_UNKNOWN",
	1: "LOC_WITHIN_2KM",
	2: "LOC_WITHIN_10KM",
	3: "LOC_WITHIN_100KM",
	4: "LOC_MISMATCH",
	5: "LOC_OTHER_COUNTRY",
}
var Match_Engine_Loc_Verify_GPS_Location_Status_value = map[string]int32{
	"LOC_UNKNOWN":       0,
	"LOC_WITHIN_2KM":    1,
	"LOC_WITHIN_10KM":   2,
	"LOC_WITHIN_100KM":  3,
	"LOC_MISMATCH":      4,
	"LOC_OTHER_COUNTRY": 5,
}

func (x Match_Engine_Loc_Verify_GPS_Location_Status) String() string {
	return proto.EnumName(Match_Engine_Loc_Verify_GPS_Location_Status_name, int32(x))
}
func (Match_Engine_Loc_Verify_GPS_Location_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{2, 1}
}

// Status of the reply
type Match_Engine_Loc_Loc_Status int32

const (
	Match_Engine_Loc_LOC_UNKNOWN Match_Engine_Loc_Loc_Status = 0
	Match_Engine_Loc_LOC_FOUND   Match_Engine_Loc_Loc_Status = 1
	// The user does not allow his location to be tracked
	Match_Engine_Loc_LOC_DENIED Match_Engine_Loc_Loc_Status = 2
)

var Match_Engine_Loc_Loc_Status_name = map[int32]string{
	0: "LOC_UNKNOWN",
	1: "LOC_FOUND",
	2: "LOC_DENIED",
}
var Match_Engine_Loc_Loc_Status_value = map[string]int32{
	"LOC_UNKNOWN": 0,
	"LOC_FOUND":   1,
	"LOC_DENIED":  2,
}

func (x Match_Engine_Loc_Loc_Status) String() string {
	return proto.EnumName(Match_Engine_Loc_Loc_Status_name, int32(x))
}
func (Match_Engine_Loc_Loc_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{3, 0}
}

// Status of the reply
type Match_Engine_Status_ME_Status int32

const (
	Match_Engine_Status_ME_SUCCESS Match_Engine_Status_ME_Status = 0
	Match_Engine_Status_ME_FAIL    Match_Engine_Status_ME_Status = 1
)

var Match_Engine_Status_ME_Status_name = map[int32]string{
	0: "ME_SUCCESS",
	1: "ME_FAIL",
}
var Match_Engine_Status_ME_Status_value = map[string]int32{
	"ME_SUCCESS": 0,
	"ME_FAIL":    1,
}

func (x Match_Engine_Status_ME_Status) String() string {
	return proto.EnumName(Match_Engine_Status_ME_Status_name, int32(x))
}
func (Match_Engine_Status_ME_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{4, 0}
}

type Match_Engine_Request struct {
	Ver    uint32                      `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	IdType Match_Engine_Request_IDType `protobuf:"varint,2,opt,name=IdType,proto3,enum=distributed_match_engine.Match_Engine_Request_IDType" json:"IdType,omitempty"`
	// Actual ID
	Id string `protobuf:"bytes,3,opt,name=Id,proto3" json:"Id,omitempty"`
	// The carrier ID that user is connected to ("Mobile Country Code")
	CarrierID uint64 `protobuf:"varint,4,opt,name=CarrierID,proto3" json:"CarrierID,omitempty"`
	// The carrier name that user is connected to ("Cellular Carrier Name")
	CarrierName string `protobuf:"bytes,5,opt,name=CarrierName,proto3" json:"CarrierName,omitempty"`
	// The tower that user is currently connected to
	Tower uint64 `protobuf:"varint,6,opt,name=Tower,proto3" json:"Tower,omitempty"`
	// The GPS location of the user
	GpsLocation *Loc `protobuf:"bytes,7,opt,name=GpsLocation" json:"GpsLocation,omitempty"`
	// Edge-cloud assigned application ID
	AppId uint64 `protobuf:"varint,8,opt,name=AppId,proto3" json:"AppId,omitempty"`
	// Protocol application uses
	Protocol []byte `protobuf:"bytes,9,opt,name=Protocol,proto3" json:"Protocol,omitempty"`
	// The protocol port on the server side
	ServerPort []byte `protobuf:"bytes,10,opt,name=ServerPort,proto3" json:"ServerPort,omitempty"`
	// App Developer Name
	DevName string `protobuf:"bytes,11,opt,name=DevName,proto3" json:"DevName,omitempty"`
	// App Name
	AppName string `protobuf:"bytes,12,opt,name=AppName,proto3" json:"AppName,omitempty"`
	// App Version
	AppVers string `protobuf:"bytes,13,opt,name=AppVers,proto3" json:"AppVers,omitempty"`
	// Token provided by the Operator for subsequent calls
	Token string `protobuf:"bytes,14,opt,name=Token,proto3" json:"Token,omitempty"`
}

func (m *Match_Engine_Request) Reset()                    { *m = Match_Engine_Request{} }
func (m *Match_Engine_Request) String() string            { return proto.CompactTextString(m) }
func (*Match_Engine_Request) ProtoMessage()               {}
func (*Match_Engine_Request) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{0} }

type Match_Engine_Reply struct {
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// domain name
	Uri string `protobuf:"bytes,2,opt,name=uri,proto3" json:"uri,omitempty"`
	// ip of the app service
	ServiceIp []byte `protobuf:"bytes,3,opt,name=service_ip,json=serviceIp,proto3" json:"service_ip,omitempty"`
	// port of the app service?
	ServicePort uint32 `protobuf:"varint,4,opt,name=service_port,json=servicePort,proto3" json:"service_port,omitempty"`
	// location of the cloudlet?
	CloudletLocation *Loc `protobuf:"bytes,5,opt,name=cloudlet_location,json=cloudletLocation" json:"cloudlet_location,omitempty"`
	// Status return
	Status bool `protobuf:"varint,6,opt,name=Status,proto3" json:"Status,omitempty"`
	// Token
	Token string `protobuf:"bytes,7,opt,name=Token,proto3" json:"Token,omitempty"`
}

func (m *Match_Engine_Reply) Reset()                    { *m = Match_Engine_Reply{} }
func (m *Match_Engine_Reply) String() string            { return proto.CompactTextString(m) }
func (*Match_Engine_Reply) ProtoMessage()               {}
func (*Match_Engine_Reply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{1} }

type Match_Engine_Loc_Verify struct {
	Ver               uint32                                      `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	TowerStatus       Match_Engine_Loc_Verify_Tower_Status        `protobuf:"varint,2,opt,name=tower_status,json=towerStatus,proto3,enum=distributed_match_engine.Match_Engine_Loc_Verify_Tower_Status" json:"tower_status,omitempty"`
	GpsLocationStatus Match_Engine_Loc_Verify_GPS_Location_Status `protobuf:"varint,3,opt,name=gps_location_status,json=gpsLocationStatus,proto3,enum=distributed_match_engine.Match_Engine_Loc_Verify_GPS_Location_Status" json:"gps_location_status,omitempty"`
	// Token
	Token string `protobuf:"bytes,4,opt,name=Token,proto3" json:"Token,omitempty"`
}

func (m *Match_Engine_Loc_Verify) Reset()                    { *m = Match_Engine_Loc_Verify{} }
func (m *Match_Engine_Loc_Verify) String() string            { return proto.CompactTextString(m) }
func (*Match_Engine_Loc_Verify) ProtoMessage()               {}
func (*Match_Engine_Loc_Verify) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{2} }

type Match_Engine_Loc struct {
	Ver    uint32                      `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	Status Match_Engine_Loc_Loc_Status `protobuf:"varint,2,opt,name=Status,proto3,enum=distributed_match_engine.Match_Engine_Loc_Loc_Status" json:"Status,omitempty"`
	// The carrier name that user is connected to ("Cellular Carrier Name")
	CarrierName string `protobuf:"bytes,3,opt,name=CarrierName,proto3" json:"CarrierName,omitempty"`
	// The tower that user is currently connected to
	Tower uint64 `protobuf:"varint,4,opt,name=Tower,proto3" json:"Tower,omitempty"`
	// The GPS location of the user
	NetworkLocation *Loc `protobuf:"bytes,5,opt,name=NetworkLocation" json:"NetworkLocation,omitempty"`
	// Token
	Token string `protobuf:"bytes,6,opt,name=Token,proto3" json:"Token,omitempty"`
}

func (m *Match_Engine_Loc) Reset()                    { *m = Match_Engine_Loc{} }
func (m *Match_Engine_Loc) String() string            { return proto.CompactTextString(m) }
func (*Match_Engine_Loc) ProtoMessage()               {}
func (*Match_Engine_Loc) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{3} }

type Match_Engine_Status struct {
	Ver    uint32                        `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	Status Match_Engine_Status_ME_Status `protobuf:"varint,2,opt,name=Status,proto3,enum=distributed_match_engine.Match_Engine_Status_ME_Status" json:"Status,omitempty"`
	// Error Code based on Failure
	ErrorCode uint32 `protobuf:"varint,3,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	// Token
	Token string `protobuf:"bytes,4,opt,name=Token,proto3" json:"Token,omitempty"`
}

func (m *Match_Engine_Status) Reset()                    { *m = Match_Engine_Status{} }
func (m *Match_Engine_Status) String() string            { return proto.CompactTextString(m) }
func (*Match_Engine_Status) ProtoMessage()               {}
func (*Match_Engine_Status) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{4} }

func init() {
	proto.RegisterType((*Match_Engine_Request)(nil), "distributed_match_engine.Match_Engine_Request")
	proto.RegisterType((*Match_Engine_Reply)(nil), "distributed_match_engine.Match_Engine_Reply")
	proto.RegisterType((*Match_Engine_Loc_Verify)(nil), "distributed_match_engine.Match_Engine_Loc_Verify")
	proto.RegisterType((*Match_Engine_Loc)(nil), "distributed_match_engine.Match_Engine_Loc")
	proto.RegisterType((*Match_Engine_Status)(nil), "distributed_match_engine.Match_Engine_Status")
	proto.RegisterEnum("distributed_match_engine.Match_Engine_Request_IDType", Match_Engine_Request_IDType_name, Match_Engine_Request_IDType_value)
	proto.RegisterEnum("distributed_match_engine.Match_Engine_Loc_Verify_Tower_Status", Match_Engine_Loc_Verify_Tower_Status_name, Match_Engine_Loc_Verify_Tower_Status_value)
	proto.RegisterEnum("distributed_match_engine.Match_Engine_Loc_Verify_GPS_Location_Status", Match_Engine_Loc_Verify_GPS_Location_Status_name, Match_Engine_Loc_Verify_GPS_Location_Status_value)
	proto.RegisterEnum("distributed_match_engine.Match_Engine_Loc_Loc_Status", Match_Engine_Loc_Loc_Status_name, Match_Engine_Loc_Loc_Status_value)
	proto.RegisterEnum("distributed_match_engine.Match_Engine_Status_ME_Status", Match_Engine_Status_ME_Status_name, Match_Engine_Status_ME_Status_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Match_Engine_Api service

type Match_Engine_ApiClient interface {
	FindCloudlet(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Reply, error)
	VerifyLocation(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Loc_Verify, error)
	GetLocation(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Loc, error)
	RegisterClient(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Status, error)
}

type match_Engine_ApiClient struct {
	cc *grpc.ClientConn
}

func NewMatch_Engine_ApiClient(cc *grpc.ClientConn) Match_Engine_ApiClient {
	return &match_Engine_ApiClient{cc}
}

func (c *match_Engine_ApiClient) FindCloudlet(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Reply, error) {
	out := new(Match_Engine_Reply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/FindCloudlet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *match_Engine_ApiClient) VerifyLocation(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Loc_Verify, error) {
	out := new(Match_Engine_Loc_Verify)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/VerifyLocation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *match_Engine_ApiClient) GetLocation(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Loc, error) {
	out := new(Match_Engine_Loc)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/GetLocation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *match_Engine_ApiClient) RegisterClient(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Status, error) {
	out := new(Match_Engine_Status)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/RegisterClient", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Match_Engine_Api service

type Match_Engine_ApiServer interface {
	FindCloudlet(context.Context, *Match_Engine_Request) (*Match_Engine_Reply, error)
	VerifyLocation(context.Context, *Match_Engine_Request) (*Match_Engine_Loc_Verify, error)
	GetLocation(context.Context, *Match_Engine_Request) (*Match_Engine_Loc, error)
	RegisterClient(context.Context, *Match_Engine_Request) (*Match_Engine_Status, error)
}

func RegisterMatch_Engine_ApiServer(s *grpc.Server, srv Match_Engine_ApiServer) {
	s.RegisterService(&_Match_Engine_Api_serviceDesc, srv)
}

func _Match_Engine_Api_FindCloudlet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Match_Engine_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).FindCloudlet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/FindCloudlet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).FindCloudlet(ctx, req.(*Match_Engine_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_Engine_Api_VerifyLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Match_Engine_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).VerifyLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/VerifyLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).VerifyLocation(ctx, req.(*Match_Engine_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_Engine_Api_GetLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Match_Engine_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).GetLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/GetLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).GetLocation(ctx, req.(*Match_Engine_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_Engine_Api_RegisterClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Match_Engine_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).RegisterClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/RegisterClient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).RegisterClient(ctx, req.(*Match_Engine_Request))
	}
	return interceptor(ctx, in, info, handler)
}

var _Match_Engine_Api_serviceDesc = grpc.ServiceDesc{
	ServiceName: "distributed_match_engine.Match_Engine_Api",
	HandlerType: (*Match_Engine_ApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FindCloudlet",
			Handler:    _Match_Engine_Api_FindCloudlet_Handler,
		},
		{
			MethodName: "VerifyLocation",
			Handler:    _Match_Engine_Api_VerifyLocation_Handler,
		},
		{
			MethodName: "GetLocation",
			Handler:    _Match_Engine_Api_GetLocation_Handler,
		},
		{
			MethodName: "RegisterClient",
			Handler:    _Match_Engine_Api_RegisterClient_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app-client.proto",
}

func (m *Match_Engine_Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match_Engine_Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.IdType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.IdType))
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.CarrierID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CarrierID))
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if m.Tower != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Tower))
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n1, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.AppId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.AppId))
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if len(m.ServerPort) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.ServerPort)))
		i += copy(dAtA[i:], m.ServerPort)
	}
	if len(m.DevName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.DevName)))
		i += copy(dAtA[i:], m.DevName)
	}
	if len(m.AppName) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppName)))
		i += copy(dAtA[i:], m.AppName)
	}
	if len(m.AppVers) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppVers)))
		i += copy(dAtA[i:], m.AppVers)
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	return i, nil
}

func (m *Match_Engine_Reply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match_Engine_Reply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.Uri) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	if len(m.ServiceIp) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.ServiceIp)))
		i += copy(dAtA[i:], m.ServiceIp)
	}
	if m.ServicePort != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.ServicePort))
	}
	if m.CloudletLocation != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CloudletLocation.Size()))
		n2, err := m.CloudletLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Status {
		dAtA[i] = 0x30
		i++
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	return i, nil
}

func (m *Match_Engine_Loc_Verify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match_Engine_Loc_Verify) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.TowerStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.TowerStatus))
	}
	if m.GpsLocationStatus != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocationStatus))
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	return i, nil
}

func (m *Match_Engine_Loc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match_Engine_Loc) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if m.Tower != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Tower))
	}
	if m.NetworkLocation != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.NetworkLocation.Size()))
		n3, err := m.NetworkLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	return i, nil
}

func (m *Match_Engine_Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match_Engine_Status) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	return i, nil
}

func encodeVarintAppClient(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Match_Engine_Request) CopyInFields(src *Match_Engine_Request) {
	m.Ver = src.Ver
	m.IdType = src.IdType
	m.Id = src.Id
	m.CarrierID = src.CarrierID
	m.CarrierName = src.CarrierName
	m.Tower = src.Tower
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		m.GpsLocation.Lat = src.GpsLocation.Lat
		m.GpsLocation.Long = src.GpsLocation.Long
		m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
		m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
		m.GpsLocation.Altitude = src.GpsLocation.Altitude
		m.GpsLocation.Course = src.GpsLocation.Course
		m.GpsLocation.Speed = src.GpsLocation.Speed
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &google_protobuf.Timestamp{}
			m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
			m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
		}
	}
	m.AppId = src.AppId
	if m.Protocol == nil || len(m.Protocol) < len(src.Protocol) {
		m.Protocol = make([]byte, len(src.Protocol))
	}
	copy(m.Protocol, src.Protocol)
	if m.ServerPort == nil || len(m.ServerPort) < len(src.ServerPort) {
		m.ServerPort = make([]byte, len(src.ServerPort))
	}
	copy(m.ServerPort, src.ServerPort)
	m.DevName = src.DevName
	m.AppName = src.AppName
	m.AppVers = src.AppVers
	m.Token = src.Token
}

func (m *Match_Engine_Reply) CopyInFields(src *Match_Engine_Reply) {
	m.Ver = src.Ver
	m.Uri = src.Uri
	if m.ServiceIp == nil || len(m.ServiceIp) < len(src.ServiceIp) {
		m.ServiceIp = make([]byte, len(src.ServiceIp))
	}
	copy(m.ServiceIp, src.ServiceIp)
	m.ServicePort = src.ServicePort
	if src.CloudletLocation != nil {
		m.CloudletLocation = &Loc{}
		m.CloudletLocation.Lat = src.CloudletLocation.Lat
		m.CloudletLocation.Long = src.CloudletLocation.Long
		m.CloudletLocation.HorizontalAccuracy = src.CloudletLocation.HorizontalAccuracy
		m.CloudletLocation.VerticalAccuracy = src.CloudletLocation.VerticalAccuracy
		m.CloudletLocation.Altitude = src.CloudletLocation.Altitude
		m.CloudletLocation.Course = src.CloudletLocation.Course
		m.CloudletLocation.Speed = src.CloudletLocation.Speed
		if src.CloudletLocation.Timestamp != nil {
			m.CloudletLocation.Timestamp = &google_protobuf.Timestamp{}
			m.CloudletLocation.Timestamp.Seconds = src.CloudletLocation.Timestamp.Seconds
			m.CloudletLocation.Timestamp.Nanos = src.CloudletLocation.Timestamp.Nanos
		}
	}
	m.Status = src.Status
	m.Token = src.Token
}

func (m *Match_Engine_Loc_Verify) CopyInFields(src *Match_Engine_Loc_Verify) {
	m.Ver = src.Ver
	m.TowerStatus = src.TowerStatus
	m.GpsLocationStatus = src.GpsLocationStatus
	m.Token = src.Token
}

func (m *Match_Engine_Loc) CopyInFields(src *Match_Engine_Loc) {
	m.Ver = src.Ver
	m.Status = src.Status
	m.CarrierName = src.CarrierName
	m.Tower = src.Tower
	if src.NetworkLocation != nil {
		m.NetworkLocation = &Loc{}
		m.NetworkLocation.Lat = src.NetworkLocation.Lat
		m.NetworkLocation.Long = src.NetworkLocation.Long
		m.NetworkLocation.HorizontalAccuracy = src.NetworkLocation.HorizontalAccuracy
		m.NetworkLocation.VerticalAccuracy = src.NetworkLocation.VerticalAccuracy
		m.NetworkLocation.Altitude = src.NetworkLocation.Altitude
		m.NetworkLocation.Course = src.NetworkLocation.Course
		m.NetworkLocation.Speed = src.NetworkLocation.Speed
		if src.NetworkLocation.Timestamp != nil {
			m.NetworkLocation.Timestamp = &google_protobuf.Timestamp{}
			m.NetworkLocation.Timestamp.Seconds = src.NetworkLocation.Timestamp.Seconds
			m.NetworkLocation.Timestamp.Nanos = src.NetworkLocation.Timestamp.Nanos
		}
	}
	m.Token = src.Token
}

func (m *Match_Engine_Status) CopyInFields(src *Match_Engine_Status) {
	m.Ver = src.Ver
	m.Status = src.Status
	m.ErrorCode = src.ErrorCode
	m.Token = src.Token
}

var IDTypeStrings = []string{
	"IMEI",
	"MSISDN",
	"IPADDR",
}

const (
	IDTypeIMEI   uint64 = 1 << 0
	IDTypeMSISDN uint64 = 1 << 1
	IDTypeIPADDR uint64 = 1 << 2
)

func (e *Match_Engine_Request_IDType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := Match_Engine_Request_IDType_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = Match_Engine_Request_IDType_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = Match_Engine_Request_IDType(val)
	return nil
}

func (e Match_Engine_Request_IDType) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

var Tower_StatusStrings = []string{
	"UNKNOWN",
	"CONNECTED_TO_SPECIFIED_TOWER",
	"NOT_CONNECTED_TO_SPECIFIED_TOWER",
}

const (
	Tower_StatusUNKNOWN                          uint64 = 1 << 0
	Tower_StatusCONNECTED_TO_SPECIFIED_TOWER     uint64 = 1 << 1
	Tower_StatusNOT_CONNECTED_TO_SPECIFIED_TOWER uint64 = 1 << 2
)

func (e *Match_Engine_Loc_Verify_Tower_Status) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := Match_Engine_Loc_Verify_Tower_Status_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = Match_Engine_Loc_Verify_Tower_Status_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = Match_Engine_Loc_Verify_Tower_Status(val)
	return nil
}

func (e Match_Engine_Loc_Verify_Tower_Status) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

var GPS_Location_StatusStrings = []string{
	"LOC_UNKNOWN",
	"LOC_WITHIN_2KM",
	"LOC_WITHIN_10KM",
	"LOC_WITHIN_100KM",
	"LOC_MISMATCH",
	"LOC_OTHER_COUNTRY",
}

const (
	GPS_Location_StatusLOC_UNKNOWN       uint64 = 1 << 0
	GPS_Location_StatusLOC_WITHIN_2KM    uint64 = 1 << 1
	GPS_Location_StatusLOC_WITHIN_10KM   uint64 = 1 << 2
	GPS_Location_StatusLOC_WITHIN_100KM  uint64 = 1 << 3
	GPS_Location_StatusLOC_MISMATCH      uint64 = 1 << 4
	GPS_Location_StatusLOC_OTHER_COUNTRY uint64 = 1 << 5
)

func (e *Match_Engine_Loc_Verify_GPS_Location_Status) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := Match_Engine_Loc_Verify_GPS_Location_Status_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = Match_Engine_Loc_Verify_GPS_Location_Status_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = Match_Engine_Loc_Verify_GPS_Location_Status(val)
	return nil
}

func (e Match_Engine_Loc_Verify_GPS_Location_Status) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

var Loc_StatusStrings = []string{
	"LOC_UNKNOWN",
	"LOC_FOUND",
	"LOC_DENIED",
}

const (
	Loc_StatusLOC_UNKNOWN uint64 = 1 << 0
	Loc_StatusLOC_FOUND   uint64 = 1 << 1
	Loc_StatusLOC_DENIED  uint64 = 1 << 2
)

func (e *Match_Engine_Loc_Loc_Status) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := Match_Engine_Loc_Loc_Status_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = Match_Engine_Loc_Loc_Status_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = Match_Engine_Loc_Loc_Status(val)
	return nil
}

func (e Match_Engine_Loc_Loc_Status) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

var ME_StatusStrings = []string{
	"ME_SUCCESS",
	"ME_FAIL",
}

const (
	ME_StatusME_SUCCESS uint64 = 1 << 0
	ME_StatusME_FAIL    uint64 = 1 << 1
)

func (e *Match_Engine_Status_ME_Status) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := Match_Engine_Status_ME_Status_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = Match_Engine_Status_ME_Status_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = Match_Engine_Status_ME_Status(val)
	return nil
}

func (e Match_Engine_Status_ME_Status) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

func (m *Match_Engine_Request) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.IdType != 0 {
		n += 1 + sovAppClient(uint64(m.IdType))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.CarrierID != 0 {
		n += 1 + sovAppClient(uint64(m.CarrierID))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Tower != 0 {
		n += 1 + sovAppClient(uint64(m.Tower))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.AppId != 0 {
		n += 1 + sovAppClient(uint64(m.AppId))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.ServerPort)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.DevName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppVers)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *Match_Engine_Reply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.ServiceIp)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.ServicePort != 0 {
		n += 1 + sovAppClient(uint64(m.ServicePort))
	}
	if m.CloudletLocation != nil {
		l = m.CloudletLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Status {
		n += 2
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *Match_Engine_Loc_Verify) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.TowerStatus != 0 {
		n += 1 + sovAppClient(uint64(m.TowerStatus))
	}
	if m.GpsLocationStatus != 0 {
		n += 1 + sovAppClient(uint64(m.GpsLocationStatus))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *Match_Engine_Loc) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Tower != 0 {
		n += 1 + sovAppClient(uint64(m.Tower))
	}
	if m.NetworkLocation != nil {
		l = m.NetworkLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *Match_Engine_Status) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAppClient(uint64(m.ErrorCode))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func sovAppClient(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAppClient(x uint64) (n int) {
	return sovAppClient(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Match_Engine_Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match_Engine_Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match_Engine_Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdType", wireType)
			}
			m.IdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdType |= (Match_Engine_Request_IDType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierID", wireType)
			}
			m.CarrierID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CarrierID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tower", wireType)
			}
			m.Tower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tower |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = append(m.Protocol[:0], dAtA[iNdEx:postIndex]...)
			if m.Protocol == nil {
				m.Protocol = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerPort", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerPort = append(m.ServerPort[:0], dAtA[iNdEx:postIndex]...)
			if m.ServerPort == nil {
				m.ServerPort = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Match_Engine_Reply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match_Engine_Reply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match_Engine_Reply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceIp", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceIp = append(m.ServiceIp[:0], dAtA[iNdEx:postIndex]...)
			if m.ServiceIp == nil {
				m.ServiceIp = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicePort", wireType)
			}
			m.ServicePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServicePort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloudletLocation == nil {
				m.CloudletLocation = &Loc{}
			}
			if err := m.CloudletLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Match_Engine_Loc_Verify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match_Engine_Loc_Verify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match_Engine_Loc_Verify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TowerStatus", wireType)
			}
			m.TowerStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TowerStatus |= (Match_Engine_Loc_Verify_Tower_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocationStatus", wireType)
			}
			m.GpsLocationStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpsLocationStatus |= (Match_Engine_Loc_Verify_GPS_Location_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Match_Engine_Loc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match_Engine_Loc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match_Engine_Loc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Match_Engine_Loc_Loc_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tower", wireType)
			}
			m.Tower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tower |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkLocation == nil {
				m.NetworkLocation = &Loc{}
			}
			if err := m.NetworkLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Match_Engine_Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match_Engine_Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match_Engine_Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Match_Engine_Status_ME_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAppClient(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAppClient
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAppClient(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAppClient = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAppClient   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("app-client.proto", fileDescriptorAppClient) }

var fileDescriptorAppClient = []byte{
	// 926 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x51, 0x6f, 0xe2, 0x46,
	0x10, 0x66, 0x81, 0x90, 0x30, 0x10, 0xb2, 0xd9, 0xa4, 0xad, 0x15, 0xe5, 0x10, 0xb5, 0xfa, 0x80,
	0x4e, 0x3d, 0xd4, 0x4b, 0x75, 0xea, 0x4b, 0xd5, 0x8a, 0xda, 0x4e, 0xb2, 0x0d, 0x36, 0xc8, 0x26,
	0x17, 0xf5, 0xc9, 0xe2, 0xcc, 0x36, 0xb5, 0xc2, 0x61, 0xdf, 0xda, 0xe4, 0x94, 0xb7, 0xfe, 0x82,
	0x4a, 0xfd, 0x57, 0x79, 0xec, 0x53, 0xa5, 0xbe, 0xb5, 0xf9, 0x0d, 0xfd, 0x01, 0xa7, 0x5d, 0xdb,
	0xe0, 0x70, 0xe4, 0x04, 0x6f, 0x9e, 0x6f, 0x76, 0x66, 0x76, 0xbe, 0xf9, 0x76, 0x00, 0xf0, 0x28,
	0x0c, 0x5f, 0x78, 0x13, 0x9f, 0x4d, 0xe3, 0x4e, 0xc8, 0x83, 0x38, 0x20, 0xca, 0xd8, 0x8f, 0x62,
	0xee, 0xbf, 0x99, 0xc5, 0x6c, 0xec, 0xbe, 0x1d, 0xc5, 0xde, 0x6f, 0x2e, 0x9b, 0x5e, 0xfb, 0x53,
	0x76, 0x54, 0x9d, 0x04, 0x5e, 0x72, 0x48, 0xfd, 0xbd, 0x0c, 0x87, 0xa6, 0xf4, 0x19, 0xd2, 0xe7,
	0xda, 0xec, 0xdd, 0x8c, 0x45, 0x31, 0xc1, 0x50, 0xba, 0x65, 0x5c, 0x41, 0x2d, 0xd4, 0xde, 0xb5,
	0xc5, 0x27, 0x31, 0xa1, 0x42, 0xc7, 0xc3, 0xbb, 0x90, 0x29, 0xc5, 0x16, 0x6a, 0x37, 0x4e, 0x5e,
	0x75, 0x9e, 0x2a, 0xd0, 0x59, 0x95, 0xb1, 0x43, 0x75, 0x11, 0x6c, 0xa7, 0x49, 0x48, 0x03, 0x8a,
	0x74, 0xac, 0x94, 0x5a, 0xa8, 0x5d, 0xb5, 0x8b, 0x74, 0x4c, 0x8e, 0xa1, 0xaa, 0x8d, 0x38, 0xf7,
	0x19, 0xa7, 0xba, 0x52, 0x6e, 0xa1, 0x76, 0xd9, 0x5e, 0x00, 0xa4, 0x05, 0xb5, 0xd4, 0xb0, 0x46,
	0x6f, 0x99, 0xb2, 0x25, 0xc3, 0xf2, 0x10, 0x39, 0x84, 0xad, 0x61, 0xf0, 0x9e, 0x71, 0xa5, 0x22,
	0x63, 0x13, 0x83, 0xfc, 0x08, 0xb5, 0xb3, 0x30, 0xea, 0x05, 0xde, 0x28, 0xf6, 0x83, 0xa9, 0xb2,
	0xdd, 0x42, 0xed, 0xda, 0xc9, 0xb3, 0xa7, 0x6f, 0xde, 0x0b, 0x3c, 0x3b, 0x1f, 0x21, 0xd2, 0x76,
	0xc3, 0x90, 0x8e, 0x95, 0x9d, 0x24, 0xad, 0x34, 0xc8, 0x11, 0xec, 0x0c, 0x04, 0x7f, 0x5e, 0x30,
	0x51, 0xaa, 0x2d, 0xd4, 0xae, 0xdb, 0x73, 0x9b, 0x34, 0x01, 0x1c, 0xc6, 0x6f, 0x19, 0x1f, 0x04,
	0x3c, 0x56, 0x40, 0x7a, 0x73, 0x08, 0x51, 0x60, 0x5b, 0x67, 0xb7, 0xb2, 0x8d, 0x9a, 0x6c, 0x23,
	0x33, 0x85, 0xa7, 0x1b, 0x86, 0xd2, 0x53, 0x4f, 0x3c, 0xa9, 0x99, 0x7a, 0x5e, 0x33, 0x1e, 0x29,
	0xbb, 0x73, 0x8f, 0x30, 0x93, 0xb6, 0x6f, 0xd8, 0x54, 0x69, 0x48, 0x3c, 0x31, 0xd4, 0xe7, 0x50,
	0x49, 0xe8, 0x26, 0x3b, 0x50, 0xa6, 0xa6, 0x41, 0x71, 0x81, 0x00, 0x54, 0x4c, 0x87, 0x3a, 0xba,
	0x85, 0x91, 0xf8, 0xa6, 0x83, 0xae, 0xae, 0xdb, 0xb8, 0xa8, 0xfe, 0x8f, 0x80, 0x2c, 0x0d, 0x2c,
	0x9c, 0xdc, 0xad, 0x10, 0x00, 0x86, 0xd2, 0x8c, 0xfb, 0x72, 0xfa, 0x55, 0x5b, 0x7c, 0x92, 0x67,
	0x00, 0x11, 0xe3, 0xb7, 0xbe, 0xc7, 0x5c, 0x3f, 0x94, 0xb3, 0xac, 0xdb, 0xd5, 0x14, 0xa1, 0x21,
	0xf9, 0x12, 0xea, 0x99, 0x3b, 0x14, 0x5c, 0x94, 0x65, 0xae, 0x5a, 0x8a, 0x49, 0x32, 0x7e, 0x86,
	0x7d, 0x6f, 0x12, 0xcc, 0xc6, 0x13, 0x16, 0xbb, 0x93, 0x6c, 0x4a, 0x5b, 0xeb, 0x4c, 0x09, 0x67,
	0x71, 0xf3, 0x51, 0x7d, 0x0e, 0x15, 0x27, 0x1e, 0xc5, 0xb3, 0x48, 0x4a, 0x60, 0xc7, 0x4e, 0xad,
	0x05, 0x45, 0xdb, 0x79, 0x8a, 0xfe, 0x2c, 0xc3, 0x17, 0x8f, 0xda, 0xee, 0x05, 0x9e, 0xfb, 0x9a,
	0x71, 0xff, 0xd7, 0x55, 0xbd, 0x8f, 0xa0, 0x1e, 0x0b, 0x41, 0xb9, 0x51, 0x52, 0x21, 0x79, 0x02,
	0x3f, 0xac, 0xf9, 0x04, 0x16, 0xa9, 0x3b, 0x52, 0x96, 0x6e, 0x72, 0x33, 0xbb, 0x26, 0x73, 0xa6,
	0xd7, 0x9c, 0xc1, 0xc1, 0x75, 0x18, 0xcd, 0x59, 0xc8, 0x2a, 0x95, 0x64, 0x25, 0x63, 0xf3, 0x4a,
	0x67, 0x03, 0xc7, 0xcd, 0xb8, 0xc9, 0x0a, 0xee, 0x5f, 0x2f, 0xa4, 0xbd, 0xcc, 0x4e, 0x39, 0xcf,
	0x8e, 0x07, 0xf5, 0xfc, 0x4d, 0x49, 0x0d, 0xb6, 0x2f, 0xad, 0x0b, 0xab, 0x7f, 0x65, 0xe1, 0x02,
	0x69, 0xc1, 0xb1, 0xd6, 0xb7, 0x2c, 0x43, 0x1b, 0x1a, 0xba, 0x3b, 0xec, 0xbb, 0xce, 0xc0, 0xd0,
	0xe8, 0x29, 0x95, 0xc6, 0x95, 0x61, 0x63, 0x44, 0xbe, 0x82, 0x96, 0xd5, 0x1f, 0xba, 0x9f, 0x3c,
	0x55, 0x54, 0xff, 0x40, 0x70, 0xb0, 0xe2, 0x96, 0x64, 0x0f, 0x6a, 0xbd, 0xbe, 0xe6, 0x2e, 0x0a,
	0x12, 0x68, 0x08, 0xe0, 0x8a, 0x0e, 0xcf, 0xa9, 0xe5, 0x9e, 0x5c, 0x98, 0x18, 0x91, 0x03, 0xd8,
	0xcb, 0x61, 0x2f, 0xbf, 0xb9, 0x30, 0x71, 0x91, 0x1c, 0x02, 0x7e, 0x04, 0x0a, 0xb4, 0x44, 0x30,
	0xd4, 0x05, 0x6a, 0x52, 0xc7, 0xec, 0x0e, 0xb5, 0x73, 0x5c, 0x26, 0x9f, 0xc1, 0xbe, 0x40, 0xfa,
	0xc3, 0x73, 0xc3, 0x76, 0xb5, 0xfe, 0xa5, 0x35, 0xb4, 0x7f, 0xc1, 0x5b, 0xea, 0x7d, 0x11, 0xf0,
	0x32, 0x9d, 0xab, 0x37, 0xa1, 0x93, 0x97, 0xc1, 0xab, 0xf5, 0x87, 0x23, 0xa4, 0x9b, 0x0d, 0x23,
	0xd3, 0xe7, 0xd2, 0x6e, 0x2b, 0x7d, 0x62, 0xb7, 0x95, 0xf3, 0xbb, 0xed, 0x0c, 0xf6, 0x2c, 0x16,
	0xbf, 0x0f, 0xf8, 0x4d, 0x6f, 0xa3, 0x97, 0xb3, 0x1c, 0xb5, 0x90, 0x40, 0x25, 0x2f, 0x81, 0xef,
	0x01, 0x16, 0x97, 0xfd, 0x78, 0x26, 0xbb, 0x50, 0x15, 0xc0, 0x69, 0xff, 0xd2, 0xd2, 0x31, 0x22,
	0x0d, 0x00, 0x61, 0xea, 0x86, 0x45, 0x0d, 0x1d, 0x17, 0xd5, 0xbf, 0x11, 0x1c, 0x3c, 0x6a, 0x3e,
	0xcd, 0xf3, 0x31, 0x9b, 0xfd, 0x25, 0x36, 0xbf, 0x5b, 0x93, 0xcd, 0x24, 0xa8, 0x63, 0x1a, 0xcb,
	0x7c, 0x1e, 0x43, 0xd5, 0xe0, 0x3c, 0xe0, 0x5a, 0x30, 0x4e, 0xd8, 0xdc, 0xb5, 0x17, 0xc0, 0x13,
	0x7a, 0x6f, 0x43, 0x75, 0x9e, 0x48, 0xf4, 0x22, 0x8c, 0x4b, 0x4d, 0x33, 0x1c, 0x07, 0x17, 0x84,
	0xf8, 0x4d, 0xc3, 0x3d, 0xed, 0xd2, 0x1e, 0x46, 0x27, 0xff, 0x94, 0x96, 0x34, 0xd2, 0x0d, 0x7d,
	0x32, 0x85, 0xfa, 0xa9, 0x3f, 0x1d, 0x6b, 0xe9, 0x4a, 0x22, 0x9d, 0xcd, 0x7e, 0x1b, 0x8f, 0xbe,
	0x5e, 0xfb, 0x7c, 0x38, 0xb9, 0x53, 0x0b, 0x64, 0x06, 0x8d, 0xe4, 0x95, 0xcf, 0x67, 0xb8, 0x69,
	0xc5, 0x97, 0x1b, 0x2f, 0x14, 0xb5, 0x40, 0x6e, 0xa0, 0x76, 0x96, 0x5b, 0xb8, 0x9b, 0xd6, 0x7c,
	0xbe, 0x7e, 0x4d, 0xb5, 0x40, 0xde, 0x41, 0xc3, 0x66, 0xd7, 0x7e, 0x14, 0x33, 0xae, 0xc9, 0xff,
	0x35, 0x1b, 0xd7, 0x7b, 0xb1, 0x91, 0x92, 0xd4, 0xc2, 0x4f, 0xf8, 0xfe, 0xbf, 0x66, 0xe1, 0xfe,
	0xa1, 0x89, 0xfe, 0x7a, 0x68, 0xa2, 0x7f, 0x1f, 0x9a, 0xe8, 0x4d, 0x45, 0xfe, 0x4d, 0xfa, 0xf6,
	0x43, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe4, 0xb9, 0x60, 0xa3, 0x5f, 0x09, 0x00, 0x00,
}
