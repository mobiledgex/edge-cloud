// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app-client.proto

/*
	Package distributed_match_engine is a generated protocol buffer package.

	It is generated from these files:
		app-client.proto
		appcommon.proto
		dynamic-location-group.proto
		loc.proto

	It has these top-level messages:
		Tag
		RegisterClientRequest
		RegisterClientReply
		FindCloudletRequest
		FindCloudletReply
		VerifyLocationRequest
		VerifyLocationReply
		GetLocationRequest
		GetLocationReply
		AppInstListRequest
		Appinstance
		CloudletLocation
		AppInstListReply
		FqdnListRequest
		AppFqdn
		FqdnListReply
		DynamicLocGroupRequest
		DynamicLocGroupReply
		QosPosition
		BandSelection
		QosPositionRequest
		QosPositionKpiResult
		QosPositionKpiReply
		AppPort
		DlgMessage
		DlgReply
		Timestamp
		Loc
*/
package distributed_match_engine

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import binary "encoding/binary"

import "github.com/mobiledgex/edge-cloud/util"
import "errors"
import "strconv"
import "encoding/json"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type IDTypes int32

const (
	IDTypes_ID_UNDEFINED IDTypes = 0
	IDTypes_IMEI         IDTypes = 1
	IDTypes_MSISDN       IDTypes = 2
	IDTypes_IPADDR       IDTypes = 3
)

var IDTypes_name = map[int32]string{
	0: "ID_UNDEFINED",
	1: "IMEI",
	2: "MSISDN",
	3: "IPADDR",
}
var IDTypes_value = map[string]int32{
	"ID_UNDEFINED": 0,
	"IMEI":         1,
	"MSISDN":       2,
	"IPADDR":       3,
}

func (x IDTypes) String() string {
	return proto.EnumName(IDTypes_name, int32(x))
}
func (IDTypes) EnumDescriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{0} }

type ReplyStatus int32

const (
	ReplyStatus_RS_UNDEFINED ReplyStatus = 0
	ReplyStatus_RS_SUCCESS   ReplyStatus = 1
	ReplyStatus_RS_FAIL      ReplyStatus = 2
)

var ReplyStatus_name = map[int32]string{
	0: "RS_UNDEFINED",
	1: "RS_SUCCESS",
	2: "RS_FAIL",
}
var ReplyStatus_value = map[string]int32{
	"RS_UNDEFINED": 0,
	"RS_SUCCESS":   1,
	"RS_FAIL":      2,
}

func (x ReplyStatus) String() string {
	return proto.EnumName(ReplyStatus_name, int32(x))
}
func (ReplyStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{1} }

type FindCloudletReply_FindStatus int32

const (
	FindCloudletReply_FIND_UNKNOWN  FindCloudletReply_FindStatus = 0
	FindCloudletReply_FIND_FOUND    FindCloudletReply_FindStatus = 1
	FindCloudletReply_FIND_NOTFOUND FindCloudletReply_FindStatus = 2
)

var FindCloudletReply_FindStatus_name = map[int32]string{
	0: "FIND_UNKNOWN",
	1: "FIND_FOUND",
	2: "FIND_NOTFOUND",
}
var FindCloudletReply_FindStatus_value = map[string]int32{
	"FIND_UNKNOWN":  0,
	"FIND_FOUND":    1,
	"FIND_NOTFOUND": 2,
}

func (x FindCloudletReply_FindStatus) String() string {
	return proto.EnumName(FindCloudletReply_FindStatus_name, int32(x))
}
func (FindCloudletReply_FindStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{4, 0}
}

// Status of the reply
type VerifyLocationReply_TowerStatus int32

const (
	VerifyLocationReply_TOWER_UNKNOWN                    VerifyLocationReply_TowerStatus = 0
	VerifyLocationReply_CONNECTED_TO_SPECIFIED_TOWER     VerifyLocationReply_TowerStatus = 1
	VerifyLocationReply_NOT_CONNECTED_TO_SPECIFIED_TOWER VerifyLocationReply_TowerStatus = 2
)

var VerifyLocationReply_TowerStatus_name = map[int32]string{
	0: "TOWER_UNKNOWN",
	1: "CONNECTED_TO_SPECIFIED_TOWER",
	2: "NOT_CONNECTED_TO_SPECIFIED_TOWER",
}
var VerifyLocationReply_TowerStatus_value = map[string]int32{
	"TOWER_UNKNOWN":                    0,
	"CONNECTED_TO_SPECIFIED_TOWER":     1,
	"NOT_CONNECTED_TO_SPECIFIED_TOWER": 2,
}

func (x VerifyLocationReply_TowerStatus) String() string {
	return proto.EnumName(VerifyLocationReply_TowerStatus_name, int32(x))
}
func (VerifyLocationReply_TowerStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{6, 0}
}

type VerifyLocationReply_GPSLocationStatus int32

const (
	VerifyLocationReply_LOC_UNKNOWN                  VerifyLocationReply_GPSLocationStatus = 0
	VerifyLocationReply_LOC_VERIFIED                 VerifyLocationReply_GPSLocationStatus = 1
	VerifyLocationReply_LOC_MISMATCH_SAME_COUNTRY    VerifyLocationReply_GPSLocationStatus = 2
	VerifyLocationReply_LOC_MISMATCH_OTHER_COUNTRY   VerifyLocationReply_GPSLocationStatus = 3
	VerifyLocationReply_LOC_ROAMING_COUNTRY_MATCH    VerifyLocationReply_GPSLocationStatus = 4
	VerifyLocationReply_LOC_ROAMING_COUNTRY_MISMATCH VerifyLocationReply_GPSLocationStatus = 5
	VerifyLocationReply_LOC_ERROR_UNAUTHORIZED       VerifyLocationReply_GPSLocationStatus = 6
	VerifyLocationReply_LOC_ERROR_OTHER              VerifyLocationReply_GPSLocationStatus = 7
)

var VerifyLocationReply_GPSLocationStatus_name = map[int32]string{
	0: "LOC_UNKNOWN",
	1: "LOC_VERIFIED",
	2: "LOC_MISMATCH_SAME_COUNTRY",
	3: "LOC_MISMATCH_OTHER_COUNTRY",
	4: "LOC_ROAMING_COUNTRY_MATCH",
	5: "LOC_ROAMING_COUNTRY_MISMATCH",
	6: "LOC_ERROR_UNAUTHORIZED",
	7: "LOC_ERROR_OTHER",
}
var VerifyLocationReply_GPSLocationStatus_value = map[string]int32{
	"LOC_UNKNOWN":                  0,
	"LOC_VERIFIED":                 1,
	"LOC_MISMATCH_SAME_COUNTRY":    2,
	"LOC_MISMATCH_OTHER_COUNTRY":   3,
	"LOC_ROAMING_COUNTRY_MATCH":    4,
	"LOC_ROAMING_COUNTRY_MISMATCH": 5,
	"LOC_ERROR_UNAUTHORIZED":       6,
	"LOC_ERROR_OTHER":              7,
}

func (x VerifyLocationReply_GPSLocationStatus) String() string {
	return proto.EnumName(VerifyLocationReply_GPSLocationStatus_name, int32(x))
}
func (VerifyLocationReply_GPSLocationStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{6, 1}
}

// Status of the reply
type GetLocationReply_LocStatus int32

const (
	GetLocationReply_LOC_UNKNOWN GetLocationReply_LocStatus = 0
	GetLocationReply_LOC_FOUND   GetLocationReply_LocStatus = 1
	// The user does not allow his location to be tracked
	GetLocationReply_LOC_DENIED GetLocationReply_LocStatus = 2
)

var GetLocationReply_LocStatus_name = map[int32]string{
	0: "LOC_UNKNOWN",
	1: "LOC_FOUND",
	2: "LOC_DENIED",
}
var GetLocationReply_LocStatus_value = map[string]int32{
	"LOC_UNKNOWN": 0,
	"LOC_FOUND":   1,
	"LOC_DENIED":  2,
}

func (x GetLocationReply_LocStatus) String() string {
	return proto.EnumName(GetLocationReply_LocStatus_name, int32(x))
}
func (GetLocationReply_LocStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{8, 0}
}

// Status of the reply
type AppInstListReply_AIStatus int32

const (
	AppInstListReply_AI_UNDEFINED AppInstListReply_AIStatus = 0
	AppInstListReply_AI_SUCCESS   AppInstListReply_AIStatus = 1
	AppInstListReply_AI_FAIL      AppInstListReply_AIStatus = 2
)

var AppInstListReply_AIStatus_name = map[int32]string{
	0: "AI_UNDEFINED",
	1: "AI_SUCCESS",
	2: "AI_FAIL",
}
var AppInstListReply_AIStatus_value = map[string]int32{
	"AI_UNDEFINED": 0,
	"AI_SUCCESS":   1,
	"AI_FAIL":      2,
}

func (x AppInstListReply_AIStatus) String() string {
	return proto.EnumName(AppInstListReply_AIStatus_name, int32(x))
}
func (AppInstListReply_AIStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{12, 0}
}

// Status of the reply
type FqdnListReply_FLStatus int32

const (
	FqdnListReply_FL_UNDEFINED FqdnListReply_FLStatus = 0
	FqdnListReply_FL_SUCCESS   FqdnListReply_FLStatus = 1
	FqdnListReply_FL_FAIL      FqdnListReply_FLStatus = 2
)

var FqdnListReply_FLStatus_name = map[int32]string{
	0: "FL_UNDEFINED",
	1: "FL_SUCCESS",
	2: "FL_FAIL",
}
var FqdnListReply_FLStatus_value = map[string]int32{
	"FL_UNDEFINED": 0,
	"FL_SUCCESS":   1,
	"FL_FAIL":      2,
}

func (x FqdnListReply_FLStatus) String() string {
	return proto.EnumName(FqdnListReply_FLStatus_name, int32(x))
}
func (FqdnListReply_FLStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{15, 0}
}

// Use Secure communication or Open with the group
type DynamicLocGroupRequest_DlgCommType int32

const (
	DynamicLocGroupRequest_DLG_UNDEFINED DynamicLocGroupRequest_DlgCommType = 0
	DynamicLocGroupRequest_DLG_SECURE    DynamicLocGroupRequest_DlgCommType = 1
	DynamicLocGroupRequest_DLG_OPEN      DynamicLocGroupRequest_DlgCommType = 2
)

var DynamicLocGroupRequest_DlgCommType_name = map[int32]string{
	0: "DLG_UNDEFINED",
	1: "DLG_SECURE",
	2: "DLG_OPEN",
}
var DynamicLocGroupRequest_DlgCommType_value = map[string]int32{
	"DLG_UNDEFINED": 0,
	"DLG_SECURE":    1,
	"DLG_OPEN":      2,
}

func (x DynamicLocGroupRequest_DlgCommType) String() string {
	return proto.EnumName(DynamicLocGroupRequest_DlgCommType_name, int32(x))
}
func (DynamicLocGroupRequest_DlgCommType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{16, 0}
}

type Tag struct {
	// type of data
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// data value
	Data string `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Tag) Reset()                    { *m = Tag{} }
func (m *Tag) String() string            { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()               {}
func (*Tag) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{0} }

type RegisterClientRequest struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// App Developer Name
	DevName string `protobuf:"bytes,2,opt,name=dev_name,json=devName,proto3" json:"dev_name,omitempty"`
	// App Name
	AppName string `protobuf:"bytes,3,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	// App Version
	AppVers string `protobuf:"bytes,4,opt,name=app_vers,json=appVers,proto3" json:"app_vers,omitempty"`
	//
	// Carrier Name
	//
	// _Not currently used_
	CarrierName string `protobuf:"bytes,5,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	//
	// Authentication Token
	//
	// More details about the auth token here
	AuthToken string `protobuf:"bytes,6,opt,name=auth_token,json=authToken,proto3" json:"auth_token,omitempty"`
	//
	// Cell ID
	//
	// Cell ID where the client is
	CellId uint32 `protobuf:"varint,7,opt,name=cell_id,json=cellId,proto3" json:"cell_id,omitempty"`
	//
	// Unique ID Type
	//
	// Type of unique ID provided by the client
	UniqueIdType string `protobuf:"bytes,8,opt,name=unique_id_type,json=uniqueIdType,proto3" json:"unique_id_type,omitempty"`
	//
	// Unique ID
	//
	// Optional. Unique identification of the client device or user. May be overridden by the server.
	UniqueId string `protobuf:"bytes,9,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
	//
	// Tags
	//
	// Vendor specific data
	Tags []*Tag `protobuf:"bytes,99,rep,name=tags" json:"tags,omitempty"`
}

func (m *RegisterClientRequest) Reset()                    { *m = RegisterClientRequest{} }
func (m *RegisterClientRequest) String() string            { return proto.CompactTextString(m) }
func (*RegisterClientRequest) ProtoMessage()               {}
func (*RegisterClientRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{1} }

type RegisterClientReply struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Status of the reply
	Status ReplyStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.ReplyStatus" json:"status,omitempty"`
	// Session Cookie to be used in later API calls
	SessionCookie string `protobuf:"bytes,3,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// URI for the Token Server
	TokenServerUri string `protobuf:"bytes,4,opt,name=token_server_uri,json=tokenServerUri,proto3" json:"token_server_uri,omitempty"`
	//
	// Unique ID Type
	//
	// Type of unique ID provided by the server
	UniqueIdType string `protobuf:"bytes,5,opt,name=unique_id_type,json=uniqueIdType,proto3" json:"unique_id_type,omitempty"`
	//
	// Unique ID
	//
	// Optional. Unique identification of the client device or user
	UniqueId string `protobuf:"bytes,6,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
	// Vendor specific data
	Tags []*Tag `protobuf:"bytes,99,rep,name=tags" json:"tags,omitempty"`
}

func (m *RegisterClientReply) Reset()                    { *m = RegisterClientReply{} }
func (m *RegisterClientReply) String() string            { return proto.CompactTextString(m) }
func (*RegisterClientReply) ProtoMessage()               {}
func (*RegisterClientReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{2} }

type FindCloudletRequest struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	//
	// Session Cookie
	//
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	//
	// Carrier Name
	//
	// Unique carrier identification (typically MCC + MNC)
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	//
	// GPS Location
	//
	// The GPS location of the user
	GpsLocation *Loc `protobuf:"bytes,4,opt,name=gps_location,json=gpsLocation" json:"gps_location,omitempty"`
	//
	// Dev Name
	//
	// Applicable to Platform apps only
	DevName string `protobuf:"bytes,5,opt,name=dev_name,json=devName,proto3" json:"dev_name,omitempty"`
	//
	// App Name
	//
	// Applicable to Platform apps only
	AppName string `protobuf:"bytes,6,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	//
	// App Version
	//
	// Applicable to Platform apps only
	AppVers string `protobuf:"bytes,7,opt,name=app_vers,json=appVers,proto3" json:"app_vers,omitempty"`
	//
	// Cell ID
	//
	// Cell ID where the client is
	CellId uint32 `protobuf:"varint,8,opt,name=cell_id,json=cellId,proto3" json:"cell_id,omitempty"`
	//
	// Tags
	//
	// Vendor specific data
	Tags []*Tag `protobuf:"bytes,99,rep,name=tags" json:"tags,omitempty"`
}

func (m *FindCloudletRequest) Reset()                    { *m = FindCloudletRequest{} }
func (m *FindCloudletRequest) String() string            { return proto.CompactTextString(m) }
func (*FindCloudletRequest) ProtoMessage()               {}
func (*FindCloudletRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{3} }

type FindCloudletReply struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Status return
	Status FindCloudletReply_FindStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.FindCloudletReply_FindStatus" json:"status,omitempty"`
	// Fully Qualified Domain Name of the Closest App instance
	Fqdn string `protobuf:"bytes,3,opt,name=fqdn,proto3" json:"fqdn,omitempty"`
	// List of Service Endpoints for AppInst
	Ports []*AppPort `protobuf:"bytes,4,rep,name=ports" json:"ports,omitempty"`
	// Location of the cloudlet
	CloudletLocation *Loc `protobuf:"bytes,5,opt,name=cloudlet_location,json=cloudletLocation" json:"cloudlet_location,omitempty"`
	// Vendor specific data
	Tags []*Tag `protobuf:"bytes,99,rep,name=tags" json:"tags,omitempty"`
}

func (m *FindCloudletReply) Reset()                    { *m = FindCloudletReply{} }
func (m *FindCloudletReply) String() string            { return proto.CompactTextString(m) }
func (*FindCloudletReply) ProtoMessage()               {}
func (*FindCloudletReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{4} }

type VerifyLocationRequest struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	//
	// Session Cookie
	//
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	//
	// Carrier Name
	//
	// Unique carrier identification (typically MCC + MNC)
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	//
	// GPS Location
	//
	// The GPS location to verify
	GpsLocation *Loc `protobuf:"bytes,4,opt,name=gps_location,json=gpsLocation" json:"gps_location,omitempty"`
	//
	// Verify Location Token
	//
	// Must be retrieved from TokenServerURI
	VerifyLocToken string `protobuf:"bytes,5,opt,name=verify_loc_token,json=verifyLocToken,proto3" json:"verify_loc_token,omitempty"`
	//
	// Cell ID
	//
	// Cell ID where the client is
	CellId uint32 `protobuf:"varint,6,opt,name=cell_id,json=cellId,proto3" json:"cell_id,omitempty"`
	//
	// Tags
	//
	// Vendor specific data
	Tags []*Tag `protobuf:"bytes,99,rep,name=tags" json:"tags,omitempty"`
}

func (m *VerifyLocationRequest) Reset()                    { *m = VerifyLocationRequest{} }
func (m *VerifyLocationRequest) String() string            { return proto.CompactTextString(m) }
func (*VerifyLocationRequest) ProtoMessage()               {}
func (*VerifyLocationRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{5} }

type VerifyLocationReply struct {
	// API version
	Ver               uint32                                `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	TowerStatus       VerifyLocationReply_TowerStatus       `protobuf:"varint,2,opt,name=tower_status,json=towerStatus,proto3,enum=distributed_match_engine.VerifyLocationReply_TowerStatus" json:"tower_status,omitempty"`
	GpsLocationStatus VerifyLocationReply_GPSLocationStatus `protobuf:"varint,3,opt,name=gps_location_status,json=gpsLocationStatus,proto3,enum=distributed_match_engine.VerifyLocationReply_GPSLocationStatus" json:"gps_location_status,omitempty"`
	// location accuracy, the location is verified to
	// be within this number of kilometers.  Negative value
	// means no verification was performed
	GpsLocationAccuracyKm float64 `protobuf:"fixed64,4,opt,name=gps_location_accuracy_km,json=gpsLocationAccuracyKm,proto3" json:"gps_location_accuracy_km,omitempty"`
	// Vendor specific data
	Tags []*Tag `protobuf:"bytes,99,rep,name=tags" json:"tags,omitempty"`
}

func (m *VerifyLocationReply) Reset()                    { *m = VerifyLocationReply{} }
func (m *VerifyLocationReply) String() string            { return proto.CompactTextString(m) }
func (*VerifyLocationReply) ProtoMessage()               {}
func (*VerifyLocationReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{6} }

type GetLocationRequest struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// Unique carrier identification (typically MCC + MNC)
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	// Cell id where the client is
	CellId uint32 `protobuf:"varint,4,opt,name=cell_id,json=cellId,proto3" json:"cell_id,omitempty"`
	// Vendor specific data
	Tags []*Tag `protobuf:"bytes,99,rep,name=tags" json:"tags,omitempty"`
}

func (m *GetLocationRequest) Reset()                    { *m = GetLocationRequest{} }
func (m *GetLocationRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLocationRequest) ProtoMessage()               {}
func (*GetLocationRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{7} }

type GetLocationReply struct {
	Ver    uint32                     `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	Status GetLocationReply_LocStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.GetLocationReply_LocStatus" json:"status,omitempty"`
	// Unique carrier identification (typically MCC + MNC)
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	// The tower that the user is currently connected to
	Tower uint64 `protobuf:"varint,4,opt,name=tower,proto3" json:"tower,omitempty"`
	// The GPS location of the user
	NetworkLocation *Loc `protobuf:"bytes,5,opt,name=network_location,json=networkLocation" json:"network_location,omitempty"`
	// Vendor specific data
	Tags []*Tag `protobuf:"bytes,99,rep,name=tags" json:"tags,omitempty"`
}

func (m *GetLocationReply) Reset()                    { *m = GetLocationReply{} }
func (m *GetLocationReply) String() string            { return proto.CompactTextString(m) }
func (*GetLocationReply) ProtoMessage()               {}
func (*GetLocationReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{8} }

type AppInstListRequest struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// Unique carrier identification (typically MCC + MNC)
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	// The GPS location of the user
	GpsLocation *Loc `protobuf:"bytes,4,opt,name=gps_location,json=gpsLocation" json:"gps_location,omitempty"`
	// Cell id where the client is
	CellId uint32 `protobuf:"varint,5,opt,name=cell_id,json=cellId,proto3" json:"cell_id,omitempty"`
	// Vendor specific data
	Tags []*Tag `protobuf:"bytes,99,rep,name=tags" json:"tags,omitempty"`
}

func (m *AppInstListRequest) Reset()                    { *m = AppInstListRequest{} }
func (m *AppInstListRequest) String() string            { return proto.CompactTextString(m) }
func (*AppInstListRequest) ProtoMessage()               {}
func (*AppInstListRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{9} }

type Appinstance struct {
	// App Instance Name
	AppName string `protobuf:"bytes,1,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	// App Instance Version
	AppVers string `protobuf:"bytes,2,opt,name=app_vers,json=appVers,proto3" json:"app_vers,omitempty"`
	// App Instance FQDN
	Fqdn string `protobuf:"bytes,3,opt,name=fqdn,proto3" json:"fqdn,omitempty"`
	// ports to access app
	Ports []*AppPort `protobuf:"bytes,4,rep,name=ports" json:"ports,omitempty"`
}

func (m *Appinstance) Reset()                    { *m = Appinstance{} }
func (m *Appinstance) String() string            { return proto.CompactTextString(m) }
func (*Appinstance) ProtoMessage()               {}
func (*Appinstance) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{10} }

type CloudletLocation struct {
	// Unique carrier identification (typically MCC + MNC)
	CarrierName string `protobuf:"bytes,1,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	// Cloudlet Name
	CloudletName string `protobuf:"bytes,2,opt,name=cloudlet_name,json=cloudletName,proto3" json:"cloudlet_name,omitempty"`
	// The GPS Location of the user
	GpsLocation *Loc `protobuf:"bytes,3,opt,name=gps_location,json=gpsLocation" json:"gps_location,omitempty"`
	// Distance of cloudlet vs loc in request
	Distance float64 `protobuf:"fixed64,4,opt,name=distance,proto3" json:"distance,omitempty"`
	// App instances
	Appinstances []*Appinstance `protobuf:"bytes,5,rep,name=appinstances" json:"appinstances,omitempty"`
}

func (m *CloudletLocation) Reset()                    { *m = CloudletLocation{} }
func (m *CloudletLocation) String() string            { return proto.CompactTextString(m) }
func (*CloudletLocation) ProtoMessage()               {}
func (*CloudletLocation) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{11} }

type AppInstListReply struct {
	// API version
	Ver       uint32                    `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	Status    AppInstListReply_AIStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.AppInstListReply_AIStatus" json:"status,omitempty"`
	Cloudlets []*CloudletLocation       `protobuf:"bytes,3,rep,name=cloudlets" json:"cloudlets,omitempty"`
	// Vendor specific data
	Tags []*Tag `protobuf:"bytes,99,rep,name=tags" json:"tags,omitempty"`
}

func (m *AppInstListReply) Reset()                    { *m = AppInstListReply{} }
func (m *AppInstListReply) String() string            { return proto.CompactTextString(m) }
func (*AppInstListReply) ProtoMessage()               {}
func (*AppInstListReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{12} }

type FqdnListRequest struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// Cell id where the client is
	CellId uint32 `protobuf:"varint,3,opt,name=cell_id,json=cellId,proto3" json:"cell_id,omitempty"`
	// Vendor specific data
	Tags []*Tag `protobuf:"bytes,99,rep,name=tags" json:"tags,omitempty"`
}

func (m *FqdnListRequest) Reset()                    { *m = FqdnListRequest{} }
func (m *FqdnListRequest) String() string            { return proto.CompactTextString(m) }
func (*FqdnListRequest) ProtoMessage()               {}
func (*FqdnListRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{13} }

type AppFqdn struct {
	// App  Name
	AppName string `protobuf:"bytes,1,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	// App Version
	AppVers string `protobuf:"bytes,2,opt,name=app_vers,json=appVers,proto3" json:"app_vers,omitempty"`
	// developer name
	DevName string `protobuf:"bytes,3,opt,name=dev_name,json=devName,proto3" json:"dev_name,omitempty"`
	// App FQDN
	Fqdns []string `protobuf:"bytes,4,rep,name=fqdns" json:"fqdns,omitempty"`
	// Optional. Android package name
	AndroidPackageName string `protobuf:"bytes,5,opt,name=android_package_name,json=androidPackageName,proto3" json:"android_package_name,omitempty"`
}

func (m *AppFqdn) Reset()                    { *m = AppFqdn{} }
func (m *AppFqdn) String() string            { return proto.CompactTextString(m) }
func (*AppFqdn) ProtoMessage()               {}
func (*AppFqdn) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{14} }

type FqdnListReply struct {
	// API version
	Ver      uint32                 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	AppFqdns []*AppFqdn             `protobuf:"bytes,3,rep,name=app_fqdns,json=appFqdns" json:"app_fqdns,omitempty"`
	Status   FqdnListReply_FLStatus `protobuf:"varint,4,opt,name=status,proto3,enum=distributed_match_engine.FqdnListReply_FLStatus" json:"status,omitempty"`
	// Vendor specific data
	Tags []*Tag `protobuf:"bytes,99,rep,name=tags" json:"tags,omitempty"`
}

func (m *FqdnListReply) Reset()                    { *m = FqdnListReply{} }
func (m *FqdnListReply) String() string            { return proto.CompactTextString(m) }
func (*FqdnListReply) ProtoMessage()               {}
func (*FqdnListReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{15} }

type DynamicLocGroupRequest struct {
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// Dynamic Location Group Id
	LgId     uint64                             `protobuf:"varint,3,opt,name=lg_id,json=lgId,proto3" json:"lg_id,omitempty"`
	CommType DynamicLocGroupRequest_DlgCommType `protobuf:"varint,11,opt,name=comm_type,json=commType,proto3,enum=distributed_match_engine.DynamicLocGroupRequest_DlgCommType" json:"comm_type,omitempty"`
	// Unused
	UserData string `protobuf:"bytes,12,opt,name=user_data,json=userData,proto3" json:"user_data,omitempty"`
	// Cell id where the client is
	CellId uint32 `protobuf:"varint,13,opt,name=cell_id,json=cellId,proto3" json:"cell_id,omitempty"`
	// Vendor specific data
	Tags []*Tag `protobuf:"bytes,99,rep,name=tags" json:"tags,omitempty"`
}

func (m *DynamicLocGroupRequest) Reset()                    { *m = DynamicLocGroupRequest{} }
func (m *DynamicLocGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*DynamicLocGroupRequest) ProtoMessage()               {}
func (*DynamicLocGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{16} }

type DynamicLocGroupReply struct {
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Status of the reply
	Status ReplyStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.ReplyStatus" json:"status,omitempty"`
	// Error Code based on Failure
	ErrorCode uint32 `protobuf:"varint,3,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	// Group Cookie for Secure Group Communication
	GroupCookie string `protobuf:"bytes,5,opt,name=group_cookie,json=groupCookie,proto3" json:"group_cookie,omitempty"`
	// Vendor specific data
	Tags []*Tag `protobuf:"bytes,99,rep,name=tags" json:"tags,omitempty"`
}

func (m *DynamicLocGroupReply) Reset()                    { *m = DynamicLocGroupReply{} }
func (m *DynamicLocGroupReply) String() string            { return proto.CompactTextString(m) }
func (*DynamicLocGroupReply) ProtoMessage()               {}
func (*DynamicLocGroupReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{17} }

type QosPosition struct {
	// as set by the client, must be unique within QosRequest
	Positionid int64 `protobuf:"varint,1,opt,name=positionid,proto3" json:"positionid,omitempty"`
	// location
	GpsLocation *Loc `protobuf:"bytes,2,opt,name=gps_location,json=gpsLocation" json:"gps_location,omitempty"`
}

func (m *QosPosition) Reset()                    { *m = QosPosition{} }
func (m *QosPosition) String() string            { return proto.CompactTextString(m) }
func (*QosPosition) ProtoMessage()               {}
func (*QosPosition) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{18} }

// supported band values
type BandSelection struct {
	// Radio Access Technologies
	Rat_2G []string `protobuf:"bytes,1,rep,name=rat_2g,json=rat2g" json:"rat_2g,omitempty"`
	Rat_3G []string `protobuf:"bytes,2,rep,name=rat_3g,json=rat3g" json:"rat_3g,omitempty"`
	Rat_4G []string `protobuf:"bytes,3,rep,name=rat_4g,json=rat4g" json:"rat_4g,omitempty"`
	Rat_5G []string `protobuf:"bytes,4,rep,name=rat_5g,json=rat5g" json:"rat_5g,omitempty"`
}

func (m *BandSelection) Reset()                    { *m = BandSelection{} }
func (m *BandSelection) String() string            { return proto.CompactTextString(m) }
func (*BandSelection) ProtoMessage()               {}
func (*BandSelection) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{19} }

// QosPositionRequest is used for both GetQosPositionKpi
type QosPositionRequest struct {
	// API version
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// list of positions
	Positions []*QosPosition `protobuf:"bytes,3,rep,name=positions" json:"positions,omitempty"`
	// Optional. Client's device LTE category number.
	LteCategory int32 `protobuf:"varint,4,opt,name=lte_category,json=lteCategory,proto3" json:"lte_category,omitempty"`
	// Optional. Band list used by the client.
	BandSelection *BandSelection `protobuf:"bytes,5,opt,name=band_selection,json=bandSelection" json:"band_selection,omitempty"`
	// Cell id where the client is
	CellId uint32 `protobuf:"varint,6,opt,name=cell_id,json=cellId,proto3" json:"cell_id,omitempty"`
	// Vendor specific data
	Tags []*Tag `protobuf:"bytes,99,rep,name=tags" json:"tags,omitempty"`
}

func (m *QosPositionRequest) Reset()                    { *m = QosPositionRequest{} }
func (m *QosPositionRequest) String() string            { return proto.CompactTextString(m) }
func (*QosPositionRequest) ProtoMessage()               {}
func (*QosPositionRequest) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{20} }

type QosPositionKpiResult struct {
	// as set by the client, must be unique within one QosPositionRequest
	Positionid int64 `protobuf:"varint,1,opt,name=positionid,proto3" json:"positionid,omitempty"`
	// the location which was requested
	GpsLocation *Loc `protobuf:"bytes,2,opt,name=gps_location,json=gpsLocation" json:"gps_location,omitempty"`
	// throughput
	DluserthroughputMin float32 `protobuf:"fixed32,3,opt,name=dluserthroughput_min,json=dluserthroughputMin,proto3" json:"dluserthroughput_min,omitempty"`
	DluserthroughputAvg float32 `protobuf:"fixed32,4,opt,name=dluserthroughput_avg,json=dluserthroughputAvg,proto3" json:"dluserthroughput_avg,omitempty"`
	DluserthroughputMax float32 `protobuf:"fixed32,5,opt,name=dluserthroughput_max,json=dluserthroughputMax,proto3" json:"dluserthroughput_max,omitempty"`
	UluserthroughputMin float32 `protobuf:"fixed32,6,opt,name=uluserthroughput_min,json=uluserthroughputMin,proto3" json:"uluserthroughput_min,omitempty"`
	UluserthroughputAvg float32 `protobuf:"fixed32,7,opt,name=uluserthroughput_avg,json=uluserthroughputAvg,proto3" json:"uluserthroughput_avg,omitempty"`
	UluserthroughputMax float32 `protobuf:"fixed32,8,opt,name=uluserthroughput_max,json=uluserthroughputMax,proto3" json:"uluserthroughput_max,omitempty"`
	LatencyMin          float32 `protobuf:"fixed32,9,opt,name=latency_min,json=latencyMin,proto3" json:"latency_min,omitempty"`
	LatencyAvg          float32 `protobuf:"fixed32,10,opt,name=latency_avg,json=latencyAvg,proto3" json:"latency_avg,omitempty"`
	LatencyMax          float32 `protobuf:"fixed32,11,opt,name=latency_max,json=latencyMax,proto3" json:"latency_max,omitempty"`
}

func (m *QosPositionKpiResult) Reset()                    { *m = QosPositionKpiResult{} }
func (m *QosPositionKpiResult) String() string            { return proto.CompactTextString(m) }
func (*QosPositionKpiResult) ProtoMessage()               {}
func (*QosPositionKpiResult) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{21} }

type QosPositionKpiReply struct {
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Status of the reply
	Status ReplyStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.ReplyStatus" json:"status,omitempty"`
	// kpi details
	PositionResults []*QosPositionKpiResult `protobuf:"bytes,3,rep,name=position_results,json=positionResults" json:"position_results,omitempty"`
	// Vendor specific data
	Tags []*Tag `protobuf:"bytes,99,rep,name=tags" json:"tags,omitempty"`
}

func (m *QosPositionKpiReply) Reset()                    { *m = QosPositionKpiReply{} }
func (m *QosPositionKpiReply) String() string            { return proto.CompactTextString(m) }
func (*QosPositionKpiReply) ProtoMessage()               {}
func (*QosPositionKpiReply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{22} }

func init() {
	proto.RegisterType((*Tag)(nil), "distributed_match_engine.Tag")
	proto.RegisterType((*RegisterClientRequest)(nil), "distributed_match_engine.RegisterClientRequest")
	proto.RegisterType((*RegisterClientReply)(nil), "distributed_match_engine.RegisterClientReply")
	proto.RegisterType((*FindCloudletRequest)(nil), "distributed_match_engine.FindCloudletRequest")
	proto.RegisterType((*FindCloudletReply)(nil), "distributed_match_engine.FindCloudletReply")
	proto.RegisterType((*VerifyLocationRequest)(nil), "distributed_match_engine.VerifyLocationRequest")
	proto.RegisterType((*VerifyLocationReply)(nil), "distributed_match_engine.VerifyLocationReply")
	proto.RegisterType((*GetLocationRequest)(nil), "distributed_match_engine.GetLocationRequest")
	proto.RegisterType((*GetLocationReply)(nil), "distributed_match_engine.GetLocationReply")
	proto.RegisterType((*AppInstListRequest)(nil), "distributed_match_engine.AppInstListRequest")
	proto.RegisterType((*Appinstance)(nil), "distributed_match_engine.Appinstance")
	proto.RegisterType((*CloudletLocation)(nil), "distributed_match_engine.CloudletLocation")
	proto.RegisterType((*AppInstListReply)(nil), "distributed_match_engine.AppInstListReply")
	proto.RegisterType((*FqdnListRequest)(nil), "distributed_match_engine.FqdnListRequest")
	proto.RegisterType((*AppFqdn)(nil), "distributed_match_engine.AppFqdn")
	proto.RegisterType((*FqdnListReply)(nil), "distributed_match_engine.FqdnListReply")
	proto.RegisterType((*DynamicLocGroupRequest)(nil), "distributed_match_engine.DynamicLocGroupRequest")
	proto.RegisterType((*DynamicLocGroupReply)(nil), "distributed_match_engine.DynamicLocGroupReply")
	proto.RegisterType((*QosPosition)(nil), "distributed_match_engine.QosPosition")
	proto.RegisterType((*BandSelection)(nil), "distributed_match_engine.BandSelection")
	proto.RegisterType((*QosPositionRequest)(nil), "distributed_match_engine.QosPositionRequest")
	proto.RegisterType((*QosPositionKpiResult)(nil), "distributed_match_engine.QosPositionKpiResult")
	proto.RegisterType((*QosPositionKpiReply)(nil), "distributed_match_engine.QosPositionKpiReply")
	proto.RegisterEnum("distributed_match_engine.IDTypes", IDTypes_name, IDTypes_value)
	proto.RegisterEnum("distributed_match_engine.ReplyStatus", ReplyStatus_name, ReplyStatus_value)
	proto.RegisterEnum("distributed_match_engine.FindCloudletReply_FindStatus", FindCloudletReply_FindStatus_name, FindCloudletReply_FindStatus_value)
	proto.RegisterEnum("distributed_match_engine.VerifyLocationReply_TowerStatus", VerifyLocationReply_TowerStatus_name, VerifyLocationReply_TowerStatus_value)
	proto.RegisterEnum("distributed_match_engine.VerifyLocationReply_GPSLocationStatus", VerifyLocationReply_GPSLocationStatus_name, VerifyLocationReply_GPSLocationStatus_value)
	proto.RegisterEnum("distributed_match_engine.GetLocationReply_LocStatus", GetLocationReply_LocStatus_name, GetLocationReply_LocStatus_value)
	proto.RegisterEnum("distributed_match_engine.AppInstListReply_AIStatus", AppInstListReply_AIStatus_name, AppInstListReply_AIStatus_value)
	proto.RegisterEnum("distributed_match_engine.FqdnListReply_FLStatus", FqdnListReply_FLStatus_name, FqdnListReply_FLStatus_value)
	proto.RegisterEnum("distributed_match_engine.DynamicLocGroupRequest_DlgCommType", DynamicLocGroupRequest_DlgCommType_name, DynamicLocGroupRequest_DlgCommType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for MatchEngineApi service

type MatchEngineApiClient interface {
	RegisterClient(ctx context.Context, in *RegisterClientRequest, opts ...grpc.CallOption) (*RegisterClientReply, error)
	FindCloudlet(ctx context.Context, in *FindCloudletRequest, opts ...grpc.CallOption) (*FindCloudletReply, error)
	VerifyLocation(ctx context.Context, in *VerifyLocationRequest, opts ...grpc.CallOption) (*VerifyLocationReply, error)
	GetLocation(ctx context.Context, in *GetLocationRequest, opts ...grpc.CallOption) (*GetLocationReply, error)
	AddUserToGroup(ctx context.Context, in *DynamicLocGroupRequest, opts ...grpc.CallOption) (*DynamicLocGroupReply, error)
	GetAppInstList(ctx context.Context, in *AppInstListRequest, opts ...grpc.CallOption) (*AppInstListReply, error)
	GetFqdnList(ctx context.Context, in *FqdnListRequest, opts ...grpc.CallOption) (*FqdnListReply, error)
	GetQosPositionKpi(ctx context.Context, in *QosPositionRequest, opts ...grpc.CallOption) (MatchEngineApi_GetQosPositionKpiClient, error)
}

type matchEngineApiClient struct {
	cc *grpc.ClientConn
}

func NewMatchEngineApiClient(cc *grpc.ClientConn) MatchEngineApiClient {
	return &matchEngineApiClient{cc}
}

func (c *matchEngineApiClient) RegisterClient(ctx context.Context, in *RegisterClientRequest, opts ...grpc.CallOption) (*RegisterClientReply, error) {
	out := new(RegisterClientReply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/RegisterClient", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) FindCloudlet(ctx context.Context, in *FindCloudletRequest, opts ...grpc.CallOption) (*FindCloudletReply, error) {
	out := new(FindCloudletReply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/FindCloudlet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) VerifyLocation(ctx context.Context, in *VerifyLocationRequest, opts ...grpc.CallOption) (*VerifyLocationReply, error) {
	out := new(VerifyLocationReply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/VerifyLocation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) GetLocation(ctx context.Context, in *GetLocationRequest, opts ...grpc.CallOption) (*GetLocationReply, error) {
	out := new(GetLocationReply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/GetLocation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) AddUserToGroup(ctx context.Context, in *DynamicLocGroupRequest, opts ...grpc.CallOption) (*DynamicLocGroupReply, error) {
	out := new(DynamicLocGroupReply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/AddUserToGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) GetAppInstList(ctx context.Context, in *AppInstListRequest, opts ...grpc.CallOption) (*AppInstListReply, error) {
	out := new(AppInstListReply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/GetAppInstList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) GetFqdnList(ctx context.Context, in *FqdnListRequest, opts ...grpc.CallOption) (*FqdnListReply, error) {
	out := new(FqdnListReply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/GetFqdnList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) GetQosPositionKpi(ctx context.Context, in *QosPositionRequest, opts ...grpc.CallOption) (MatchEngineApi_GetQosPositionKpiClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_MatchEngineApi_serviceDesc.Streams[0], c.cc, "/distributed_match_engine.MatchEngineApi/GetQosPositionKpi", opts...)
	if err != nil {
		return nil, err
	}
	x := &matchEngineApiGetQosPositionKpiClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MatchEngineApi_GetQosPositionKpiClient interface {
	Recv() (*QosPositionKpiReply, error)
	grpc.ClientStream
}

type matchEngineApiGetQosPositionKpiClient struct {
	grpc.ClientStream
}

func (x *matchEngineApiGetQosPositionKpiClient) Recv() (*QosPositionKpiReply, error) {
	m := new(QosPositionKpiReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for MatchEngineApi service

type MatchEngineApiServer interface {
	RegisterClient(context.Context, *RegisterClientRequest) (*RegisterClientReply, error)
	FindCloudlet(context.Context, *FindCloudletRequest) (*FindCloudletReply, error)
	VerifyLocation(context.Context, *VerifyLocationRequest) (*VerifyLocationReply, error)
	GetLocation(context.Context, *GetLocationRequest) (*GetLocationReply, error)
	AddUserToGroup(context.Context, *DynamicLocGroupRequest) (*DynamicLocGroupReply, error)
	GetAppInstList(context.Context, *AppInstListRequest) (*AppInstListReply, error)
	GetFqdnList(context.Context, *FqdnListRequest) (*FqdnListReply, error)
	GetQosPositionKpi(*QosPositionRequest, MatchEngineApi_GetQosPositionKpiServer) error
}

func RegisterMatchEngineApiServer(s *grpc.Server, srv MatchEngineApiServer) {
	s.RegisterService(&_MatchEngineApi_serviceDesc, srv)
}

func _MatchEngineApi_RegisterClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).RegisterClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/RegisterClient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).RegisterClient(ctx, req.(*RegisterClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_FindCloudlet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindCloudletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).FindCloudlet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/FindCloudlet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).FindCloudlet(ctx, req.(*FindCloudletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_VerifyLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).VerifyLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/VerifyLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).VerifyLocation(ctx, req.(*VerifyLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_GetLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).GetLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/GetLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).GetLocation(ctx, req.(*GetLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_AddUserToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DynamicLocGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).AddUserToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/AddUserToGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).AddUserToGroup(ctx, req.(*DynamicLocGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_GetAppInstList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInstListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).GetAppInstList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/GetAppInstList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).GetAppInstList(ctx, req.(*AppInstListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_GetFqdnList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FqdnListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).GetFqdnList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/GetFqdnList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).GetFqdnList(ctx, req.(*FqdnListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_GetQosPositionKpi_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QosPositionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MatchEngineApiServer).GetQosPositionKpi(m, &matchEngineApiGetQosPositionKpiServer{stream})
}

type MatchEngineApi_GetQosPositionKpiServer interface {
	Send(*QosPositionKpiReply) error
	grpc.ServerStream
}

type matchEngineApiGetQosPositionKpiServer struct {
	grpc.ServerStream
}

func (x *matchEngineApiGetQosPositionKpiServer) Send(m *QosPositionKpiReply) error {
	return x.ServerStream.SendMsg(m)
}

var _MatchEngineApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "distributed_match_engine.MatchEngineApi",
	HandlerType: (*MatchEngineApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterClient",
			Handler:    _MatchEngineApi_RegisterClient_Handler,
		},
		{
			MethodName: "FindCloudlet",
			Handler:    _MatchEngineApi_FindCloudlet_Handler,
		},
		{
			MethodName: "VerifyLocation",
			Handler:    _MatchEngineApi_VerifyLocation_Handler,
		},
		{
			MethodName: "GetLocation",
			Handler:    _MatchEngineApi_GetLocation_Handler,
		},
		{
			MethodName: "AddUserToGroup",
			Handler:    _MatchEngineApi_AddUserToGroup_Handler,
		},
		{
			MethodName: "GetAppInstList",
			Handler:    _MatchEngineApi_GetAppInstList_Handler,
		},
		{
			MethodName: "GetFqdnList",
			Handler:    _MatchEngineApi_GetFqdnList_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetQosPositionKpi",
			Handler:       _MatchEngineApi_GetQosPositionKpi_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "app-client.proto",
}

func (m *Tag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *RegisterClientRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterClientRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.DevName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.DevName)))
		i += copy(dAtA[i:], m.DevName)
	}
	if len(m.AppName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppName)))
		i += copy(dAtA[i:], m.AppName)
	}
	if len(m.AppVers) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppVers)))
		i += copy(dAtA[i:], m.AppVers)
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if len(m.AuthToken) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AuthToken)))
		i += copy(dAtA[i:], m.AuthToken)
	}
	if m.CellId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CellId))
	}
	if len(m.UniqueIdType) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.UniqueIdType)))
		i += copy(dAtA[i:], m.UniqueIdType)
	}
	if len(m.UniqueId) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.UniqueId)))
		i += copy(dAtA[i:], m.UniqueId)
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RegisterClientReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterClientReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if len(m.TokenServerUri) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.TokenServerUri)))
		i += copy(dAtA[i:], m.TokenServerUri)
	}
	if len(m.UniqueIdType) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.UniqueIdType)))
		i += copy(dAtA[i:], m.UniqueIdType)
	}
	if len(m.UniqueId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.UniqueId)))
		i += copy(dAtA[i:], m.UniqueId)
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FindCloudletRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindCloudletRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n1, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.DevName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.DevName)))
		i += copy(dAtA[i:], m.DevName)
	}
	if len(m.AppName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppName)))
		i += copy(dAtA[i:], m.AppName)
	}
	if len(m.AppVers) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppVers)))
		i += copy(dAtA[i:], m.AppVers)
	}
	if m.CellId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CellId))
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FindCloudletReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindCloudletReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if len(m.Fqdn) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Fqdn)))
		i += copy(dAtA[i:], m.Fqdn)
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CloudletLocation != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CloudletLocation.Size()))
		n2, err := m.CloudletLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VerifyLocationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyLocationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n3, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.VerifyLocToken) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.VerifyLocToken)))
		i += copy(dAtA[i:], m.VerifyLocToken)
	}
	if m.CellId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CellId))
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VerifyLocationReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyLocationReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.TowerStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.TowerStatus))
	}
	if m.GpsLocationStatus != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocationStatus))
	}
	if m.GpsLocationAccuracyKm != 0 {
		dAtA[i] = 0x21
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GpsLocationAccuracyKm))))
		i += 8
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetLocationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLocationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if m.CellId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CellId))
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetLocationReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLocationReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if m.Tower != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Tower))
	}
	if m.NetworkLocation != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.NetworkLocation.Size()))
		n4, err := m.NetworkLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AppInstListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n5, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.CellId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CellId))
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Appinstance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Appinstance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppName)))
		i += copy(dAtA[i:], m.AppName)
	}
	if len(m.AppVers) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppVers)))
		i += copy(dAtA[i:], m.AppVers)
	}
	if len(m.Fqdn) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Fqdn)))
		i += copy(dAtA[i:], m.Fqdn)
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CloudletLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletLocation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if len(m.CloudletName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CloudletName)))
		i += copy(dAtA[i:], m.CloudletName)
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n6, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Distance != 0 {
		dAtA[i] = 0x21
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Distance))))
		i += 8
	}
	if len(m.Appinstances) > 0 {
		for _, msg := range m.Appinstances {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AppInstListReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstListReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if len(m.Cloudlets) > 0 {
		for _, msg := range m.Cloudlets {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FqdnListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FqdnListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if m.CellId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CellId))
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AppFqdn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppFqdn) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppName)))
		i += copy(dAtA[i:], m.AppName)
	}
	if len(m.AppVers) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppVers)))
		i += copy(dAtA[i:], m.AppVers)
	}
	if len(m.DevName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.DevName)))
		i += copy(dAtA[i:], m.DevName)
	}
	if len(m.Fqdns) > 0 {
		for _, s := range m.Fqdns {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.AndroidPackageName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AndroidPackageName)))
		i += copy(dAtA[i:], m.AndroidPackageName)
	}
	return i, nil
}

func (m *FqdnListReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FqdnListReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.AppFqdns) > 0 {
		for _, msg := range m.AppFqdns {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Status != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DynamicLocGroupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicLocGroupRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if m.LgId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.LgId))
	}
	if m.CommType != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CommType))
	}
	if len(m.UserData) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.UserData)))
		i += copy(dAtA[i:], m.UserData)
	}
	if m.CellId != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CellId))
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DynamicLocGroupReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicLocGroupReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.GroupCookie) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.GroupCookie)))
		i += copy(dAtA[i:], m.GroupCookie)
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPosition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Positionid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Positionid))
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n7, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *BandSelection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BandSelection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rat_2G) > 0 {
		for _, s := range m.Rat_2G {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Rat_3G) > 0 {
		for _, s := range m.Rat_3G {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Rat_4G) > 0 {
		for _, s := range m.Rat_4G {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Rat_5G) > 0 {
		for _, s := range m.Rat_5G {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *QosPositionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPositionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.SessionCookie) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i += copy(dAtA[i:], m.SessionCookie)
	}
	if len(m.Positions) > 0 {
		for _, msg := range m.Positions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LteCategory != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.LteCategory))
	}
	if m.BandSelection != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.BandSelection.Size()))
		n8, err := m.BandSelection.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.CellId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CellId))
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosPositionKpiResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPositionKpiResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Positionid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Positionid))
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n9, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.DluserthroughputMin != 0 {
		dAtA[i] = 0x1d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DluserthroughputMin))))
		i += 4
	}
	if m.DluserthroughputAvg != 0 {
		dAtA[i] = 0x25
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DluserthroughputAvg))))
		i += 4
	}
	if m.DluserthroughputMax != 0 {
		dAtA[i] = 0x2d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DluserthroughputMax))))
		i += 4
	}
	if m.UluserthroughputMin != 0 {
		dAtA[i] = 0x35
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UluserthroughputMin))))
		i += 4
	}
	if m.UluserthroughputAvg != 0 {
		dAtA[i] = 0x3d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UluserthroughputAvg))))
		i += 4
	}
	if m.UluserthroughputMax != 0 {
		dAtA[i] = 0x45
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UluserthroughputMax))))
		i += 4
	}
	if m.LatencyMin != 0 {
		dAtA[i] = 0x4d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LatencyMin))))
		i += 4
	}
	if m.LatencyAvg != 0 {
		dAtA[i] = 0x55
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LatencyAvg))))
		i += 4
	}
	if m.LatencyMax != 0 {
		dAtA[i] = 0x5d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LatencyMax))))
		i += 4
	}
	return i, nil
}

func (m *QosPositionKpiReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPositionKpiReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if len(m.PositionResults) > 0 {
		for _, msg := range m.PositionResults {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintAppClient(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintAppClient(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Tag) CopyInFields(src *Tag) int {
	changed := 0
	if m.Type != src.Type {
		m.Type = src.Type
		changed++
	}
	if m.Data != src.Data {
		m.Data = src.Data
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *Tag) ValidateEnums() error {
	return nil
}

func (m *RegisterClientRequest) CopyInFields(src *RegisterClientRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.DevName != src.DevName {
		m.DevName = src.DevName
		changed++
	}
	if m.AppName != src.AppName {
		m.AppName = src.AppName
		changed++
	}
	if m.AppVers != src.AppVers {
		m.AppVers = src.AppVers
		changed++
	}
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if m.AuthToken != src.AuthToken {
		m.AuthToken = src.AuthToken
		changed++
	}
	if m.CellId != src.CellId {
		m.CellId = src.CellId
		changed++
	}
	if m.UniqueIdType != src.UniqueIdType {
		m.UniqueIdType = src.UniqueIdType
		changed++
	}
	if m.UniqueId != src.UniqueId {
		m.UniqueId = src.UniqueId
		changed++
	}
	if src.Tags != nil {
		if m.Tags == nil || len(m.Tags) != len(src.Tags) {
			m.Tags = make([]*Tag, len(src.Tags))
			changed++
		}
		for i0 := 0; i0 < len(src.Tags); i0++ {
			m.Tags[i0] = &Tag{}
			if m.Tags[i0].Type != src.Tags[i0].Type {
				m.Tags[i0].Type = src.Tags[i0].Type
				changed++
			}
			if m.Tags[i0].Data != src.Tags[i0].Data {
				m.Tags[i0].Data = src.Tags[i0].Data
				changed++
			}
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *RegisterClientRequest) ValidateEnums() error {
	for _, e := range m.Tags {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *RegisterClientReply) CopyInFields(src *RegisterClientReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.TokenServerUri != src.TokenServerUri {
		m.TokenServerUri = src.TokenServerUri
		changed++
	}
	if m.UniqueIdType != src.UniqueIdType {
		m.UniqueIdType = src.UniqueIdType
		changed++
	}
	if m.UniqueId != src.UniqueId {
		m.UniqueId = src.UniqueId
		changed++
	}
	if src.Tags != nil {
		if m.Tags == nil || len(m.Tags) != len(src.Tags) {
			m.Tags = make([]*Tag, len(src.Tags))
			changed++
		}
		for i0 := 0; i0 < len(src.Tags); i0++ {
			m.Tags[i0] = &Tag{}
			if m.Tags[i0].Type != src.Tags[i0].Type {
				m.Tags[i0].Type = src.Tags[i0].Type
				changed++
			}
			if m.Tags[i0].Data != src.Tags[i0].Data {
				m.Tags[i0].Data = src.Tags[i0].Data
				changed++
			}
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *RegisterClientReply) ValidateEnums() error {
	if _, ok := ReplyStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	for _, e := range m.Tags {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *FindCloudletRequest) CopyInFields(src *FindCloudletRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &Timestamp{}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	if m.DevName != src.DevName {
		m.DevName = src.DevName
		changed++
	}
	if m.AppName != src.AppName {
		m.AppName = src.AppName
		changed++
	}
	if m.AppVers != src.AppVers {
		m.AppVers = src.AppVers
		changed++
	}
	if m.CellId != src.CellId {
		m.CellId = src.CellId
		changed++
	}
	if src.Tags != nil {
		if m.Tags == nil || len(m.Tags) != len(src.Tags) {
			m.Tags = make([]*Tag, len(src.Tags))
			changed++
		}
		for i0 := 0; i0 < len(src.Tags); i0++ {
			m.Tags[i0] = &Tag{}
			if m.Tags[i0].Type != src.Tags[i0].Type {
				m.Tags[i0].Type = src.Tags[i0].Type
				changed++
			}
			if m.Tags[i0].Data != src.Tags[i0].Data {
				m.Tags[i0].Data = src.Tags[i0].Data
				changed++
			}
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *FindCloudletRequest) ValidateEnums() error {
	if err := m.GpsLocation.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.Tags {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *FindCloudletReply) CopyInFields(src *FindCloudletReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if m.Fqdn != src.Fqdn {
		m.Fqdn = src.Fqdn
		changed++
	}
	if src.Ports != nil {
		if m.Ports == nil || len(m.Ports) != len(src.Ports) {
			m.Ports = make([]*AppPort, len(src.Ports))
			changed++
		}
		for i0 := 0; i0 < len(src.Ports); i0++ {
			m.Ports[i0] = &AppPort{}
			if m.Ports[i0].Proto != src.Ports[i0].Proto {
				m.Ports[i0].Proto = src.Ports[i0].Proto
				changed++
			}
			if m.Ports[i0].InternalPort != src.Ports[i0].InternalPort {
				m.Ports[i0].InternalPort = src.Ports[i0].InternalPort
				changed++
			}
			if m.Ports[i0].PublicPort != src.Ports[i0].PublicPort {
				m.Ports[i0].PublicPort = src.Ports[i0].PublicPort
				changed++
			}
			if m.Ports[i0].PathPrefix != src.Ports[i0].PathPrefix {
				m.Ports[i0].PathPrefix = src.Ports[i0].PathPrefix
				changed++
			}
			if m.Ports[i0].FqdnPrefix != src.Ports[i0].FqdnPrefix {
				m.Ports[i0].FqdnPrefix = src.Ports[i0].FqdnPrefix
				changed++
			}
			if m.Ports[i0].EndPort != src.Ports[i0].EndPort {
				m.Ports[i0].EndPort = src.Ports[i0].EndPort
				changed++
			}
		}
	} else if m.Ports != nil {
		m.Ports = nil
		changed++
	}
	if src.CloudletLocation != nil {
		m.CloudletLocation = &Loc{}
		if m.CloudletLocation.Latitude != src.CloudletLocation.Latitude {
			m.CloudletLocation.Latitude = src.CloudletLocation.Latitude
			changed++
		}
		if m.CloudletLocation.Longitude != src.CloudletLocation.Longitude {
			m.CloudletLocation.Longitude = src.CloudletLocation.Longitude
			changed++
		}
		if m.CloudletLocation.HorizontalAccuracy != src.CloudletLocation.HorizontalAccuracy {
			m.CloudletLocation.HorizontalAccuracy = src.CloudletLocation.HorizontalAccuracy
			changed++
		}
		if m.CloudletLocation.VerticalAccuracy != src.CloudletLocation.VerticalAccuracy {
			m.CloudletLocation.VerticalAccuracy = src.CloudletLocation.VerticalAccuracy
			changed++
		}
		if m.CloudletLocation.Altitude != src.CloudletLocation.Altitude {
			m.CloudletLocation.Altitude = src.CloudletLocation.Altitude
			changed++
		}
		if m.CloudletLocation.Course != src.CloudletLocation.Course {
			m.CloudletLocation.Course = src.CloudletLocation.Course
			changed++
		}
		if m.CloudletLocation.Speed != src.CloudletLocation.Speed {
			m.CloudletLocation.Speed = src.CloudletLocation.Speed
			changed++
		}
		if src.CloudletLocation.Timestamp != nil {
			m.CloudletLocation.Timestamp = &Timestamp{}
			if m.CloudletLocation.Timestamp.Seconds != src.CloudletLocation.Timestamp.Seconds {
				m.CloudletLocation.Timestamp.Seconds = src.CloudletLocation.Timestamp.Seconds
				changed++
			}
			if m.CloudletLocation.Timestamp.Nanos != src.CloudletLocation.Timestamp.Nanos {
				m.CloudletLocation.Timestamp.Nanos = src.CloudletLocation.Timestamp.Nanos
				changed++
			}
		} else if m.CloudletLocation.Timestamp != nil {
			m.CloudletLocation.Timestamp = nil
			changed++
		}
	} else if m.CloudletLocation != nil {
		m.CloudletLocation = nil
		changed++
	}
	if src.Tags != nil {
		if m.Tags == nil || len(m.Tags) != len(src.Tags) {
			m.Tags = make([]*Tag, len(src.Tags))
			changed++
		}
		for i0 := 0; i0 < len(src.Tags); i0++ {
			m.Tags[i0] = &Tag{}
			if m.Tags[i0].Type != src.Tags[i0].Type {
				m.Tags[i0].Type = src.Tags[i0].Type
				changed++
			}
			if m.Tags[i0].Data != src.Tags[i0].Data {
				m.Tags[i0].Data = src.Tags[i0].Data
				changed++
			}
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *FindCloudletReply) ValidateEnums() error {
	if _, ok := FindCloudletReply_FindStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	for _, e := range m.Ports {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if err := m.CloudletLocation.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.Tags {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *VerifyLocationRequest) CopyInFields(src *VerifyLocationRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &Timestamp{}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	if m.VerifyLocToken != src.VerifyLocToken {
		m.VerifyLocToken = src.VerifyLocToken
		changed++
	}
	if m.CellId != src.CellId {
		m.CellId = src.CellId
		changed++
	}
	if src.Tags != nil {
		if m.Tags == nil || len(m.Tags) != len(src.Tags) {
			m.Tags = make([]*Tag, len(src.Tags))
			changed++
		}
		for i0 := 0; i0 < len(src.Tags); i0++ {
			m.Tags[i0] = &Tag{}
			if m.Tags[i0].Type != src.Tags[i0].Type {
				m.Tags[i0].Type = src.Tags[i0].Type
				changed++
			}
			if m.Tags[i0].Data != src.Tags[i0].Data {
				m.Tags[i0].Data = src.Tags[i0].Data
				changed++
			}
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *VerifyLocationRequest) ValidateEnums() error {
	if err := m.GpsLocation.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.Tags {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *VerifyLocationReply) CopyInFields(src *VerifyLocationReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.TowerStatus != src.TowerStatus {
		m.TowerStatus = src.TowerStatus
		changed++
	}
	if m.GpsLocationStatus != src.GpsLocationStatus {
		m.GpsLocationStatus = src.GpsLocationStatus
		changed++
	}
	if m.GpsLocationAccuracyKm != src.GpsLocationAccuracyKm {
		m.GpsLocationAccuracyKm = src.GpsLocationAccuracyKm
		changed++
	}
	if src.Tags != nil {
		if m.Tags == nil || len(m.Tags) != len(src.Tags) {
			m.Tags = make([]*Tag, len(src.Tags))
			changed++
		}
		for i0 := 0; i0 < len(src.Tags); i0++ {
			m.Tags[i0] = &Tag{}
			if m.Tags[i0].Type != src.Tags[i0].Type {
				m.Tags[i0].Type = src.Tags[i0].Type
				changed++
			}
			if m.Tags[i0].Data != src.Tags[i0].Data {
				m.Tags[i0].Data = src.Tags[i0].Data
				changed++
			}
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *VerifyLocationReply) ValidateEnums() error {
	if _, ok := VerifyLocationReply_TowerStatus_name[int32(m.TowerStatus)]; !ok {
		return errors.New("invalid TowerStatus")
	}
	if _, ok := VerifyLocationReply_GPSLocationStatus_name[int32(m.GpsLocationStatus)]; !ok {
		return errors.New("invalid GpsLocationStatus")
	}
	for _, e := range m.Tags {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *GetLocationRequest) CopyInFields(src *GetLocationRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if m.CellId != src.CellId {
		m.CellId = src.CellId
		changed++
	}
	if src.Tags != nil {
		if m.Tags == nil || len(m.Tags) != len(src.Tags) {
			m.Tags = make([]*Tag, len(src.Tags))
			changed++
		}
		for i0 := 0; i0 < len(src.Tags); i0++ {
			m.Tags[i0] = &Tag{}
			if m.Tags[i0].Type != src.Tags[i0].Type {
				m.Tags[i0].Type = src.Tags[i0].Type
				changed++
			}
			if m.Tags[i0].Data != src.Tags[i0].Data {
				m.Tags[i0].Data = src.Tags[i0].Data
				changed++
			}
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *GetLocationRequest) ValidateEnums() error {
	for _, e := range m.Tags {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *GetLocationReply) CopyInFields(src *GetLocationReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if m.Tower != src.Tower {
		m.Tower = src.Tower
		changed++
	}
	if src.NetworkLocation != nil {
		m.NetworkLocation = &Loc{}
		if m.NetworkLocation.Latitude != src.NetworkLocation.Latitude {
			m.NetworkLocation.Latitude = src.NetworkLocation.Latitude
			changed++
		}
		if m.NetworkLocation.Longitude != src.NetworkLocation.Longitude {
			m.NetworkLocation.Longitude = src.NetworkLocation.Longitude
			changed++
		}
		if m.NetworkLocation.HorizontalAccuracy != src.NetworkLocation.HorizontalAccuracy {
			m.NetworkLocation.HorizontalAccuracy = src.NetworkLocation.HorizontalAccuracy
			changed++
		}
		if m.NetworkLocation.VerticalAccuracy != src.NetworkLocation.VerticalAccuracy {
			m.NetworkLocation.VerticalAccuracy = src.NetworkLocation.VerticalAccuracy
			changed++
		}
		if m.NetworkLocation.Altitude != src.NetworkLocation.Altitude {
			m.NetworkLocation.Altitude = src.NetworkLocation.Altitude
			changed++
		}
		if m.NetworkLocation.Course != src.NetworkLocation.Course {
			m.NetworkLocation.Course = src.NetworkLocation.Course
			changed++
		}
		if m.NetworkLocation.Speed != src.NetworkLocation.Speed {
			m.NetworkLocation.Speed = src.NetworkLocation.Speed
			changed++
		}
		if src.NetworkLocation.Timestamp != nil {
			m.NetworkLocation.Timestamp = &Timestamp{}
			if m.NetworkLocation.Timestamp.Seconds != src.NetworkLocation.Timestamp.Seconds {
				m.NetworkLocation.Timestamp.Seconds = src.NetworkLocation.Timestamp.Seconds
				changed++
			}
			if m.NetworkLocation.Timestamp.Nanos != src.NetworkLocation.Timestamp.Nanos {
				m.NetworkLocation.Timestamp.Nanos = src.NetworkLocation.Timestamp.Nanos
				changed++
			}
		} else if m.NetworkLocation.Timestamp != nil {
			m.NetworkLocation.Timestamp = nil
			changed++
		}
	} else if m.NetworkLocation != nil {
		m.NetworkLocation = nil
		changed++
	}
	if src.Tags != nil {
		if m.Tags == nil || len(m.Tags) != len(src.Tags) {
			m.Tags = make([]*Tag, len(src.Tags))
			changed++
		}
		for i0 := 0; i0 < len(src.Tags); i0++ {
			m.Tags[i0] = &Tag{}
			if m.Tags[i0].Type != src.Tags[i0].Type {
				m.Tags[i0].Type = src.Tags[i0].Type
				changed++
			}
			if m.Tags[i0].Data != src.Tags[i0].Data {
				m.Tags[i0].Data = src.Tags[i0].Data
				changed++
			}
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *GetLocationReply) ValidateEnums() error {
	if _, ok := GetLocationReply_LocStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	if err := m.NetworkLocation.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.Tags {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *AppInstListRequest) CopyInFields(src *AppInstListRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &Timestamp{}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	if m.CellId != src.CellId {
		m.CellId = src.CellId
		changed++
	}
	if src.Tags != nil {
		if m.Tags == nil || len(m.Tags) != len(src.Tags) {
			m.Tags = make([]*Tag, len(src.Tags))
			changed++
		}
		for i0 := 0; i0 < len(src.Tags); i0++ {
			m.Tags[i0] = &Tag{}
			if m.Tags[i0].Type != src.Tags[i0].Type {
				m.Tags[i0].Type = src.Tags[i0].Type
				changed++
			}
			if m.Tags[i0].Data != src.Tags[i0].Data {
				m.Tags[i0].Data = src.Tags[i0].Data
				changed++
			}
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *AppInstListRequest) ValidateEnums() error {
	if err := m.GpsLocation.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.Tags {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *Appinstance) CopyInFields(src *Appinstance) int {
	changed := 0
	if m.AppName != src.AppName {
		m.AppName = src.AppName
		changed++
	}
	if m.AppVers != src.AppVers {
		m.AppVers = src.AppVers
		changed++
	}
	if m.Fqdn != src.Fqdn {
		m.Fqdn = src.Fqdn
		changed++
	}
	if src.Ports != nil {
		if m.Ports == nil || len(m.Ports) != len(src.Ports) {
			m.Ports = make([]*AppPort, len(src.Ports))
			changed++
		}
		for i0 := 0; i0 < len(src.Ports); i0++ {
			m.Ports[i0] = &AppPort{}
			if m.Ports[i0].Proto != src.Ports[i0].Proto {
				m.Ports[i0].Proto = src.Ports[i0].Proto
				changed++
			}
			if m.Ports[i0].InternalPort != src.Ports[i0].InternalPort {
				m.Ports[i0].InternalPort = src.Ports[i0].InternalPort
				changed++
			}
			if m.Ports[i0].PublicPort != src.Ports[i0].PublicPort {
				m.Ports[i0].PublicPort = src.Ports[i0].PublicPort
				changed++
			}
			if m.Ports[i0].PathPrefix != src.Ports[i0].PathPrefix {
				m.Ports[i0].PathPrefix = src.Ports[i0].PathPrefix
				changed++
			}
			if m.Ports[i0].FqdnPrefix != src.Ports[i0].FqdnPrefix {
				m.Ports[i0].FqdnPrefix = src.Ports[i0].FqdnPrefix
				changed++
			}
			if m.Ports[i0].EndPort != src.Ports[i0].EndPort {
				m.Ports[i0].EndPort = src.Ports[i0].EndPort
				changed++
			}
		}
	} else if m.Ports != nil {
		m.Ports = nil
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *Appinstance) ValidateEnums() error {
	for _, e := range m.Ports {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *CloudletLocation) CopyInFields(src *CloudletLocation) int {
	changed := 0
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if m.CloudletName != src.CloudletName {
		m.CloudletName = src.CloudletName
		changed++
	}
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &Timestamp{}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	if m.Distance != src.Distance {
		m.Distance = src.Distance
		changed++
	}
	if src.Appinstances != nil {
		if m.Appinstances == nil || len(m.Appinstances) != len(src.Appinstances) {
			m.Appinstances = make([]*Appinstance, len(src.Appinstances))
			changed++
		}
		for i0 := 0; i0 < len(src.Appinstances); i0++ {
			m.Appinstances[i0] = &Appinstance{}
			if m.Appinstances[i0].AppName != src.Appinstances[i0].AppName {
				m.Appinstances[i0].AppName = src.Appinstances[i0].AppName
				changed++
			}
			if m.Appinstances[i0].AppVers != src.Appinstances[i0].AppVers {
				m.Appinstances[i0].AppVers = src.Appinstances[i0].AppVers
				changed++
			}
			if m.Appinstances[i0].Fqdn != src.Appinstances[i0].Fqdn {
				m.Appinstances[i0].Fqdn = src.Appinstances[i0].Fqdn
				changed++
			}
			if src.Appinstances[i0].Ports != nil {
				if m.Appinstances[i0].Ports == nil || len(m.Appinstances[i0].Ports) != len(src.Appinstances[i0].Ports) {
					m.Appinstances[i0].Ports = make([]*AppPort, len(src.Appinstances[i0].Ports))
					changed++
				}
				for i1 := 0; i1 < len(src.Appinstances[i0].Ports); i1++ {
					m.Appinstances[i0].Ports[i1] = &AppPort{}
					if m.Appinstances[i0].Ports[i1].Proto != src.Appinstances[i0].Ports[i1].Proto {
						m.Appinstances[i0].Ports[i1].Proto = src.Appinstances[i0].Ports[i1].Proto
						changed++
					}
					if m.Appinstances[i0].Ports[i1].InternalPort != src.Appinstances[i0].Ports[i1].InternalPort {
						m.Appinstances[i0].Ports[i1].InternalPort = src.Appinstances[i0].Ports[i1].InternalPort
						changed++
					}
					if m.Appinstances[i0].Ports[i1].PublicPort != src.Appinstances[i0].Ports[i1].PublicPort {
						m.Appinstances[i0].Ports[i1].PublicPort = src.Appinstances[i0].Ports[i1].PublicPort
						changed++
					}
					if m.Appinstances[i0].Ports[i1].PathPrefix != src.Appinstances[i0].Ports[i1].PathPrefix {
						m.Appinstances[i0].Ports[i1].PathPrefix = src.Appinstances[i0].Ports[i1].PathPrefix
						changed++
					}
					if m.Appinstances[i0].Ports[i1].FqdnPrefix != src.Appinstances[i0].Ports[i1].FqdnPrefix {
						m.Appinstances[i0].Ports[i1].FqdnPrefix = src.Appinstances[i0].Ports[i1].FqdnPrefix
						changed++
					}
					if m.Appinstances[i0].Ports[i1].EndPort != src.Appinstances[i0].Ports[i1].EndPort {
						m.Appinstances[i0].Ports[i1].EndPort = src.Appinstances[i0].Ports[i1].EndPort
						changed++
					}
				}
			} else if m.Appinstances[i0].Ports != nil {
				m.Appinstances[i0].Ports = nil
				changed++
			}
		}
	} else if m.Appinstances != nil {
		m.Appinstances = nil
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *CloudletLocation) ValidateEnums() error {
	if err := m.GpsLocation.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.Appinstances {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *AppInstListReply) CopyInFields(src *AppInstListReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if src.Cloudlets != nil {
		if m.Cloudlets == nil || len(m.Cloudlets) != len(src.Cloudlets) {
			m.Cloudlets = make([]*CloudletLocation, len(src.Cloudlets))
			changed++
		}
		for i0 := 0; i0 < len(src.Cloudlets); i0++ {
			m.Cloudlets[i0] = &CloudletLocation{}
			if m.Cloudlets[i0].CarrierName != src.Cloudlets[i0].CarrierName {
				m.Cloudlets[i0].CarrierName = src.Cloudlets[i0].CarrierName
				changed++
			}
			if m.Cloudlets[i0].CloudletName != src.Cloudlets[i0].CloudletName {
				m.Cloudlets[i0].CloudletName = src.Cloudlets[i0].CloudletName
				changed++
			}
			if src.Cloudlets[i0].GpsLocation != nil {
				m.Cloudlets[i0].GpsLocation = &Loc{}
				if m.Cloudlets[i0].GpsLocation.Latitude != src.Cloudlets[i0].GpsLocation.Latitude {
					m.Cloudlets[i0].GpsLocation.Latitude = src.Cloudlets[i0].GpsLocation.Latitude
					changed++
				}
				if m.Cloudlets[i0].GpsLocation.Longitude != src.Cloudlets[i0].GpsLocation.Longitude {
					m.Cloudlets[i0].GpsLocation.Longitude = src.Cloudlets[i0].GpsLocation.Longitude
					changed++
				}
				if m.Cloudlets[i0].GpsLocation.HorizontalAccuracy != src.Cloudlets[i0].GpsLocation.HorizontalAccuracy {
					m.Cloudlets[i0].GpsLocation.HorizontalAccuracy = src.Cloudlets[i0].GpsLocation.HorizontalAccuracy
					changed++
				}
				if m.Cloudlets[i0].GpsLocation.VerticalAccuracy != src.Cloudlets[i0].GpsLocation.VerticalAccuracy {
					m.Cloudlets[i0].GpsLocation.VerticalAccuracy = src.Cloudlets[i0].GpsLocation.VerticalAccuracy
					changed++
				}
				if m.Cloudlets[i0].GpsLocation.Altitude != src.Cloudlets[i0].GpsLocation.Altitude {
					m.Cloudlets[i0].GpsLocation.Altitude = src.Cloudlets[i0].GpsLocation.Altitude
					changed++
				}
				if m.Cloudlets[i0].GpsLocation.Course != src.Cloudlets[i0].GpsLocation.Course {
					m.Cloudlets[i0].GpsLocation.Course = src.Cloudlets[i0].GpsLocation.Course
					changed++
				}
				if m.Cloudlets[i0].GpsLocation.Speed != src.Cloudlets[i0].GpsLocation.Speed {
					m.Cloudlets[i0].GpsLocation.Speed = src.Cloudlets[i0].GpsLocation.Speed
					changed++
				}
				if src.Cloudlets[i0].GpsLocation.Timestamp != nil {
					m.Cloudlets[i0].GpsLocation.Timestamp = &Timestamp{}
					if m.Cloudlets[i0].GpsLocation.Timestamp.Seconds != src.Cloudlets[i0].GpsLocation.Timestamp.Seconds {
						m.Cloudlets[i0].GpsLocation.Timestamp.Seconds = src.Cloudlets[i0].GpsLocation.Timestamp.Seconds
						changed++
					}
					if m.Cloudlets[i0].GpsLocation.Timestamp.Nanos != src.Cloudlets[i0].GpsLocation.Timestamp.Nanos {
						m.Cloudlets[i0].GpsLocation.Timestamp.Nanos = src.Cloudlets[i0].GpsLocation.Timestamp.Nanos
						changed++
					}
				} else if m.Cloudlets[i0].GpsLocation.Timestamp != nil {
					m.Cloudlets[i0].GpsLocation.Timestamp = nil
					changed++
				}
			} else if m.Cloudlets[i0].GpsLocation != nil {
				m.Cloudlets[i0].GpsLocation = nil
				changed++
			}
			if m.Cloudlets[i0].Distance != src.Cloudlets[i0].Distance {
				m.Cloudlets[i0].Distance = src.Cloudlets[i0].Distance
				changed++
			}
			if src.Cloudlets[i0].Appinstances != nil {
				if m.Cloudlets[i0].Appinstances == nil || len(m.Cloudlets[i0].Appinstances) != len(src.Cloudlets[i0].Appinstances) {
					m.Cloudlets[i0].Appinstances = make([]*Appinstance, len(src.Cloudlets[i0].Appinstances))
					changed++
				}
				for i1 := 0; i1 < len(src.Cloudlets[i0].Appinstances); i1++ {
					m.Cloudlets[i0].Appinstances[i1] = &Appinstance{}
					if m.Cloudlets[i0].Appinstances[i1].AppName != src.Cloudlets[i0].Appinstances[i1].AppName {
						m.Cloudlets[i0].Appinstances[i1].AppName = src.Cloudlets[i0].Appinstances[i1].AppName
						changed++
					}
					if m.Cloudlets[i0].Appinstances[i1].AppVers != src.Cloudlets[i0].Appinstances[i1].AppVers {
						m.Cloudlets[i0].Appinstances[i1].AppVers = src.Cloudlets[i0].Appinstances[i1].AppVers
						changed++
					}
					if m.Cloudlets[i0].Appinstances[i1].Fqdn != src.Cloudlets[i0].Appinstances[i1].Fqdn {
						m.Cloudlets[i0].Appinstances[i1].Fqdn = src.Cloudlets[i0].Appinstances[i1].Fqdn
						changed++
					}
					if src.Cloudlets[i0].Appinstances[i1].Ports != nil {
						if m.Cloudlets[i0].Appinstances[i1].Ports == nil || len(m.Cloudlets[i0].Appinstances[i1].Ports) != len(src.Cloudlets[i0].Appinstances[i1].Ports) {
							m.Cloudlets[i0].Appinstances[i1].Ports = make([]*AppPort, len(src.Cloudlets[i0].Appinstances[i1].Ports))
							changed++
						}
						for i2 := 0; i2 < len(src.Cloudlets[i0].Appinstances[i1].Ports); i2++ {
							m.Cloudlets[i0].Appinstances[i1].Ports[i2] = &AppPort{}
							if m.Cloudlets[i0].Appinstances[i1].Ports[i2].Proto != src.Cloudlets[i0].Appinstances[i1].Ports[i2].Proto {
								m.Cloudlets[i0].Appinstances[i1].Ports[i2].Proto = src.Cloudlets[i0].Appinstances[i1].Ports[i2].Proto
								changed++
							}
							if m.Cloudlets[i0].Appinstances[i1].Ports[i2].InternalPort != src.Cloudlets[i0].Appinstances[i1].Ports[i2].InternalPort {
								m.Cloudlets[i0].Appinstances[i1].Ports[i2].InternalPort = src.Cloudlets[i0].Appinstances[i1].Ports[i2].InternalPort
								changed++
							}
							if m.Cloudlets[i0].Appinstances[i1].Ports[i2].PublicPort != src.Cloudlets[i0].Appinstances[i1].Ports[i2].PublicPort {
								m.Cloudlets[i0].Appinstances[i1].Ports[i2].PublicPort = src.Cloudlets[i0].Appinstances[i1].Ports[i2].PublicPort
								changed++
							}
							if m.Cloudlets[i0].Appinstances[i1].Ports[i2].PathPrefix != src.Cloudlets[i0].Appinstances[i1].Ports[i2].PathPrefix {
								m.Cloudlets[i0].Appinstances[i1].Ports[i2].PathPrefix = src.Cloudlets[i0].Appinstances[i1].Ports[i2].PathPrefix
								changed++
							}
							if m.Cloudlets[i0].Appinstances[i1].Ports[i2].FqdnPrefix != src.Cloudlets[i0].Appinstances[i1].Ports[i2].FqdnPrefix {
								m.Cloudlets[i0].Appinstances[i1].Ports[i2].FqdnPrefix = src.Cloudlets[i0].Appinstances[i1].Ports[i2].FqdnPrefix
								changed++
							}
							if m.Cloudlets[i0].Appinstances[i1].Ports[i2].EndPort != src.Cloudlets[i0].Appinstances[i1].Ports[i2].EndPort {
								m.Cloudlets[i0].Appinstances[i1].Ports[i2].EndPort = src.Cloudlets[i0].Appinstances[i1].Ports[i2].EndPort
								changed++
							}
						}
					} else if m.Cloudlets[i0].Appinstances[i1].Ports != nil {
						m.Cloudlets[i0].Appinstances[i1].Ports = nil
						changed++
					}
				}
			} else if m.Cloudlets[i0].Appinstances != nil {
				m.Cloudlets[i0].Appinstances = nil
				changed++
			}
		}
	} else if m.Cloudlets != nil {
		m.Cloudlets = nil
		changed++
	}
	if src.Tags != nil {
		if m.Tags == nil || len(m.Tags) != len(src.Tags) {
			m.Tags = make([]*Tag, len(src.Tags))
			changed++
		}
		for i0 := 0; i0 < len(src.Tags); i0++ {
			m.Tags[i0] = &Tag{}
			if m.Tags[i0].Type != src.Tags[i0].Type {
				m.Tags[i0].Type = src.Tags[i0].Type
				changed++
			}
			if m.Tags[i0].Data != src.Tags[i0].Data {
				m.Tags[i0].Data = src.Tags[i0].Data
				changed++
			}
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *AppInstListReply) ValidateEnums() error {
	if _, ok := AppInstListReply_AIStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	for _, e := range m.Cloudlets {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.Tags {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *FqdnListRequest) CopyInFields(src *FqdnListRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.CellId != src.CellId {
		m.CellId = src.CellId
		changed++
	}
	if src.Tags != nil {
		if m.Tags == nil || len(m.Tags) != len(src.Tags) {
			m.Tags = make([]*Tag, len(src.Tags))
			changed++
		}
		for i0 := 0; i0 < len(src.Tags); i0++ {
			m.Tags[i0] = &Tag{}
			if m.Tags[i0].Type != src.Tags[i0].Type {
				m.Tags[i0].Type = src.Tags[i0].Type
				changed++
			}
			if m.Tags[i0].Data != src.Tags[i0].Data {
				m.Tags[i0].Data = src.Tags[i0].Data
				changed++
			}
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *FqdnListRequest) ValidateEnums() error {
	for _, e := range m.Tags {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *AppFqdn) CopyInFields(src *AppFqdn) int {
	changed := 0
	if m.AppName != src.AppName {
		m.AppName = src.AppName
		changed++
	}
	if m.AppVers != src.AppVers {
		m.AppVers = src.AppVers
		changed++
	}
	if m.DevName != src.DevName {
		m.DevName = src.DevName
		changed++
	}
	if m.Fqdns == nil || len(m.Fqdns) != len(src.Fqdns) {
		m.Fqdns = make([]string, len(src.Fqdns))
		changed++
	}
	copy(m.Fqdns, src.Fqdns)
	changed++
	if m.AndroidPackageName != src.AndroidPackageName {
		m.AndroidPackageName = src.AndroidPackageName
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *AppFqdn) ValidateEnums() error {
	return nil
}

func (m *FqdnListReply) CopyInFields(src *FqdnListReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if src.AppFqdns != nil {
		if m.AppFqdns == nil || len(m.AppFqdns) != len(src.AppFqdns) {
			m.AppFqdns = make([]*AppFqdn, len(src.AppFqdns))
			changed++
		}
		for i0 := 0; i0 < len(src.AppFqdns); i0++ {
			m.AppFqdns[i0] = &AppFqdn{}
			if m.AppFqdns[i0].AppName != src.AppFqdns[i0].AppName {
				m.AppFqdns[i0].AppName = src.AppFqdns[i0].AppName
				changed++
			}
			if m.AppFqdns[i0].AppVers != src.AppFqdns[i0].AppVers {
				m.AppFqdns[i0].AppVers = src.AppFqdns[i0].AppVers
				changed++
			}
			if m.AppFqdns[i0].DevName != src.AppFqdns[i0].DevName {
				m.AppFqdns[i0].DevName = src.AppFqdns[i0].DevName
				changed++
			}
			if m.AppFqdns[i0].Fqdns == nil || len(m.AppFqdns[i0].Fqdns) != len(src.AppFqdns[i0].Fqdns) {
				m.AppFqdns[i0].Fqdns = make([]string, len(src.AppFqdns[i0].Fqdns))
				changed++
			}
			copy(m.AppFqdns[i0].Fqdns, src.AppFqdns[i0].Fqdns)
			changed++
			if m.AppFqdns[i0].AndroidPackageName != src.AppFqdns[i0].AndroidPackageName {
				m.AppFqdns[i0].AndroidPackageName = src.AppFqdns[i0].AndroidPackageName
				changed++
			}
		}
	} else if m.AppFqdns != nil {
		m.AppFqdns = nil
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if src.Tags != nil {
		if m.Tags == nil || len(m.Tags) != len(src.Tags) {
			m.Tags = make([]*Tag, len(src.Tags))
			changed++
		}
		for i0 := 0; i0 < len(src.Tags); i0++ {
			m.Tags[i0] = &Tag{}
			if m.Tags[i0].Type != src.Tags[i0].Type {
				m.Tags[i0].Type = src.Tags[i0].Type
				changed++
			}
			if m.Tags[i0].Data != src.Tags[i0].Data {
				m.Tags[i0].Data = src.Tags[i0].Data
				changed++
			}
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *FqdnListReply) ValidateEnums() error {
	for _, e := range m.AppFqdns {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if _, ok := FqdnListReply_FLStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	for _, e := range m.Tags {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *DynamicLocGroupRequest) CopyInFields(src *DynamicLocGroupRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.LgId != src.LgId {
		m.LgId = src.LgId
		changed++
	}
	if m.CommType != src.CommType {
		m.CommType = src.CommType
		changed++
	}
	if m.UserData != src.UserData {
		m.UserData = src.UserData
		changed++
	}
	if m.CellId != src.CellId {
		m.CellId = src.CellId
		changed++
	}
	if src.Tags != nil {
		if m.Tags == nil || len(m.Tags) != len(src.Tags) {
			m.Tags = make([]*Tag, len(src.Tags))
			changed++
		}
		for i0 := 0; i0 < len(src.Tags); i0++ {
			m.Tags[i0] = &Tag{}
			if m.Tags[i0].Type != src.Tags[i0].Type {
				m.Tags[i0].Type = src.Tags[i0].Type
				changed++
			}
			if m.Tags[i0].Data != src.Tags[i0].Data {
				m.Tags[i0].Data = src.Tags[i0].Data
				changed++
			}
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *DynamicLocGroupRequest) ValidateEnums() error {
	if _, ok := DynamicLocGroupRequest_DlgCommType_name[int32(m.CommType)]; !ok {
		return errors.New("invalid CommType")
	}
	for _, e := range m.Tags {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *DynamicLocGroupReply) CopyInFields(src *DynamicLocGroupReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if m.ErrorCode != src.ErrorCode {
		m.ErrorCode = src.ErrorCode
		changed++
	}
	if m.GroupCookie != src.GroupCookie {
		m.GroupCookie = src.GroupCookie
		changed++
	}
	if src.Tags != nil {
		if m.Tags == nil || len(m.Tags) != len(src.Tags) {
			m.Tags = make([]*Tag, len(src.Tags))
			changed++
		}
		for i0 := 0; i0 < len(src.Tags); i0++ {
			m.Tags[i0] = &Tag{}
			if m.Tags[i0].Type != src.Tags[i0].Type {
				m.Tags[i0].Type = src.Tags[i0].Type
				changed++
			}
			if m.Tags[i0].Data != src.Tags[i0].Data {
				m.Tags[i0].Data = src.Tags[i0].Data
				changed++
			}
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *DynamicLocGroupReply) ValidateEnums() error {
	if _, ok := ReplyStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	for _, e := range m.Tags {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *QosPosition) CopyInFields(src *QosPosition) int {
	changed := 0
	if m.Positionid != src.Positionid {
		m.Positionid = src.Positionid
		changed++
	}
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &Timestamp{}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *QosPosition) ValidateEnums() error {
	if err := m.GpsLocation.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *BandSelection) CopyInFields(src *BandSelection) int {
	changed := 0
	if m.Rat_2G == nil || len(m.Rat_2G) != len(src.Rat_2G) {
		m.Rat_2G = make([]string, len(src.Rat_2G))
		changed++
	}
	copy(m.Rat_2G, src.Rat_2G)
	changed++
	if m.Rat_3G == nil || len(m.Rat_3G) != len(src.Rat_3G) {
		m.Rat_3G = make([]string, len(src.Rat_3G))
		changed++
	}
	copy(m.Rat_3G, src.Rat_3G)
	changed++
	if m.Rat_4G == nil || len(m.Rat_4G) != len(src.Rat_4G) {
		m.Rat_4G = make([]string, len(src.Rat_4G))
		changed++
	}
	copy(m.Rat_4G, src.Rat_4G)
	changed++
	if m.Rat_5G == nil || len(m.Rat_5G) != len(src.Rat_5G) {
		m.Rat_5G = make([]string, len(src.Rat_5G))
		changed++
	}
	copy(m.Rat_5G, src.Rat_5G)
	changed++
	return changed
}

// Helper method to check that enums have valid values
func (m *BandSelection) ValidateEnums() error {
	return nil
}

func (m *QosPositionRequest) CopyInFields(src *QosPositionRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if src.Positions != nil {
		if m.Positions == nil || len(m.Positions) != len(src.Positions) {
			m.Positions = make([]*QosPosition, len(src.Positions))
			changed++
		}
		for i0 := 0; i0 < len(src.Positions); i0++ {
			m.Positions[i0] = &QosPosition{}
			if m.Positions[i0].Positionid != src.Positions[i0].Positionid {
				m.Positions[i0].Positionid = src.Positions[i0].Positionid
				changed++
			}
			if src.Positions[i0].GpsLocation != nil {
				m.Positions[i0].GpsLocation = &Loc{}
				if m.Positions[i0].GpsLocation.Latitude != src.Positions[i0].GpsLocation.Latitude {
					m.Positions[i0].GpsLocation.Latitude = src.Positions[i0].GpsLocation.Latitude
					changed++
				}
				if m.Positions[i0].GpsLocation.Longitude != src.Positions[i0].GpsLocation.Longitude {
					m.Positions[i0].GpsLocation.Longitude = src.Positions[i0].GpsLocation.Longitude
					changed++
				}
				if m.Positions[i0].GpsLocation.HorizontalAccuracy != src.Positions[i0].GpsLocation.HorizontalAccuracy {
					m.Positions[i0].GpsLocation.HorizontalAccuracy = src.Positions[i0].GpsLocation.HorizontalAccuracy
					changed++
				}
				if m.Positions[i0].GpsLocation.VerticalAccuracy != src.Positions[i0].GpsLocation.VerticalAccuracy {
					m.Positions[i0].GpsLocation.VerticalAccuracy = src.Positions[i0].GpsLocation.VerticalAccuracy
					changed++
				}
				if m.Positions[i0].GpsLocation.Altitude != src.Positions[i0].GpsLocation.Altitude {
					m.Positions[i0].GpsLocation.Altitude = src.Positions[i0].GpsLocation.Altitude
					changed++
				}
				if m.Positions[i0].GpsLocation.Course != src.Positions[i0].GpsLocation.Course {
					m.Positions[i0].GpsLocation.Course = src.Positions[i0].GpsLocation.Course
					changed++
				}
				if m.Positions[i0].GpsLocation.Speed != src.Positions[i0].GpsLocation.Speed {
					m.Positions[i0].GpsLocation.Speed = src.Positions[i0].GpsLocation.Speed
					changed++
				}
				if src.Positions[i0].GpsLocation.Timestamp != nil {
					m.Positions[i0].GpsLocation.Timestamp = &Timestamp{}
					if m.Positions[i0].GpsLocation.Timestamp.Seconds != src.Positions[i0].GpsLocation.Timestamp.Seconds {
						m.Positions[i0].GpsLocation.Timestamp.Seconds = src.Positions[i0].GpsLocation.Timestamp.Seconds
						changed++
					}
					if m.Positions[i0].GpsLocation.Timestamp.Nanos != src.Positions[i0].GpsLocation.Timestamp.Nanos {
						m.Positions[i0].GpsLocation.Timestamp.Nanos = src.Positions[i0].GpsLocation.Timestamp.Nanos
						changed++
					}
				} else if m.Positions[i0].GpsLocation.Timestamp != nil {
					m.Positions[i0].GpsLocation.Timestamp = nil
					changed++
				}
			} else if m.Positions[i0].GpsLocation != nil {
				m.Positions[i0].GpsLocation = nil
				changed++
			}
		}
	} else if m.Positions != nil {
		m.Positions = nil
		changed++
	}
	if m.LteCategory != src.LteCategory {
		m.LteCategory = src.LteCategory
		changed++
	}
	if src.BandSelection != nil {
		m.BandSelection = &BandSelection{}
		if m.BandSelection.Rat_2G == nil || len(m.BandSelection.Rat_2G) != len(src.BandSelection.Rat_2G) {
			m.BandSelection.Rat_2G = make([]string, len(src.BandSelection.Rat_2G))
			changed++
		}
		copy(m.BandSelection.Rat_2G, src.BandSelection.Rat_2G)
		changed++
		if m.BandSelection.Rat_3G == nil || len(m.BandSelection.Rat_3G) != len(src.BandSelection.Rat_3G) {
			m.BandSelection.Rat_3G = make([]string, len(src.BandSelection.Rat_3G))
			changed++
		}
		copy(m.BandSelection.Rat_3G, src.BandSelection.Rat_3G)
		changed++
		if m.BandSelection.Rat_4G == nil || len(m.BandSelection.Rat_4G) != len(src.BandSelection.Rat_4G) {
			m.BandSelection.Rat_4G = make([]string, len(src.BandSelection.Rat_4G))
			changed++
		}
		copy(m.BandSelection.Rat_4G, src.BandSelection.Rat_4G)
		changed++
		if m.BandSelection.Rat_5G == nil || len(m.BandSelection.Rat_5G) != len(src.BandSelection.Rat_5G) {
			m.BandSelection.Rat_5G = make([]string, len(src.BandSelection.Rat_5G))
			changed++
		}
		copy(m.BandSelection.Rat_5G, src.BandSelection.Rat_5G)
		changed++
	} else if m.BandSelection != nil {
		m.BandSelection = nil
		changed++
	}
	if m.CellId != src.CellId {
		m.CellId = src.CellId
		changed++
	}
	if src.Tags != nil {
		if m.Tags == nil || len(m.Tags) != len(src.Tags) {
			m.Tags = make([]*Tag, len(src.Tags))
			changed++
		}
		for i0 := 0; i0 < len(src.Tags); i0++ {
			m.Tags[i0] = &Tag{}
			if m.Tags[i0].Type != src.Tags[i0].Type {
				m.Tags[i0].Type = src.Tags[i0].Type
				changed++
			}
			if m.Tags[i0].Data != src.Tags[i0].Data {
				m.Tags[i0].Data = src.Tags[i0].Data
				changed++
			}
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *QosPositionRequest) ValidateEnums() error {
	for _, e := range m.Positions {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if err := m.BandSelection.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.Tags {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *QosPositionKpiResult) CopyInFields(src *QosPositionKpiResult) int {
	changed := 0
	if m.Positionid != src.Positionid {
		m.Positionid = src.Positionid
		changed++
	}
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &Timestamp{}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	if m.DluserthroughputMin != src.DluserthroughputMin {
		m.DluserthroughputMin = src.DluserthroughputMin
		changed++
	}
	if m.DluserthroughputAvg != src.DluserthroughputAvg {
		m.DluserthroughputAvg = src.DluserthroughputAvg
		changed++
	}
	if m.DluserthroughputMax != src.DluserthroughputMax {
		m.DluserthroughputMax = src.DluserthroughputMax
		changed++
	}
	if m.UluserthroughputMin != src.UluserthroughputMin {
		m.UluserthroughputMin = src.UluserthroughputMin
		changed++
	}
	if m.UluserthroughputAvg != src.UluserthroughputAvg {
		m.UluserthroughputAvg = src.UluserthroughputAvg
		changed++
	}
	if m.UluserthroughputMax != src.UluserthroughputMax {
		m.UluserthroughputMax = src.UluserthroughputMax
		changed++
	}
	if m.LatencyMin != src.LatencyMin {
		m.LatencyMin = src.LatencyMin
		changed++
	}
	if m.LatencyAvg != src.LatencyAvg {
		m.LatencyAvg = src.LatencyAvg
		changed++
	}
	if m.LatencyMax != src.LatencyMax {
		m.LatencyMax = src.LatencyMax
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *QosPositionKpiResult) ValidateEnums() error {
	if err := m.GpsLocation.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *QosPositionKpiReply) CopyInFields(src *QosPositionKpiReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if src.PositionResults != nil {
		if m.PositionResults == nil || len(m.PositionResults) != len(src.PositionResults) {
			m.PositionResults = make([]*QosPositionKpiResult, len(src.PositionResults))
			changed++
		}
		for i0 := 0; i0 < len(src.PositionResults); i0++ {
			m.PositionResults[i0] = &QosPositionKpiResult{}
			if m.PositionResults[i0].Positionid != src.PositionResults[i0].Positionid {
				m.PositionResults[i0].Positionid = src.PositionResults[i0].Positionid
				changed++
			}
			if src.PositionResults[i0].GpsLocation != nil {
				m.PositionResults[i0].GpsLocation = &Loc{}
				if m.PositionResults[i0].GpsLocation.Latitude != src.PositionResults[i0].GpsLocation.Latitude {
					m.PositionResults[i0].GpsLocation.Latitude = src.PositionResults[i0].GpsLocation.Latitude
					changed++
				}
				if m.PositionResults[i0].GpsLocation.Longitude != src.PositionResults[i0].GpsLocation.Longitude {
					m.PositionResults[i0].GpsLocation.Longitude = src.PositionResults[i0].GpsLocation.Longitude
					changed++
				}
				if m.PositionResults[i0].GpsLocation.HorizontalAccuracy != src.PositionResults[i0].GpsLocation.HorizontalAccuracy {
					m.PositionResults[i0].GpsLocation.HorizontalAccuracy = src.PositionResults[i0].GpsLocation.HorizontalAccuracy
					changed++
				}
				if m.PositionResults[i0].GpsLocation.VerticalAccuracy != src.PositionResults[i0].GpsLocation.VerticalAccuracy {
					m.PositionResults[i0].GpsLocation.VerticalAccuracy = src.PositionResults[i0].GpsLocation.VerticalAccuracy
					changed++
				}
				if m.PositionResults[i0].GpsLocation.Altitude != src.PositionResults[i0].GpsLocation.Altitude {
					m.PositionResults[i0].GpsLocation.Altitude = src.PositionResults[i0].GpsLocation.Altitude
					changed++
				}
				if m.PositionResults[i0].GpsLocation.Course != src.PositionResults[i0].GpsLocation.Course {
					m.PositionResults[i0].GpsLocation.Course = src.PositionResults[i0].GpsLocation.Course
					changed++
				}
				if m.PositionResults[i0].GpsLocation.Speed != src.PositionResults[i0].GpsLocation.Speed {
					m.PositionResults[i0].GpsLocation.Speed = src.PositionResults[i0].GpsLocation.Speed
					changed++
				}
				if src.PositionResults[i0].GpsLocation.Timestamp != nil {
					m.PositionResults[i0].GpsLocation.Timestamp = &Timestamp{}
					if m.PositionResults[i0].GpsLocation.Timestamp.Seconds != src.PositionResults[i0].GpsLocation.Timestamp.Seconds {
						m.PositionResults[i0].GpsLocation.Timestamp.Seconds = src.PositionResults[i0].GpsLocation.Timestamp.Seconds
						changed++
					}
					if m.PositionResults[i0].GpsLocation.Timestamp.Nanos != src.PositionResults[i0].GpsLocation.Timestamp.Nanos {
						m.PositionResults[i0].GpsLocation.Timestamp.Nanos = src.PositionResults[i0].GpsLocation.Timestamp.Nanos
						changed++
					}
				} else if m.PositionResults[i0].GpsLocation.Timestamp != nil {
					m.PositionResults[i0].GpsLocation.Timestamp = nil
					changed++
				}
			} else if m.PositionResults[i0].GpsLocation != nil {
				m.PositionResults[i0].GpsLocation = nil
				changed++
			}
			if m.PositionResults[i0].DluserthroughputMin != src.PositionResults[i0].DluserthroughputMin {
				m.PositionResults[i0].DluserthroughputMin = src.PositionResults[i0].DluserthroughputMin
				changed++
			}
			if m.PositionResults[i0].DluserthroughputAvg != src.PositionResults[i0].DluserthroughputAvg {
				m.PositionResults[i0].DluserthroughputAvg = src.PositionResults[i0].DluserthroughputAvg
				changed++
			}
			if m.PositionResults[i0].DluserthroughputMax != src.PositionResults[i0].DluserthroughputMax {
				m.PositionResults[i0].DluserthroughputMax = src.PositionResults[i0].DluserthroughputMax
				changed++
			}
			if m.PositionResults[i0].UluserthroughputMin != src.PositionResults[i0].UluserthroughputMin {
				m.PositionResults[i0].UluserthroughputMin = src.PositionResults[i0].UluserthroughputMin
				changed++
			}
			if m.PositionResults[i0].UluserthroughputAvg != src.PositionResults[i0].UluserthroughputAvg {
				m.PositionResults[i0].UluserthroughputAvg = src.PositionResults[i0].UluserthroughputAvg
				changed++
			}
			if m.PositionResults[i0].UluserthroughputMax != src.PositionResults[i0].UluserthroughputMax {
				m.PositionResults[i0].UluserthroughputMax = src.PositionResults[i0].UluserthroughputMax
				changed++
			}
			if m.PositionResults[i0].LatencyMin != src.PositionResults[i0].LatencyMin {
				m.PositionResults[i0].LatencyMin = src.PositionResults[i0].LatencyMin
				changed++
			}
			if m.PositionResults[i0].LatencyAvg != src.PositionResults[i0].LatencyAvg {
				m.PositionResults[i0].LatencyAvg = src.PositionResults[i0].LatencyAvg
				changed++
			}
			if m.PositionResults[i0].LatencyMax != src.PositionResults[i0].LatencyMax {
				m.PositionResults[i0].LatencyMax = src.PositionResults[i0].LatencyMax
				changed++
			}
		}
	} else if m.PositionResults != nil {
		m.PositionResults = nil
		changed++
	}
	if src.Tags != nil {
		if m.Tags == nil || len(m.Tags) != len(src.Tags) {
			m.Tags = make([]*Tag, len(src.Tags))
			changed++
		}
		for i0 := 0; i0 < len(src.Tags); i0++ {
			m.Tags[i0] = &Tag{}
			if m.Tags[i0].Type != src.Tags[i0].Type {
				m.Tags[i0].Type = src.Tags[i0].Type
				changed++
			}
			if m.Tags[i0].Data != src.Tags[i0].Data {
				m.Tags[i0].Data = src.Tags[i0].Data
				changed++
			}
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *QosPositionKpiReply) ValidateEnums() error {
	if _, ok := ReplyStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	for _, e := range m.PositionResults {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.Tags {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

var IDTypesStrings = []string{
	"ID_UNDEFINED",
	"IMEI",
	"MSISDN",
	"IPADDR",
}

const (
	IDTypesID_UNDEFINED uint64 = 1 << 0
	IDTypesIMEI         uint64 = 1 << 1
	IDTypesMSISDN       uint64 = 1 << 2
	IDTypesIPADDR       uint64 = 1 << 3
)

var IDTypes_CamelName = map[int32]string{
	// ID_UNDEFINED -> IdUndefined
	0: "IdUndefined",
	// IMEI -> Imei
	1: "Imei",
	// MSISDN -> Msisdn
	2: "Msisdn",
	// IPADDR -> Ipaddr
	3: "Ipaddr",
}
var IDTypes_CamelValue = map[string]int32{
	"IdUndefined": 0,
	"Imei":        1,
	"Msisdn":      2,
	"Ipaddr":      3,
}

func (e *IDTypes) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := IDTypes_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = IDTypes_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = IDTypes(val)
	return nil
}

func (e IDTypes) MarshalYAML() (interface{}, error) {
	return proto.EnumName(IDTypes_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *IDTypes) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := IDTypes_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = IDTypes_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = IDTypes(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = IDTypes(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

var ReplyStatusStrings = []string{
	"RS_UNDEFINED",
	"RS_SUCCESS",
	"RS_FAIL",
}

const (
	ReplyStatusRS_UNDEFINED uint64 = 1 << 0
	ReplyStatusRS_SUCCESS   uint64 = 1 << 1
	ReplyStatusRS_FAIL      uint64 = 1 << 2
)

var ReplyStatus_CamelName = map[int32]string{
	// RS_UNDEFINED -> RsUndefined
	0: "RsUndefined",
	// RS_SUCCESS -> RsSuccess
	1: "RsSuccess",
	// RS_FAIL -> RsFail
	2: "RsFail",
}
var ReplyStatus_CamelValue = map[string]int32{
	"RsUndefined": 0,
	"RsSuccess":   1,
	"RsFail":      2,
}

func (e *ReplyStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := ReplyStatus_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = ReplyStatus_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = ReplyStatus(val)
	return nil
}

func (e ReplyStatus) MarshalYAML() (interface{}, error) {
	return proto.EnumName(ReplyStatus_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *ReplyStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := ReplyStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = ReplyStatus_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = ReplyStatus(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = ReplyStatus(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

var FindStatusStrings = []string{
	"FIND_UNKNOWN",
	"FIND_FOUND",
	"FIND_NOTFOUND",
}

const (
	FindStatusFIND_UNKNOWN  uint64 = 1 << 0
	FindStatusFIND_FOUND    uint64 = 1 << 1
	FindStatusFIND_NOTFOUND uint64 = 1 << 2
)

var FindCloudletReply_FindStatus_CamelName = map[int32]string{
	// FIND_UNKNOWN -> FindUnknown
	0: "FindUnknown",
	// FIND_FOUND -> FindFound
	1: "FindFound",
	// FIND_NOTFOUND -> FindNotfound
	2: "FindNotfound",
}
var FindCloudletReply_FindStatus_CamelValue = map[string]int32{
	"FindUnknown":  0,
	"FindFound":    1,
	"FindNotfound": 2,
}

func (e *FindCloudletReply_FindStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := FindCloudletReply_FindStatus_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = FindCloudletReply_FindStatus_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = FindCloudletReply_FindStatus(val)
	return nil
}

func (e FindCloudletReply_FindStatus) MarshalYAML() (interface{}, error) {
	return proto.EnumName(FindCloudletReply_FindStatus_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *FindCloudletReply_FindStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := FindCloudletReply_FindStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = FindCloudletReply_FindStatus_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = FindCloudletReply_FindStatus(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = FindCloudletReply_FindStatus(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

var TowerStatusStrings = []string{
	"TOWER_UNKNOWN",
	"CONNECTED_TO_SPECIFIED_TOWER",
	"NOT_CONNECTED_TO_SPECIFIED_TOWER",
}

const (
	TowerStatusTOWER_UNKNOWN                    uint64 = 1 << 0
	TowerStatusCONNECTED_TO_SPECIFIED_TOWER     uint64 = 1 << 1
	TowerStatusNOT_CONNECTED_TO_SPECIFIED_TOWER uint64 = 1 << 2
)

var VerifyLocationReply_TowerStatus_CamelName = map[int32]string{
	// TOWER_UNKNOWN -> TowerUnknown
	0: "TowerUnknown",
	// CONNECTED_TO_SPECIFIED_TOWER -> ConnectedToSpecifiedTower
	1: "ConnectedToSpecifiedTower",
	// NOT_CONNECTED_TO_SPECIFIED_TOWER -> NotConnectedToSpecifiedTower
	2: "NotConnectedToSpecifiedTower",
}
var VerifyLocationReply_TowerStatus_CamelValue = map[string]int32{
	"TowerUnknown":                 0,
	"ConnectedToSpecifiedTower":    1,
	"NotConnectedToSpecifiedTower": 2,
}

func (e *VerifyLocationReply_TowerStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := VerifyLocationReply_TowerStatus_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = VerifyLocationReply_TowerStatus_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = VerifyLocationReply_TowerStatus(val)
	return nil
}

func (e VerifyLocationReply_TowerStatus) MarshalYAML() (interface{}, error) {
	return proto.EnumName(VerifyLocationReply_TowerStatus_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *VerifyLocationReply_TowerStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := VerifyLocationReply_TowerStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = VerifyLocationReply_TowerStatus_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = VerifyLocationReply_TowerStatus(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = VerifyLocationReply_TowerStatus(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

var GPSLocationStatusStrings = []string{
	"LOC_UNKNOWN",
	"LOC_VERIFIED",
	"LOC_MISMATCH_SAME_COUNTRY",
	"LOC_MISMATCH_OTHER_COUNTRY",
	"LOC_ROAMING_COUNTRY_MATCH",
	"LOC_ROAMING_COUNTRY_MISMATCH",
	"LOC_ERROR_UNAUTHORIZED",
	"LOC_ERROR_OTHER",
}

const (
	GPSLocationStatusLOC_UNKNOWN                  uint64 = 1 << 0
	GPSLocationStatusLOC_VERIFIED                 uint64 = 1 << 1
	GPSLocationStatusLOC_MISMATCH_SAME_COUNTRY    uint64 = 1 << 2
	GPSLocationStatusLOC_MISMATCH_OTHER_COUNTRY   uint64 = 1 << 3
	GPSLocationStatusLOC_ROAMING_COUNTRY_MATCH    uint64 = 1 << 4
	GPSLocationStatusLOC_ROAMING_COUNTRY_MISMATCH uint64 = 1 << 5
	GPSLocationStatusLOC_ERROR_UNAUTHORIZED       uint64 = 1 << 6
	GPSLocationStatusLOC_ERROR_OTHER              uint64 = 1 << 7
)

var VerifyLocationReply_GPSLocationStatus_CamelName = map[int32]string{
	// LOC_UNKNOWN -> LocUnknown
	0: "LocUnknown",
	// LOC_VERIFIED -> LocVerified
	1: "LocVerified",
	// LOC_MISMATCH_SAME_COUNTRY -> LocMismatchSameCountry
	2: "LocMismatchSameCountry",
	// LOC_MISMATCH_OTHER_COUNTRY -> LocMismatchOtherCountry
	3: "LocMismatchOtherCountry",
	// LOC_ROAMING_COUNTRY_MATCH -> LocRoamingCountryMatch
	4: "LocRoamingCountryMatch",
	// LOC_ROAMING_COUNTRY_MISMATCH -> LocRoamingCountryMismatch
	5: "LocRoamingCountryMismatch",
	// LOC_ERROR_UNAUTHORIZED -> LocErrorUnauthorized
	6: "LocErrorUnauthorized",
	// LOC_ERROR_OTHER -> LocErrorOther
	7: "LocErrorOther",
}
var VerifyLocationReply_GPSLocationStatus_CamelValue = map[string]int32{
	"LocUnknown":                0,
	"LocVerified":               1,
	"LocMismatchSameCountry":    2,
	"LocMismatchOtherCountry":   3,
	"LocRoamingCountryMatch":    4,
	"LocRoamingCountryMismatch": 5,
	"LocErrorUnauthorized":      6,
	"LocErrorOther":             7,
}

func (e *VerifyLocationReply_GPSLocationStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := VerifyLocationReply_GPSLocationStatus_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = VerifyLocationReply_GPSLocationStatus_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = VerifyLocationReply_GPSLocationStatus(val)
	return nil
}

func (e VerifyLocationReply_GPSLocationStatus) MarshalYAML() (interface{}, error) {
	return proto.EnumName(VerifyLocationReply_GPSLocationStatus_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *VerifyLocationReply_GPSLocationStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := VerifyLocationReply_GPSLocationStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = VerifyLocationReply_GPSLocationStatus_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = VerifyLocationReply_GPSLocationStatus(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = VerifyLocationReply_GPSLocationStatus(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

var LocStatusStrings = []string{
	"LOC_UNKNOWN",
	"LOC_FOUND",
	"LOC_DENIED",
}

const (
	LocStatusLOC_UNKNOWN uint64 = 1 << 0
	LocStatusLOC_FOUND   uint64 = 1 << 1
	LocStatusLOC_DENIED  uint64 = 1 << 2
)

var GetLocationReply_LocStatus_CamelName = map[int32]string{
	// LOC_UNKNOWN -> LocUnknown
	0: "LocUnknown",
	// LOC_FOUND -> LocFound
	1: "LocFound",
	// LOC_DENIED -> LocDenied
	2: "LocDenied",
}
var GetLocationReply_LocStatus_CamelValue = map[string]int32{
	"LocUnknown": 0,
	"LocFound":   1,
	"LocDenied":  2,
}

func (e *GetLocationReply_LocStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := GetLocationReply_LocStatus_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = GetLocationReply_LocStatus_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = GetLocationReply_LocStatus(val)
	return nil
}

func (e GetLocationReply_LocStatus) MarshalYAML() (interface{}, error) {
	return proto.EnumName(GetLocationReply_LocStatus_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *GetLocationReply_LocStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := GetLocationReply_LocStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = GetLocationReply_LocStatus_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = GetLocationReply_LocStatus(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = GetLocationReply_LocStatus(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

var AIStatusStrings = []string{
	"AI_UNDEFINED",
	"AI_SUCCESS",
	"AI_FAIL",
}

const (
	AIStatusAI_UNDEFINED uint64 = 1 << 0
	AIStatusAI_SUCCESS   uint64 = 1 << 1
	AIStatusAI_FAIL      uint64 = 1 << 2
)

var AppInstListReply_AIStatus_CamelName = map[int32]string{
	// AI_UNDEFINED -> AiUndefined
	0: "AiUndefined",
	// AI_SUCCESS -> AiSuccess
	1: "AiSuccess",
	// AI_FAIL -> AiFail
	2: "AiFail",
}
var AppInstListReply_AIStatus_CamelValue = map[string]int32{
	"AiUndefined": 0,
	"AiSuccess":   1,
	"AiFail":      2,
}

func (e *AppInstListReply_AIStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := AppInstListReply_AIStatus_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = AppInstListReply_AIStatus_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = AppInstListReply_AIStatus(val)
	return nil
}

func (e AppInstListReply_AIStatus) MarshalYAML() (interface{}, error) {
	return proto.EnumName(AppInstListReply_AIStatus_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *AppInstListReply_AIStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := AppInstListReply_AIStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = AppInstListReply_AIStatus_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = AppInstListReply_AIStatus(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = AppInstListReply_AIStatus(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

var FLStatusStrings = []string{
	"FL_UNDEFINED",
	"FL_SUCCESS",
	"FL_FAIL",
}

const (
	FLStatusFL_UNDEFINED uint64 = 1 << 0
	FLStatusFL_SUCCESS   uint64 = 1 << 1
	FLStatusFL_FAIL      uint64 = 1 << 2
)

var FqdnListReply_FLStatus_CamelName = map[int32]string{
	// FL_UNDEFINED -> FlUndefined
	0: "FlUndefined",
	// FL_SUCCESS -> FlSuccess
	1: "FlSuccess",
	// FL_FAIL -> FlFail
	2: "FlFail",
}
var FqdnListReply_FLStatus_CamelValue = map[string]int32{
	"FlUndefined": 0,
	"FlSuccess":   1,
	"FlFail":      2,
}

func (e *FqdnListReply_FLStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := FqdnListReply_FLStatus_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = FqdnListReply_FLStatus_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = FqdnListReply_FLStatus(val)
	return nil
}

func (e FqdnListReply_FLStatus) MarshalYAML() (interface{}, error) {
	return proto.EnumName(FqdnListReply_FLStatus_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *FqdnListReply_FLStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := FqdnListReply_FLStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = FqdnListReply_FLStatus_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = FqdnListReply_FLStatus(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = FqdnListReply_FLStatus(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

var DlgCommTypeStrings = []string{
	"DLG_UNDEFINED",
	"DLG_SECURE",
	"DLG_OPEN",
}

const (
	DlgCommTypeDLG_UNDEFINED uint64 = 1 << 0
	DlgCommTypeDLG_SECURE    uint64 = 1 << 1
	DlgCommTypeDLG_OPEN      uint64 = 1 << 2
)

var DynamicLocGroupRequest_DlgCommType_CamelName = map[int32]string{
	// DLG_UNDEFINED -> DlgUndefined
	0: "DlgUndefined",
	// DLG_SECURE -> DlgSecure
	1: "DlgSecure",
	// DLG_OPEN -> DlgOpen
	2: "DlgOpen",
}
var DynamicLocGroupRequest_DlgCommType_CamelValue = map[string]int32{
	"DlgUndefined": 0,
	"DlgSecure":    1,
	"DlgOpen":      2,
}

func (e *DynamicLocGroupRequest_DlgCommType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := DynamicLocGroupRequest_DlgCommType_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = DynamicLocGroupRequest_DlgCommType_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = DynamicLocGroupRequest_DlgCommType(val)
	return nil
}

func (e DynamicLocGroupRequest_DlgCommType) MarshalYAML() (interface{}, error) {
	return proto.EnumName(DynamicLocGroupRequest_DlgCommType_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *DynamicLocGroupRequest_DlgCommType) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := DynamicLocGroupRequest_DlgCommType_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = DynamicLocGroupRequest_DlgCommType_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = DynamicLocGroupRequest_DlgCommType(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = DynamicLocGroupRequest_DlgCommType(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

type MatchOptions struct {
	// Filter will ignore 0 or nil fields on the passed in object
	Filter bool
	// IgnoreBackend will ignore fields that were marked backend in .proto
	IgnoreBackend bool
	// Sort repeated (arrays) of Key objects so matching does not
	// fail due to order.
	SortArrayedKeys bool
}

type MatchOpt func(*MatchOptions)

func MatchFilter() MatchOpt {
	return func(opts *MatchOptions) {
		opts.Filter = true
	}
}

func MatchIgnoreBackend() MatchOpt {
	return func(opts *MatchOptions) {
		opts.IgnoreBackend = true
	}
}

func MatchSortArrayedKeys() MatchOpt {
	return func(opts *MatchOptions) {
		opts.SortArrayedKeys = true
	}
}

func applyMatchOptions(opts *MatchOptions, args ...MatchOpt) {
	for _, f := range args {
		f(opts)
	}
}

// DecodeHook for use with the mapstructure package.
// Allows decoding to handle protobuf enums that are
// represented as strings.
func EnumDecodeHook(from, to reflect.Type, data interface{}) (interface{}, error) {
	if from.Kind() != reflect.String {
		return data, nil
	}
	switch to {
	case reflect.TypeOf(LProto(0)):
		if en, ok := LProto_CamelValue[util.CamelCase(data.(string))]; ok {
			return en, nil
		}
	case reflect.TypeOf(IDTypes(0)):
		if en, ok := IDTypes_CamelValue[util.CamelCase(data.(string))]; ok {
			return en, nil
		}
	case reflect.TypeOf(ReplyStatus(0)):
		if en, ok := ReplyStatus_CamelValue[util.CamelCase(data.(string))]; ok {
			return en, nil
		}
	}
	return data, nil
}

func (m *Tag) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *RegisterClientRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.DevName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppVers)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AuthToken)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.CellId != 0 {
		n += 1 + sovAppClient(uint64(m.CellId))
	}
	l = len(m.UniqueIdType)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.UniqueId)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 2 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *RegisterClientReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.TokenServerUri)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.UniqueIdType)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.UniqueId)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 2 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *FindCloudletRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.DevName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppVers)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.CellId != 0 {
		n += 1 + sovAppClient(uint64(m.CellId))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 2 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *FindCloudletReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	l = len(m.Fqdn)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if m.CloudletLocation != nil {
		l = m.CloudletLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 2 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *VerifyLocationRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.VerifyLocToken)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.CellId != 0 {
		n += 1 + sovAppClient(uint64(m.CellId))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 2 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *VerifyLocationReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.TowerStatus != 0 {
		n += 1 + sovAppClient(uint64(m.TowerStatus))
	}
	if m.GpsLocationStatus != 0 {
		n += 1 + sovAppClient(uint64(m.GpsLocationStatus))
	}
	if m.GpsLocationAccuracyKm != 0 {
		n += 9
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 2 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *GetLocationRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.CellId != 0 {
		n += 1 + sovAppClient(uint64(m.CellId))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 2 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *GetLocationReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Tower != 0 {
		n += 1 + sovAppClient(uint64(m.Tower))
	}
	if m.NetworkLocation != nil {
		l = m.NetworkLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 2 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *AppInstListRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.CellId != 0 {
		n += 1 + sovAppClient(uint64(m.CellId))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 2 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *Appinstance) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppVers)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.Fqdn)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *CloudletLocation) Size() (n int) {
	var l int
	_ = l
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CloudletName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Distance != 0 {
		n += 9
	}
	if len(m.Appinstances) > 0 {
		for _, e := range m.Appinstances {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *AppInstListReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	if len(m.Cloudlets) > 0 {
		for _, e := range m.Cloudlets {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 2 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *FqdnListRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.CellId != 0 {
		n += 1 + sovAppClient(uint64(m.CellId))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 2 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *AppFqdn) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppVers)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.DevName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Fqdns) > 0 {
		for _, s := range m.Fqdns {
			l = len(s)
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	l = len(m.AndroidPackageName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *FqdnListReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if len(m.AppFqdns) > 0 {
		for _, e := range m.AppFqdns {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 2 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *DynamicLocGroupRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.LgId != 0 {
		n += 1 + sovAppClient(uint64(m.LgId))
	}
	if m.CommType != 0 {
		n += 1 + sovAppClient(uint64(m.CommType))
	}
	l = len(m.UserData)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.CellId != 0 {
		n += 1 + sovAppClient(uint64(m.CellId))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 2 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *DynamicLocGroupReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAppClient(uint64(m.ErrorCode))
	}
	l = len(m.GroupCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 2 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *QosPosition) Size() (n int) {
	var l int
	_ = l
	if m.Positionid != 0 {
		n += 1 + sovAppClient(uint64(m.Positionid))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *BandSelection) Size() (n int) {
	var l int
	_ = l
	if len(m.Rat_2G) > 0 {
		for _, s := range m.Rat_2G {
			l = len(s)
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if len(m.Rat_3G) > 0 {
		for _, s := range m.Rat_3G {
			l = len(s)
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if len(m.Rat_4G) > 0 {
		for _, s := range m.Rat_4G {
			l = len(s)
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if len(m.Rat_5G) > 0 {
		for _, s := range m.Rat_5G {
			l = len(s)
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *QosPositionRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Positions) > 0 {
		for _, e := range m.Positions {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if m.LteCategory != 0 {
		n += 1 + sovAppClient(uint64(m.LteCategory))
	}
	if m.BandSelection != nil {
		l = m.BandSelection.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.CellId != 0 {
		n += 1 + sovAppClient(uint64(m.CellId))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 2 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func (m *QosPositionKpiResult) Size() (n int) {
	var l int
	_ = l
	if m.Positionid != 0 {
		n += 1 + sovAppClient(uint64(m.Positionid))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.DluserthroughputMin != 0 {
		n += 5
	}
	if m.DluserthroughputAvg != 0 {
		n += 5
	}
	if m.DluserthroughputMax != 0 {
		n += 5
	}
	if m.UluserthroughputMin != 0 {
		n += 5
	}
	if m.UluserthroughputAvg != 0 {
		n += 5
	}
	if m.UluserthroughputMax != 0 {
		n += 5
	}
	if m.LatencyMin != 0 {
		n += 5
	}
	if m.LatencyAvg != 0 {
		n += 5
	}
	if m.LatencyMax != 0 {
		n += 5
	}
	return n
}

func (m *QosPositionKpiReply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	if len(m.PositionResults) > 0 {
		for _, e := range m.PositionResults {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 2 + l + sovAppClient(uint64(l))
		}
	}
	return n
}

func sovAppClient(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAppClient(x uint64) (n int) {
	return sovAppClient(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Tag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterClientRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterClientRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterClientRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellId", wireType)
			}
			m.CellId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueIdType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueIdType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterClientReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterClientReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterClientReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (ReplyStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenServerUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenServerUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueIdType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueIdType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindCloudletRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindCloudletRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindCloudletRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellId", wireType)
			}
			m.CellId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindCloudletReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindCloudletReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindCloudletReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (FindCloudletReply_FindStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fqdn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fqdn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &AppPort{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloudletLocation == nil {
				m.CloudletLocation = &Loc{}
			}
			if err := m.CloudletLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyLocationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyLocationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyLocationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyLocToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifyLocToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellId", wireType)
			}
			m.CellId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyLocationReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyLocationReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyLocationReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TowerStatus", wireType)
			}
			m.TowerStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TowerStatus |= (VerifyLocationReply_TowerStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocationStatus", wireType)
			}
			m.GpsLocationStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpsLocationStatus |= (VerifyLocationReply_GPSLocationStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocationAccuracyKm", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GpsLocationAccuracyKm = float64(math.Float64frombits(v))
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLocationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLocationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLocationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellId", wireType)
			}
			m.CellId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLocationReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLocationReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLocationReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (GetLocationReply_LocStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tower", wireType)
			}
			m.Tower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tower |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkLocation == nil {
				m.NetworkLocation = &Loc{}
			}
			if err := m.NetworkLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellId", wireType)
			}
			m.CellId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Appinstance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Appinstance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Appinstance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fqdn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fqdn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &AppPort{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudletName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Distance = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appinstances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Appinstances = append(m.Appinstances, &Appinstance{})
			if err := m.Appinstances[len(m.Appinstances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstListReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstListReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstListReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (AppInstListReply_AIStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cloudlets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cloudlets = append(m.Cloudlets, &CloudletLocation{})
			if err := m.Cloudlets[len(m.Cloudlets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FqdnListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FqdnListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FqdnListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellId", wireType)
			}
			m.CellId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppFqdn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppFqdn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppFqdn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fqdns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fqdns = append(m.Fqdns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AndroidPackageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AndroidPackageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FqdnListReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FqdnListReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FqdnListReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppFqdns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppFqdns = append(m.AppFqdns, &AppFqdn{})
			if err := m.AppFqdns[len(m.AppFqdns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (FqdnListReply_FLStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicLocGroupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicLocGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicLocGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LgId", wireType)
			}
			m.LgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LgId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommType", wireType)
			}
			m.CommType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommType |= (DynamicLocGroupRequest_DlgCommType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellId", wireType)
			}
			m.CellId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicLocGroupReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicLocGroupReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicLocGroupReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (ReplyStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positionid", wireType)
			}
			m.Positionid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Positionid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BandSelection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BandSelection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BandSelection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rat_2G", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rat_2G = append(m.Rat_2G, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rat_3G", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rat_3G = append(m.Rat_3G, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rat_4G", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rat_4G = append(m.Rat_4G, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rat_5G", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rat_5G = append(m.Rat_5G, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPositionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPositionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPositionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Positions = append(m.Positions, &QosPosition{})
			if err := m.Positions[len(m.Positions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LteCategory", wireType)
			}
			m.LteCategory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LteCategory |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BandSelection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BandSelection == nil {
				m.BandSelection = &BandSelection{}
			}
			if err := m.BandSelection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellId", wireType)
			}
			m.CellId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPositionKpiResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPositionKpiResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPositionKpiResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positionid", wireType)
			}
			m.Positionid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Positionid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DluserthroughputMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DluserthroughputMin = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DluserthroughputAvg", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DluserthroughputAvg = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DluserthroughputMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DluserthroughputMax = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UluserthroughputMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UluserthroughputMin = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UluserthroughputAvg", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UluserthroughputAvg = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UluserthroughputMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UluserthroughputMax = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LatencyMin = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyAvg", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LatencyAvg = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LatencyMax = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPositionKpiReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPositionKpiReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPositionKpiReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (ReplyStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PositionResults = append(m.PositionResults, &QosPositionKpiResult{})
			if err := m.PositionResults[len(m.PositionResults)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAppClient(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAppClient
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAppClient(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAppClient = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAppClient   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("app-client.proto", fileDescriptorAppClient) }

var fileDescriptorAppClient = []byte{
	// 2512 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x5a, 0x4d, 0x6c, 0x24, 0x47,
	0xf5, 0x4f, 0xf7, 0x78, 0x6c, 0xcf, 0x1b, 0x7b, 0xdc, 0xdb, 0xb6, 0x13, 0xc7, 0xff, 0xec, 0xfe,
	0x3b, 0x93, 0x44, 0x59, 0xcc, 0xda, 0xfb, 0x95, 0x10, 0x25, 0x24, 0x81, 0xce, 0xcc, 0xd8, 0xdb,
	0xac, 0x3d, 0x63, 0x7a, 0xc6, 0x59, 0x16, 0x21, 0xb5, 0x6a, 0xbb, 0x6b, 0xdb, 0x2d, 0xf7, 0x74,
	0xf5, 0x56, 0xd7, 0xd8, 0xeb, 0x03, 0x17, 0xc2, 0x85, 0x03, 0x12, 0x2c, 0x08, 0x89, 0x2b, 0x17,
	0x84, 0x10, 0x57, 0xb8, 0x70, 0xe0, 0x18, 0x89, 0x4b, 0x10, 0x12, 0x12, 0x12, 0x07, 0x12, 0x40,
	0x48, 0x48, 0xdc, 0x38, 0x23, 0x54, 0xd5, 0xdd, 0xe3, 0x9e, 0x99, 0x9e, 0xc1, 0x1f, 0x59, 0xa4,
	0x9c, 0xdc, 0xf5, 0xea, 0x7d, 0xd7, 0xef, 0xbd, 0xfa, 0x18, 0x83, 0x82, 0xc2, 0x70, 0xdd, 0xf6,
	0x3d, 0x1c, 0xb0, 0x8d, 0x90, 0x12, 0x46, 0xd4, 0x15, 0xc7, 0x8b, 0x18, 0xf5, 0x1e, 0xf4, 0x18,
	0x76, 0xac, 0x2e, 0x62, 0xf6, 0xbe, 0x85, 0x03, 0xd7, 0x0b, 0xf0, 0xea, 0x0b, 0x2e, 0x21, 0xae,
	0x8f, 0xaf, 0xa3, 0xd0, 0xbb, 0x8e, 0x82, 0x80, 0x30, 0xc4, 0x3c, 0x12, 0x44, 0xb1, 0xdc, 0x6a,
	0xc9, 0x27, 0x76, 0xf2, 0xb9, 0x80, 0xc2, 0xd0, 0x26, 0xdd, 0x2e, 0x09, 0x12, 0xc2, 0x35, 0xf1,
	0xc7, 0x5e, 0x77, 0x71, 0xb0, 0x1e, 0x1d, 0x21, 0xd7, 0xc5, 0xf4, 0x3a, 0x09, 0x85, 0xf4, 0xa8,
	0xa6, 0xea, 0x3a, 0x14, 0x3a, 0xc8, 0x55, 0x55, 0x98, 0x62, 0xc7, 0x21, 0x5e, 0x91, 0x34, 0xe9,
	0x6a, 0xc9, 0x14, 0xdf, 0x9c, 0xe6, 0x20, 0x86, 0x56, 0xe4, 0x98, 0xc6, 0xbf, 0xab, 0xbf, 0x95,
	0x61, 0xd9, 0xc4, 0xae, 0x17, 0x31, 0x4c, 0x6b, 0x22, 0x12, 0x13, 0x3f, 0xea, 0xe1, 0x88, 0xa9,
	0x0a, 0x14, 0x0e, 0x31, 0x15, 0x0a, 0xe6, 0x4d, 0xfe, 0xa9, 0x3e, 0x0f, 0xb3, 0x0e, 0x3e, 0xb4,
	0x02, 0xd4, 0xc5, 0x89, 0x8e, 0x19, 0x07, 0x1f, 0x36, 0x51, 0x17, 0xf3, 0x29, 0x14, 0x86, 0xf1,
	0x54, 0x21, 0x9e, 0x42, 0x61, 0x98, 0x9d, 0x3a, 0xc4, 0x34, 0x5a, 0x99, 0xea, 0x4f, 0xbd, 0x8f,
	0x69, 0xa4, 0xbe, 0x08, 0x73, 0x36, 0xa2, 0xd4, 0xc3, 0x34, 0x96, 0x2c, 0x8a, 0xe9, 0x72, 0x42,
	0x13, 0xd2, 0x97, 0x01, 0x50, 0x8f, 0xed, 0x5b, 0x8c, 0x1c, 0xe0, 0x60, 0x65, 0x5a, 0x30, 0x94,
	0x38, 0xa5, 0xc3, 0x09, 0xea, 0x73, 0x30, 0x63, 0x63, 0xdf, 0xb7, 0x3c, 0x67, 0x65, 0x46, 0x38,
	0x3a, 0xcd, 0x87, 0x86, 0xa3, 0xbe, 0x0c, 0x95, 0x5e, 0xe0, 0x3d, 0xea, 0x61, 0xcb, 0x73, 0x2c,
	0x91, 0x89, 0x59, 0x21, 0x3b, 0x17, 0x53, 0x0d, 0xa7, 0xc3, 0x33, 0xf2, 0x7f, 0x50, 0xea, 0x73,
	0xad, 0x94, 0x04, 0xc3, 0x6c, 0xca, 0xa0, 0xde, 0x84, 0x29, 0x86, 0xdc, 0x68, 0xc5, 0xd6, 0x0a,
	0x57, 0xcb, 0xb7, 0x2e, 0x6f, 0x8c, 0x5b, 0xda, 0x8d, 0x0e, 0x72, 0x4d, 0xc1, 0x5a, 0xfd, 0x85,
	0x0c, 0x8b, 0xc3, 0xd9, 0x0c, 0xfd, 0xe3, 0x9c, 0x5c, 0xbe, 0x03, 0xd3, 0x11, 0x43, 0xac, 0x17,
	0x89, 0x4c, 0x56, 0x6e, 0xbd, 0x32, 0x5e, 0xbd, 0x50, 0xd1, 0x16, 0xcc, 0x66, 0x22, 0xa4, 0xbe,
	0x02, 0x95, 0x08, 0x47, 0x91, 0x47, 0x02, 0xcb, 0x26, 0xe4, 0xc0, 0x4b, 0xb3, 0x3e, 0x9f, 0x50,
	0x6b, 0x82, 0xa8, 0x5e, 0x05, 0x45, 0x24, 0xce, 0x8a, 0x30, 0x3d, 0xc4, 0xd4, 0xea, 0x51, 0x2f,
	0x59, 0x83, 0x8a, 0xa0, 0xb7, 0x05, 0x79, 0x8f, 0x7a, 0x39, 0xf9, 0x2a, 0xfe, 0xb7, 0x7c, 0x4d,
	0x5f, 0x3c, 0x5f, 0x1f, 0xc9, 0xb0, 0xb8, 0xe9, 0x05, 0x4e, 0xcd, 0x27, 0x3d, 0xc7, 0xc7, 0x13,
	0xb0, 0x37, 0x1a, 0xb0, 0x9c, 0x17, 0xf0, 0x30, 0xa2, 0x0a, 0xa3, 0x88, 0xfa, 0x32, 0xcc, 0xb9,
	0x61, 0x64, 0xf9, 0xc4, 0x16, 0x75, 0x23, 0xf2, 0x31, 0xd1, 0xdd, 0x6d, 0x62, 0x9b, 0x65, 0x37,
	0x8c, 0xb6, 0x13, 0x89, 0x81, 0x3a, 0x28, 0x8e, 0xaf, 0x83, 0xe9, 0xf1, 0x75, 0x30, 0x33, 0x58,
	0x07, 0x19, 0x14, 0xcf, 0x0e, 0xa0, 0xf8, 0x1c, 0x29, 0xfd, 0x76, 0x01, 0x2e, 0x0d, 0xa6, 0x34,
	0x1f, 0x80, 0xcd, 0x21, 0x00, 0x7e, 0x61, 0xbc, 0xf2, 0x11, 0x75, 0x82, 0x32, 0x84, 0x48, 0x15,
	0xa6, 0x1e, 0x3e, 0x72, 0x82, 0x24, 0xe3, 0xe2, 0x5b, 0x7d, 0x03, 0x8a, 0x21, 0xa1, 0x8c, 0xd7,
	0x3d, 0xf7, 0xff, 0xc5, 0xf1, 0x26, 0xf4, 0x30, 0xdc, 0x25, 0x94, 0x99, 0x31, 0xbf, 0xfa, 0x15,
	0xb8, 0x64, 0x27, 0x06, 0x4f, 0x16, 0xaa, 0x78, 0x9a, 0x85, 0x52, 0x52, 0xb9, 0xfe, 0x6a, 0x9d,
	0x23, 0x87, 0x3a, 0xc0, 0x49, 0x84, 0xaa, 0x02, 0x73, 0x9b, 0x46, 0xb3, 0x6e, 0xed, 0x35, 0xef,
	0x36, 0x5b, 0xf7, 0x9a, 0xca, 0x33, 0x6a, 0x05, 0x40, 0x50, 0x36, 0x5b, 0x7b, 0xcd, 0xba, 0x22,
	0xa9, 0x97, 0x60, 0x5e, 0x8c, 0x9b, 0xad, 0x4e, 0x4c, 0x92, 0xab, 0x3f, 0x97, 0x61, 0xf9, 0x7d,
	0x4c, 0xbd, 0x87, 0xc7, 0xa9, 0x23, 0x9f, 0x0d, 0x6c, 0x5f, 0x05, 0xe5, 0x50, 0xb8, 0xcd, 0x95,
	0x24, 0x5d, 0x37, 0xc6, 0x78, 0xe5, 0x30, 0x0d, 0x67, 0xa4, 0xf5, 0x4e, 0x5f, 0x14, 0xb4, 0xbf,
	0x2c, 0xc2, 0xe2, 0x70, 0xb6, 0xf2, 0x61, 0xfb, 0x0d, 0x98, 0x63, 0xe4, 0x08, 0x53, 0x6b, 0x00,
	0xbc, 0x6f, 0x8e, 0x37, 0x92, 0xa3, 0x76, 0xa3, 0xc3, 0x35, 0x24, 0xf8, 0x2d, 0xb3, 0x93, 0x81,
	0x4a, 0x60, 0x31, 0x9b, 0xbf, 0xd4, 0x48, 0x41, 0x18, 0xf9, 0xd2, 0xd9, 0x8c, 0x6c, 0xed, 0xb6,
	0x53, 0x42, 0x62, 0xea, 0x52, 0x26, 0xd1, 0x89, 0xc1, 0x37, 0x60, 0x65, 0xc0, 0x20, 0xb2, 0xed,
	0x1e, 0x45, 0xf6, 0xb1, 0x75, 0xd0, 0x15, 0x8b, 0x27, 0x99, 0xcb, 0x19, 0x21, 0x3d, 0x99, 0xbd,
	0xdb, 0x3d, 0x4f, 0x92, 0xf7, 0xa1, 0x9c, 0x09, 0x9c, 0x83, 0xb6, 0xd3, 0xba, 0xd7, 0x30, 0x33,
	0xb8, 0xd6, 0xe0, 0x85, 0x5a, 0xab, 0xd9, 0x6c, 0xd4, 0x3a, 0x8d, 0xba, 0xd5, 0x69, 0x59, 0xed,
	0xdd, 0x46, 0xcd, 0xd8, 0x34, 0xc4, 0xe0, 0x5e, 0xc3, 0x54, 0x24, 0xf5, 0x65, 0xd0, 0x9a, 0xad,
	0x8e, 0x35, 0x91, 0x4b, 0xae, 0xfe, 0x5d, 0x82, 0x4b, 0x23, 0xe1, 0xab, 0x0b, 0x50, 0xde, 0x6e,
	0xd5, 0x32, 0xe6, 0x14, 0x98, 0xe3, 0x84, 0xf7, 0x1b, 0xa6, 0x10, 0x57, 0x24, 0xf5, 0x32, 0x3c,
	0xcf, 0x29, 0x3b, 0x46, 0x7b, 0x47, 0xef, 0xd4, 0xee, 0x58, 0x6d, 0x7d, 0xa7, 0x61, 0xd5, 0x5a,
	0x7b, 0xcd, 0x8e, 0x79, 0x5f, 0x91, 0xd5, 0x2b, 0xb0, 0x3a, 0x30, 0xdd, 0xea, 0xdc, 0x69, 0x98,
	0xfd, 0xf9, 0x42, 0x2a, 0x6e, 0xb6, 0xf4, 0x1d, 0xa3, 0xb9, 0x95, 0x4e, 0x58, 0x82, 0x59, 0x99,
	0xe2, 0xe1, 0xe5, 0x4e, 0x27, 0xea, 0x94, 0xa2, 0xba, 0x0a, 0xcf, 0x72, 0x8e, 0x86, 0x69, 0xb6,
	0x78, 0x5e, 0xf4, 0xbd, 0xce, 0x9d, 0x96, 0x69, 0x7c, 0xbd, 0x51, 0x57, 0xa6, 0xd5, 0x45, 0x58,
	0x38, 0x99, 0x13, 0x96, 0x95, 0x99, 0xea, 0xaf, 0x25, 0x50, 0xb7, 0x4e, 0x9a, 0xcd, 0xff, 0xa2,
	0xc6, 0x33, 0x75, 0x37, 0x75, 0xd1, 0xba, 0xfb, 0x9b, 0x0c, 0xca, 0x80, 0xfb, 0xf9, 0x45, 0xb7,
	0x3d, 0xb4, 0x57, 0xbc, 0x36, 0x5e, 0xf7, 0xb0, 0x36, 0xde, 0x61, 0x86, 0x76, 0x8a, 0x53, 0xc4,
	0xb8, 0x04, 0x45, 0x51, 0x96, 0x22, 0xc2, 0x29, 0x33, 0x1e, 0xa8, 0x77, 0x40, 0x09, 0x30, 0x3b,
	0x22, 0xf4, 0xe0, 0x8c, 0x9b, 0xc2, 0x42, 0x22, 0x76, 0x91, 0x3d, 0xe1, 0x8b, 0x50, 0xea, 0x87,
	0x32, 0x0a, 0xe5, 0x79, 0x28, 0x71, 0x42, 0xba, 0x21, 0x54, 0x00, 0xf8, 0xb0, 0xde, 0x68, 0x72,
	0x5c, 0xcb, 0xd5, 0x7f, 0x4b, 0xa0, 0xea, 0x61, 0x68, 0x04, 0x11, 0xdb, 0xf6, 0xa2, 0xcf, 0xc8,
	0x31, 0x27, 0x03, 0xb4, 0xe2, 0x45, 0x81, 0xf6, 0x3d, 0x09, 0xca, 0x7a, 0x18, 0x7a, 0x41, 0xc4,
	0x50, 0x60, 0x0f, 0x9e, 0x93, 0xa4, 0xf1, 0xe7, 0x24, 0x79, 0xf0, 0x9c, 0xf4, 0x69, 0x9e, 0x31,
	0xaa, 0x1f, 0xc8, 0xa0, 0xd4, 0x86, 0x0f, 0x0b, 0xc3, 0x89, 0x95, 0x46, 0x13, 0xfb, 0x12, 0xcc,
	0xf7, 0xcf, 0x26, 0x99, 0xab, 0xd0, 0x5c, 0x4a, 0xcc, 0xcd, 0x7e, 0xe1, 0xcc, 0xd9, 0x5f, 0x85,
	0x59, 0xce, 0xcc, 0xb3, 0x95, 0xec, 0x04, 0xfd, 0xb1, 0x6a, 0xc0, 0x1c, 0x3a, 0x49, 0x66, 0xb4,
	0x52, 0x14, 0xa1, 0xbf, 0x32, 0x31, 0xf4, 0x94, 0xdb, 0x1c, 0x10, 0xad, 0xfe, 0x4c, 0x06, 0x65,
	0x00, 0x99, 0xf9, 0x1d, 0xe0, 0xee, 0x50, 0x07, 0xb8, 0x3d, 0xd1, 0xd6, 0x80, 0xb6, 0x0d, 0xdd,
	0x18, 0x6a, 0x00, 0x77, 0xa0, 0x94, 0x26, 0x8b, 0xef, 0xad, 0xdc, 0xf7, 0xb5, 0xf1, 0xfa, 0x86,
	0xd7, 0xc8, 0x3c, 0x11, 0x3e, 0x0f, 0x12, 0xdf, 0x84, 0xd9, 0xd4, 0x21, 0xbe, 0x01, 0xe9, 0x86,
	0xb5, 0xd7, 0xac, 0x37, 0x36, 0x8d, 0x66, 0xa3, 0x1e, 0x9f, 0xec, 0x74, 0xc3, 0x6a, 0xef, 0xd5,
	0x6a, 0x8d, 0x76, 0x5b, 0x91, 0xd4, 0x32, 0xcc, 0xe8, 0x86, 0xb5, 0xa9, 0x1b, 0xdb, 0x8a, 0x5c,
	0xfd, 0x91, 0x04, 0x0b, 0x9b, 0x8f, 0x9c, 0xe0, 0x53, 0x29, 0xe1, 0x4c, 0x75, 0x15, 0x2e, 0x5a,
	0x5d, 0x3f, 0x91, 0x60, 0x46, 0x0f, 0x43, 0xee, 0xdb, 0x39, 0x2b, 0x2b, 0x7b, 0xa5, 0x29, 0x0c,
	0x5e, 0x69, 0x96, 0xa0, 0xc8, 0x0b, 0x2d, 0x2e, 0xb0, 0x92, 0x19, 0x0f, 0xd4, 0x1b, 0xb0, 0x84,
	0x02, 0x87, 0x12, 0xcf, 0xb1, 0x42, 0x64, 0x1f, 0x20, 0x17, 0x67, 0xef, 0x43, 0x6a, 0x32, 0xb7,
	0x1b, 0x4f, 0x71, 0x3d, 0xd5, 0x1f, 0xcb, 0x30, 0x7f, 0x92, 0xbd, 0x7c, 0x98, 0xbd, 0x0b, 0x25,
	0xee, 0x61, 0x6c, 0xaf, 0x70, 0x8a, 0x82, 0xe6, 0x0a, 0x4d, 0x1e, 0xd5, 0xa6, 0xf0, 0xea, 0x4e,
	0x1f, 0xa6, 0x53, 0x02, 0xa6, 0x37, 0x26, 0x5c, 0x6a, 0xb2, 0xae, 0x6c, 0x6c, 0x6e, 0x0f, 0x61,
	0xf4, 0x7c, 0xc8, 0x4a, 0xd5, 0x88, 0x3b, 0xc3, 0xf6, 0x30, 0xb2, 0x36, 0xb7, 0x07, 0x91, 0xb5,
	0xb9, 0x9d, 0x22, 0xeb, 0x1f, 0x32, 0x3c, 0x5b, 0x3f, 0x0e, 0x50, 0xd7, 0xb3, 0xb7, 0x89, 0xbd,
	0x45, 0x49, 0x2f, 0xbc, 0x30, 0xc0, 0x16, 0xa1, 0xe8, 0xbb, 0x29, 0xbc, 0xa6, 0xcc, 0x29, 0xdf,
	0x35, 0x1c, 0xf5, 0x3e, 0x94, 0x6c, 0xd2, 0xed, 0xc6, 0x37, 0xfc, 0xb2, 0xc8, 0xd1, 0xdb, 0xe3,
	0x63, 0xcb, 0x77, 0x69, 0xa3, 0xee, 0xbb, 0x35, 0xd2, 0xed, 0x76, 0x8e, 0x43, 0x6c, 0xce, 0xda,
	0xc9, 0x97, 0x78, 0x1b, 0x88, 0x30, 0xb5, 0xc4, 0x13, 0xd3, 0x5c, 0xf2, 0x36, 0x10, 0x61, 0x5a,
	0x47, 0x0c, 0x65, 0xd1, 0x3e, 0x7f, 0x51, 0xb4, 0xbf, 0x0b, 0xe5, 0x8c, 0x07, 0xfc, 0x1c, 0x5b,
	0xdf, 0xde, 0x1a, 0xce, 0x35, 0x27, 0xb5, 0x1b, 0xb5, 0x3d, 0xb3, 0xa1, 0x48, 0xea, 0x1c, 0xcc,
	0xf2, 0x71, 0x6b, 0xb7, 0xd1, 0x54, 0xe4, 0xea, 0x9f, 0x24, 0x58, 0x1a, 0x89, 0xec, 0xa9, 0xbc,
	0xd2, 0x5c, 0x06, 0xc0, 0x94, 0x12, 0x6a, 0xd9, 0xc4, 0xc1, 0x49, 0x99, 0x97, 0x04, 0xa5, 0x46,
	0x1c, 0xb1, 0x8b, 0xbb, 0xdc, 0x7a, 0xba, 0x8c, 0xc9, 0xf3, 0x97, 0xa0, 0x25, 0x8b, 0x78, 0x8e,
	0xf4, 0x10, 0x28, 0x7f, 0x95, 0x44, 0xbb, 0x24, 0xf2, 0xc4, 0x3e, 0x72, 0x05, 0x20, 0x4c, 0xbe,
	0x3d, 0x47, 0xc4, 0x56, 0x30, 0x33, 0x94, 0x91, 0x9d, 0x4a, 0x3e, 0xeb, 0x4e, 0x55, 0x3d, 0x80,
	0xf9, 0xf7, 0x50, 0xe0, 0xb4, 0xb1, 0x8f, 0x6d, 0x61, 0x72, 0x19, 0xa6, 0x29, 0x62, 0xd6, 0x2d,
	0x77, 0x45, 0x8a, 0x5b, 0x06, 0x45, 0xec, 0x96, 0x9b, 0x92, 0x6f, 0xbb, 0x2b, 0x72, 0x9f, 0x7c,
	0xbb, 0x4f, 0x7e, 0xcd, 0x15, 0x05, 0x1f, 0x93, 0x5f, 0xeb, 0x93, 0x5f, 0x77, 0xd3, 0xbe, 0x43,
	0x11, 0x7b, 0xdd, 0xad, 0xfe, 0x4e, 0x06, 0x35, 0x13, 0xde, 0x85, 0xab, 0xa4, 0x06, 0xa5, 0x34,
	0x19, 0x69, 0xc7, 0x99, 0xb0, 0xc8, 0x59, 0xcb, 0x27, 0x72, 0x7c, 0x21, 0x7d, 0x86, 0x2d, 0x1b,
	0x31, 0xec, 0x12, 0x7a, 0x2c, 0x9a, 0x4f, 0xd1, 0x2c, 0xfb, 0x0c, 0xd7, 0x12, 0x92, 0xda, 0x84,
	0xca, 0x03, 0x14, 0x38, 0x56, 0x94, 0x66, 0x29, 0x39, 0xb9, 0xbe, 0x3a, 0xde, 0xd8, 0x40, 0x52,
	0xcd, 0xf9, 0x07, 0x03, 0x39, 0xfe, 0x34, 0x6f, 0xdf, 0xdf, 0x9d, 0x82, 0xa5, 0x4c, 0x64, 0x77,
	0x43, 0xcf, 0xc4, 0x51, 0xcf, 0x67, 0x4f, 0x1f, 0x3b, 0xea, 0x4d, 0x58, 0x72, 0x7c, 0xde, 0x25,
	0xd8, 0x3e, 0x25, 0x3d, 0x77, 0x3f, 0xec, 0x31, 0xab, 0xeb, 0xc5, 0xe7, 0x25, 0xd9, 0x5c, 0x1c,
	0x9e, 0xdb, 0xf1, 0xf2, 0x45, 0xd0, 0xa1, 0x2b, 0x92, 0x9e, 0x23, 0xa2, 0x1f, 0xba, 0xf9, 0x56,
	0xd0, 0x63, 0xb1, 0x04, 0x79, 0x56, 0xd0, 0x63, 0x2e, 0xd2, 0xcb, 0x73, 0x6c, 0x3a, 0x16, 0xe9,
	0xe5, 0x3b, 0xd6, 0xcb, 0x73, 0x6c, 0x26, 0x5f, 0x24, 0x71, 0xac, 0x97, 0xe7, 0xd8, 0xec, 0x18,
	0x2b, 0xe8, 0xb1, 0xfa, 0xff, 0x50, 0xf6, 0x11, 0xc3, 0x81, 0x7d, 0x2c, 0xfc, 0x29, 0x09, 0x4e,
	0x48, 0x48, 0xdc, 0x8d, 0x0c, 0x03, 0xb7, 0x0e, 0x03, 0x0c, 0xdc, 0x68, 0x56, 0x03, 0x7a, 0x2c,
	0x76, 0x81, 0x8c, 0x06, 0xf4, 0xb8, 0xfa, 0x2f, 0x09, 0x16, 0x87, 0xf1, 0xf0, 0x54, 0xfa, 0xe3,
	0x7d, 0x50, 0x52, 0x34, 0x59, 0x54, 0x40, 0x2e, 0xad, 0xc1, 0x8d, 0x53, 0xd5, 0x60, 0x1f, 0xa9,
	0xe6, 0x42, 0xd8, 0x6f, 0x08, 0x42, 0xcd, 0x39, 0xca, 0x60, 0xed, 0x1d, 0x98, 0x31, 0xea, 0x7c,
	0x4b, 0x11, 0xdb, 0xb7, 0x51, 0x1f, 0xd8, 0x52, 0x66, 0x61, 0xca, 0xd8, 0x69, 0x18, 0x8a, 0xa4,
	0x02, 0x4c, 0xef, 0xb4, 0x8d, 0x76, 0xbd, 0xa9, 0xc8, 0xfc, 0xdb, 0xd8, 0xd5, 0xeb, 0x75, 0x53,
	0x29, 0xac, 0xbd, 0x0d, 0xe5, 0x4c, 0x8c, 0x5c, 0x85, 0xd9, 0x1e, 0xde, 0x95, 0xcc, 0xf6, 0xe0,
	0x09, 0xc0, 0x6c, 0x27, 0x27, 0x80, 0x5b, 0xbf, 0x01, 0xa8, 0xec, 0x70, 0xbf, 0x1a, 0xc2, 0x2d,
	0x3d, 0xf4, 0xd4, 0x9f, 0x4a, 0x50, 0x19, 0xfc, 0x31, 0x41, 0xbd, 0x3e, 0x29, 0xbf, 0x39, 0x3f,
	0xe2, 0xac, 0xae, 0x9f, 0x5e, 0x20, 0xf4, 0x8f, 0xab, 0xaf, 0x3f, 0xd1, 0x97, 0x57, 0xfb, 0xbf,
	0x60, 0x68, 0x6c, 0x1f, 0x6b, 0x0e, 0x3e, 0xf4, 0x6c, 0xfc, 0xad, 0xdf, 0xff, 0xf5, 0x07, 0xf2,
	0x73, 0x55, 0xf5, 0xfa, 0xe1, 0xcd, 0xeb, 0x34, 0x99, 0x8e, 0x7f, 0xf8, 0x7a, 0x4b, 0x5a, 0x53,
	0xff, 0x22, 0xc1, 0x5c, 0xf6, 0x91, 0x58, 0x5d, 0x3f, 0xed, 0x63, 0x72, 0xec, 0xe5, 0xe7, 0xcf,
	0xf0, 0xf6, 0x5c, 0x3d, 0x7a, 0xa2, 0xdf, 0x5f, 0xbd, 0x57, 0xc7, 0x0c, 0xd3, 0xae, 0x17, 0xe0,
	0xe8, 0x9a, 0x76, 0xe4, 0xb1, 0x7d, 0x8d, 0xf4, 0xa8, 0x66, 0xf7, 0x28, 0xc5, 0x01, 0xd3, 0xb6,
	0x76, 0xdb, 0x9a, 0x4d, 0xd6, 0x09, 0x75, 0xbc, 0x00, 0x31, 0xce, 0xc2, 0x23, 0xb1, 0x7d, 0x12,
	0xe1, 0x88, 0x69, 0xe9, 0xf5, 0x41, 0xa3, 0xbd, 0x20, 0xf0, 0x02, 0x57, 0x88, 0x3e, 0x40, 0xf6,
	0x01, 0x0e, 0x1c, 0x11, 0xe7, 0x72, 0x55, 0xe1, 0x71, 0x3e, 0xf4, 0x02, 0x27, 0xe5, 0xe5, 0x51,
	0x7e, 0x2c, 0x41, 0x65, 0xf0, 0xa1, 0x6f, 0xd2, 0x7a, 0xe4, 0x3e, 0xfe, 0x4e, 0x5a, 0x8f, 0x9c,
	0x37, 0xc4, 0x2a, 0x79, 0xa2, 0xb7, 0x56, 0x77, 0xc4, 0x8c, 0x87, 0x23, 0x8d, 0xed, 0x23, 0x26,
	0x42, 0x89, 0x03, 0xec, 0xc7, 0xa7, 0xc5, 0xcf, 0x86, 0x0c, 0xfb, 0xc7, 0x1a, 0xc5, 0xfc, 0x7a,
	0xab, 0x21, 0x9b, 0xf5, 0x90, 0xaf, 0xa5, 0xad, 0x59, 0x23, 0x0f, 0x73, 0x56, 0x32, 0x7e, 0xd1,
	0x4d, 0x79, 0x78, 0x8c, 0x1f, 0x48, 0x50, 0xce, 0x3c, 0xe1, 0xa8, 0xd7, 0x4e, 0xf9, 0xd2, 0x13,
	0x47, 0xb7, 0x76, 0xfa, 0x77, 0xa1, 0xea, 0xaa, 0x70, 0x64, 0xa9, 0xba, 0xc0, 0x1d, 0x71, 0x31,
	0xcb, 0x7a, 0xf1, 0x7d, 0x09, 0x2a, 0xba, 0xe3, 0xec, 0x45, 0x98, 0x76, 0x88, 0x38, 0xa0, 0xa9,
	0x37, 0xce, 0x7a, 0x4a, 0x5d, 0xdd, 0x38, 0x83, 0x04, 0x77, 0xe8, 0x72, 0x36, 0x33, 0xc8, 0x71,
	0x44, 0xeb, 0x25, 0xe2, 0x30, 0xc6, 0x7d, 0xfa, 0x8e, 0x04, 0x95, 0x2d, 0xcc, 0x32, 0xb7, 0xdb,
	0x49, 0xc9, 0x19, 0x7d, 0xec, 0x99, 0x94, 0x9c, 0xe1, 0x2b, 0xf3, 0xa0, 0x2f, 0x2e, 0x66, 0xc9,
	0x95, 0xdd, 0xf7, 0x22, 0x81, 0xc4, 0x6f, 0x8a, 0x45, 0x4a, 0x6f, 0x30, 0xea, 0xe7, 0x4e, 0x73,
	0xcb, 0x89, 0x9d, 0x78, 0xf5, 0x94, 0x17, 0xa2, 0x91, 0xe5, 0xe1, 0x57, 0xb2, 0xd4, 0xfc, 0x0f,
	0x25, 0xb8, 0xb4, 0x85, 0xd9, 0x60, 0x23, 0x9e, 0x94, 0x8d, 0xd1, 0x03, 0xdb, 0xa4, 0x42, 0xc8,
	0xd9, 0x7a, 0xaa, 0x9a, 0x70, 0x67, 0xb5, 0xba, 0x9c, 0xb8, 0xf3, 0x88, 0x44, 0x69, 0xc7, 0x3f,
	0x08, 0xbd, 0xb7, 0xa4, 0xb5, 0x1b, 0xd2, 0x7b, 0xff, 0x94, 0x9f, 0xe8, 0x7f, 0x94, 0xd5, 0x3f,
	0xc8, 0xb0, 0xbc, 0x43, 0x1e, 0x78, 0x3e, 0x76, 0x5c, 0xfc, 0x35, 0x2d, 0x6e, 0x6f, 0x9a, 0xbe,
	0x6b, 0xa8, 0xbf, 0x92, 0x5f, 0xd2, 0x8c, 0x80, 0x51, 0xe2, 0xf4, 0xc4, 0x21, 0x0a, 0x3a, 0xfb,
	0x58, 0xcb, 0xb0, 0xea, 0xbb, 0x46, 0xa4, 0x85, 0x94, 0x1c, 0x7a, 0x0e, 0xd6, 0x8e, 0x49, 0x2f,
	0x6e, 0x2c, 0x48, 0x8b, 0x30, 0xe3, 0xf5, 0x43, 0x42, 0x4c, 0xe3, 0x9f, 0xda, 0x35, 0x14, 0x38,
	0x1a, 0xc5, 0x11, 0xe9, 0x51, 0x9b, 0x97, 0x25, 0x79, 0x0b, 0x34, 0x4d, 0x5b, 0xd3, 0x0c, 0x07,
	0x07, 0xcc, 0x7b, 0x78, 0xcc, 0x85, 0xa9, 0x86, 0xc2, 0xd0, 0xf7, 0x62, 0x50, 0xbf, 0x1a, 0xa5,
	0x0d, 0x46, 0x8b, 0xc8, 0x43, 0x76, 0x84, 0x28, 0x8e, 0x25, 0x44, 0x4d, 0x60, 0xed, 0x68, 0x1f,
	0x53, 0x9c, 0xed, 0x43, 0x9a, 0x17, 0xa5, 0xed, 0x29, 0x66, 0x8c, 0xbb, 0xc3, 0x59, 0x3a, 0x00,
	0xe7, 0xca, 0xe9, 0x02, 0x27, 0x3d, 0x3d, 0x56, 0xcc, 0x1b, 0x6c, 0x6e, 0x7b, 0xbc, 0x26, 0xa2,
	0xec, 0x12, 0x8a, 0x37, 0x6e, 0x15, 0x6e, 0x6e, 0xdc, 0xf8, 0xf0, 0xe3, 0x2b, 0xcf, 0x7c, 0xf8,
	0xc9, 0x15, 0xe9, 0xa3, 0x4f, 0xae, 0x48, 0x7f, 0xfe, 0xe4, 0x8a, 0xf4, 0x60, 0x5a, 0xfc, 0xc3,
	0xc1, 0xed, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x35, 0xad, 0x3a, 0x50, 0x06, 0x21, 0x00, 0x00,
}
