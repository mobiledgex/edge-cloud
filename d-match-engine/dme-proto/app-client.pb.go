// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app-client.proto

/*
	Package distributed_match_engine is a generated protocol buffer package.

	It is generated from these files:
		app-client.proto
		dynamic-location-group.proto
		loc.proto

	It has these top-level messages:
		Match_Engine_Request
		Match_Engine_Reply
		Match_Engine_Loc_Verify
		Match_Engine_Loc
		Match_Engine_Status
		DynamicLocGroupAdd
		DlgMessage
		DlgReply
		Loc
*/
package distributed_match_engine

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import google_protobuf "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// User ID type - IMEI, MSISDN etc
type Match_Engine_Request_IDType int32

const (
	Match_Engine_Request_IMEI   Match_Engine_Request_IDType = 0
	Match_Engine_Request_MSISDN Match_Engine_Request_IDType = 1
	Match_Engine_Request_IPADDR Match_Engine_Request_IDType = 2
)

var Match_Engine_Request_IDType_name = map[int32]string{
	0: "IMEI",
	1: "MSISDN",
	2: "IPADDR",
}
var Match_Engine_Request_IDType_value = map[string]int32{
	"IMEI":   0,
	"MSISDN": 1,
	"IPADDR": 2,
}

func (x Match_Engine_Request_IDType) String() string {
	return proto.EnumName(Match_Engine_Request_IDType_name, int32(x))
}
func (Match_Engine_Request_IDType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{0, 0}
}

// Status of the reply
type Match_Engine_Loc_Verify_Tower_Status int32

const (
	Match_Engine_Loc_Verify_UNKNOWN                          Match_Engine_Loc_Verify_Tower_Status = 0
	Match_Engine_Loc_Verify_CONNECTED_TO_SPECIFIED_TOWER     Match_Engine_Loc_Verify_Tower_Status = 1
	Match_Engine_Loc_Verify_NOT_CONNECTED_TO_SPECIFIED_TOWER Match_Engine_Loc_Verify_Tower_Status = 2
)

var Match_Engine_Loc_Verify_Tower_Status_name = map[int32]string{
	0: "UNKNOWN",
	1: "CONNECTED_TO_SPECIFIED_TOWER",
	2: "NOT_CONNECTED_TO_SPECIFIED_TOWER",
}
var Match_Engine_Loc_Verify_Tower_Status_value = map[string]int32{
	"UNKNOWN":                          0,
	"CONNECTED_TO_SPECIFIED_TOWER":     1,
	"NOT_CONNECTED_TO_SPECIFIED_TOWER": 2,
}

func (x Match_Engine_Loc_Verify_Tower_Status) String() string {
	return proto.EnumName(Match_Engine_Loc_Verify_Tower_Status_name, int32(x))
}
func (Match_Engine_Loc_Verify_Tower_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{2, 0}
}

type Match_Engine_Loc_Verify_GPS_Location_Status int32

const (
	Match_Engine_Loc_Verify_LOC_UNKNOWN       Match_Engine_Loc_Verify_GPS_Location_Status = 0
	Match_Engine_Loc_Verify_LOC_WITHIN_2KM    Match_Engine_Loc_Verify_GPS_Location_Status = 1
	Match_Engine_Loc_Verify_LOC_WITHIN_10KM   Match_Engine_Loc_Verify_GPS_Location_Status = 2
	Match_Engine_Loc_Verify_LOC_WITHIN_100KM  Match_Engine_Loc_Verify_GPS_Location_Status = 3
	Match_Engine_Loc_Verify_LOC_MISMATCH      Match_Engine_Loc_Verify_GPS_Location_Status = 4
	Match_Engine_Loc_Verify_LOC_OTHER_COUNTRY Match_Engine_Loc_Verify_GPS_Location_Status = 5
)

var Match_Engine_Loc_Verify_GPS_Location_Status_name = map[int32]string{
	0: "LOC_UNKNOWN",
	1: "LOC_WITHIN_2KM",
	2: "LOC_WITHIN_10KM",
	3: "LOC_WITHIN_100KM",
	4: "LOC_MISMATCH",
	5: "LOC_OTHER_COUNTRY",
}
var Match_Engine_Loc_Verify_GPS_Location_Status_value = map[string]int32{
	"LOC_UNKNOWN":       0,
	"LOC_WITHIN_2KM":    1,
	"LOC_WITHIN_10KM":   2,
	"LOC_WITHIN_100KM":  3,
	"LOC_MISMATCH":      4,
	"LOC_OTHER_COUNTRY": 5,
}

func (x Match_Engine_Loc_Verify_GPS_Location_Status) String() string {
	return proto.EnumName(Match_Engine_Loc_Verify_GPS_Location_Status_name, int32(x))
}
func (Match_Engine_Loc_Verify_GPS_Location_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{2, 1}
}

// Status of the reply
type Match_Engine_Loc_Loc_Status int32

const (
	Match_Engine_Loc_LOC_UNKNOWN Match_Engine_Loc_Loc_Status = 0
	Match_Engine_Loc_LOC_FOUND   Match_Engine_Loc_Loc_Status = 1
	// The user does not allow his location to be tracked
	Match_Engine_Loc_LOC_DENIED Match_Engine_Loc_Loc_Status = 2
)

var Match_Engine_Loc_Loc_Status_name = map[int32]string{
	0: "LOC_UNKNOWN",
	1: "LOC_FOUND",
	2: "LOC_DENIED",
}
var Match_Engine_Loc_Loc_Status_value = map[string]int32{
	"LOC_UNKNOWN": 0,
	"LOC_FOUND":   1,
	"LOC_DENIED":  2,
}

func (x Match_Engine_Loc_Loc_Status) String() string {
	return proto.EnumName(Match_Engine_Loc_Loc_Status_name, int32(x))
}
func (Match_Engine_Loc_Loc_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{3, 0}
}

// Status of the reply
type Match_Engine_Status_ME_Status int32

const (
	Match_Engine_Status_ME_SUCCESS Match_Engine_Status_ME_Status = 0
	Match_Engine_Status_ME_FAIL    Match_Engine_Status_ME_Status = 1
)

var Match_Engine_Status_ME_Status_name = map[int32]string{
	0: "ME_SUCCESS",
	1: "ME_FAIL",
}
var Match_Engine_Status_ME_Status_value = map[string]int32{
	"ME_SUCCESS": 0,
	"ME_FAIL":    1,
}

func (x Match_Engine_Status_ME_Status) String() string {
	return proto.EnumName(Match_Engine_Status_ME_Status_name, int32(x))
}
func (Match_Engine_Status_ME_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{4, 0}
}

// User ID type - IMEI, MSISDN etc
type DynamicLocGroupAdd_IDType int32

const (
	DynamicLocGroupAdd_IMEI   DynamicLocGroupAdd_IDType = 0
	DynamicLocGroupAdd_MSISDN DynamicLocGroupAdd_IDType = 1
	DynamicLocGroupAdd_IPADDR DynamicLocGroupAdd_IDType = 2
)

var DynamicLocGroupAdd_IDType_name = map[int32]string{
	0: "IMEI",
	1: "MSISDN",
	2: "IPADDR",
}
var DynamicLocGroupAdd_IDType_value = map[string]int32{
	"IMEI":   0,
	"MSISDN": 1,
	"IPADDR": 2,
}

func (x DynamicLocGroupAdd_IDType) String() string {
	return proto.EnumName(DynamicLocGroupAdd_IDType_name, int32(x))
}
func (DynamicLocGroupAdd_IDType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{5, 0}
}

// Use Secure communication or Open  with the group
type DynamicLocGroupAdd_DlgCommType int32

const (
	DynamicLocGroupAdd_DlgSecure DynamicLocGroupAdd_DlgCommType = 0
	DynamicLocGroupAdd_DlgOpen   DynamicLocGroupAdd_DlgCommType = 1
)

var DynamicLocGroupAdd_DlgCommType_name = map[int32]string{
	0: "DlgSecure",
	1: "DlgOpen",
}
var DynamicLocGroupAdd_DlgCommType_value = map[string]int32{
	"DlgSecure": 0,
	"DlgOpen":   1,
}

func (x DynamicLocGroupAdd_DlgCommType) String() string {
	return proto.EnumName(DynamicLocGroupAdd_DlgCommType_name, int32(x))
}
func (DynamicLocGroupAdd_DlgCommType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppClient, []int{5, 1}
}

type Match_Engine_Request struct {
	Ver    uint32                      `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	IdType Match_Engine_Request_IDType `protobuf:"varint,2,opt,name=IdType,proto3,enum=distributed_match_engine.Match_Engine_Request_IDType" json:"IdType,omitempty"`
	// Actual ID
	Id string `protobuf:"bytes,3,opt,name=Id,proto3" json:"Id,omitempty"`
	// App/OS generated ID
	Uuid string `protobuf:"bytes,4,opt,name=Uuid,proto3" json:"Uuid,omitempty"`
	// The carrier ID that user is connected to ("Mobile Country Code")
	CarrierID uint64 `protobuf:"varint,5,opt,name=CarrierID,proto3" json:"CarrierID,omitempty"`
	// The carrier name that user is connected to ("Cellular Carrier Name")
	CarrierName string `protobuf:"bytes,6,opt,name=CarrierName,proto3" json:"CarrierName,omitempty"`
	// The tower that user is currently connected to
	Tower uint64 `protobuf:"varint,7,opt,name=Tower,proto3" json:"Tower,omitempty"`
	// The GPS location of the user
	GpsLocation *Loc `protobuf:"bytes,8,opt,name=GpsLocation" json:"GpsLocation,omitempty"`
	// Edge-cloud assigned application ID
	AppId uint64 `protobuf:"varint,9,opt,name=AppId,proto3" json:"AppId,omitempty"`
	// Protocol application uses
	Protocol []byte `protobuf:"bytes,10,opt,name=Protocol,proto3" json:"Protocol,omitempty"`
	// The protocol port on the server side
	ServerPort []byte `protobuf:"bytes,11,opt,name=ServerPort,proto3" json:"ServerPort,omitempty"`
	// App Developer Name
	DevName string `protobuf:"bytes,12,opt,name=DevName,proto3" json:"DevName,omitempty"`
	// App Name
	AppName string `protobuf:"bytes,13,opt,name=AppName,proto3" json:"AppName,omitempty"`
	// App Version
	AppVers string `protobuf:"bytes,14,opt,name=AppVers,proto3" json:"AppVers,omitempty"`
	// Token provided by the Operator for subsequent calls
	Token string `protobuf:"bytes,15,opt,name=Token,proto3" json:"Token,omitempty"`
}

func (m *Match_Engine_Request) Reset()                    { *m = Match_Engine_Request{} }
func (m *Match_Engine_Request) String() string            { return proto.CompactTextString(m) }
func (*Match_Engine_Request) ProtoMessage()               {}
func (*Match_Engine_Request) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{0} }

type Match_Engine_Reply struct {
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// domain name
	Uri string `protobuf:"bytes,2,opt,name=uri,proto3" json:"uri,omitempty"`
	// ip of the app service
	ServiceIp []byte `protobuf:"bytes,3,opt,name=service_ip,json=serviceIp,proto3" json:"service_ip,omitempty"`
	// port of the app service?
	ServicePort uint32 `protobuf:"varint,4,opt,name=service_port,json=servicePort,proto3" json:"service_port,omitempty"`
	// location of the cloudlet?
	CloudletLocation *Loc `protobuf:"bytes,5,opt,name=cloudlet_location,json=cloudletLocation" json:"cloudlet_location,omitempty"`
	// Status return
	// enum MrStatus {
	//  MrSUCCESS = 0;
	//  MrFAIL = 1;
	// }
	// MrStatus Status = 6;
	Status bool `protobuf:"varint,6,opt,name=Status,proto3" json:"Status,omitempty"`
	// Token
	Token string `protobuf:"bytes,7,opt,name=Token,proto3" json:"Token,omitempty"`
}

func (m *Match_Engine_Reply) Reset()                    { *m = Match_Engine_Reply{} }
func (m *Match_Engine_Reply) String() string            { return proto.CompactTextString(m) }
func (*Match_Engine_Reply) ProtoMessage()               {}
func (*Match_Engine_Reply) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{1} }

type Match_Engine_Loc_Verify struct {
	Ver               uint32                                      `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	TowerStatus       Match_Engine_Loc_Verify_Tower_Status        `protobuf:"varint,2,opt,name=tower_status,json=towerStatus,proto3,enum=distributed_match_engine.Match_Engine_Loc_Verify_Tower_Status" json:"tower_status,omitempty"`
	GpsLocationStatus Match_Engine_Loc_Verify_GPS_Location_Status `protobuf:"varint,3,opt,name=gps_location_status,json=gpsLocationStatus,proto3,enum=distributed_match_engine.Match_Engine_Loc_Verify_GPS_Location_Status" json:"gps_location_status,omitempty"`
	// Token
	Token string `protobuf:"bytes,4,opt,name=Token,proto3" json:"Token,omitempty"`
}

func (m *Match_Engine_Loc_Verify) Reset()                    { *m = Match_Engine_Loc_Verify{} }
func (m *Match_Engine_Loc_Verify) String() string            { return proto.CompactTextString(m) }
func (*Match_Engine_Loc_Verify) ProtoMessage()               {}
func (*Match_Engine_Loc_Verify) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{2} }

type Match_Engine_Loc struct {
	Ver    uint32                      `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	Status Match_Engine_Loc_Loc_Status `protobuf:"varint,2,opt,name=Status,proto3,enum=distributed_match_engine.Match_Engine_Loc_Loc_Status" json:"Status,omitempty"`
	// The carrier name that user is connected to ("Cellular Carrier Name")
	CarrierName string `protobuf:"bytes,3,opt,name=CarrierName,proto3" json:"CarrierName,omitempty"`
	// The tower that user is currently connected to
	Tower uint64 `protobuf:"varint,4,opt,name=Tower,proto3" json:"Tower,omitempty"`
	// The GPS location of the user
	NetworkLocation *Loc `protobuf:"bytes,5,opt,name=NetworkLocation" json:"NetworkLocation,omitempty"`
	// Token
	Token string `protobuf:"bytes,6,opt,name=Token,proto3" json:"Token,omitempty"`
}

func (m *Match_Engine_Loc) Reset()                    { *m = Match_Engine_Loc{} }
func (m *Match_Engine_Loc) String() string            { return proto.CompactTextString(m) }
func (*Match_Engine_Loc) ProtoMessage()               {}
func (*Match_Engine_Loc) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{3} }

type Match_Engine_Status struct {
	Ver    uint32                        `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	Status Match_Engine_Status_ME_Status `protobuf:"varint,2,opt,name=Status,proto3,enum=distributed_match_engine.Match_Engine_Status_ME_Status" json:"Status,omitempty"`
	// Error Code based on Failure
	ErrorCode uint32 `protobuf:"varint,3,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	// Token
	Token string `protobuf:"bytes,4,opt,name=Token,proto3" json:"Token,omitempty"`
	// Cookie to use for future comminication
	Cookie string `protobuf:"bytes,5,opt,name=Cookie,proto3" json:"Cookie,omitempty"`
	// Not used
	UserData string `protobuf:"bytes,6,opt,name=UserData,proto3" json:"UserData,omitempty"`
}

func (m *Match_Engine_Status) Reset()                    { *m = Match_Engine_Status{} }
func (m *Match_Engine_Status) String() string            { return proto.CompactTextString(m) }
func (*Match_Engine_Status) ProtoMessage()               {}
func (*Match_Engine_Status) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{4} }

type DynamicLocGroupAdd struct {
	Ver    uint32                    `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	IdType DynamicLocGroupAdd_IDType `protobuf:"varint,2,opt,name=IdType,proto3,enum=distributed_match_engine.DynamicLocGroupAdd_IDType" json:"IdType,omitempty"`
	// Actual ID
	Id string `protobuf:"bytes,3,opt,name=Id,proto3" json:"Id,omitempty"`
	// App/OS generated ID
	Uuid string `protobuf:"bytes,4,opt,name=Uuid,proto3" json:"Uuid,omitempty"`
	// The carrier ID that user is connected to ("Mobile Country Code")
	CarrierID uint64 `protobuf:"varint,5,opt,name=CarrierID,proto3" json:"CarrierID,omitempty"`
	// The carrier name that user is connected to ("Cellular Carrier Name")
	CarrierName string `protobuf:"bytes,6,opt,name=CarrierName,proto3" json:"CarrierName,omitempty"`
	// The tower that user is currently connected to
	Tower uint64 `protobuf:"varint,7,opt,name=Tower,proto3" json:"Tower,omitempty"`
	// The GPS location of the user
	GpsLocation *Loc `protobuf:"bytes,8,opt,name=GpsLocation" json:"GpsLocation,omitempty"`
	// Dynamic Location Group Id
	LgId uint64 `protobuf:"varint,9,opt,name=LgId,proto3" json:"LgId,omitempty"`
	// Token
	Token    string                         `protobuf:"bytes,10,opt,name=Token,proto3" json:"Token,omitempty"`
	CommType DynamicLocGroupAdd_DlgCommType `protobuf:"varint,11,opt,name=CommType,proto3,enum=distributed_match_engine.DynamicLocGroupAdd_DlgCommType" json:"CommType,omitempty"`
	// Not used
	CommCookie string `protobuf:"bytes,12,opt,name=CommCookie,proto3" json:"CommCookie,omitempty"`
}

func (m *DynamicLocGroupAdd) Reset()                    { *m = DynamicLocGroupAdd{} }
func (m *DynamicLocGroupAdd) String() string            { return proto.CompactTextString(m) }
func (*DynamicLocGroupAdd) ProtoMessage()               {}
func (*DynamicLocGroupAdd) Descriptor() ([]byte, []int) { return fileDescriptorAppClient, []int{5} }

func init() {
	proto.RegisterType((*Match_Engine_Request)(nil), "distributed_match_engine.Match_Engine_Request")
	proto.RegisterType((*Match_Engine_Reply)(nil), "distributed_match_engine.Match_Engine_Reply")
	proto.RegisterType((*Match_Engine_Loc_Verify)(nil), "distributed_match_engine.Match_Engine_Loc_Verify")
	proto.RegisterType((*Match_Engine_Loc)(nil), "distributed_match_engine.Match_Engine_Loc")
	proto.RegisterType((*Match_Engine_Status)(nil), "distributed_match_engine.Match_Engine_Status")
	proto.RegisterType((*DynamicLocGroupAdd)(nil), "distributed_match_engine.DynamicLocGroupAdd")
	proto.RegisterEnum("distributed_match_engine.Match_Engine_Request_IDType", Match_Engine_Request_IDType_name, Match_Engine_Request_IDType_value)
	proto.RegisterEnum("distributed_match_engine.Match_Engine_Loc_Verify_Tower_Status", Match_Engine_Loc_Verify_Tower_Status_name, Match_Engine_Loc_Verify_Tower_Status_value)
	proto.RegisterEnum("distributed_match_engine.Match_Engine_Loc_Verify_GPS_Location_Status", Match_Engine_Loc_Verify_GPS_Location_Status_name, Match_Engine_Loc_Verify_GPS_Location_Status_value)
	proto.RegisterEnum("distributed_match_engine.Match_Engine_Loc_Loc_Status", Match_Engine_Loc_Loc_Status_name, Match_Engine_Loc_Loc_Status_value)
	proto.RegisterEnum("distributed_match_engine.Match_Engine_Status_ME_Status", Match_Engine_Status_ME_Status_name, Match_Engine_Status_ME_Status_value)
	proto.RegisterEnum("distributed_match_engine.DynamicLocGroupAdd_IDType", DynamicLocGroupAdd_IDType_name, DynamicLocGroupAdd_IDType_value)
	proto.RegisterEnum("distributed_match_engine.DynamicLocGroupAdd_DlgCommType", DynamicLocGroupAdd_DlgCommType_name, DynamicLocGroupAdd_DlgCommType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Match_Engine_Api service

type Match_Engine_ApiClient interface {
	FindCloudlet(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Reply, error)
	VerifyLocation(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Loc_Verify, error)
	GetLocation(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Loc, error)
	RegisterClient(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Status, error)
	AddUserToGroup(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Status, error)
}

type match_Engine_ApiClient struct {
	cc *grpc.ClientConn
}

func NewMatch_Engine_ApiClient(cc *grpc.ClientConn) Match_Engine_ApiClient {
	return &match_Engine_ApiClient{cc}
}

func (c *match_Engine_ApiClient) FindCloudlet(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Reply, error) {
	out := new(Match_Engine_Reply)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/FindCloudlet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *match_Engine_ApiClient) VerifyLocation(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Loc_Verify, error) {
	out := new(Match_Engine_Loc_Verify)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/VerifyLocation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *match_Engine_ApiClient) GetLocation(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Loc, error) {
	out := new(Match_Engine_Loc)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/GetLocation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *match_Engine_ApiClient) RegisterClient(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Status, error) {
	out := new(Match_Engine_Status)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/RegisterClient", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *match_Engine_ApiClient) AddUserToGroup(ctx context.Context, in *Match_Engine_Request, opts ...grpc.CallOption) (*Match_Engine_Status, error) {
	out := new(Match_Engine_Status)
	err := grpc.Invoke(ctx, "/distributed_match_engine.Match_Engine_Api/AddUserToGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Match_Engine_Api service

type Match_Engine_ApiServer interface {
	FindCloudlet(context.Context, *Match_Engine_Request) (*Match_Engine_Reply, error)
	VerifyLocation(context.Context, *Match_Engine_Request) (*Match_Engine_Loc_Verify, error)
	GetLocation(context.Context, *Match_Engine_Request) (*Match_Engine_Loc, error)
	RegisterClient(context.Context, *Match_Engine_Request) (*Match_Engine_Status, error)
	AddUserToGroup(context.Context, *Match_Engine_Request) (*Match_Engine_Status, error)
}

func RegisterMatch_Engine_ApiServer(s *grpc.Server, srv Match_Engine_ApiServer) {
	s.RegisterService(&_Match_Engine_Api_serviceDesc, srv)
}

func _Match_Engine_Api_FindCloudlet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Match_Engine_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).FindCloudlet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/FindCloudlet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).FindCloudlet(ctx, req.(*Match_Engine_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_Engine_Api_VerifyLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Match_Engine_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).VerifyLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/VerifyLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).VerifyLocation(ctx, req.(*Match_Engine_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_Engine_Api_GetLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Match_Engine_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).GetLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/GetLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).GetLocation(ctx, req.(*Match_Engine_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_Engine_Api_RegisterClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Match_Engine_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).RegisterClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/RegisterClient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).RegisterClient(ctx, req.(*Match_Engine_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Match_Engine_Api_AddUserToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Match_Engine_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Match_Engine_ApiServer).AddUserToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Match_Engine_Api/AddUserToGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Match_Engine_ApiServer).AddUserToGroup(ctx, req.(*Match_Engine_Request))
	}
	return interceptor(ctx, in, info, handler)
}

var _Match_Engine_Api_serviceDesc = grpc.ServiceDesc{
	ServiceName: "distributed_match_engine.Match_Engine_Api",
	HandlerType: (*Match_Engine_ApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FindCloudlet",
			Handler:    _Match_Engine_Api_FindCloudlet_Handler,
		},
		{
			MethodName: "VerifyLocation",
			Handler:    _Match_Engine_Api_VerifyLocation_Handler,
		},
		{
			MethodName: "GetLocation",
			Handler:    _Match_Engine_Api_GetLocation_Handler,
		},
		{
			MethodName: "RegisterClient",
			Handler:    _Match_Engine_Api_RegisterClient_Handler,
		},
		{
			MethodName: "AddUserToGroup",
			Handler:    _Match_Engine_Api_AddUserToGroup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app-client.proto",
}

func (m *Match_Engine_Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match_Engine_Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.IdType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.IdType))
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Uuid) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if m.CarrierID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CarrierID))
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if m.Tower != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Tower))
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n1, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.AppId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.AppId))
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if len(m.ServerPort) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.ServerPort)))
		i += copy(dAtA[i:], m.ServerPort)
	}
	if len(m.DevName) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.DevName)))
		i += copy(dAtA[i:], m.DevName)
	}
	if len(m.AppName) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppName)))
		i += copy(dAtA[i:], m.AppName)
	}
	if len(m.AppVers) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppVers)))
		i += copy(dAtA[i:], m.AppVers)
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	return i, nil
}

func (m *Match_Engine_Reply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match_Engine_Reply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if len(m.Uri) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	if len(m.ServiceIp) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.ServiceIp)))
		i += copy(dAtA[i:], m.ServiceIp)
	}
	if m.ServicePort != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.ServicePort))
	}
	if m.CloudletLocation != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CloudletLocation.Size()))
		n2, err := m.CloudletLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Status {
		dAtA[i] = 0x30
		i++
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	return i, nil
}

func (m *Match_Engine_Loc_Verify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match_Engine_Loc_Verify) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.TowerStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.TowerStatus))
	}
	if m.GpsLocationStatus != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocationStatus))
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	return i, nil
}

func (m *Match_Engine_Loc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match_Engine_Loc) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if m.Tower != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Tower))
	}
	if m.NetworkLocation != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.NetworkLocation.Size()))
		n3, err := m.NetworkLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	return i, nil
}

func (m *Match_Engine_Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match_Engine_Status) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if len(m.Cookie) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Cookie)))
		i += copy(dAtA[i:], m.Cookie)
	}
	if len(m.UserData) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.UserData)))
		i += copy(dAtA[i:], m.UserData)
	}
	return i, nil
}

func (m *DynamicLocGroupAdd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicLocGroupAdd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
	}
	if m.IdType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.IdType))
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Uuid) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if m.CarrierID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CarrierID))
	}
	if len(m.CarrierName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i += copy(dAtA[i:], m.CarrierName)
	}
	if m.Tower != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.Tower))
	}
	if m.GpsLocation != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.GpsLocation.Size()))
		n4, err := m.GpsLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.LgId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.LgId))
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if m.CommType != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(m.CommType))
	}
	if len(m.CommCookie) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CommCookie)))
		i += copy(dAtA[i:], m.CommCookie)
	}
	return i, nil
}

func encodeVarintAppClient(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Match_Engine_Request) CopyInFields(src *Match_Engine_Request) {
	m.Ver = src.Ver
	m.IdType = src.IdType
	m.Id = src.Id
	m.Uuid = src.Uuid
	m.CarrierID = src.CarrierID
	m.CarrierName = src.CarrierName
	m.Tower = src.Tower
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		m.GpsLocation.Lat = src.GpsLocation.Lat
		m.GpsLocation.Long = src.GpsLocation.Long
		m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
		m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
		m.GpsLocation.Altitude = src.GpsLocation.Altitude
		m.GpsLocation.Course = src.GpsLocation.Course
		m.GpsLocation.Speed = src.GpsLocation.Speed
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &google_protobuf.Timestamp{}
			m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
			m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
		}
	}
	m.AppId = src.AppId
	if m.Protocol == nil || len(m.Protocol) < len(src.Protocol) {
		m.Protocol = make([]byte, len(src.Protocol))
	}
	copy(m.Protocol, src.Protocol)
	if m.ServerPort == nil || len(m.ServerPort) < len(src.ServerPort) {
		m.ServerPort = make([]byte, len(src.ServerPort))
	}
	copy(m.ServerPort, src.ServerPort)
	m.DevName = src.DevName
	m.AppName = src.AppName
	m.AppVers = src.AppVers
	m.Token = src.Token
}

func (m *Match_Engine_Reply) CopyInFields(src *Match_Engine_Reply) {
	m.Ver = src.Ver
	m.Uri = src.Uri
	if m.ServiceIp == nil || len(m.ServiceIp) < len(src.ServiceIp) {
		m.ServiceIp = make([]byte, len(src.ServiceIp))
	}
	copy(m.ServiceIp, src.ServiceIp)
	m.ServicePort = src.ServicePort
	if src.CloudletLocation != nil {
		m.CloudletLocation = &Loc{}
		m.CloudletLocation.Lat = src.CloudletLocation.Lat
		m.CloudletLocation.Long = src.CloudletLocation.Long
		m.CloudletLocation.HorizontalAccuracy = src.CloudletLocation.HorizontalAccuracy
		m.CloudletLocation.VerticalAccuracy = src.CloudletLocation.VerticalAccuracy
		m.CloudletLocation.Altitude = src.CloudletLocation.Altitude
		m.CloudletLocation.Course = src.CloudletLocation.Course
		m.CloudletLocation.Speed = src.CloudletLocation.Speed
		if src.CloudletLocation.Timestamp != nil {
			m.CloudletLocation.Timestamp = &google_protobuf.Timestamp{}
			m.CloudletLocation.Timestamp.Seconds = src.CloudletLocation.Timestamp.Seconds
			m.CloudletLocation.Timestamp.Nanos = src.CloudletLocation.Timestamp.Nanos
		}
	}
	m.Status = src.Status
	m.Token = src.Token
}

func (m *Match_Engine_Loc_Verify) CopyInFields(src *Match_Engine_Loc_Verify) {
	m.Ver = src.Ver
	m.TowerStatus = src.TowerStatus
	m.GpsLocationStatus = src.GpsLocationStatus
	m.Token = src.Token
}

func (m *Match_Engine_Loc) CopyInFields(src *Match_Engine_Loc) {
	m.Ver = src.Ver
	m.Status = src.Status
	m.CarrierName = src.CarrierName
	m.Tower = src.Tower
	if src.NetworkLocation != nil {
		m.NetworkLocation = &Loc{}
		m.NetworkLocation.Lat = src.NetworkLocation.Lat
		m.NetworkLocation.Long = src.NetworkLocation.Long
		m.NetworkLocation.HorizontalAccuracy = src.NetworkLocation.HorizontalAccuracy
		m.NetworkLocation.VerticalAccuracy = src.NetworkLocation.VerticalAccuracy
		m.NetworkLocation.Altitude = src.NetworkLocation.Altitude
		m.NetworkLocation.Course = src.NetworkLocation.Course
		m.NetworkLocation.Speed = src.NetworkLocation.Speed
		if src.NetworkLocation.Timestamp != nil {
			m.NetworkLocation.Timestamp = &google_protobuf.Timestamp{}
			m.NetworkLocation.Timestamp.Seconds = src.NetworkLocation.Timestamp.Seconds
			m.NetworkLocation.Timestamp.Nanos = src.NetworkLocation.Timestamp.Nanos
		}
	}
	m.Token = src.Token
}

func (m *Match_Engine_Status) CopyInFields(src *Match_Engine_Status) {
	m.Ver = src.Ver
	m.Status = src.Status
	m.ErrorCode = src.ErrorCode
	m.Token = src.Token
	m.Cookie = src.Cookie
	m.UserData = src.UserData
}

func (m *DynamicLocGroupAdd) CopyInFields(src *DynamicLocGroupAdd) {
	m.Ver = src.Ver
	m.IdType = src.IdType
	m.Id = src.Id
	m.Uuid = src.Uuid
	m.CarrierID = src.CarrierID
	m.CarrierName = src.CarrierName
	m.Tower = src.Tower
	if src.GpsLocation != nil {
		m.GpsLocation = &Loc{}
		m.GpsLocation.Lat = src.GpsLocation.Lat
		m.GpsLocation.Long = src.GpsLocation.Long
		m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
		m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
		m.GpsLocation.Altitude = src.GpsLocation.Altitude
		m.GpsLocation.Course = src.GpsLocation.Course
		m.GpsLocation.Speed = src.GpsLocation.Speed
		if src.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = &google_protobuf.Timestamp{}
			m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
			m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
		}
	}
	m.LgId = src.LgId
	m.Token = src.Token
	m.CommType = src.CommType
	m.CommCookie = src.CommCookie
}

func (m *Match_Engine_Request) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.IdType != 0 {
		n += 1 + sovAppClient(uint64(m.IdType))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.CarrierID != 0 {
		n += 1 + sovAppClient(uint64(m.CarrierID))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Tower != 0 {
		n += 1 + sovAppClient(uint64(m.Tower))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.AppId != 0 {
		n += 1 + sovAppClient(uint64(m.AppId))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.ServerPort)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.DevName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppVers)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *Match_Engine_Reply) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.ServiceIp)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.ServicePort != 0 {
		n += 1 + sovAppClient(uint64(m.ServicePort))
	}
	if m.CloudletLocation != nil {
		l = m.CloudletLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Status {
		n += 2
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *Match_Engine_Loc_Verify) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.TowerStatus != 0 {
		n += 1 + sovAppClient(uint64(m.TowerStatus))
	}
	if m.GpsLocationStatus != 0 {
		n += 1 + sovAppClient(uint64(m.GpsLocationStatus))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *Match_Engine_Loc) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Tower != 0 {
		n += 1 + sovAppClient(uint64(m.Tower))
	}
	if m.NetworkLocation != nil {
		l = m.NetworkLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *Match_Engine_Status) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAppClient(uint64(m.ErrorCode))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.Cookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.UserData)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func (m *DynamicLocGroupAdd) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.IdType != 0 {
		n += 1 + sovAppClient(uint64(m.IdType))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.CarrierID != 0 {
		n += 1 + sovAppClient(uint64(m.CarrierID))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Tower != 0 {
		n += 1 + sovAppClient(uint64(m.Tower))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.LgId != 0 {
		n += 1 + sovAppClient(uint64(m.LgId))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.CommType != 0 {
		n += 1 + sovAppClient(uint64(m.CommType))
	}
	l = len(m.CommCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	return n
}

func sovAppClient(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAppClient(x uint64) (n int) {
	return sovAppClient(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Match_Engine_Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match_Engine_Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match_Engine_Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdType", wireType)
			}
			m.IdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdType |= (Match_Engine_Request_IDType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierID", wireType)
			}
			m.CarrierID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CarrierID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tower", wireType)
			}
			m.Tower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tower |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = append(m.Protocol[:0], dAtA[iNdEx:postIndex]...)
			if m.Protocol == nil {
				m.Protocol = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerPort", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerPort = append(m.ServerPort[:0], dAtA[iNdEx:postIndex]...)
			if m.ServerPort == nil {
				m.ServerPort = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Match_Engine_Reply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match_Engine_Reply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match_Engine_Reply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceIp", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceIp = append(m.ServiceIp[:0], dAtA[iNdEx:postIndex]...)
			if m.ServiceIp == nil {
				m.ServiceIp = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicePort", wireType)
			}
			m.ServicePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServicePort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloudletLocation == nil {
				m.CloudletLocation = &Loc{}
			}
			if err := m.CloudletLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Match_Engine_Loc_Verify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match_Engine_Loc_Verify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match_Engine_Loc_Verify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TowerStatus", wireType)
			}
			m.TowerStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TowerStatus |= (Match_Engine_Loc_Verify_Tower_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocationStatus", wireType)
			}
			m.GpsLocationStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpsLocationStatus |= (Match_Engine_Loc_Verify_GPS_Location_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Match_Engine_Loc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match_Engine_Loc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match_Engine_Loc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Match_Engine_Loc_Loc_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tower", wireType)
			}
			m.Tower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tower |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkLocation == nil {
				m.NetworkLocation = &Loc{}
			}
			if err := m.NetworkLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Match_Engine_Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match_Engine_Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match_Engine_Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Match_Engine_Status_ME_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicLocGroupAdd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicLocGroupAdd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicLocGroupAdd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdType", wireType)
			}
			m.IdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdType |= (DynamicLocGroupAdd_IDType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierID", wireType)
			}
			m.CarrierID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CarrierID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tower", wireType)
			}
			m.Tower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tower |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LgId", wireType)
			}
			m.LgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LgId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommType", wireType)
			}
			m.CommType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommType |= (DynamicLocGroupAdd_DlgCommType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAppClient(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAppClient
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAppClient(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAppClient = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAppClient   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("app-client.proto", fileDescriptorAppClient) }

var fileDescriptorAppClient = []byte{
	// 1085 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x57, 0xd1, 0x6e, 0xe3, 0x54,
	0x13, 0x8e, 0x13, 0x37, 0x6d, 0xc6, 0x69, 0x7a, 0x7a, 0xda, 0xff, 0xc7, 0xaa, 0xba, 0x55, 0xb0,
	0xb8, 0x08, 0x2b, 0x36, 0x62, 0xbb, 0x5a, 0xc1, 0x05, 0x02, 0x05, 0xdb, 0x6d, 0x4d, 0x13, 0xa7,
	0xb2, 0x9d, 0xad, 0xb8, 0xb2, 0xb2, 0xf6, 0x21, 0x58, 0x75, 0x63, 0xef, 0x89, 0xd3, 0x55, 0x5f,
	0x81, 0x0b, 0x24, 0x24, 0x5e, 0x81, 0x77, 0xe9, 0x05, 0x17, 0x3c, 0x02, 0xf4, 0x19, 0x78, 0x00,
	0x74, 0x8e, 0x9d, 0xc4, 0x4d, 0xd3, 0x55, 0x7c, 0xc1, 0x0d, 0x77, 0x67, 0xbe, 0xf1, 0xcc, 0x9c,
	0xf9, 0x66, 0xce, 0x4c, 0x02, 0x68, 0x18, 0xc7, 0x2f, 0xbc, 0x30, 0x20, 0xe3, 0xa4, 0x1d, 0xd3,
	0x28, 0x89, 0xb0, 0xec, 0x07, 0x93, 0x84, 0x06, 0x6f, 0xa7, 0x09, 0xf1, 0xdd, 0xeb, 0x61, 0xe2,
	0xfd, 0xe8, 0x92, 0xf1, 0x28, 0x18, 0x93, 0x83, 0x5a, 0x18, 0x79, 0xe9, 0x47, 0xca, 0xaf, 0x22,
	0xec, 0xf7, 0xb8, 0x4e, 0xe7, 0x3a, 0xd7, 0x22, 0xef, 0xa6, 0x64, 0x92, 0x60, 0x04, 0x95, 0x1b,
	0x42, 0x65, 0xa1, 0x29, 0xb4, 0xb6, 0x2d, 0x76, 0xc4, 0x3d, 0xa8, 0x1a, 0xbe, 0x73, 0x1b, 0x13,
	0xb9, 0xdc, 0x14, 0x5a, 0x8d, 0xe3, 0xd7, 0xed, 0xa7, 0x02, 0xb4, 0x57, 0x79, 0x6c, 0x1b, 0x1a,
	0x33, 0xb6, 0x32, 0x27, 0xb8, 0x01, 0x65, 0xc3, 0x97, 0x2b, 0x4d, 0xa1, 0x55, 0xb3, 0xca, 0x86,
	0x8f, 0x31, 0x88, 0x83, 0x69, 0xe0, 0xcb, 0x22, 0x47, 0xf8, 0x19, 0x1f, 0x42, 0x4d, 0x1d, 0x52,
	0x1a, 0x10, 0x6a, 0x68, 0xf2, 0x46, 0x53, 0x68, 0x89, 0xd6, 0x02, 0xc0, 0x4d, 0x90, 0x32, 0xc1,
	0x1c, 0x5e, 0x13, 0xb9, 0xca, 0x0d, 0xf3, 0x10, 0xde, 0x87, 0x0d, 0x27, 0x7a, 0x4f, 0xa8, 0xbc,
	0xc9, 0x6d, 0x53, 0x01, 0x7f, 0x03, 0xd2, 0x69, 0x3c, 0xe9, 0x46, 0xde, 0x30, 0x09, 0xa2, 0xb1,
	0xbc, 0xd5, 0x14, 0x5a, 0xd2, 0xf1, 0xb3, 0xa7, 0xb3, 0xe9, 0x46, 0x9e, 0x95, 0xb7, 0x60, 0x6e,
	0x3b, 0x71, 0x6c, 0xf8, 0x72, 0x2d, 0x75, 0xcb, 0x05, 0x7c, 0x00, 0x5b, 0x17, 0x8c, 0x53, 0x2f,
	0x0a, 0x65, 0x68, 0x0a, 0xad, 0xba, 0x35, 0x97, 0xf1, 0x11, 0x80, 0x4d, 0xe8, 0x0d, 0xa1, 0x17,
	0x11, 0x4d, 0x64, 0x89, 0x6b, 0x73, 0x08, 0x96, 0x61, 0x53, 0x23, 0x37, 0x3c, 0x8d, 0x3a, 0x4f,
	0x63, 0x26, 0x32, 0x4d, 0x27, 0x8e, 0xb9, 0x66, 0x3b, 0xd5, 0x64, 0x62, 0xa6, 0x79, 0x43, 0xe8,
	0x44, 0x6e, 0xcc, 0x35, 0x4c, 0x4c, 0xd3, 0xbe, 0x22, 0x63, 0x79, 0x87, 0xe3, 0xa9, 0xa0, 0x3c,
	0x87, 0x6a, 0x5a, 0x02, 0xbc, 0x05, 0xa2, 0xd1, 0xd3, 0x0d, 0x54, 0xc2, 0x00, 0xd5, 0x9e, 0x6d,
	0xd8, 0x9a, 0x89, 0x04, 0x76, 0x36, 0x2e, 0x3a, 0x9a, 0x66, 0xa1, 0xb2, 0xf2, 0xb7, 0x00, 0x78,
	0xa9, 0x88, 0x71, 0x78, 0xbb, 0xa2, 0x29, 0x10, 0x54, 0xa6, 0x34, 0xe0, 0x1d, 0x51, 0xb3, 0xd8,
	0x11, 0x3f, 0x03, 0x98, 0x10, 0x7a, 0x13, 0x78, 0xc4, 0x0d, 0x62, 0x5e, 0xdf, 0xba, 0x55, 0xcb,
	0x10, 0x23, 0xc6, 0x1f, 0x43, 0x7d, 0xa6, 0x8e, 0x19, 0x17, 0x22, 0xf7, 0x25, 0x65, 0x18, 0x27,
	0xe3, 0x3b, 0xd8, 0xf5, 0xc2, 0x68, 0xea, 0x87, 0x24, 0x71, 0xc3, 0x59, 0x95, 0x36, 0xd6, 0xa9,
	0x12, 0x9a, 0xd9, 0xcd, 0x4b, 0xf5, 0x7f, 0xa8, 0xda, 0xc9, 0x30, 0x99, 0x4e, 0x78, 0x7b, 0x6c,
	0x59, 0x99, 0xb4, 0xa0, 0x68, 0x33, 0x4f, 0xd1, 0x2f, 0x22, 0x7c, 0xf4, 0x20, 0xed, 0x6e, 0xe4,
	0xb9, 0x6f, 0x08, 0x0d, 0x7e, 0x58, 0x95, 0xfb, 0x10, 0xea, 0x09, 0x6b, 0x28, 0x77, 0x92, 0x46,
	0x48, 0x9f, 0xc5, 0xd7, 0x6b, 0x3e, 0x8b, 0x85, 0xeb, 0x36, 0x6f, 0x4b, 0x37, 0xbd, 0x99, 0x25,
	0x71, 0x9f, 0xd9, 0x35, 0xa7, 0xb0, 0x37, 0x8a, 0x27, 0x73, 0x16, 0x66, 0x91, 0x2a, 0x3c, 0x92,
	0x5e, 0x3c, 0xd2, 0xe9, 0x85, 0xed, 0xce, 0xb8, 0x99, 0x05, 0xdc, 0x1d, 0x2d, 0x5a, 0x7b, 0x99,
	0x1d, 0x31, 0xcf, 0x8e, 0x07, 0xf5, 0xfc, 0x4d, 0xb1, 0x04, 0x9b, 0x03, 0xf3, 0xdc, 0xec, 0x5f,
	0x9a, 0xa8, 0x84, 0x9b, 0x70, 0xa8, 0xf6, 0x4d, 0x53, 0x57, 0x1d, 0x5d, 0x73, 0x9d, 0xbe, 0x6b,
	0x5f, 0xe8, 0xaa, 0x71, 0x62, 0x70, 0xe1, 0x52, 0xb7, 0x90, 0x80, 0x3f, 0x81, 0xa6, 0xd9, 0x77,
	0xdc, 0x0f, 0x7e, 0x55, 0x56, 0x7e, 0x16, 0x60, 0x6f, 0xc5, 0x2d, 0xf1, 0x0e, 0x48, 0xdd, 0xbe,
	0xea, 0x2e, 0x02, 0x62, 0x68, 0x30, 0xe0, 0xd2, 0x70, 0xce, 0x0c, 0xd3, 0x3d, 0x3e, 0xef, 0x21,
	0x01, 0xef, 0xc1, 0x4e, 0x0e, 0x7b, 0xf9, 0xf9, 0x79, 0x0f, 0x95, 0xf1, 0x3e, 0xa0, 0x07, 0x20,
	0x43, 0x2b, 0x18, 0x41, 0x9d, 0xa1, 0x3d, 0xc3, 0xee, 0x75, 0x1c, 0xf5, 0x0c, 0x89, 0xf8, 0x7f,
	0xb0, 0xcb, 0x90, 0xbe, 0x73, 0xa6, 0x5b, 0xae, 0xda, 0x1f, 0x98, 0x8e, 0xf5, 0x3d, 0xda, 0x50,
	0xee, 0xca, 0x80, 0x96, 0xe9, 0x5c, 0x3d, 0x1d, 0xed, 0x7c, 0x1b, 0xbc, 0x5e, 0xbf, 0x38, 0xac,
	0x75, 0x67, 0xc5, 0x98, 0xf5, 0xe7, 0xd2, 0x6c, 0xab, 0x7c, 0x60, 0xb6, 0x89, 0xf9, 0xd9, 0x76,
	0x0a, 0x3b, 0x26, 0x49, 0xde, 0x47, 0xf4, 0xaa, 0x5b, 0xe8, 0xe5, 0x2c, 0x5b, 0x2d, 0x5a, 0xa0,
	0x9a, 0x6f, 0x81, 0xaf, 0x00, 0x16, 0x97, 0x7d, 0x5c, 0x93, 0x6d, 0xa8, 0x31, 0xe0, 0xa4, 0x3f,
	0x30, 0x35, 0x24, 0xe0, 0x06, 0x00, 0x13, 0x35, 0xdd, 0x34, 0x74, 0x0d, 0x95, 0x95, 0x9f, 0xca,
	0xb0, 0xf7, 0x20, 0xf9, 0xcc, 0xcf, 0x63, 0x36, 0xfb, 0x4b, 0x6c, 0x7e, 0xb1, 0x26, 0x9b, 0xa9,
	0x51, 0xbb, 0xa7, 0x2f, 0xf3, 0x79, 0x08, 0x35, 0x9d, 0xd2, 0x88, 0xaa, 0x91, 0x9f, 0xb2, 0xb9,
	0x6d, 0x2d, 0x80, 0xd5, 0xfd, 0xce, 0x66, 0x87, 0x1a, 0x45, 0x57, 0x01, 0xe1, 0x14, 0xd6, 0xac,
	0x4c, 0x62, 0x83, 0x7e, 0x30, 0x21, 0x54, 0x1b, 0x26, 0xc3, 0x8c, 0x9d, 0xb9, 0xac, 0xb4, 0xa0,
	0x36, 0x0f, 0xce, 0xf2, 0x67, 0xc2, 0x40, 0x55, 0x75, 0xdb, 0x46, 0x25, 0xf6, 0x60, 0x7a, 0xba,
	0x7b, 0xd2, 0x31, 0xba, 0x48, 0x50, 0x7e, 0x13, 0x01, 0x6b, 0xb7, 0xe3, 0xe1, 0x75, 0xe0, 0x75,
	0x23, 0xef, 0x94, 0x46, 0xd3, 0xb8, 0xe3, 0xfb, 0x2b, 0xb8, 0x38, 0x5f, 0xda, 0xbb, 0xaf, 0x9e,
	0xe6, 0xe2, 0xb1, 0xbf, 0xff, 0xd0, 0xd6, 0xc5, 0x20, 0x76, 0x47, 0xf3, 0xa5, 0xcb, 0xcf, 0x8b,
	0xc2, 0x41, 0xbe, 0x70, 0x0e, 0x6c, 0xa9, 0xd1, 0xf5, 0x35, 0xe7, 0x4c, 0xe2, 0x9c, 0x7d, 0x59,
	0x88, 0x33, 0x2d, 0x1c, 0xcd, 0xec, 0xad, 0xb9, 0x27, 0xb6, 0xc3, 0xd9, 0x39, 0x6b, 0x89, 0x74,
	0x4d, 0xe7, 0x90, 0x42, 0xfb, 0xf5, 0x53, 0x90, 0x72, 0x41, 0xd8, 0xbb, 0xd1, 0xc2, 0x91, 0x4d,
	0xbc, 0x29, 0x25, 0x69, 0x9f, 0x68, 0xe1, 0xa8, 0x1f, 0x93, 0x31, 0x12, 0x8e, 0x7f, 0x17, 0x97,
	0xe6, 0x4f, 0x27, 0x0e, 0xf0, 0x18, 0xea, 0x27, 0xc1, 0xd8, 0x57, 0xb3, 0x75, 0x87, 0xdb, 0xc5,
	0x7e, 0x8b, 0x1d, 0x7c, 0xb6, 0xf6, 0xf7, 0x71, 0x78, 0xab, 0x94, 0xf0, 0x14, 0x1a, 0xe9, 0x06,
	0x99, 0x57, 0xa3, 0x68, 0xc4, 0x97, 0x85, 0x97, 0x95, 0x52, 0xc2, 0x57, 0x20, 0x9d, 0xe6, 0x96,
	0x79, 0xd1, 0x98, 0xcf, 0xd7, 0x8f, 0xa9, 0x94, 0xf0, 0x3b, 0x68, 0x58, 0x64, 0x14, 0x4c, 0x12,
	0x42, 0x55, 0xfe, 0x3b, 0xba, 0x70, 0xbc, 0x17, 0x85, 0xa6, 0x54, 0x1a, 0xb2, 0xe3, 0xfb, 0x6c,
	0x78, 0x38, 0x11, 0xef, 0xbe, 0x7f, 0x3d, 0xe4, 0xb7, 0xe8, 0xee, 0xaf, 0xa3, 0xd2, 0xdd, 0xfd,
	0x91, 0xf0, 0xc7, 0xfd, 0x91, 0xf0, 0xe7, 0xfd, 0x91, 0xf0, 0xb6, 0xca, 0xff, 0x09, 0xbc, 0xfa,
	0x27, 0x00, 0x00, 0xff, 0xff, 0x40, 0x36, 0x11, 0x21, 0x42, 0x0c, 0x00, 0x00,
}
