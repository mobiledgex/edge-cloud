// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app-client.proto

/*
Package gencmd is a generated protocol buffer package.

It is generated from these files:
	app-client.proto
	appcommon.proto
	dynamic-location-group.proto
	loc.proto

It has these top-level messages:
	RegisterClientRequest
	RegisterClientReply
	FindCloudletRequest
	FindCloudletReply
	VerifyLocationRequest
	VerifyLocationReply
	GetLocationRequest
	GetLocationReply
	AppInstListRequest
	Appinstance
	CloudletLocation
	AppInstListReply
	FqdnListRequest
	AppFqdn
	FqdnListReply
	DynamicLocGroupRequest
	DynamicLocGroupReply
	AppPort
	DlgMessage
	DlgReply
	Timestamp
	Loc
*/
package gencmd

import distributed_match_engine "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto"
import "strings"
import "strconv"
import "github.com/spf13/cobra"
import "context"
import "os"
import "text/tabwriter"
import "github.com/spf13/pflag"
import "errors"
import "github.com/mobiledgex/edge-cloud/protoc-gen-cmd/cmdsup"
import "google.golang.org/grpc/status"
import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Auto-generated code: DO NOT EDIT
var Match_Engine_ApiCmd distributed_match_engine.Match_Engine_ApiClient
var AppInstListRequestIn distributed_match_engine.AppInstListRequest
var AppInstListRequestFlagSet = pflag.NewFlagSet("AppInstListRequest", pflag.ExitOnError)
var AppInstListRequestNoConfigFlagSet = pflag.NewFlagSet("AppInstListRequestNoConfig", pflag.ExitOnError)
var DynamicLocGroupRequestIn distributed_match_engine.DynamicLocGroupRequest
var DynamicLocGroupRequestFlagSet = pflag.NewFlagSet("DynamicLocGroupRequest", pflag.ExitOnError)
var DynamicLocGroupRequestNoConfigFlagSet = pflag.NewFlagSet("DynamicLocGroupRequestNoConfig", pflag.ExitOnError)
var DynamicLocGroupRequestInCommType string
var FindCloudletRequestIn distributed_match_engine.FindCloudletRequest
var FindCloudletRequestFlagSet = pflag.NewFlagSet("FindCloudletRequest", pflag.ExitOnError)
var FindCloudletRequestNoConfigFlagSet = pflag.NewFlagSet("FindCloudletRequestNoConfig", pflag.ExitOnError)
var FqdnListRequestIn distributed_match_engine.FqdnListRequest
var FqdnListRequestFlagSet = pflag.NewFlagSet("FqdnListRequest", pflag.ExitOnError)
var FqdnListRequestNoConfigFlagSet = pflag.NewFlagSet("FqdnListRequestNoConfig", pflag.ExitOnError)
var GetLocationRequestIn distributed_match_engine.GetLocationRequest
var GetLocationRequestFlagSet = pflag.NewFlagSet("GetLocationRequest", pflag.ExitOnError)
var GetLocationRequestNoConfigFlagSet = pflag.NewFlagSet("GetLocationRequestNoConfig", pflag.ExitOnError)
var RegisterClientRequestIn distributed_match_engine.RegisterClientRequest
var RegisterClientRequestFlagSet = pflag.NewFlagSet("RegisterClientRequest", pflag.ExitOnError)
var RegisterClientRequestNoConfigFlagSet = pflag.NewFlagSet("RegisterClientRequestNoConfig", pflag.ExitOnError)
var VerifyLocationRequestIn distributed_match_engine.VerifyLocationRequest
var VerifyLocationRequestFlagSet = pflag.NewFlagSet("VerifyLocationRequest", pflag.ExitOnError)
var VerifyLocationRequestNoConfigFlagSet = pflag.NewFlagSet("VerifyLocationRequestNoConfig", pflag.ExitOnError)
var IDTypesStrings = []string{
	"ID_UNDEFINED",
	"IMEI",
	"MSISDN",
	"IPADDR",
}

var ReplyStatusStrings = []string{
	"RS_UNDEFINED",
	"RS_SUCCESS",
	"RS_FAIL",
}

var FindStatusStrings = []string{
	"FIND_UNKNOWN",
	"FIND_FOUND",
	"FIND_NOTFOUND",
}

var Tower_StatusStrings = []string{
	"TOWER_UNKNOWN",
	"CONNECTED_TO_SPECIFIED_TOWER",
	"NOT_CONNECTED_TO_SPECIFIED_TOWER",
}

var GPS_Location_StatusStrings = []string{
	"LOC_UNKNOWN",
	"LOC_VERIFIED",
	"LOC_MISMATCH_SAME_COUNTRY",
	"LOC_MISMATCH_OTHER_COUNTRY",
	"LOC_ROAMING_COUNTRY_MATCH",
	"LOC_ROAMING_COUNTRY_MISMATCH",
	"LOC_ERROR_UNAUTHORIZED",
	"LOC_ERROR_OTHER",
}

var Loc_StatusStrings = []string{
	"LOC_UNKNOWN",
	"LOC_FOUND",
	"LOC_DENIED",
}

var AI_StatusStrings = []string{
	"AI_UNDEFINED",
	"AI_SUCCESS",
	"AI_FAIL",
}

var FL_StatusStrings = []string{
	"FL_UNDEFINED",
	"FL_SUCCESS",
	"FL_FAIL",
}

var DlgCommTypeStrings = []string{
	"DlgUndefined",
	"DlgSecure",
	"DlgOpen",
}

func RegisterClientRequestSlicer(in *distributed_match_engine.RegisterClientRequest) []string {
	s := make([]string, 0, 6)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, in.DevName)
	s = append(s, in.AppName)
	s = append(s, in.AppVers)
	s = append(s, in.CarrierName)
	s = append(s, in.AuthToken)
	return s
}

func RegisterClientRequestHeaderSlicer() []string {
	s := make([]string, 0, 6)
	s = append(s, "Ver")
	s = append(s, "DevName")
	s = append(s, "AppName")
	s = append(s, "AppVers")
	s = append(s, "CarrierName")
	s = append(s, "AuthToken")
	return s
}

func RegisterClientRequestWriteOutputArray(objs []*distributed_match_engine.RegisterClientRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(RegisterClientRequestHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(RegisterClientRequestSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func RegisterClientRequestWriteOutputOne(obj *distributed_match_engine.RegisterClientRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(RegisterClientRequestHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(RegisterClientRequestSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func RegisterClientReplySlicer(in *distributed_match_engine.RegisterClientReply) []string {
	s := make([]string, 0, 4)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, distributed_match_engine.ReplyStatus_name[int32(in.Status)])
	s = append(s, in.SessionCookie)
	s = append(s, in.TokenServerURI)
	return s
}

func RegisterClientReplyHeaderSlicer() []string {
	s := make([]string, 0, 4)
	s = append(s, "Ver")
	s = append(s, "Status")
	s = append(s, "SessionCookie")
	s = append(s, "TokenServerURI")
	return s
}

func RegisterClientReplyWriteOutputArray(objs []*distributed_match_engine.RegisterClientReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(RegisterClientReplyHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(RegisterClientReplySlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func RegisterClientReplyWriteOutputOne(obj *distributed_match_engine.RegisterClientReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(RegisterClientReplyHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(RegisterClientReplySlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func FindCloudletRequestSlicer(in *distributed_match_engine.FindCloudletRequest) []string {
	s := make([]string, 0, 7)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, in.SessionCookie)
	s = append(s, in.CarrierName)
	if in.GpsLocation == nil {
		in.GpsLocation = &distributed_match_engine.Loc{}
	}
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Lat), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Long), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.HorizontalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.VerticalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Altitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Course), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Speed), 'e', -1, 32))
	if in.GpsLocation.Timestamp == nil {
		in.GpsLocation.Timestamp = &distributed_match_engine.Timestamp{}
	}
	s = append(s, strconv.FormatUint(uint64(in.GpsLocation.Timestamp.Seconds), 10))
	s = append(s, strconv.FormatUint(uint64(in.GpsLocation.Timestamp.Nanos), 10))
	s = append(s, in.DevName)
	s = append(s, in.AppName)
	s = append(s, in.AppVers)
	return s
}

func FindCloudletRequestHeaderSlicer() []string {
	s := make([]string, 0, 7)
	s = append(s, "Ver")
	s = append(s, "SessionCookie")
	s = append(s, "CarrierName")
	s = append(s, "GpsLocation-Lat")
	s = append(s, "GpsLocation-Long")
	s = append(s, "GpsLocation-HorizontalAccuracy")
	s = append(s, "GpsLocation-VerticalAccuracy")
	s = append(s, "GpsLocation-Altitude")
	s = append(s, "GpsLocation-Course")
	s = append(s, "GpsLocation-Speed")
	s = append(s, "GpsLocation-Timestamp-Seconds")
	s = append(s, "GpsLocation-Timestamp-Nanos")
	s = append(s, "DevName")
	s = append(s, "AppName")
	s = append(s, "AppVers")
	return s
}

func FindCloudletRequestWriteOutputArray(objs []*distributed_match_engine.FindCloudletRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(FindCloudletRequestHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(FindCloudletRequestSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func FindCloudletRequestWriteOutputOne(obj *distributed_match_engine.FindCloudletRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(FindCloudletRequestHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(FindCloudletRequestSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func FindCloudletReplySlicer(in *distributed_match_engine.FindCloudletReply) []string {
	s := make([]string, 0, 5)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, distributed_match_engine.FindCloudletReply_FindStatus_name[int32(in.Status)])
	s = append(s, in.FQDN)
	if in.Ports == nil {
		in.Ports = make([]*distributed_match_engine.AppPort, 1)
	}
	if in.Ports[0] == nil {
		in.Ports[0] = &distributed_match_engine.AppPort{}
	}
	s = append(s, distributed_match_engine.LProto_name[int32(in.Ports[0].Proto)])
	s = append(s, strconv.FormatUint(uint64(in.Ports[0].InternalPort), 10))
	s = append(s, strconv.FormatUint(uint64(in.Ports[0].PublicPort), 10))
	s = append(s, in.Ports[0].PublicPath)
	s = append(s, in.Ports[0].FQDNPrefix)
	if in.CloudletLocation == nil {
		in.CloudletLocation = &distributed_match_engine.Loc{}
	}
	s = append(s, strconv.FormatFloat(float64(in.CloudletLocation.Lat), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.CloudletLocation.Long), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.CloudletLocation.HorizontalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.CloudletLocation.VerticalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.CloudletLocation.Altitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.CloudletLocation.Course), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.CloudletLocation.Speed), 'e', -1, 32))
	if in.CloudletLocation.Timestamp == nil {
		in.CloudletLocation.Timestamp = &distributed_match_engine.Timestamp{}
	}
	s = append(s, strconv.FormatUint(uint64(in.CloudletLocation.Timestamp.Seconds), 10))
	s = append(s, strconv.FormatUint(uint64(in.CloudletLocation.Timestamp.Nanos), 10))
	return s
}

func FindCloudletReplyHeaderSlicer() []string {
	s := make([]string, 0, 5)
	s = append(s, "Ver")
	s = append(s, "Status")
	s = append(s, "FQDN")
	s = append(s, "Ports-Proto")
	s = append(s, "Ports-InternalPort")
	s = append(s, "Ports-PublicPort")
	s = append(s, "Ports-PublicPath")
	s = append(s, "Ports-FQDNPrefix")
	s = append(s, "CloudletLocation-Lat")
	s = append(s, "CloudletLocation-Long")
	s = append(s, "CloudletLocation-HorizontalAccuracy")
	s = append(s, "CloudletLocation-VerticalAccuracy")
	s = append(s, "CloudletLocation-Altitude")
	s = append(s, "CloudletLocation-Course")
	s = append(s, "CloudletLocation-Speed")
	s = append(s, "CloudletLocation-Timestamp-Seconds")
	s = append(s, "CloudletLocation-Timestamp-Nanos")
	return s
}

func FindCloudletReplyWriteOutputArray(objs []*distributed_match_engine.FindCloudletReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(FindCloudletReplyHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(FindCloudletReplySlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func FindCloudletReplyWriteOutputOne(obj *distributed_match_engine.FindCloudletReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(FindCloudletReplyHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(FindCloudletReplySlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func VerifyLocationRequestSlicer(in *distributed_match_engine.VerifyLocationRequest) []string {
	s := make([]string, 0, 5)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, in.SessionCookie)
	s = append(s, in.CarrierName)
	if in.GpsLocation == nil {
		in.GpsLocation = &distributed_match_engine.Loc{}
	}
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Lat), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Long), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.HorizontalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.VerticalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Altitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Course), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Speed), 'e', -1, 32))
	if in.GpsLocation.Timestamp == nil {
		in.GpsLocation.Timestamp = &distributed_match_engine.Timestamp{}
	}
	s = append(s, strconv.FormatUint(uint64(in.GpsLocation.Timestamp.Seconds), 10))
	s = append(s, strconv.FormatUint(uint64(in.GpsLocation.Timestamp.Nanos), 10))
	s = append(s, in.VerifyLocToken)
	return s
}

func VerifyLocationRequestHeaderSlicer() []string {
	s := make([]string, 0, 5)
	s = append(s, "Ver")
	s = append(s, "SessionCookie")
	s = append(s, "CarrierName")
	s = append(s, "GpsLocation-Lat")
	s = append(s, "GpsLocation-Long")
	s = append(s, "GpsLocation-HorizontalAccuracy")
	s = append(s, "GpsLocation-VerticalAccuracy")
	s = append(s, "GpsLocation-Altitude")
	s = append(s, "GpsLocation-Course")
	s = append(s, "GpsLocation-Speed")
	s = append(s, "GpsLocation-Timestamp-Seconds")
	s = append(s, "GpsLocation-Timestamp-Nanos")
	s = append(s, "VerifyLocToken")
	return s
}

func VerifyLocationRequestWriteOutputArray(objs []*distributed_match_engine.VerifyLocationRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(VerifyLocationRequestHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(VerifyLocationRequestSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func VerifyLocationRequestWriteOutputOne(obj *distributed_match_engine.VerifyLocationRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(VerifyLocationRequestHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(VerifyLocationRequestSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func VerifyLocationReplySlicer(in *distributed_match_engine.VerifyLocationReply) []string {
	s := make([]string, 0, 4)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, distributed_match_engine.VerifyLocationReply_Tower_Status_name[int32(in.TowerStatus)])
	s = append(s, distributed_match_engine.VerifyLocationReply_GPS_Location_Status_name[int32(in.GpsLocationStatus)])
	s = append(s, strconv.FormatFloat(float64(in.GPS_Location_Accuracy_KM), 'e', -1, 32))
	return s
}

func VerifyLocationReplyHeaderSlicer() []string {
	s := make([]string, 0, 4)
	s = append(s, "Ver")
	s = append(s, "TowerStatus")
	s = append(s, "GpsLocationStatus")
	s = append(s, "GPS_Location_Accuracy_KM")
	return s
}

func VerifyLocationReplyWriteOutputArray(objs []*distributed_match_engine.VerifyLocationReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(VerifyLocationReplyHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(VerifyLocationReplySlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func VerifyLocationReplyWriteOutputOne(obj *distributed_match_engine.VerifyLocationReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(VerifyLocationReplyHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(VerifyLocationReplySlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func GetLocationRequestSlicer(in *distributed_match_engine.GetLocationRequest) []string {
	s := make([]string, 0, 3)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, in.SessionCookie)
	s = append(s, in.CarrierName)
	return s
}

func GetLocationRequestHeaderSlicer() []string {
	s := make([]string, 0, 3)
	s = append(s, "Ver")
	s = append(s, "SessionCookie")
	s = append(s, "CarrierName")
	return s
}

func GetLocationRequestWriteOutputArray(objs []*distributed_match_engine.GetLocationRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(GetLocationRequestHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(GetLocationRequestSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func GetLocationRequestWriteOutputOne(obj *distributed_match_engine.GetLocationRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(GetLocationRequestHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(GetLocationRequestSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func GetLocationReplySlicer(in *distributed_match_engine.GetLocationReply) []string {
	s := make([]string, 0, 5)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, distributed_match_engine.GetLocationReply_Loc_Status_name[int32(in.Status)])
	s = append(s, in.CarrierName)
	s = append(s, strconv.FormatUint(uint64(in.Tower), 10))
	if in.NetworkLocation == nil {
		in.NetworkLocation = &distributed_match_engine.Loc{}
	}
	s = append(s, strconv.FormatFloat(float64(in.NetworkLocation.Lat), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.NetworkLocation.Long), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.NetworkLocation.HorizontalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.NetworkLocation.VerticalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.NetworkLocation.Altitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.NetworkLocation.Course), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.NetworkLocation.Speed), 'e', -1, 32))
	if in.NetworkLocation.Timestamp == nil {
		in.NetworkLocation.Timestamp = &distributed_match_engine.Timestamp{}
	}
	s = append(s, strconv.FormatUint(uint64(in.NetworkLocation.Timestamp.Seconds), 10))
	s = append(s, strconv.FormatUint(uint64(in.NetworkLocation.Timestamp.Nanos), 10))
	return s
}

func GetLocationReplyHeaderSlicer() []string {
	s := make([]string, 0, 5)
	s = append(s, "Ver")
	s = append(s, "Status")
	s = append(s, "CarrierName")
	s = append(s, "Tower")
	s = append(s, "NetworkLocation-Lat")
	s = append(s, "NetworkLocation-Long")
	s = append(s, "NetworkLocation-HorizontalAccuracy")
	s = append(s, "NetworkLocation-VerticalAccuracy")
	s = append(s, "NetworkLocation-Altitude")
	s = append(s, "NetworkLocation-Course")
	s = append(s, "NetworkLocation-Speed")
	s = append(s, "NetworkLocation-Timestamp-Seconds")
	s = append(s, "NetworkLocation-Timestamp-Nanos")
	return s
}

func GetLocationReplyWriteOutputArray(objs []*distributed_match_engine.GetLocationReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(GetLocationReplyHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(GetLocationReplySlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func GetLocationReplyWriteOutputOne(obj *distributed_match_engine.GetLocationReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(GetLocationReplyHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(GetLocationReplySlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func AppInstListRequestSlicer(in *distributed_match_engine.AppInstListRequest) []string {
	s := make([]string, 0, 4)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, in.SessionCookie)
	s = append(s, in.CarrierName)
	if in.GpsLocation == nil {
		in.GpsLocation = &distributed_match_engine.Loc{}
	}
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Lat), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Long), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.HorizontalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.VerticalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Altitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Course), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Speed), 'e', -1, 32))
	if in.GpsLocation.Timestamp == nil {
		in.GpsLocation.Timestamp = &distributed_match_engine.Timestamp{}
	}
	s = append(s, strconv.FormatUint(uint64(in.GpsLocation.Timestamp.Seconds), 10))
	s = append(s, strconv.FormatUint(uint64(in.GpsLocation.Timestamp.Nanos), 10))
	return s
}

func AppInstListRequestHeaderSlicer() []string {
	s := make([]string, 0, 4)
	s = append(s, "Ver")
	s = append(s, "SessionCookie")
	s = append(s, "CarrierName")
	s = append(s, "GpsLocation-Lat")
	s = append(s, "GpsLocation-Long")
	s = append(s, "GpsLocation-HorizontalAccuracy")
	s = append(s, "GpsLocation-VerticalAccuracy")
	s = append(s, "GpsLocation-Altitude")
	s = append(s, "GpsLocation-Course")
	s = append(s, "GpsLocation-Speed")
	s = append(s, "GpsLocation-Timestamp-Seconds")
	s = append(s, "GpsLocation-Timestamp-Nanos")
	return s
}

func AppInstListRequestWriteOutputArray(objs []*distributed_match_engine.AppInstListRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(AppInstListRequestHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(AppInstListRequestSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func AppInstListRequestWriteOutputOne(obj *distributed_match_engine.AppInstListRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(AppInstListRequestHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(AppInstListRequestSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func AppinstanceSlicer(in *distributed_match_engine.Appinstance) []string {
	s := make([]string, 0, 4)
	s = append(s, in.AppName)
	s = append(s, in.AppVers)
	s = append(s, in.FQDN)
	if in.Ports == nil {
		in.Ports = make([]*distributed_match_engine.AppPort, 1)
	}
	if in.Ports[0] == nil {
		in.Ports[0] = &distributed_match_engine.AppPort{}
	}
	s = append(s, distributed_match_engine.LProto_name[int32(in.Ports[0].Proto)])
	s = append(s, strconv.FormatUint(uint64(in.Ports[0].InternalPort), 10))
	s = append(s, strconv.FormatUint(uint64(in.Ports[0].PublicPort), 10))
	s = append(s, in.Ports[0].PublicPath)
	s = append(s, in.Ports[0].FQDNPrefix)
	return s
}

func AppinstanceHeaderSlicer() []string {
	s := make([]string, 0, 4)
	s = append(s, "AppName")
	s = append(s, "AppVers")
	s = append(s, "FQDN")
	s = append(s, "Ports-Proto")
	s = append(s, "Ports-InternalPort")
	s = append(s, "Ports-PublicPort")
	s = append(s, "Ports-PublicPath")
	s = append(s, "Ports-FQDNPrefix")
	return s
}

func AppinstanceWriteOutputArray(objs []*distributed_match_engine.Appinstance) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(AppinstanceHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(AppinstanceSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func AppinstanceWriteOutputOne(obj *distributed_match_engine.Appinstance) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(AppinstanceHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(AppinstanceSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func CloudletLocationSlicer(in *distributed_match_engine.CloudletLocation) []string {
	s := make([]string, 0, 5)
	s = append(s, in.CarrierName)
	s = append(s, in.CloudletName)
	if in.GpsLocation == nil {
		in.GpsLocation = &distributed_match_engine.Loc{}
	}
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Lat), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Long), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.HorizontalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.VerticalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Altitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Course), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Speed), 'e', -1, 32))
	if in.GpsLocation.Timestamp == nil {
		in.GpsLocation.Timestamp = &distributed_match_engine.Timestamp{}
	}
	s = append(s, strconv.FormatUint(uint64(in.GpsLocation.Timestamp.Seconds), 10))
	s = append(s, strconv.FormatUint(uint64(in.GpsLocation.Timestamp.Nanos), 10))
	s = append(s, strconv.FormatFloat(float64(in.Distance), 'e', -1, 32))
	if in.Appinstances == nil {
		in.Appinstances = make([]*distributed_match_engine.Appinstance, 1)
	}
	if in.Appinstances[0] == nil {
		in.Appinstances[0] = &distributed_match_engine.Appinstance{}
	}
	s = append(s, in.Appinstances[0].AppName)
	s = append(s, in.Appinstances[0].AppVers)
	s = append(s, in.Appinstances[0].FQDN)
	if in.Appinstances[0].Ports == nil {
		in.Appinstances[0].Ports = make([]*distributed_match_engine.AppPort, 1)
	}
	if in.Appinstances[0].Ports[0] == nil {
		in.Appinstances[0].Ports[0] = &distributed_match_engine.AppPort{}
	}
	s = append(s, distributed_match_engine.LProto_name[int32(in.Appinstances[0].Ports[0].Proto)])
	s = append(s, strconv.FormatUint(uint64(in.Appinstances[0].Ports[0].InternalPort), 10))
	s = append(s, strconv.FormatUint(uint64(in.Appinstances[0].Ports[0].PublicPort), 10))
	s = append(s, in.Appinstances[0].Ports[0].PublicPath)
	s = append(s, in.Appinstances[0].Ports[0].FQDNPrefix)
	return s
}

func CloudletLocationHeaderSlicer() []string {
	s := make([]string, 0, 5)
	s = append(s, "CarrierName")
	s = append(s, "CloudletName")
	s = append(s, "GpsLocation-Lat")
	s = append(s, "GpsLocation-Long")
	s = append(s, "GpsLocation-HorizontalAccuracy")
	s = append(s, "GpsLocation-VerticalAccuracy")
	s = append(s, "GpsLocation-Altitude")
	s = append(s, "GpsLocation-Course")
	s = append(s, "GpsLocation-Speed")
	s = append(s, "GpsLocation-Timestamp-Seconds")
	s = append(s, "GpsLocation-Timestamp-Nanos")
	s = append(s, "Distance")
	s = append(s, "Appinstances-AppName")
	s = append(s, "Appinstances-AppVers")
	s = append(s, "Appinstances-FQDN")
	s = append(s, "Appinstances-Ports-Proto")
	s = append(s, "Appinstances-Ports-InternalPort")
	s = append(s, "Appinstances-Ports-PublicPort")
	s = append(s, "Appinstances-Ports-PublicPath")
	s = append(s, "Appinstances-Ports-FQDNPrefix")
	return s
}

func CloudletLocationWriteOutputArray(objs []*distributed_match_engine.CloudletLocation) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(CloudletLocationHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(CloudletLocationSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func CloudletLocationWriteOutputOne(obj *distributed_match_engine.CloudletLocation) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(CloudletLocationHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(CloudletLocationSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func AppInstListReplySlicer(in *distributed_match_engine.AppInstListReply) []string {
	s := make([]string, 0, 3)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, distributed_match_engine.AppInstListReply_AI_Status_name[int32(in.Status)])
	if in.Cloudlets == nil {
		in.Cloudlets = make([]*distributed_match_engine.CloudletLocation, 1)
	}
	if in.Cloudlets[0] == nil {
		in.Cloudlets[0] = &distributed_match_engine.CloudletLocation{}
	}
	s = append(s, in.Cloudlets[0].CarrierName)
	s = append(s, in.Cloudlets[0].CloudletName)
	if in.Cloudlets[0].GpsLocation == nil {
		in.Cloudlets[0].GpsLocation = &distributed_match_engine.Loc{}
	}
	s = append(s, strconv.FormatFloat(float64(in.Cloudlets[0].GpsLocation.Lat), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.Cloudlets[0].GpsLocation.Long), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.Cloudlets[0].GpsLocation.HorizontalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.Cloudlets[0].GpsLocation.VerticalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.Cloudlets[0].GpsLocation.Altitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.Cloudlets[0].GpsLocation.Course), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.Cloudlets[0].GpsLocation.Speed), 'e', -1, 32))
	if in.Cloudlets[0].GpsLocation.Timestamp == nil {
		in.Cloudlets[0].GpsLocation.Timestamp = &distributed_match_engine.Timestamp{}
	}
	s = append(s, strconv.FormatUint(uint64(in.Cloudlets[0].GpsLocation.Timestamp.Seconds), 10))
	s = append(s, strconv.FormatUint(uint64(in.Cloudlets[0].GpsLocation.Timestamp.Nanos), 10))
	s = append(s, strconv.FormatFloat(float64(in.Cloudlets[0].Distance), 'e', -1, 32))
	if in.Cloudlets[0].Appinstances == nil {
		in.Cloudlets[0].Appinstances = make([]*distributed_match_engine.Appinstance, 1)
	}
	if in.Cloudlets[0].Appinstances[0] == nil {
		in.Cloudlets[0].Appinstances[0] = &distributed_match_engine.Appinstance{}
	}
	s = append(s, in.Cloudlets[0].Appinstances[0].AppName)
	s = append(s, in.Cloudlets[0].Appinstances[0].AppVers)
	s = append(s, in.Cloudlets[0].Appinstances[0].FQDN)
	if in.Cloudlets[0].Appinstances[0].Ports == nil {
		in.Cloudlets[0].Appinstances[0].Ports = make([]*distributed_match_engine.AppPort, 1)
	}
	if in.Cloudlets[0].Appinstances[0].Ports[0] == nil {
		in.Cloudlets[0].Appinstances[0].Ports[0] = &distributed_match_engine.AppPort{}
	}
	s = append(s, distributed_match_engine.LProto_name[int32(in.Cloudlets[0].Appinstances[0].Ports[0].Proto)])
	s = append(s, strconv.FormatUint(uint64(in.Cloudlets[0].Appinstances[0].Ports[0].InternalPort), 10))
	s = append(s, strconv.FormatUint(uint64(in.Cloudlets[0].Appinstances[0].Ports[0].PublicPort), 10))
	s = append(s, in.Cloudlets[0].Appinstances[0].Ports[0].PublicPath)
	s = append(s, in.Cloudlets[0].Appinstances[0].Ports[0].FQDNPrefix)
	return s
}

func AppInstListReplyHeaderSlicer() []string {
	s := make([]string, 0, 3)
	s = append(s, "Ver")
	s = append(s, "Status")
	s = append(s, "Cloudlets-CarrierName")
	s = append(s, "Cloudlets-CloudletName")
	s = append(s, "Cloudlets-GpsLocation-Lat")
	s = append(s, "Cloudlets-GpsLocation-Long")
	s = append(s, "Cloudlets-GpsLocation-HorizontalAccuracy")
	s = append(s, "Cloudlets-GpsLocation-VerticalAccuracy")
	s = append(s, "Cloudlets-GpsLocation-Altitude")
	s = append(s, "Cloudlets-GpsLocation-Course")
	s = append(s, "Cloudlets-GpsLocation-Speed")
	s = append(s, "Cloudlets-GpsLocation-Timestamp-Seconds")
	s = append(s, "Cloudlets-GpsLocation-Timestamp-Nanos")
	s = append(s, "Cloudlets-Distance")
	s = append(s, "Cloudlets-Appinstances-AppName")
	s = append(s, "Cloudlets-Appinstances-AppVers")
	s = append(s, "Cloudlets-Appinstances-FQDN")
	s = append(s, "Cloudlets-Appinstances-Ports-Proto")
	s = append(s, "Cloudlets-Appinstances-Ports-InternalPort")
	s = append(s, "Cloudlets-Appinstances-Ports-PublicPort")
	s = append(s, "Cloudlets-Appinstances-Ports-PublicPath")
	s = append(s, "Cloudlets-Appinstances-Ports-FQDNPrefix")
	return s
}

func AppInstListReplyWriteOutputArray(objs []*distributed_match_engine.AppInstListReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(AppInstListReplyHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(AppInstListReplySlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func AppInstListReplyWriteOutputOne(obj *distributed_match_engine.AppInstListReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(AppInstListReplyHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(AppInstListReplySlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func FqdnListRequestSlicer(in *distributed_match_engine.FqdnListRequest) []string {
	s := make([]string, 0, 2)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, in.SessionCookie)
	return s
}

func FqdnListRequestHeaderSlicer() []string {
	s := make([]string, 0, 2)
	s = append(s, "Ver")
	s = append(s, "SessionCookie")
	return s
}

func FqdnListRequestWriteOutputArray(objs []*distributed_match_engine.FqdnListRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(FqdnListRequestHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(FqdnListRequestSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func FqdnListRequestWriteOutputOne(obj *distributed_match_engine.FqdnListRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(FqdnListRequestHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(FqdnListRequestSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func AppFqdnSlicer(in *distributed_match_engine.AppFqdn) []string {
	s := make([]string, 0, 5)
	s = append(s, in.AppName)
	s = append(s, in.AppVers)
	s = append(s, in.DevName)
	s = append(s, in.FQDN)
	s = append(s, in.AndroidPackageName)
	return s
}

func AppFqdnHeaderSlicer() []string {
	s := make([]string, 0, 5)
	s = append(s, "AppName")
	s = append(s, "AppVers")
	s = append(s, "DevName")
	s = append(s, "FQDN")
	s = append(s, "AndroidPackageName")
	return s
}

func AppFqdnWriteOutputArray(objs []*distributed_match_engine.AppFqdn) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(AppFqdnHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(AppFqdnSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func AppFqdnWriteOutputOne(obj *distributed_match_engine.AppFqdn) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(AppFqdnHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(AppFqdnSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func FqdnListReplySlicer(in *distributed_match_engine.FqdnListReply) []string {
	s := make([]string, 0, 3)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	if in.AppFqdns == nil {
		in.AppFqdns = make([]*distributed_match_engine.AppFqdn, 1)
	}
	if in.AppFqdns[0] == nil {
		in.AppFqdns[0] = &distributed_match_engine.AppFqdn{}
	}
	s = append(s, in.AppFqdns[0].AppName)
	s = append(s, in.AppFqdns[0].AppVers)
	s = append(s, in.AppFqdns[0].DevName)
	s = append(s, in.AppFqdns[0].FQDN)
	s = append(s, in.AppFqdns[0].AndroidPackageName)
	s = append(s, distributed_match_engine.FqdnListReply_FL_Status_name[int32(in.Status)])
	return s
}

func FqdnListReplyHeaderSlicer() []string {
	s := make([]string, 0, 3)
	s = append(s, "Ver")
	s = append(s, "AppFqdns-AppName")
	s = append(s, "AppFqdns-AppVers")
	s = append(s, "AppFqdns-DevName")
	s = append(s, "AppFqdns-FQDN")
	s = append(s, "AppFqdns-AndroidPackageName")
	s = append(s, "Status")
	return s
}

func FqdnListReplyWriteOutputArray(objs []*distributed_match_engine.FqdnListReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(FqdnListReplyHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(FqdnListReplySlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func FqdnListReplyWriteOutputOne(obj *distributed_match_engine.FqdnListReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(FqdnListReplyHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(FqdnListReplySlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func DynamicLocGroupRequestSlicer(in *distributed_match_engine.DynamicLocGroupRequest) []string {
	s := make([]string, 0, 5)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, in.SessionCookie)
	s = append(s, strconv.FormatUint(uint64(in.LgId), 10))
	s = append(s, distributed_match_engine.DynamicLocGroupRequest_DlgCommType_name[int32(in.CommType)])
	s = append(s, in.UserData)
	return s
}

func DynamicLocGroupRequestHeaderSlicer() []string {
	s := make([]string, 0, 5)
	s = append(s, "Ver")
	s = append(s, "SessionCookie")
	s = append(s, "LgId")
	s = append(s, "CommType")
	s = append(s, "UserData")
	return s
}

func DynamicLocGroupRequestWriteOutputArray(objs []*distributed_match_engine.DynamicLocGroupRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(DynamicLocGroupRequestHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(DynamicLocGroupRequestSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func DynamicLocGroupRequestWriteOutputOne(obj *distributed_match_engine.DynamicLocGroupRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(DynamicLocGroupRequestHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(DynamicLocGroupRequestSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func DynamicLocGroupReplySlicer(in *distributed_match_engine.DynamicLocGroupReply) []string {
	s := make([]string, 0, 4)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, distributed_match_engine.ReplyStatus_name[int32(in.Status)])
	s = append(s, strconv.FormatUint(uint64(in.ErrorCode), 10))
	s = append(s, in.GroupCookie)
	return s
}

func DynamicLocGroupReplyHeaderSlicer() []string {
	s := make([]string, 0, 4)
	s = append(s, "Ver")
	s = append(s, "Status")
	s = append(s, "ErrorCode")
	s = append(s, "GroupCookie")
	return s
}

func DynamicLocGroupReplyWriteOutputArray(objs []*distributed_match_engine.DynamicLocGroupReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(DynamicLocGroupReplyHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(DynamicLocGroupReplySlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func DynamicLocGroupReplyWriteOutputOne(obj *distributed_match_engine.DynamicLocGroupReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(DynamicLocGroupReplyHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(DynamicLocGroupReplySlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}

var RegisterClientCmd = &cobra.Command{
	Use: "RegisterClient",
	RunE: func(cmd *cobra.Command, args []string) error {
		// if we got this far, usage has been met.
		cmd.SilenceUsage = true
		return RegisterClient(&RegisterClientRequestIn)
	},
}

func RegisterClient(in *distributed_match_engine.RegisterClientRequest) error {
	if Match_Engine_ApiCmd == nil {
		return fmt.Errorf("Match_Engine_Api client not initialized")
	}
	ctx := context.Background()
	obj, err := Match_Engine_ApiCmd.RegisterClient(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("RegisterClient failed: %s", errstr)
	}
	RegisterClientReplyWriteOutputOne(obj)
	return nil
}

func RegisterClients(data []distributed_match_engine.RegisterClientRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("RegisterClient %v\n", data[ii])
		myerr := RegisterClient(&data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var FindCloudletCmd = &cobra.Command{
	Use: "FindCloudlet",
	RunE: func(cmd *cobra.Command, args []string) error {
		// if we got this far, usage has been met.
		cmd.SilenceUsage = true
		return FindCloudlet(&FindCloudletRequestIn)
	},
}

func FindCloudlet(in *distributed_match_engine.FindCloudletRequest) error {
	if Match_Engine_ApiCmd == nil {
		return fmt.Errorf("Match_Engine_Api client not initialized")
	}
	ctx := context.Background()
	obj, err := Match_Engine_ApiCmd.FindCloudlet(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("FindCloudlet failed: %s", errstr)
	}
	FindCloudletReplyWriteOutputOne(obj)
	return nil
}

func FindCloudlets(data []distributed_match_engine.FindCloudletRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("FindCloudlet %v\n", data[ii])
		myerr := FindCloudlet(&data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var VerifyLocationCmd = &cobra.Command{
	Use: "VerifyLocation",
	RunE: func(cmd *cobra.Command, args []string) error {
		// if we got this far, usage has been met.
		cmd.SilenceUsage = true
		return VerifyLocation(&VerifyLocationRequestIn)
	},
}

func VerifyLocation(in *distributed_match_engine.VerifyLocationRequest) error {
	if Match_Engine_ApiCmd == nil {
		return fmt.Errorf("Match_Engine_Api client not initialized")
	}
	ctx := context.Background()
	obj, err := Match_Engine_ApiCmd.VerifyLocation(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("VerifyLocation failed: %s", errstr)
	}
	VerifyLocationReplyWriteOutputOne(obj)
	return nil
}

func VerifyLocations(data []distributed_match_engine.VerifyLocationRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("VerifyLocation %v\n", data[ii])
		myerr := VerifyLocation(&data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetLocationCmd = &cobra.Command{
	Use: "GetLocation",
	RunE: func(cmd *cobra.Command, args []string) error {
		// if we got this far, usage has been met.
		cmd.SilenceUsage = true
		return GetLocation(&GetLocationRequestIn)
	},
}

func GetLocation(in *distributed_match_engine.GetLocationRequest) error {
	if Match_Engine_ApiCmd == nil {
		return fmt.Errorf("Match_Engine_Api client not initialized")
	}
	ctx := context.Background()
	obj, err := Match_Engine_ApiCmd.GetLocation(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetLocation failed: %s", errstr)
	}
	GetLocationReplyWriteOutputOne(obj)
	return nil
}

func GetLocations(data []distributed_match_engine.GetLocationRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetLocation %v\n", data[ii])
		myerr := GetLocation(&data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var AddUserToGroupCmd = &cobra.Command{
	Use: "AddUserToGroup",
	RunE: func(cmd *cobra.Command, args []string) error {
		// if we got this far, usage has been met.
		cmd.SilenceUsage = true
		err := parseDynamicLocGroupRequestEnums()
		if err != nil {
			return fmt.Errorf("AddUserToGroup failed: %s", err.Error())
		}
		return AddUserToGroup(&DynamicLocGroupRequestIn)
	},
}

func AddUserToGroup(in *distributed_match_engine.DynamicLocGroupRequest) error {
	if Match_Engine_ApiCmd == nil {
		return fmt.Errorf("Match_Engine_Api client not initialized")
	}
	ctx := context.Background()
	obj, err := Match_Engine_ApiCmd.AddUserToGroup(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("AddUserToGroup failed: %s", errstr)
	}
	DynamicLocGroupReplyWriteOutputOne(obj)
	return nil
}

func AddUserToGroups(data []distributed_match_engine.DynamicLocGroupRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("AddUserToGroup %v\n", data[ii])
		myerr := AddUserToGroup(&data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetAppInstListCmd = &cobra.Command{
	Use: "GetAppInstList",
	RunE: func(cmd *cobra.Command, args []string) error {
		// if we got this far, usage has been met.
		cmd.SilenceUsage = true
		return GetAppInstList(&AppInstListRequestIn)
	},
}

func GetAppInstList(in *distributed_match_engine.AppInstListRequest) error {
	if Match_Engine_ApiCmd == nil {
		return fmt.Errorf("Match_Engine_Api client not initialized")
	}
	ctx := context.Background()
	obj, err := Match_Engine_ApiCmd.GetAppInstList(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetAppInstList failed: %s", errstr)
	}
	AppInstListReplyWriteOutputOne(obj)
	return nil
}

func GetAppInstLists(data []distributed_match_engine.AppInstListRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetAppInstList %v\n", data[ii])
		myerr := GetAppInstList(&data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetFqdnListCmd = &cobra.Command{
	Use: "GetFqdnList",
	RunE: func(cmd *cobra.Command, args []string) error {
		// if we got this far, usage has been met.
		cmd.SilenceUsage = true
		return GetFqdnList(&FqdnListRequestIn)
	},
}

func GetFqdnList(in *distributed_match_engine.FqdnListRequest) error {
	if Match_Engine_ApiCmd == nil {
		return fmt.Errorf("Match_Engine_Api client not initialized")
	}
	ctx := context.Background()
	obj, err := Match_Engine_ApiCmd.GetFqdnList(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetFqdnList failed: %s", errstr)
	}
	FqdnListReplyWriteOutputOne(obj)
	return nil
}

func GetFqdnLists(data []distributed_match_engine.FqdnListRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetFqdnList %v\n", data[ii])
		myerr := GetFqdnList(&data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var Match_Engine_ApiCmds = []*cobra.Command{
	RegisterClientCmd,
	FindCloudletCmd,
	VerifyLocationCmd,
	GetLocationCmd,
	AddUserToGroupCmd,
	GetAppInstListCmd,
	GetFqdnListCmd,
}

func init() {
	RegisterClientRequestFlagSet.Uint32Var(&RegisterClientRequestIn.Ver, "ver", 0, "Ver")
	RegisterClientRequestFlagSet.StringVar(&RegisterClientRequestIn.DevName, "devname", "", "DevName")
	RegisterClientRequestFlagSet.StringVar(&RegisterClientRequestIn.AppName, "appname", "", "AppName")
	RegisterClientRequestFlagSet.StringVar(&RegisterClientRequestIn.AppVers, "appvers", "", "AppVers")
	RegisterClientRequestFlagSet.StringVar(&RegisterClientRequestIn.CarrierName, "carriername", "", "CarrierName")
	RegisterClientRequestFlagSet.StringVar(&RegisterClientRequestIn.AuthToken, "authtoken", "", "AuthToken")
	FindCloudletRequestFlagSet.Uint32Var(&FindCloudletRequestIn.Ver, "ver", 0, "Ver")
	FindCloudletRequestFlagSet.StringVar(&FindCloudletRequestIn.SessionCookie, "sessioncookie", "", "SessionCookie")
	FindCloudletRequestFlagSet.StringVar(&FindCloudletRequestIn.CarrierName, "carriername", "", "CarrierName")
	FindCloudletRequestIn.GpsLocation = &distributed_match_engine.Loc{}
	FindCloudletRequestFlagSet.Float64Var(&FindCloudletRequestIn.GpsLocation.Lat, "gpslocation-lat", 0, "GpsLocation.Lat")
	FindCloudletRequestFlagSet.Float64Var(&FindCloudletRequestIn.GpsLocation.Long, "gpslocation-long", 0, "GpsLocation.Long")
	FindCloudletRequestFlagSet.Float64Var(&FindCloudletRequestIn.GpsLocation.HorizontalAccuracy, "gpslocation-horizontalaccuracy", 0, "GpsLocation.HorizontalAccuracy")
	FindCloudletRequestFlagSet.Float64Var(&FindCloudletRequestIn.GpsLocation.VerticalAccuracy, "gpslocation-verticalaccuracy", 0, "GpsLocation.VerticalAccuracy")
	FindCloudletRequestFlagSet.Float64Var(&FindCloudletRequestIn.GpsLocation.Altitude, "gpslocation-altitude", 0, "GpsLocation.Altitude")
	FindCloudletRequestFlagSet.Float64Var(&FindCloudletRequestIn.GpsLocation.Course, "gpslocation-course", 0, "GpsLocation.Course")
	FindCloudletRequestFlagSet.Float64Var(&FindCloudletRequestIn.GpsLocation.Speed, "gpslocation-speed", 0, "GpsLocation.Speed")
	FindCloudletRequestIn.GpsLocation.Timestamp = &distributed_match_engine.Timestamp{}
	FindCloudletRequestFlagSet.Int64Var(&FindCloudletRequestIn.GpsLocation.Timestamp.Seconds, "gpslocation-timestamp-seconds", 0, "GpsLocation.Timestamp.Seconds")
	FindCloudletRequestFlagSet.Int32Var(&FindCloudletRequestIn.GpsLocation.Timestamp.Nanos, "gpslocation-timestamp-nanos", 0, "GpsLocation.Timestamp.Nanos")
	FindCloudletRequestFlagSet.StringVar(&FindCloudletRequestIn.DevName, "devname", "", "DevName")
	FindCloudletRequestFlagSet.StringVar(&FindCloudletRequestIn.AppName, "appname", "", "AppName")
	FindCloudletRequestFlagSet.StringVar(&FindCloudletRequestIn.AppVers, "appvers", "", "AppVers")
	VerifyLocationRequestFlagSet.Uint32Var(&VerifyLocationRequestIn.Ver, "ver", 0, "Ver")
	VerifyLocationRequestFlagSet.StringVar(&VerifyLocationRequestIn.SessionCookie, "sessioncookie", "", "SessionCookie")
	VerifyLocationRequestFlagSet.StringVar(&VerifyLocationRequestIn.CarrierName, "carriername", "", "CarrierName")
	VerifyLocationRequestIn.GpsLocation = &distributed_match_engine.Loc{}
	VerifyLocationRequestFlagSet.Float64Var(&VerifyLocationRequestIn.GpsLocation.Lat, "gpslocation-lat", 0, "GpsLocation.Lat")
	VerifyLocationRequestFlagSet.Float64Var(&VerifyLocationRequestIn.GpsLocation.Long, "gpslocation-long", 0, "GpsLocation.Long")
	VerifyLocationRequestFlagSet.Float64Var(&VerifyLocationRequestIn.GpsLocation.HorizontalAccuracy, "gpslocation-horizontalaccuracy", 0, "GpsLocation.HorizontalAccuracy")
	VerifyLocationRequestFlagSet.Float64Var(&VerifyLocationRequestIn.GpsLocation.VerticalAccuracy, "gpslocation-verticalaccuracy", 0, "GpsLocation.VerticalAccuracy")
	VerifyLocationRequestFlagSet.Float64Var(&VerifyLocationRequestIn.GpsLocation.Altitude, "gpslocation-altitude", 0, "GpsLocation.Altitude")
	VerifyLocationRequestFlagSet.Float64Var(&VerifyLocationRequestIn.GpsLocation.Course, "gpslocation-course", 0, "GpsLocation.Course")
	VerifyLocationRequestFlagSet.Float64Var(&VerifyLocationRequestIn.GpsLocation.Speed, "gpslocation-speed", 0, "GpsLocation.Speed")
	VerifyLocationRequestIn.GpsLocation.Timestamp = &distributed_match_engine.Timestamp{}
	VerifyLocationRequestFlagSet.Int64Var(&VerifyLocationRequestIn.GpsLocation.Timestamp.Seconds, "gpslocation-timestamp-seconds", 0, "GpsLocation.Timestamp.Seconds")
	VerifyLocationRequestFlagSet.Int32Var(&VerifyLocationRequestIn.GpsLocation.Timestamp.Nanos, "gpslocation-timestamp-nanos", 0, "GpsLocation.Timestamp.Nanos")
	VerifyLocationRequestFlagSet.StringVar(&VerifyLocationRequestIn.VerifyLocToken, "verifyloctoken", "", "VerifyLocToken")
	GetLocationRequestFlagSet.Uint32Var(&GetLocationRequestIn.Ver, "ver", 0, "Ver")
	GetLocationRequestFlagSet.StringVar(&GetLocationRequestIn.SessionCookie, "sessioncookie", "", "SessionCookie")
	GetLocationRequestFlagSet.StringVar(&GetLocationRequestIn.CarrierName, "carriername", "", "CarrierName")
	AppInstListRequestFlagSet.Uint32Var(&AppInstListRequestIn.Ver, "ver", 0, "Ver")
	AppInstListRequestFlagSet.StringVar(&AppInstListRequestIn.SessionCookie, "sessioncookie", "", "SessionCookie")
	AppInstListRequestFlagSet.StringVar(&AppInstListRequestIn.CarrierName, "carriername", "", "CarrierName")
	AppInstListRequestIn.GpsLocation = &distributed_match_engine.Loc{}
	AppInstListRequestFlagSet.Float64Var(&AppInstListRequestIn.GpsLocation.Lat, "gpslocation-lat", 0, "GpsLocation.Lat")
	AppInstListRequestFlagSet.Float64Var(&AppInstListRequestIn.GpsLocation.Long, "gpslocation-long", 0, "GpsLocation.Long")
	AppInstListRequestFlagSet.Float64Var(&AppInstListRequestIn.GpsLocation.HorizontalAccuracy, "gpslocation-horizontalaccuracy", 0, "GpsLocation.HorizontalAccuracy")
	AppInstListRequestFlagSet.Float64Var(&AppInstListRequestIn.GpsLocation.VerticalAccuracy, "gpslocation-verticalaccuracy", 0, "GpsLocation.VerticalAccuracy")
	AppInstListRequestFlagSet.Float64Var(&AppInstListRequestIn.GpsLocation.Altitude, "gpslocation-altitude", 0, "GpsLocation.Altitude")
	AppInstListRequestFlagSet.Float64Var(&AppInstListRequestIn.GpsLocation.Course, "gpslocation-course", 0, "GpsLocation.Course")
	AppInstListRequestFlagSet.Float64Var(&AppInstListRequestIn.GpsLocation.Speed, "gpslocation-speed", 0, "GpsLocation.Speed")
	AppInstListRequestIn.GpsLocation.Timestamp = &distributed_match_engine.Timestamp{}
	AppInstListRequestFlagSet.Int64Var(&AppInstListRequestIn.GpsLocation.Timestamp.Seconds, "gpslocation-timestamp-seconds", 0, "GpsLocation.Timestamp.Seconds")
	AppInstListRequestFlagSet.Int32Var(&AppInstListRequestIn.GpsLocation.Timestamp.Nanos, "gpslocation-timestamp-nanos", 0, "GpsLocation.Timestamp.Nanos")
	FqdnListRequestFlagSet.Uint32Var(&FqdnListRequestIn.Ver, "ver", 0, "Ver")
	FqdnListRequestFlagSet.StringVar(&FqdnListRequestIn.SessionCookie, "sessioncookie", "", "SessionCookie")
	DynamicLocGroupRequestFlagSet.Uint32Var(&DynamicLocGroupRequestIn.Ver, "ver", 0, "Ver")
	DynamicLocGroupRequestFlagSet.StringVar(&DynamicLocGroupRequestIn.SessionCookie, "sessioncookie", "", "SessionCookie")
	DynamicLocGroupRequestFlagSet.Uint64Var(&DynamicLocGroupRequestIn.LgId, "lgid", 0, "LgId")
	DynamicLocGroupRequestFlagSet.StringVar(&DynamicLocGroupRequestInCommType, "commtype", "", "one of [DlgUndefined DlgSecure DlgOpen]")
	DynamicLocGroupRequestFlagSet.StringVar(&DynamicLocGroupRequestIn.UserData, "userdata", "", "UserData")
	RegisterClientCmd.Flags().AddFlagSet(RegisterClientRequestFlagSet)
	FindCloudletCmd.Flags().AddFlagSet(FindCloudletRequestFlagSet)
	VerifyLocationCmd.Flags().AddFlagSet(VerifyLocationRequestFlagSet)
	GetLocationCmd.Flags().AddFlagSet(GetLocationRequestFlagSet)
	AddUserToGroupCmd.Flags().AddFlagSet(DynamicLocGroupRequestFlagSet)
	GetAppInstListCmd.Flags().AddFlagSet(AppInstListRequestFlagSet)
	GetFqdnListCmd.Flags().AddFlagSet(FqdnListRequestFlagSet)
}

func Match_Engine_ApiAllowNoConfig() {
	RegisterClientCmd.Flags().AddFlagSet(RegisterClientRequestNoConfigFlagSet)
	FindCloudletCmd.Flags().AddFlagSet(FindCloudletRequestNoConfigFlagSet)
	VerifyLocationCmd.Flags().AddFlagSet(VerifyLocationRequestNoConfigFlagSet)
	GetLocationCmd.Flags().AddFlagSet(GetLocationRequestNoConfigFlagSet)
	AddUserToGroupCmd.Flags().AddFlagSet(DynamicLocGroupRequestNoConfigFlagSet)
	GetAppInstListCmd.Flags().AddFlagSet(AppInstListRequestNoConfigFlagSet)
	GetFqdnListCmd.Flags().AddFlagSet(FqdnListRequestNoConfigFlagSet)
}

func parseDynamicLocGroupRequestEnums() error {
	if DynamicLocGroupRequestInCommType != "" {
		switch DynamicLocGroupRequestInCommType {
		case "DlgUndefined":
			DynamicLocGroupRequestIn.CommType = distributed_match_engine.DynamicLocGroupRequest_DlgCommType(0)
		case "DlgSecure":
			DynamicLocGroupRequestIn.CommType = distributed_match_engine.DynamicLocGroupRequest_DlgCommType(1)
		case "DlgOpen":
			DynamicLocGroupRequestIn.CommType = distributed_match_engine.DynamicLocGroupRequest_DlgCommType(2)
		default:
			return errors.New("Invalid value for DynamicLocGroupRequestInCommType")
		}
	}
	return nil
}
