// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app-client.proto

/*
Package gencmd is a generated protocol buffer package.

It is generated from these files:
	app-client.proto
	appcommon.proto
	dynamic-location-group.proto
	loc.proto
	predictiveqos.proto

It has these top-level messages:
	RegisterClientRequest
	RegisterClientReply
	FindCloudletRequest
	FindCloudletReply
	VerifyLocationRequest
	VerifyLocationReply
	GetLocationRequest
	GetLocationReply
	AppInstListRequest
	Appinstance
	CloudletLocation
	AppInstListReply
	FqdnListRequest
	AppFqdn
	FqdnListReply
	DynamicLocGroupRequest
	DynamicLocGroupReply
	QosPosition
	QosPositionKpiRequest
	QosPositionKpiReply
	AppPort
	DlgMessage
	DlgReply
	Timestamp
	Loc
	QoSKPIRequest
	PositionKpiResult
	PositionKpiRequest
	QoSKPIResponse
	HealthCheckRequest
	HealthCheckResponse
*/
package gencmd

import distributed_match_engine "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto"
import "strings"
import "strconv"
import "github.com/spf13/cobra"
import "context"
import "os"
import "text/tabwriter"
import "github.com/spf13/pflag"
import "errors"
import "github.com/mobiledgex/edge-cloud/protoc-gen-cmd/cmdsup"
import "google.golang.org/grpc/status"
import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Auto-generated code: DO NOT EDIT
var MatchEngineApiCmd distributed_match_engine.MatchEngineApiClient
var AppInstListRequestIn distributed_match_engine.AppInstListRequest
var AppInstListRequestFlagSet = pflag.NewFlagSet("AppInstListRequest", pflag.ExitOnError)
var AppInstListRequestNoConfigFlagSet = pflag.NewFlagSet("AppInstListRequestNoConfig", pflag.ExitOnError)
var DynamicLocGroupRequestIn distributed_match_engine.DynamicLocGroupRequest
var DynamicLocGroupRequestFlagSet = pflag.NewFlagSet("DynamicLocGroupRequest", pflag.ExitOnError)
var DynamicLocGroupRequestNoConfigFlagSet = pflag.NewFlagSet("DynamicLocGroupRequestNoConfig", pflag.ExitOnError)
var DynamicLocGroupRequestInCommType string
var FindCloudletRequestIn distributed_match_engine.FindCloudletRequest
var FindCloudletRequestFlagSet = pflag.NewFlagSet("FindCloudletRequest", pflag.ExitOnError)
var FindCloudletRequestNoConfigFlagSet = pflag.NewFlagSet("FindCloudletRequestNoConfig", pflag.ExitOnError)
var FqdnListRequestIn distributed_match_engine.FqdnListRequest
var FqdnListRequestFlagSet = pflag.NewFlagSet("FqdnListRequest", pflag.ExitOnError)
var FqdnListRequestNoConfigFlagSet = pflag.NewFlagSet("FqdnListRequestNoConfig", pflag.ExitOnError)
var GetLocationRequestIn distributed_match_engine.GetLocationRequest
var GetLocationRequestFlagSet = pflag.NewFlagSet("GetLocationRequest", pflag.ExitOnError)
var GetLocationRequestNoConfigFlagSet = pflag.NewFlagSet("GetLocationRequestNoConfig", pflag.ExitOnError)
var QosPositionKpiRequestIn distributed_match_engine.QosPositionKpiRequest
var QosPositionKpiRequestFlagSet = pflag.NewFlagSet("QosPositionKpiRequest", pflag.ExitOnError)
var QosPositionKpiRequestNoConfigFlagSet = pflag.NewFlagSet("QosPositionKpiRequestNoConfig", pflag.ExitOnError)
var RegisterClientRequestIn distributed_match_engine.RegisterClientRequest
var RegisterClientRequestFlagSet = pflag.NewFlagSet("RegisterClientRequest", pflag.ExitOnError)
var RegisterClientRequestNoConfigFlagSet = pflag.NewFlagSet("RegisterClientRequestNoConfig", pflag.ExitOnError)
var VerifyLocationRequestIn distributed_match_engine.VerifyLocationRequest
var VerifyLocationRequestFlagSet = pflag.NewFlagSet("VerifyLocationRequest", pflag.ExitOnError)
var VerifyLocationRequestNoConfigFlagSet = pflag.NewFlagSet("VerifyLocationRequestNoConfig", pflag.ExitOnError)
var IDTypesStrings = []string{
	"IdUndefined",
	"Imei",
	"Msisdn",
	"Ipaddr",
}

var ReplyStatusStrings = []string{
	"RsUndefined",
	"RsSuccess",
	"RsFail",
}

var FindStatusStrings = []string{
	"FindUnknown",
	"FindFound",
	"FindNotfound",
}

var TowerStatusStrings = []string{
	"TowerUnknown",
	"ConnectedToSpecifiedTower",
	"NotConnectedToSpecifiedTower",
}

var GPSLocationStatusStrings = []string{
	"LocUnknown",
	"LocVerified",
	"LocMismatchSameCountry",
	"LocMismatchOtherCountry",
	"LocRoamingCountryMatch",
	"LocRoamingCountryMismatch",
	"LocErrorUnauthorized",
	"LocErrorOther",
}

var LocStatusStrings = []string{
	"LocUnknown",
	"LocFound",
	"LocDenied",
}

var AIStatusStrings = []string{
	"AiUndefined",
	"AiSuccess",
	"AiFail",
}

var FLStatusStrings = []string{
	"FlUndefined",
	"FlSuccess",
	"FlFail",
}

var DlgCommTypeStrings = []string{
	"DlgUndefined",
	"DlgSecure",
	"DlgOpen",
}

func RegisterClientRequestSlicer(in *distributed_match_engine.RegisterClientRequest) []string {
	s := make([]string, 0, 6)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, in.DevName)
	s = append(s, in.AppName)
	s = append(s, in.AppVers)
	s = append(s, in.CarrierName)
	s = append(s, in.AuthToken)
	return s
}

func RegisterClientRequestHeaderSlicer() []string {
	s := make([]string, 0, 6)
	s = append(s, "Ver")
	s = append(s, "DevName")
	s = append(s, "AppName")
	s = append(s, "AppVers")
	s = append(s, "CarrierName")
	s = append(s, "AuthToken")
	return s
}

func RegisterClientRequestWriteOutputArray(objs []*distributed_match_engine.RegisterClientRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(RegisterClientRequestHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(RegisterClientRequestSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func RegisterClientRequestWriteOutputOne(obj *distributed_match_engine.RegisterClientRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(RegisterClientRequestHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(RegisterClientRequestSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func RegisterClientReplySlicer(in *distributed_match_engine.RegisterClientReply) []string {
	s := make([]string, 0, 4)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, distributed_match_engine.ReplyStatus_CamelName[int32(in.Status)])
	s = append(s, in.SessionCookie)
	s = append(s, in.TokenServerUri)
	return s
}

func RegisterClientReplyHeaderSlicer() []string {
	s := make([]string, 0, 4)
	s = append(s, "Ver")
	s = append(s, "Status")
	s = append(s, "SessionCookie")
	s = append(s, "TokenServerUri")
	return s
}

func RegisterClientReplyWriteOutputArray(objs []*distributed_match_engine.RegisterClientReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(RegisterClientReplyHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(RegisterClientReplySlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func RegisterClientReplyWriteOutputOne(obj *distributed_match_engine.RegisterClientReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(RegisterClientReplyHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(RegisterClientReplySlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func FindCloudletRequestSlicer(in *distributed_match_engine.FindCloudletRequest) []string {
	s := make([]string, 0, 7)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, in.SessionCookie)
	s = append(s, in.CarrierName)
	if in.GpsLocation == nil {
		in.GpsLocation = &distributed_match_engine.Loc{}
	}
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Latitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Longitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.HorizontalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.VerticalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Altitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Course), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Speed), 'e', -1, 32))
	if in.GpsLocation.Timestamp == nil {
		in.GpsLocation.Timestamp = &distributed_match_engine.Timestamp{}
	}
	s = append(s, strconv.FormatUint(uint64(in.GpsLocation.Timestamp.Seconds), 10))
	s = append(s, strconv.FormatUint(uint64(in.GpsLocation.Timestamp.Nanos), 10))
	s = append(s, in.DevName)
	s = append(s, in.AppName)
	s = append(s, in.AppVers)
	return s
}

func FindCloudletRequestHeaderSlicer() []string {
	s := make([]string, 0, 7)
	s = append(s, "Ver")
	s = append(s, "SessionCookie")
	s = append(s, "CarrierName")
	s = append(s, "GpsLocation-Latitude")
	s = append(s, "GpsLocation-Longitude")
	s = append(s, "GpsLocation-HorizontalAccuracy")
	s = append(s, "GpsLocation-VerticalAccuracy")
	s = append(s, "GpsLocation-Altitude")
	s = append(s, "GpsLocation-Course")
	s = append(s, "GpsLocation-Speed")
	s = append(s, "GpsLocation-Timestamp-Seconds")
	s = append(s, "GpsLocation-Timestamp-Nanos")
	s = append(s, "DevName")
	s = append(s, "AppName")
	s = append(s, "AppVers")
	return s
}

func FindCloudletRequestWriteOutputArray(objs []*distributed_match_engine.FindCloudletRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(FindCloudletRequestHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(FindCloudletRequestSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func FindCloudletRequestWriteOutputOne(obj *distributed_match_engine.FindCloudletRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(FindCloudletRequestHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(FindCloudletRequestSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func FindCloudletReplySlicer(in *distributed_match_engine.FindCloudletReply) []string {
	s := make([]string, 0, 5)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, distributed_match_engine.FindCloudletReply_FindStatus_CamelName[int32(in.Status)])
	s = append(s, in.Fqdn)
	if in.Ports == nil {
		in.Ports = make([]*distributed_match_engine.AppPort, 1)
	}
	if in.Ports[0] == nil {
		in.Ports[0] = &distributed_match_engine.AppPort{}
	}
	s = append(s, distributed_match_engine.LProto_CamelName[int32(in.Ports[0].Proto)])
	s = append(s, strconv.FormatUint(uint64(in.Ports[0].InternalPort), 10))
	s = append(s, strconv.FormatUint(uint64(in.Ports[0].PublicPort), 10))
	s = append(s, in.Ports[0].PathPrefix)
	s = append(s, in.Ports[0].FqdnPrefix)
	if in.CloudletLocation == nil {
		in.CloudletLocation = &distributed_match_engine.Loc{}
	}
	s = append(s, strconv.FormatFloat(float64(in.CloudletLocation.Latitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.CloudletLocation.Longitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.CloudletLocation.HorizontalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.CloudletLocation.VerticalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.CloudletLocation.Altitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.CloudletLocation.Course), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.CloudletLocation.Speed), 'e', -1, 32))
	if in.CloudletLocation.Timestamp == nil {
		in.CloudletLocation.Timestamp = &distributed_match_engine.Timestamp{}
	}
	s = append(s, strconv.FormatUint(uint64(in.CloudletLocation.Timestamp.Seconds), 10))
	s = append(s, strconv.FormatUint(uint64(in.CloudletLocation.Timestamp.Nanos), 10))
	return s
}

func FindCloudletReplyHeaderSlicer() []string {
	s := make([]string, 0, 5)
	s = append(s, "Ver")
	s = append(s, "Status")
	s = append(s, "Fqdn")
	s = append(s, "Ports-Proto")
	s = append(s, "Ports-InternalPort")
	s = append(s, "Ports-PublicPort")
	s = append(s, "Ports-PathPrefix")
	s = append(s, "Ports-FqdnPrefix")
	s = append(s, "CloudletLocation-Latitude")
	s = append(s, "CloudletLocation-Longitude")
	s = append(s, "CloudletLocation-HorizontalAccuracy")
	s = append(s, "CloudletLocation-VerticalAccuracy")
	s = append(s, "CloudletLocation-Altitude")
	s = append(s, "CloudletLocation-Course")
	s = append(s, "CloudletLocation-Speed")
	s = append(s, "CloudletLocation-Timestamp-Seconds")
	s = append(s, "CloudletLocation-Timestamp-Nanos")
	return s
}

func FindCloudletReplyWriteOutputArray(objs []*distributed_match_engine.FindCloudletReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(FindCloudletReplyHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(FindCloudletReplySlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func FindCloudletReplyWriteOutputOne(obj *distributed_match_engine.FindCloudletReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(FindCloudletReplyHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(FindCloudletReplySlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func VerifyLocationRequestSlicer(in *distributed_match_engine.VerifyLocationRequest) []string {
	s := make([]string, 0, 5)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, in.SessionCookie)
	s = append(s, in.CarrierName)
	if in.GpsLocation == nil {
		in.GpsLocation = &distributed_match_engine.Loc{}
	}
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Latitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Longitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.HorizontalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.VerticalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Altitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Course), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Speed), 'e', -1, 32))
	if in.GpsLocation.Timestamp == nil {
		in.GpsLocation.Timestamp = &distributed_match_engine.Timestamp{}
	}
	s = append(s, strconv.FormatUint(uint64(in.GpsLocation.Timestamp.Seconds), 10))
	s = append(s, strconv.FormatUint(uint64(in.GpsLocation.Timestamp.Nanos), 10))
	s = append(s, in.VerifyLocToken)
	return s
}

func VerifyLocationRequestHeaderSlicer() []string {
	s := make([]string, 0, 5)
	s = append(s, "Ver")
	s = append(s, "SessionCookie")
	s = append(s, "CarrierName")
	s = append(s, "GpsLocation-Latitude")
	s = append(s, "GpsLocation-Longitude")
	s = append(s, "GpsLocation-HorizontalAccuracy")
	s = append(s, "GpsLocation-VerticalAccuracy")
	s = append(s, "GpsLocation-Altitude")
	s = append(s, "GpsLocation-Course")
	s = append(s, "GpsLocation-Speed")
	s = append(s, "GpsLocation-Timestamp-Seconds")
	s = append(s, "GpsLocation-Timestamp-Nanos")
	s = append(s, "VerifyLocToken")
	return s
}

func VerifyLocationRequestWriteOutputArray(objs []*distributed_match_engine.VerifyLocationRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(VerifyLocationRequestHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(VerifyLocationRequestSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func VerifyLocationRequestWriteOutputOne(obj *distributed_match_engine.VerifyLocationRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(VerifyLocationRequestHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(VerifyLocationRequestSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func VerifyLocationReplySlicer(in *distributed_match_engine.VerifyLocationReply) []string {
	s := make([]string, 0, 4)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, distributed_match_engine.VerifyLocationReply_TowerStatus_CamelName[int32(in.TowerStatus)])
	s = append(s, distributed_match_engine.VerifyLocationReply_GPSLocationStatus_CamelName[int32(in.GpsLocationStatus)])
	s = append(s, strconv.FormatFloat(float64(in.GpsLocationAccuracyKm), 'e', -1, 32))
	return s
}

func VerifyLocationReplyHeaderSlicer() []string {
	s := make([]string, 0, 4)
	s = append(s, "Ver")
	s = append(s, "TowerStatus")
	s = append(s, "GpsLocationStatus")
	s = append(s, "GpsLocationAccuracyKm")
	return s
}

func VerifyLocationReplyWriteOutputArray(objs []*distributed_match_engine.VerifyLocationReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(VerifyLocationReplyHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(VerifyLocationReplySlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func VerifyLocationReplyWriteOutputOne(obj *distributed_match_engine.VerifyLocationReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(VerifyLocationReplyHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(VerifyLocationReplySlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func GetLocationRequestSlicer(in *distributed_match_engine.GetLocationRequest) []string {
	s := make([]string, 0, 3)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, in.SessionCookie)
	s = append(s, in.CarrierName)
	return s
}

func GetLocationRequestHeaderSlicer() []string {
	s := make([]string, 0, 3)
	s = append(s, "Ver")
	s = append(s, "SessionCookie")
	s = append(s, "CarrierName")
	return s
}

func GetLocationRequestWriteOutputArray(objs []*distributed_match_engine.GetLocationRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(GetLocationRequestHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(GetLocationRequestSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func GetLocationRequestWriteOutputOne(obj *distributed_match_engine.GetLocationRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(GetLocationRequestHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(GetLocationRequestSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func GetLocationReplySlicer(in *distributed_match_engine.GetLocationReply) []string {
	s := make([]string, 0, 5)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, distributed_match_engine.GetLocationReply_LocStatus_CamelName[int32(in.Status)])
	s = append(s, in.CarrierName)
	s = append(s, strconv.FormatUint(uint64(in.Tower), 10))
	if in.NetworkLocation == nil {
		in.NetworkLocation = &distributed_match_engine.Loc{}
	}
	s = append(s, strconv.FormatFloat(float64(in.NetworkLocation.Latitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.NetworkLocation.Longitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.NetworkLocation.HorizontalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.NetworkLocation.VerticalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.NetworkLocation.Altitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.NetworkLocation.Course), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.NetworkLocation.Speed), 'e', -1, 32))
	if in.NetworkLocation.Timestamp == nil {
		in.NetworkLocation.Timestamp = &distributed_match_engine.Timestamp{}
	}
	s = append(s, strconv.FormatUint(uint64(in.NetworkLocation.Timestamp.Seconds), 10))
	s = append(s, strconv.FormatUint(uint64(in.NetworkLocation.Timestamp.Nanos), 10))
	return s
}

func GetLocationReplyHeaderSlicer() []string {
	s := make([]string, 0, 5)
	s = append(s, "Ver")
	s = append(s, "Status")
	s = append(s, "CarrierName")
	s = append(s, "Tower")
	s = append(s, "NetworkLocation-Latitude")
	s = append(s, "NetworkLocation-Longitude")
	s = append(s, "NetworkLocation-HorizontalAccuracy")
	s = append(s, "NetworkLocation-VerticalAccuracy")
	s = append(s, "NetworkLocation-Altitude")
	s = append(s, "NetworkLocation-Course")
	s = append(s, "NetworkLocation-Speed")
	s = append(s, "NetworkLocation-Timestamp-Seconds")
	s = append(s, "NetworkLocation-Timestamp-Nanos")
	return s
}

func GetLocationReplyWriteOutputArray(objs []*distributed_match_engine.GetLocationReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(GetLocationReplyHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(GetLocationReplySlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func GetLocationReplyWriteOutputOne(obj *distributed_match_engine.GetLocationReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(GetLocationReplyHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(GetLocationReplySlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func AppInstListRequestSlicer(in *distributed_match_engine.AppInstListRequest) []string {
	s := make([]string, 0, 4)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, in.SessionCookie)
	s = append(s, in.CarrierName)
	if in.GpsLocation == nil {
		in.GpsLocation = &distributed_match_engine.Loc{}
	}
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Latitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Longitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.HorizontalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.VerticalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Altitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Course), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Speed), 'e', -1, 32))
	if in.GpsLocation.Timestamp == nil {
		in.GpsLocation.Timestamp = &distributed_match_engine.Timestamp{}
	}
	s = append(s, strconv.FormatUint(uint64(in.GpsLocation.Timestamp.Seconds), 10))
	s = append(s, strconv.FormatUint(uint64(in.GpsLocation.Timestamp.Nanos), 10))
	return s
}

func AppInstListRequestHeaderSlicer() []string {
	s := make([]string, 0, 4)
	s = append(s, "Ver")
	s = append(s, "SessionCookie")
	s = append(s, "CarrierName")
	s = append(s, "GpsLocation-Latitude")
	s = append(s, "GpsLocation-Longitude")
	s = append(s, "GpsLocation-HorizontalAccuracy")
	s = append(s, "GpsLocation-VerticalAccuracy")
	s = append(s, "GpsLocation-Altitude")
	s = append(s, "GpsLocation-Course")
	s = append(s, "GpsLocation-Speed")
	s = append(s, "GpsLocation-Timestamp-Seconds")
	s = append(s, "GpsLocation-Timestamp-Nanos")
	return s
}

func AppInstListRequestWriteOutputArray(objs []*distributed_match_engine.AppInstListRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(AppInstListRequestHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(AppInstListRequestSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func AppInstListRequestWriteOutputOne(obj *distributed_match_engine.AppInstListRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(AppInstListRequestHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(AppInstListRequestSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func AppinstanceSlicer(in *distributed_match_engine.Appinstance) []string {
	s := make([]string, 0, 4)
	s = append(s, in.AppName)
	s = append(s, in.AppVers)
	s = append(s, in.Fqdn)
	if in.Ports == nil {
		in.Ports = make([]*distributed_match_engine.AppPort, 1)
	}
	if in.Ports[0] == nil {
		in.Ports[0] = &distributed_match_engine.AppPort{}
	}
	s = append(s, distributed_match_engine.LProto_CamelName[int32(in.Ports[0].Proto)])
	s = append(s, strconv.FormatUint(uint64(in.Ports[0].InternalPort), 10))
	s = append(s, strconv.FormatUint(uint64(in.Ports[0].PublicPort), 10))
	s = append(s, in.Ports[0].PathPrefix)
	s = append(s, in.Ports[0].FqdnPrefix)
	return s
}

func AppinstanceHeaderSlicer() []string {
	s := make([]string, 0, 4)
	s = append(s, "AppName")
	s = append(s, "AppVers")
	s = append(s, "Fqdn")
	s = append(s, "Ports-Proto")
	s = append(s, "Ports-InternalPort")
	s = append(s, "Ports-PublicPort")
	s = append(s, "Ports-PathPrefix")
	s = append(s, "Ports-FqdnPrefix")
	return s
}

func AppinstanceWriteOutputArray(objs []*distributed_match_engine.Appinstance) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(AppinstanceHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(AppinstanceSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func AppinstanceWriteOutputOne(obj *distributed_match_engine.Appinstance) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(AppinstanceHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(AppinstanceSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func CloudletLocationSlicer(in *distributed_match_engine.CloudletLocation) []string {
	s := make([]string, 0, 5)
	s = append(s, in.CarrierName)
	s = append(s, in.CloudletName)
	if in.GpsLocation == nil {
		in.GpsLocation = &distributed_match_engine.Loc{}
	}
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Latitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Longitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.HorizontalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.VerticalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Altitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Course), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Speed), 'e', -1, 32))
	if in.GpsLocation.Timestamp == nil {
		in.GpsLocation.Timestamp = &distributed_match_engine.Timestamp{}
	}
	s = append(s, strconv.FormatUint(uint64(in.GpsLocation.Timestamp.Seconds), 10))
	s = append(s, strconv.FormatUint(uint64(in.GpsLocation.Timestamp.Nanos), 10))
	s = append(s, strconv.FormatFloat(float64(in.Distance), 'e', -1, 32))
	if in.Appinstances == nil {
		in.Appinstances = make([]*distributed_match_engine.Appinstance, 1)
	}
	if in.Appinstances[0] == nil {
		in.Appinstances[0] = &distributed_match_engine.Appinstance{}
	}
	s = append(s, in.Appinstances[0].AppName)
	s = append(s, in.Appinstances[0].AppVers)
	s = append(s, in.Appinstances[0].Fqdn)
	if in.Appinstances[0].Ports == nil {
		in.Appinstances[0].Ports = make([]*distributed_match_engine.AppPort, 1)
	}
	if in.Appinstances[0].Ports[0] == nil {
		in.Appinstances[0].Ports[0] = &distributed_match_engine.AppPort{}
	}
	s = append(s, distributed_match_engine.LProto_CamelName[int32(in.Appinstances[0].Ports[0].Proto)])
	s = append(s, strconv.FormatUint(uint64(in.Appinstances[0].Ports[0].InternalPort), 10))
	s = append(s, strconv.FormatUint(uint64(in.Appinstances[0].Ports[0].PublicPort), 10))
	s = append(s, in.Appinstances[0].Ports[0].PathPrefix)
	s = append(s, in.Appinstances[0].Ports[0].FqdnPrefix)
	return s
}

func CloudletLocationHeaderSlicer() []string {
	s := make([]string, 0, 5)
	s = append(s, "CarrierName")
	s = append(s, "CloudletName")
	s = append(s, "GpsLocation-Latitude")
	s = append(s, "GpsLocation-Longitude")
	s = append(s, "GpsLocation-HorizontalAccuracy")
	s = append(s, "GpsLocation-VerticalAccuracy")
	s = append(s, "GpsLocation-Altitude")
	s = append(s, "GpsLocation-Course")
	s = append(s, "GpsLocation-Speed")
	s = append(s, "GpsLocation-Timestamp-Seconds")
	s = append(s, "GpsLocation-Timestamp-Nanos")
	s = append(s, "Distance")
	s = append(s, "Appinstances-AppName")
	s = append(s, "Appinstances-AppVers")
	s = append(s, "Appinstances-Fqdn")
	s = append(s, "Appinstances-Ports-Proto")
	s = append(s, "Appinstances-Ports-InternalPort")
	s = append(s, "Appinstances-Ports-PublicPort")
	s = append(s, "Appinstances-Ports-PathPrefix")
	s = append(s, "Appinstances-Ports-FqdnPrefix")
	return s
}

func CloudletLocationWriteOutputArray(objs []*distributed_match_engine.CloudletLocation) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(CloudletLocationHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(CloudletLocationSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func CloudletLocationWriteOutputOne(obj *distributed_match_engine.CloudletLocation) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(CloudletLocationHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(CloudletLocationSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func AppInstListReplySlicer(in *distributed_match_engine.AppInstListReply) []string {
	s := make([]string, 0, 3)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, distributed_match_engine.AppInstListReply_AIStatus_CamelName[int32(in.Status)])
	if in.Cloudlets == nil {
		in.Cloudlets = make([]*distributed_match_engine.CloudletLocation, 1)
	}
	if in.Cloudlets[0] == nil {
		in.Cloudlets[0] = &distributed_match_engine.CloudletLocation{}
	}
	s = append(s, in.Cloudlets[0].CarrierName)
	s = append(s, in.Cloudlets[0].CloudletName)
	if in.Cloudlets[0].GpsLocation == nil {
		in.Cloudlets[0].GpsLocation = &distributed_match_engine.Loc{}
	}
	s = append(s, strconv.FormatFloat(float64(in.Cloudlets[0].GpsLocation.Latitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.Cloudlets[0].GpsLocation.Longitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.Cloudlets[0].GpsLocation.HorizontalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.Cloudlets[0].GpsLocation.VerticalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.Cloudlets[0].GpsLocation.Altitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.Cloudlets[0].GpsLocation.Course), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.Cloudlets[0].GpsLocation.Speed), 'e', -1, 32))
	if in.Cloudlets[0].GpsLocation.Timestamp == nil {
		in.Cloudlets[0].GpsLocation.Timestamp = &distributed_match_engine.Timestamp{}
	}
	s = append(s, strconv.FormatUint(uint64(in.Cloudlets[0].GpsLocation.Timestamp.Seconds), 10))
	s = append(s, strconv.FormatUint(uint64(in.Cloudlets[0].GpsLocation.Timestamp.Nanos), 10))
	s = append(s, strconv.FormatFloat(float64(in.Cloudlets[0].Distance), 'e', -1, 32))
	if in.Cloudlets[0].Appinstances == nil {
		in.Cloudlets[0].Appinstances = make([]*distributed_match_engine.Appinstance, 1)
	}
	if in.Cloudlets[0].Appinstances[0] == nil {
		in.Cloudlets[0].Appinstances[0] = &distributed_match_engine.Appinstance{}
	}
	s = append(s, in.Cloudlets[0].Appinstances[0].AppName)
	s = append(s, in.Cloudlets[0].Appinstances[0].AppVers)
	s = append(s, in.Cloudlets[0].Appinstances[0].Fqdn)
	if in.Cloudlets[0].Appinstances[0].Ports == nil {
		in.Cloudlets[0].Appinstances[0].Ports = make([]*distributed_match_engine.AppPort, 1)
	}
	if in.Cloudlets[0].Appinstances[0].Ports[0] == nil {
		in.Cloudlets[0].Appinstances[0].Ports[0] = &distributed_match_engine.AppPort{}
	}
	s = append(s, distributed_match_engine.LProto_CamelName[int32(in.Cloudlets[0].Appinstances[0].Ports[0].Proto)])
	s = append(s, strconv.FormatUint(uint64(in.Cloudlets[0].Appinstances[0].Ports[0].InternalPort), 10))
	s = append(s, strconv.FormatUint(uint64(in.Cloudlets[0].Appinstances[0].Ports[0].PublicPort), 10))
	s = append(s, in.Cloudlets[0].Appinstances[0].Ports[0].PathPrefix)
	s = append(s, in.Cloudlets[0].Appinstances[0].Ports[0].FqdnPrefix)
	return s
}

func AppInstListReplyHeaderSlicer() []string {
	s := make([]string, 0, 3)
	s = append(s, "Ver")
	s = append(s, "Status")
	s = append(s, "Cloudlets-CarrierName")
	s = append(s, "Cloudlets-CloudletName")
	s = append(s, "Cloudlets-GpsLocation-Latitude")
	s = append(s, "Cloudlets-GpsLocation-Longitude")
	s = append(s, "Cloudlets-GpsLocation-HorizontalAccuracy")
	s = append(s, "Cloudlets-GpsLocation-VerticalAccuracy")
	s = append(s, "Cloudlets-GpsLocation-Altitude")
	s = append(s, "Cloudlets-GpsLocation-Course")
	s = append(s, "Cloudlets-GpsLocation-Speed")
	s = append(s, "Cloudlets-GpsLocation-Timestamp-Seconds")
	s = append(s, "Cloudlets-GpsLocation-Timestamp-Nanos")
	s = append(s, "Cloudlets-Distance")
	s = append(s, "Cloudlets-Appinstances-AppName")
	s = append(s, "Cloudlets-Appinstances-AppVers")
	s = append(s, "Cloudlets-Appinstances-Fqdn")
	s = append(s, "Cloudlets-Appinstances-Ports-Proto")
	s = append(s, "Cloudlets-Appinstances-Ports-InternalPort")
	s = append(s, "Cloudlets-Appinstances-Ports-PublicPort")
	s = append(s, "Cloudlets-Appinstances-Ports-PathPrefix")
	s = append(s, "Cloudlets-Appinstances-Ports-FqdnPrefix")
	return s
}

func AppInstListReplyWriteOutputArray(objs []*distributed_match_engine.AppInstListReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(AppInstListReplyHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(AppInstListReplySlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func AppInstListReplyWriteOutputOne(obj *distributed_match_engine.AppInstListReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(AppInstListReplyHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(AppInstListReplySlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func FqdnListRequestSlicer(in *distributed_match_engine.FqdnListRequest) []string {
	s := make([]string, 0, 2)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, in.SessionCookie)
	return s
}

func FqdnListRequestHeaderSlicer() []string {
	s := make([]string, 0, 2)
	s = append(s, "Ver")
	s = append(s, "SessionCookie")
	return s
}

func FqdnListRequestWriteOutputArray(objs []*distributed_match_engine.FqdnListRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(FqdnListRequestHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(FqdnListRequestSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func FqdnListRequestWriteOutputOne(obj *distributed_match_engine.FqdnListRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(FqdnListRequestHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(FqdnListRequestSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func AppFqdnSlicer(in *distributed_match_engine.AppFqdn) []string {
	s := make([]string, 0, 5)
	s = append(s, in.AppName)
	s = append(s, in.AppVers)
	s = append(s, in.DevName)
	if in.Fqdns == nil {
		in.Fqdns = make([]string, 1)
	}
	s = append(s, in.Fqdns[0])
	s = append(s, in.AndroidPackageName)
	return s
}

func AppFqdnHeaderSlicer() []string {
	s := make([]string, 0, 5)
	s = append(s, "AppName")
	s = append(s, "AppVers")
	s = append(s, "DevName")
	s = append(s, "Fqdns")
	s = append(s, "AndroidPackageName")
	return s
}

func AppFqdnWriteOutputArray(objs []*distributed_match_engine.AppFqdn) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(AppFqdnHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(AppFqdnSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func AppFqdnWriteOutputOne(obj *distributed_match_engine.AppFqdn) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(AppFqdnHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(AppFqdnSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func FqdnListReplySlicer(in *distributed_match_engine.FqdnListReply) []string {
	s := make([]string, 0, 3)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	if in.AppFqdns == nil {
		in.AppFqdns = make([]*distributed_match_engine.AppFqdn, 1)
	}
	if in.AppFqdns[0] == nil {
		in.AppFqdns[0] = &distributed_match_engine.AppFqdn{}
	}
	s = append(s, in.AppFqdns[0].AppName)
	s = append(s, in.AppFqdns[0].AppVers)
	s = append(s, in.AppFqdns[0].DevName)
	if in.AppFqdns[0].Fqdns == nil {
		in.AppFqdns[0].Fqdns = make([]string, 1)
	}
	s = append(s, in.AppFqdns[0].Fqdns[0])
	s = append(s, in.AppFqdns[0].AndroidPackageName)
	s = append(s, distributed_match_engine.FqdnListReply_FLStatus_CamelName[int32(in.Status)])
	return s
}

func FqdnListReplyHeaderSlicer() []string {
	s := make([]string, 0, 3)
	s = append(s, "Ver")
	s = append(s, "AppFqdns-AppName")
	s = append(s, "AppFqdns-AppVers")
	s = append(s, "AppFqdns-DevName")
	s = append(s, "AppFqdns-Fqdns")
	s = append(s, "AppFqdns-AndroidPackageName")
	s = append(s, "Status")
	return s
}

func FqdnListReplyWriteOutputArray(objs []*distributed_match_engine.FqdnListReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(FqdnListReplyHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(FqdnListReplySlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func FqdnListReplyWriteOutputOne(obj *distributed_match_engine.FqdnListReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(FqdnListReplyHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(FqdnListReplySlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func DynamicLocGroupRequestSlicer(in *distributed_match_engine.DynamicLocGroupRequest) []string {
	s := make([]string, 0, 5)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, in.SessionCookie)
	s = append(s, strconv.FormatUint(uint64(in.LgId), 10))
	s = append(s, distributed_match_engine.DynamicLocGroupRequest_DlgCommType_CamelName[int32(in.CommType)])
	s = append(s, in.UserData)
	return s
}

func DynamicLocGroupRequestHeaderSlicer() []string {
	s := make([]string, 0, 5)
	s = append(s, "Ver")
	s = append(s, "SessionCookie")
	s = append(s, "LgId")
	s = append(s, "CommType")
	s = append(s, "UserData")
	return s
}

func DynamicLocGroupRequestWriteOutputArray(objs []*distributed_match_engine.DynamicLocGroupRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(DynamicLocGroupRequestHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(DynamicLocGroupRequestSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func DynamicLocGroupRequestWriteOutputOne(obj *distributed_match_engine.DynamicLocGroupRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(DynamicLocGroupRequestHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(DynamicLocGroupRequestSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func DynamicLocGroupReplySlicer(in *distributed_match_engine.DynamicLocGroupReply) []string {
	s := make([]string, 0, 4)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, distributed_match_engine.ReplyStatus_CamelName[int32(in.Status)])
	s = append(s, strconv.FormatUint(uint64(in.ErrorCode), 10))
	s = append(s, in.GroupCookie)
	return s
}

func DynamicLocGroupReplyHeaderSlicer() []string {
	s := make([]string, 0, 4)
	s = append(s, "Ver")
	s = append(s, "Status")
	s = append(s, "ErrorCode")
	s = append(s, "GroupCookie")
	return s
}

func DynamicLocGroupReplyWriteOutputArray(objs []*distributed_match_engine.DynamicLocGroupReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(DynamicLocGroupReplyHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(DynamicLocGroupReplySlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func DynamicLocGroupReplyWriteOutputOne(obj *distributed_match_engine.DynamicLocGroupReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(DynamicLocGroupReplyHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(DynamicLocGroupReplySlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func QosPositionSlicer(in *distributed_match_engine.QosPosition) []string {
	s := make([]string, 0, 2)
	s = append(s, strconv.FormatUint(uint64(in.Positionid), 10))
	if in.GpsLocation == nil {
		in.GpsLocation = &distributed_match_engine.Loc{}
	}
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Latitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Longitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.HorizontalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.VerticalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Altitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Course), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Speed), 'e', -1, 32))
	if in.GpsLocation.Timestamp == nil {
		in.GpsLocation.Timestamp = &distributed_match_engine.Timestamp{}
	}
	s = append(s, strconv.FormatUint(uint64(in.GpsLocation.Timestamp.Seconds), 10))
	s = append(s, strconv.FormatUint(uint64(in.GpsLocation.Timestamp.Nanos), 10))
	return s
}

func QosPositionHeaderSlicer() []string {
	s := make([]string, 0, 2)
	s = append(s, "Positionid")
	s = append(s, "GpsLocation-Latitude")
	s = append(s, "GpsLocation-Longitude")
	s = append(s, "GpsLocation-HorizontalAccuracy")
	s = append(s, "GpsLocation-VerticalAccuracy")
	s = append(s, "GpsLocation-Altitude")
	s = append(s, "GpsLocation-Course")
	s = append(s, "GpsLocation-Speed")
	s = append(s, "GpsLocation-Timestamp-Seconds")
	s = append(s, "GpsLocation-Timestamp-Nanos")
	return s
}

func QosPositionWriteOutputArray(objs []*distributed_match_engine.QosPosition) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(QosPositionHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(QosPositionSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func QosPositionWriteOutputOne(obj *distributed_match_engine.QosPosition) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(QosPositionHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(QosPositionSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func QosPositionKpiRequestSlicer(in *distributed_match_engine.QosPositionKpiRequest) []string {
	s := make([]string, 0, 3)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, in.SessionCookie)
	if in.Positions == nil {
		in.Positions = &distributed_match_engine.QosPosition{}
	}
	s = append(s, strconv.FormatUint(uint64(in.Positions.Positionid), 10))
	if in.Positions.GpsLocation == nil {
		in.Positions.GpsLocation = &distributed_match_engine.Loc{}
	}
	s = append(s, strconv.FormatFloat(float64(in.Positions.GpsLocation.Latitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.Positions.GpsLocation.Longitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.Positions.GpsLocation.HorizontalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.Positions.GpsLocation.VerticalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.Positions.GpsLocation.Altitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.Positions.GpsLocation.Course), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.Positions.GpsLocation.Speed), 'e', -1, 32))
	if in.Positions.GpsLocation.Timestamp == nil {
		in.Positions.GpsLocation.Timestamp = &distributed_match_engine.Timestamp{}
	}
	s = append(s, strconv.FormatUint(uint64(in.Positions.GpsLocation.Timestamp.Seconds), 10))
	s = append(s, strconv.FormatUint(uint64(in.Positions.GpsLocation.Timestamp.Nanos), 10))
	return s
}

func QosPositionKpiRequestHeaderSlicer() []string {
	s := make([]string, 0, 3)
	s = append(s, "Ver")
	s = append(s, "SessionCookie")
	s = append(s, "Positions-Positionid")
	s = append(s, "Positions-GpsLocation-Latitude")
	s = append(s, "Positions-GpsLocation-Longitude")
	s = append(s, "Positions-GpsLocation-HorizontalAccuracy")
	s = append(s, "Positions-GpsLocation-VerticalAccuracy")
	s = append(s, "Positions-GpsLocation-Altitude")
	s = append(s, "Positions-GpsLocation-Course")
	s = append(s, "Positions-GpsLocation-Speed")
	s = append(s, "Positions-GpsLocation-Timestamp-Seconds")
	s = append(s, "Positions-GpsLocation-Timestamp-Nanos")
	return s
}

func QosPositionKpiRequestWriteOutputArray(objs []*distributed_match_engine.QosPositionKpiRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(QosPositionKpiRequestHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(QosPositionKpiRequestSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func QosPositionKpiRequestWriteOutputOne(obj *distributed_match_engine.QosPositionKpiRequest) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(QosPositionKpiRequestHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(QosPositionKpiRequestSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func QosPositionKpiReplySlicer(in *distributed_match_engine.QosPositionKpiReply) []string {
	s := make([]string, 0, 3)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, distributed_match_engine.ReplyStatus_CamelName[int32(in.Status)])
	if in.PositionResults == nil {
		in.PositionResults = make([]*distributed_match_engine.PositionKpiResult, 1)
	}
	if in.PositionResults[0] == nil {
		in.PositionResults[0] = &distributed_match_engine.PositionKpiResult{}
	}
	s = append(s, strconv.FormatUint(uint64(in.PositionResults[0].Positionid), 10))
	return s
}

func QosPositionKpiReplyHeaderSlicer() []string {
	s := make([]string, 0, 3)
	s = append(s, "Ver")
	s = append(s, "Status")
	s = append(s, "PositionResults-Positionid")
	return s
}

func QosPositionKpiReplyWriteOutputArray(objs []*distributed_match_engine.QosPositionKpiReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(QosPositionKpiReplyHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(QosPositionKpiReplySlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func QosPositionKpiReplyWriteOutputOne(obj *distributed_match_engine.QosPositionKpiReply) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(QosPositionKpiReplyHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(QosPositionKpiReplySlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}

var RegisterClientCmd = &cobra.Command{
	Use: "RegisterClient",
	RunE: func(cmd *cobra.Command, args []string) error {
		// if we got this far, usage has been met.
		cmd.SilenceUsage = true
		return RegisterClient(&RegisterClientRequestIn)
	},
}

func RegisterClient(in *distributed_match_engine.RegisterClientRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.RegisterClient(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("RegisterClient failed: %s", errstr)
	}
	RegisterClientReplyWriteOutputOne(obj)
	return nil
}

func RegisterClients(data []distributed_match_engine.RegisterClientRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("RegisterClient %v\n", data[ii])
		myerr := RegisterClient(&data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var FindCloudletCmd = &cobra.Command{
	Use: "FindCloudlet",
	RunE: func(cmd *cobra.Command, args []string) error {
		// if we got this far, usage has been met.
		cmd.SilenceUsage = true
		return FindCloudlet(&FindCloudletRequestIn)
	},
}

func FindCloudlet(in *distributed_match_engine.FindCloudletRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.FindCloudlet(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("FindCloudlet failed: %s", errstr)
	}
	FindCloudletReplyWriteOutputOne(obj)
	return nil
}

func FindCloudlets(data []distributed_match_engine.FindCloudletRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("FindCloudlet %v\n", data[ii])
		myerr := FindCloudlet(&data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var VerifyLocationCmd = &cobra.Command{
	Use: "VerifyLocation",
	RunE: func(cmd *cobra.Command, args []string) error {
		// if we got this far, usage has been met.
		cmd.SilenceUsage = true
		return VerifyLocation(&VerifyLocationRequestIn)
	},
}

func VerifyLocation(in *distributed_match_engine.VerifyLocationRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.VerifyLocation(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("VerifyLocation failed: %s", errstr)
	}
	VerifyLocationReplyWriteOutputOne(obj)
	return nil
}

func VerifyLocations(data []distributed_match_engine.VerifyLocationRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("VerifyLocation %v\n", data[ii])
		myerr := VerifyLocation(&data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetLocationCmd = &cobra.Command{
	Use: "GetLocation",
	RunE: func(cmd *cobra.Command, args []string) error {
		// if we got this far, usage has been met.
		cmd.SilenceUsage = true
		return GetLocation(&GetLocationRequestIn)
	},
}

func GetLocation(in *distributed_match_engine.GetLocationRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.GetLocation(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetLocation failed: %s", errstr)
	}
	GetLocationReplyWriteOutputOne(obj)
	return nil
}

func GetLocations(data []distributed_match_engine.GetLocationRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetLocation %v\n", data[ii])
		myerr := GetLocation(&data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var AddUserToGroupCmd = &cobra.Command{
	Use: "AddUserToGroup",
	RunE: func(cmd *cobra.Command, args []string) error {
		// if we got this far, usage has been met.
		cmd.SilenceUsage = true
		err := parseDynamicLocGroupRequestEnums()
		if err != nil {
			return fmt.Errorf("AddUserToGroup failed: %s", err.Error())
		}
		return AddUserToGroup(&DynamicLocGroupRequestIn)
	},
}

func AddUserToGroup(in *distributed_match_engine.DynamicLocGroupRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.AddUserToGroup(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("AddUserToGroup failed: %s", errstr)
	}
	DynamicLocGroupReplyWriteOutputOne(obj)
	return nil
}

func AddUserToGroups(data []distributed_match_engine.DynamicLocGroupRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("AddUserToGroup %v\n", data[ii])
		myerr := AddUserToGroup(&data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetAppInstListCmd = &cobra.Command{
	Use: "GetAppInstList",
	RunE: func(cmd *cobra.Command, args []string) error {
		// if we got this far, usage has been met.
		cmd.SilenceUsage = true
		return GetAppInstList(&AppInstListRequestIn)
	},
}

func GetAppInstList(in *distributed_match_engine.AppInstListRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.GetAppInstList(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetAppInstList failed: %s", errstr)
	}
	AppInstListReplyWriteOutputOne(obj)
	return nil
}

func GetAppInstLists(data []distributed_match_engine.AppInstListRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetAppInstList %v\n", data[ii])
		myerr := GetAppInstList(&data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetFqdnListCmd = &cobra.Command{
	Use: "GetFqdnList",
	RunE: func(cmd *cobra.Command, args []string) error {
		// if we got this far, usage has been met.
		cmd.SilenceUsage = true
		return GetFqdnList(&FqdnListRequestIn)
	},
}

func GetFqdnList(in *distributed_match_engine.FqdnListRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.GetFqdnList(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetFqdnList failed: %s", errstr)
	}
	FqdnListReplyWriteOutputOne(obj)
	return nil
}

func GetFqdnLists(data []distributed_match_engine.FqdnListRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetFqdnList %v\n", data[ii])
		myerr := GetFqdnList(&data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetQosPositionKpiCmd = &cobra.Command{
	Use: "GetQosPositionKpi",
	RunE: func(cmd *cobra.Command, args []string) error {
		// if we got this far, usage has been met.
		cmd.SilenceUsage = true
		return GetQosPositionKpi(&QosPositionKpiRequestIn)
	},
}

func GetQosPositionKpi(in *distributed_match_engine.QosPositionKpiRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.GetQosPositionKpi(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetQosPositionKpi failed: %s", errstr)
	}
	QosPositionKpiReplyWriteOutputOne(obj)
	return nil
}

func GetQosPositionKpis(data []distributed_match_engine.QosPositionKpiRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetQosPositionKpi %v\n", data[ii])
		myerr := GetQosPositionKpi(&data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var MatchEngineApiCmds = []*cobra.Command{
	RegisterClientCmd,
	FindCloudletCmd,
	VerifyLocationCmd,
	GetLocationCmd,
	AddUserToGroupCmd,
	GetAppInstListCmd,
	GetFqdnListCmd,
	GetQosPositionKpiCmd,
}

func init() {
	RegisterClientRequestFlagSet.Uint32Var(&RegisterClientRequestIn.Ver, "ver", 0, "Ver")
	RegisterClientRequestFlagSet.StringVar(&RegisterClientRequestIn.DevName, "devname", "", "DevName")
	RegisterClientRequestFlagSet.StringVar(&RegisterClientRequestIn.AppName, "appname", "", "AppName")
	RegisterClientRequestFlagSet.StringVar(&RegisterClientRequestIn.AppVers, "appvers", "", "AppVers")
	RegisterClientRequestFlagSet.StringVar(&RegisterClientRequestIn.CarrierName, "carriername", "", "CarrierName")
	RegisterClientRequestFlagSet.StringVar(&RegisterClientRequestIn.AuthToken, "authtoken", "", "AuthToken")
	FindCloudletRequestFlagSet.Uint32Var(&FindCloudletRequestIn.Ver, "ver", 0, "Ver")
	FindCloudletRequestFlagSet.StringVar(&FindCloudletRequestIn.SessionCookie, "sessioncookie", "", "SessionCookie")
	FindCloudletRequestFlagSet.StringVar(&FindCloudletRequestIn.CarrierName, "carriername", "", "CarrierName")
	FindCloudletRequestIn.GpsLocation = &distributed_match_engine.Loc{}
	FindCloudletRequestFlagSet.Float64Var(&FindCloudletRequestIn.GpsLocation.Latitude, "gpslocation-latitude", 0, "GpsLocation.Latitude")
	FindCloudletRequestFlagSet.Float64Var(&FindCloudletRequestIn.GpsLocation.Longitude, "gpslocation-longitude", 0, "GpsLocation.Longitude")
	FindCloudletRequestFlagSet.Float64Var(&FindCloudletRequestIn.GpsLocation.HorizontalAccuracy, "gpslocation-horizontalaccuracy", 0, "GpsLocation.HorizontalAccuracy")
	FindCloudletRequestFlagSet.Float64Var(&FindCloudletRequestIn.GpsLocation.VerticalAccuracy, "gpslocation-verticalaccuracy", 0, "GpsLocation.VerticalAccuracy")
	FindCloudletRequestFlagSet.Float64Var(&FindCloudletRequestIn.GpsLocation.Altitude, "gpslocation-altitude", 0, "GpsLocation.Altitude")
	FindCloudletRequestFlagSet.Float64Var(&FindCloudletRequestIn.GpsLocation.Course, "gpslocation-course", 0, "GpsLocation.Course")
	FindCloudletRequestFlagSet.Float64Var(&FindCloudletRequestIn.GpsLocation.Speed, "gpslocation-speed", 0, "GpsLocation.Speed")
	FindCloudletRequestIn.GpsLocation.Timestamp = &distributed_match_engine.Timestamp{}
	FindCloudletRequestFlagSet.Int64Var(&FindCloudletRequestIn.GpsLocation.Timestamp.Seconds, "gpslocation-timestamp-seconds", 0, "GpsLocation.Timestamp.Seconds")
	FindCloudletRequestFlagSet.Int32Var(&FindCloudletRequestIn.GpsLocation.Timestamp.Nanos, "gpslocation-timestamp-nanos", 0, "GpsLocation.Timestamp.Nanos")
	FindCloudletRequestFlagSet.StringVar(&FindCloudletRequestIn.DevName, "devname", "", "DevName")
	FindCloudletRequestFlagSet.StringVar(&FindCloudletRequestIn.AppName, "appname", "", "AppName")
	FindCloudletRequestFlagSet.StringVar(&FindCloudletRequestIn.AppVers, "appvers", "", "AppVers")
	VerifyLocationRequestFlagSet.Uint32Var(&VerifyLocationRequestIn.Ver, "ver", 0, "Ver")
	VerifyLocationRequestFlagSet.StringVar(&VerifyLocationRequestIn.SessionCookie, "sessioncookie", "", "SessionCookie")
	VerifyLocationRequestFlagSet.StringVar(&VerifyLocationRequestIn.CarrierName, "carriername", "", "CarrierName")
	VerifyLocationRequestIn.GpsLocation = &distributed_match_engine.Loc{}
	VerifyLocationRequestFlagSet.Float64Var(&VerifyLocationRequestIn.GpsLocation.Latitude, "gpslocation-latitude", 0, "GpsLocation.Latitude")
	VerifyLocationRequestFlagSet.Float64Var(&VerifyLocationRequestIn.GpsLocation.Longitude, "gpslocation-longitude", 0, "GpsLocation.Longitude")
	VerifyLocationRequestFlagSet.Float64Var(&VerifyLocationRequestIn.GpsLocation.HorizontalAccuracy, "gpslocation-horizontalaccuracy", 0, "GpsLocation.HorizontalAccuracy")
	VerifyLocationRequestFlagSet.Float64Var(&VerifyLocationRequestIn.GpsLocation.VerticalAccuracy, "gpslocation-verticalaccuracy", 0, "GpsLocation.VerticalAccuracy")
	VerifyLocationRequestFlagSet.Float64Var(&VerifyLocationRequestIn.GpsLocation.Altitude, "gpslocation-altitude", 0, "GpsLocation.Altitude")
	VerifyLocationRequestFlagSet.Float64Var(&VerifyLocationRequestIn.GpsLocation.Course, "gpslocation-course", 0, "GpsLocation.Course")
	VerifyLocationRequestFlagSet.Float64Var(&VerifyLocationRequestIn.GpsLocation.Speed, "gpslocation-speed", 0, "GpsLocation.Speed")
	VerifyLocationRequestIn.GpsLocation.Timestamp = &distributed_match_engine.Timestamp{}
	VerifyLocationRequestFlagSet.Int64Var(&VerifyLocationRequestIn.GpsLocation.Timestamp.Seconds, "gpslocation-timestamp-seconds", 0, "GpsLocation.Timestamp.Seconds")
	VerifyLocationRequestFlagSet.Int32Var(&VerifyLocationRequestIn.GpsLocation.Timestamp.Nanos, "gpslocation-timestamp-nanos", 0, "GpsLocation.Timestamp.Nanos")
	VerifyLocationRequestFlagSet.StringVar(&VerifyLocationRequestIn.VerifyLocToken, "verifyloctoken", "", "VerifyLocToken")
	GetLocationRequestFlagSet.Uint32Var(&GetLocationRequestIn.Ver, "ver", 0, "Ver")
	GetLocationRequestFlagSet.StringVar(&GetLocationRequestIn.SessionCookie, "sessioncookie", "", "SessionCookie")
	GetLocationRequestFlagSet.StringVar(&GetLocationRequestIn.CarrierName, "carriername", "", "CarrierName")
	AppInstListRequestFlagSet.Uint32Var(&AppInstListRequestIn.Ver, "ver", 0, "Ver")
	AppInstListRequestFlagSet.StringVar(&AppInstListRequestIn.SessionCookie, "sessioncookie", "", "SessionCookie")
	AppInstListRequestFlagSet.StringVar(&AppInstListRequestIn.CarrierName, "carriername", "", "CarrierName")
	AppInstListRequestIn.GpsLocation = &distributed_match_engine.Loc{}
	AppInstListRequestFlagSet.Float64Var(&AppInstListRequestIn.GpsLocation.Latitude, "gpslocation-latitude", 0, "GpsLocation.Latitude")
	AppInstListRequestFlagSet.Float64Var(&AppInstListRequestIn.GpsLocation.Longitude, "gpslocation-longitude", 0, "GpsLocation.Longitude")
	AppInstListRequestFlagSet.Float64Var(&AppInstListRequestIn.GpsLocation.HorizontalAccuracy, "gpslocation-horizontalaccuracy", 0, "GpsLocation.HorizontalAccuracy")
	AppInstListRequestFlagSet.Float64Var(&AppInstListRequestIn.GpsLocation.VerticalAccuracy, "gpslocation-verticalaccuracy", 0, "GpsLocation.VerticalAccuracy")
	AppInstListRequestFlagSet.Float64Var(&AppInstListRequestIn.GpsLocation.Altitude, "gpslocation-altitude", 0, "GpsLocation.Altitude")
	AppInstListRequestFlagSet.Float64Var(&AppInstListRequestIn.GpsLocation.Course, "gpslocation-course", 0, "GpsLocation.Course")
	AppInstListRequestFlagSet.Float64Var(&AppInstListRequestIn.GpsLocation.Speed, "gpslocation-speed", 0, "GpsLocation.Speed")
	AppInstListRequestIn.GpsLocation.Timestamp = &distributed_match_engine.Timestamp{}
	AppInstListRequestFlagSet.Int64Var(&AppInstListRequestIn.GpsLocation.Timestamp.Seconds, "gpslocation-timestamp-seconds", 0, "GpsLocation.Timestamp.Seconds")
	AppInstListRequestFlagSet.Int32Var(&AppInstListRequestIn.GpsLocation.Timestamp.Nanos, "gpslocation-timestamp-nanos", 0, "GpsLocation.Timestamp.Nanos")
	FqdnListRequestFlagSet.Uint32Var(&FqdnListRequestIn.Ver, "ver", 0, "Ver")
	FqdnListRequestFlagSet.StringVar(&FqdnListRequestIn.SessionCookie, "sessioncookie", "", "SessionCookie")
	DynamicLocGroupRequestFlagSet.Uint32Var(&DynamicLocGroupRequestIn.Ver, "ver", 0, "Ver")
	DynamicLocGroupRequestFlagSet.StringVar(&DynamicLocGroupRequestIn.SessionCookie, "sessioncookie", "", "SessionCookie")
	DynamicLocGroupRequestFlagSet.Uint64Var(&DynamicLocGroupRequestIn.LgId, "lgid", 0, "LgId")
	DynamicLocGroupRequestFlagSet.StringVar(&DynamicLocGroupRequestInCommType, "commtype", "", "one of [DlgUndefined DlgSecure DlgOpen]")
	DynamicLocGroupRequestFlagSet.StringVar(&DynamicLocGroupRequestIn.UserData, "userdata", "", "UserData")
	QosPositionKpiRequestFlagSet.Uint32Var(&QosPositionKpiRequestIn.Ver, "ver", 0, "Ver")
	QosPositionKpiRequestFlagSet.StringVar(&QosPositionKpiRequestIn.SessionCookie, "sessioncookie", "", "SessionCookie")
	QosPositionKpiRequestIn.Positions = &distributed_match_engine.QosPosition{}
	QosPositionKpiRequestFlagSet.Int64Var(&QosPositionKpiRequestIn.Positions.Positionid, "positions-positionid", 0, "Positions.Positionid")
	QosPositionKpiRequestIn.Positions.GpsLocation = &distributed_match_engine.Loc{}
	QosPositionKpiRequestFlagSet.Float64Var(&QosPositionKpiRequestIn.Positions.GpsLocation.Latitude, "positions-gpslocation-latitude", 0, "Positions.GpsLocation.Latitude")
	QosPositionKpiRequestFlagSet.Float64Var(&QosPositionKpiRequestIn.Positions.GpsLocation.Longitude, "positions-gpslocation-longitude", 0, "Positions.GpsLocation.Longitude")
	QosPositionKpiRequestFlagSet.Float64Var(&QosPositionKpiRequestIn.Positions.GpsLocation.HorizontalAccuracy, "positions-gpslocation-horizontalaccuracy", 0, "Positions.GpsLocation.HorizontalAccuracy")
	QosPositionKpiRequestFlagSet.Float64Var(&QosPositionKpiRequestIn.Positions.GpsLocation.VerticalAccuracy, "positions-gpslocation-verticalaccuracy", 0, "Positions.GpsLocation.VerticalAccuracy")
	QosPositionKpiRequestFlagSet.Float64Var(&QosPositionKpiRequestIn.Positions.GpsLocation.Altitude, "positions-gpslocation-altitude", 0, "Positions.GpsLocation.Altitude")
	QosPositionKpiRequestFlagSet.Float64Var(&QosPositionKpiRequestIn.Positions.GpsLocation.Course, "positions-gpslocation-course", 0, "Positions.GpsLocation.Course")
	QosPositionKpiRequestFlagSet.Float64Var(&QosPositionKpiRequestIn.Positions.GpsLocation.Speed, "positions-gpslocation-speed", 0, "Positions.GpsLocation.Speed")
	QosPositionKpiRequestIn.Positions.GpsLocation.Timestamp = &distributed_match_engine.Timestamp{}
	QosPositionKpiRequestFlagSet.Int64Var(&QosPositionKpiRequestIn.Positions.GpsLocation.Timestamp.Seconds, "positions-gpslocation-timestamp-seconds", 0, "Positions.GpsLocation.Timestamp.Seconds")
	QosPositionKpiRequestFlagSet.Int32Var(&QosPositionKpiRequestIn.Positions.GpsLocation.Timestamp.Nanos, "positions-gpslocation-timestamp-nanos", 0, "Positions.GpsLocation.Timestamp.Nanos")
	RegisterClientCmd.Flags().AddFlagSet(RegisterClientRequestFlagSet)
	FindCloudletCmd.Flags().AddFlagSet(FindCloudletRequestFlagSet)
	VerifyLocationCmd.Flags().AddFlagSet(VerifyLocationRequestFlagSet)
	GetLocationCmd.Flags().AddFlagSet(GetLocationRequestFlagSet)
	AddUserToGroupCmd.Flags().AddFlagSet(DynamicLocGroupRequestFlagSet)
	GetAppInstListCmd.Flags().AddFlagSet(AppInstListRequestFlagSet)
	GetFqdnListCmd.Flags().AddFlagSet(FqdnListRequestFlagSet)
	GetQosPositionKpiCmd.Flags().AddFlagSet(QosPositionKpiRequestFlagSet)
}

func MatchEngineApiAllowNoConfig() {
	RegisterClientCmd.Flags().AddFlagSet(RegisterClientRequestNoConfigFlagSet)
	FindCloudletCmd.Flags().AddFlagSet(FindCloudletRequestNoConfigFlagSet)
	VerifyLocationCmd.Flags().AddFlagSet(VerifyLocationRequestNoConfigFlagSet)
	GetLocationCmd.Flags().AddFlagSet(GetLocationRequestNoConfigFlagSet)
	AddUserToGroupCmd.Flags().AddFlagSet(DynamicLocGroupRequestNoConfigFlagSet)
	GetAppInstListCmd.Flags().AddFlagSet(AppInstListRequestNoConfigFlagSet)
	GetFqdnListCmd.Flags().AddFlagSet(FqdnListRequestNoConfigFlagSet)
	GetQosPositionKpiCmd.Flags().AddFlagSet(QosPositionKpiRequestNoConfigFlagSet)
}

func parseDynamicLocGroupRequestEnums() error {
	if DynamicLocGroupRequestInCommType != "" {
		switch DynamicLocGroupRequestInCommType {
		case "DlgUndefined":
			DynamicLocGroupRequestIn.CommType = distributed_match_engine.DynamicLocGroupRequest_DlgCommType(0)
		case "DlgSecure":
			DynamicLocGroupRequestIn.CommType = distributed_match_engine.DynamicLocGroupRequest_DlgCommType(1)
		case "DlgOpen":
			DynamicLocGroupRequestIn.CommType = distributed_match_engine.DynamicLocGroupRequest_DlgCommType(2)
		default:
			return errors.New("Invalid value for DynamicLocGroupRequestInCommType")
		}
	}
	return nil
}
