// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app-client.proto

/*
Package gencmd is a generated protocol buffer package.

It is generated from these files:
	app-client.proto
	appcommon.proto
	dynamic-location-group.proto
	loc.proto

It has these top-level messages:
	RegisterClientRequest
	RegisterClientReply
	FindCloudletRequest
	FindCloudletReply
	VerifyLocationRequest
	VerifyLocationReply
	GetLocationRequest
	GetLocationReply
	AppInstListRequest
	Appinstance
	CloudletLocation
	AppInstListReply
	FqdnListRequest
	AppFqdn
	FqdnListReply
	DynamicLocGroupRequest
	DynamicLocGroupReply
	QosPosition
	BandSelection
	QosPositionRequest
	QosPositionKpiResult
	QosPositionKpiReply
	AppPort
	DlgMessage
	DlgReply
	Timestamp
	Loc
*/
package gencmd

import distributed_match_engine "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto"
import "strings"
import "github.com/spf13/cobra"
import "context"
import "io"
import "github.com/mobiledgex/edge-cloud/cli"
import "google.golang.org/grpc/status"
import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Auto-generated code: DO NOT EDIT
var MatchEngineApiCmd distributed_match_engine.MatchEngineApiClient

var RegisterClientCmd = &cli.Command{
	Use:          "RegisterClient",
	RequiredArgs: strings.Join(RegisterClientRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(RegisterClientRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(RegisterClientRequestAliasArgs, " "),
	SpecialArgs:  &RegisterClientRequestSpecialArgs,
	Comments:     RegisterClientRequestComments,
	ReqData:      &distributed_match_engine.RegisterClientRequest{},
	ReplyData:    &distributed_match_engine.RegisterClientReply{},
	Run:          runRegisterClient,
}

func runRegisterClient(c *cli.Command, args []string) error {
	obj := c.ReqData.(*distributed_match_engine.RegisterClientRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return RegisterClient(c, obj)
}

func RegisterClient(c *cli.Command, in *distributed_match_engine.RegisterClientRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.RegisterClient(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("RegisterClient failed: %s", errstr)
	}
	c.WriteOutput(obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func RegisterClients(c *cli.Command, data []distributed_match_engine.RegisterClientRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("RegisterClient %v\n", data[ii])
		myerr := RegisterClient(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var FindCloudletCmd = &cli.Command{
	Use:          "FindCloudlet",
	RequiredArgs: strings.Join(FindCloudletRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(FindCloudletRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(FindCloudletRequestAliasArgs, " "),
	SpecialArgs:  &FindCloudletRequestSpecialArgs,
	Comments:     FindCloudletRequestComments,
	ReqData:      &distributed_match_engine.FindCloudletRequest{},
	ReplyData:    &distributed_match_engine.FindCloudletReply{},
	Run:          runFindCloudlet,
}

func runFindCloudlet(c *cli.Command, args []string) error {
	obj := c.ReqData.(*distributed_match_engine.FindCloudletRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return FindCloudlet(c, obj)
}

func FindCloudlet(c *cli.Command, in *distributed_match_engine.FindCloudletRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.FindCloudlet(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("FindCloudlet failed: %s", errstr)
	}
	c.WriteOutput(obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func FindCloudlets(c *cli.Command, data []distributed_match_engine.FindCloudletRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("FindCloudlet %v\n", data[ii])
		myerr := FindCloudlet(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var VerifyLocationCmd = &cli.Command{
	Use:          "VerifyLocation",
	RequiredArgs: strings.Join(VerifyLocationRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(VerifyLocationRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(VerifyLocationRequestAliasArgs, " "),
	SpecialArgs:  &VerifyLocationRequestSpecialArgs,
	Comments:     VerifyLocationRequestComments,
	ReqData:      &distributed_match_engine.VerifyLocationRequest{},
	ReplyData:    &distributed_match_engine.VerifyLocationReply{},
	Run:          runVerifyLocation,
}

func runVerifyLocation(c *cli.Command, args []string) error {
	obj := c.ReqData.(*distributed_match_engine.VerifyLocationRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return VerifyLocation(c, obj)
}

func VerifyLocation(c *cli.Command, in *distributed_match_engine.VerifyLocationRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.VerifyLocation(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("VerifyLocation failed: %s", errstr)
	}
	c.WriteOutput(obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func VerifyLocations(c *cli.Command, data []distributed_match_engine.VerifyLocationRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("VerifyLocation %v\n", data[ii])
		myerr := VerifyLocation(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetLocationCmd = &cli.Command{
	Use:          "GetLocation",
	RequiredArgs: strings.Join(GetLocationRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(GetLocationRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(GetLocationRequestAliasArgs, " "),
	SpecialArgs:  &GetLocationRequestSpecialArgs,
	Comments:     GetLocationRequestComments,
	ReqData:      &distributed_match_engine.GetLocationRequest{},
	ReplyData:    &distributed_match_engine.GetLocationReply{},
	Run:          runGetLocation,
}

func runGetLocation(c *cli.Command, args []string) error {
	obj := c.ReqData.(*distributed_match_engine.GetLocationRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetLocation(c, obj)
}

func GetLocation(c *cli.Command, in *distributed_match_engine.GetLocationRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.GetLocation(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetLocation failed: %s", errstr)
	}
	c.WriteOutput(obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetLocations(c *cli.Command, data []distributed_match_engine.GetLocationRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetLocation %v\n", data[ii])
		myerr := GetLocation(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var AddUserToGroupCmd = &cli.Command{
	Use:          "AddUserToGroup",
	RequiredArgs: strings.Join(DynamicLocGroupRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(DynamicLocGroupRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(DynamicLocGroupRequestAliasArgs, " "),
	SpecialArgs:  &DynamicLocGroupRequestSpecialArgs,
	Comments:     DynamicLocGroupRequestComments,
	ReqData:      &distributed_match_engine.DynamicLocGroupRequest{},
	ReplyData:    &distributed_match_engine.DynamicLocGroupReply{},
	Run:          runAddUserToGroup,
}

func runAddUserToGroup(c *cli.Command, args []string) error {
	obj := c.ReqData.(*distributed_match_engine.DynamicLocGroupRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return AddUserToGroup(c, obj)
}

func AddUserToGroup(c *cli.Command, in *distributed_match_engine.DynamicLocGroupRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.AddUserToGroup(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("AddUserToGroup failed: %s", errstr)
	}
	c.WriteOutput(obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func AddUserToGroups(c *cli.Command, data []distributed_match_engine.DynamicLocGroupRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("AddUserToGroup %v\n", data[ii])
		myerr := AddUserToGroup(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetAppInstListCmd = &cli.Command{
	Use:          "GetAppInstList",
	RequiredArgs: strings.Join(AppInstListRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(AppInstListRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(AppInstListRequestAliasArgs, " "),
	SpecialArgs:  &AppInstListRequestSpecialArgs,
	Comments:     AppInstListRequestComments,
	ReqData:      &distributed_match_engine.AppInstListRequest{},
	ReplyData:    &distributed_match_engine.AppInstListReply{},
	Run:          runGetAppInstList,
}

func runGetAppInstList(c *cli.Command, args []string) error {
	obj := c.ReqData.(*distributed_match_engine.AppInstListRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetAppInstList(c, obj)
}

func GetAppInstList(c *cli.Command, in *distributed_match_engine.AppInstListRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.GetAppInstList(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetAppInstList failed: %s", errstr)
	}
	c.WriteOutput(obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetAppInstLists(c *cli.Command, data []distributed_match_engine.AppInstListRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetAppInstList %v\n", data[ii])
		myerr := GetAppInstList(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetFqdnListCmd = &cli.Command{
	Use:          "GetFqdnList",
	RequiredArgs: strings.Join(FqdnListRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(FqdnListRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(FqdnListRequestAliasArgs, " "),
	SpecialArgs:  &FqdnListRequestSpecialArgs,
	Comments:     FqdnListRequestComments,
	ReqData:      &distributed_match_engine.FqdnListRequest{},
	ReplyData:    &distributed_match_engine.FqdnListReply{},
	Run:          runGetFqdnList,
}

func runGetFqdnList(c *cli.Command, args []string) error {
	obj := c.ReqData.(*distributed_match_engine.FqdnListRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetFqdnList(c, obj)
}

func GetFqdnList(c *cli.Command, in *distributed_match_engine.FqdnListRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.GetFqdnList(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetFqdnList failed: %s", errstr)
	}
	c.WriteOutput(obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetFqdnLists(c *cli.Command, data []distributed_match_engine.FqdnListRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetFqdnList %v\n", data[ii])
		myerr := GetFqdnList(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetQosPositionKpiCmd = &cli.Command{
	Use:          "GetQosPositionKpi",
	RequiredArgs: strings.Join(QosPositionRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(QosPositionRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(QosPositionRequestAliasArgs, " "),
	SpecialArgs:  &QosPositionRequestSpecialArgs,
	Comments:     QosPositionRequestComments,
	ReqData:      &distributed_match_engine.QosPositionRequest{},
	ReplyData:    &distributed_match_engine.QosPositionKpiReply{},
	Run:          runGetQosPositionKpi,
}

func runGetQosPositionKpi(c *cli.Command, args []string) error {
	obj := c.ReqData.(*distributed_match_engine.QosPositionRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetQosPositionKpi(c, obj)
}

func GetQosPositionKpi(c *cli.Command, in *distributed_match_engine.QosPositionRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	stream, err := MatchEngineApiCmd.GetQosPositionKpi(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetQosPositionKpi failed: %s", errstr)
	}
	objs := make([]*distributed_match_engine.QosPositionKpiReply, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("GetQosPositionKpi recv failed: %s", errstr)
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetQosPositionKpis(c *cli.Command, data []distributed_match_engine.QosPositionRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetQosPositionKpi %v\n", data[ii])
		myerr := GetQosPositionKpi(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var MatchEngineApiCmds = []*cobra.Command{
	RegisterClientCmd.GenCmd(),
	FindCloudletCmd.GenCmd(),
	VerifyLocationCmd.GenCmd(),
	GetLocationCmd.GenCmd(),
	AddUserToGroupCmd.GenCmd(),
	GetAppInstListCmd.GenCmd(),
	GetFqdnListCmd.GenCmd(),
	GetQosPositionKpiCmd.GenCmd(),
}

var RegisterClientRequestRequiredArgs = []string{}
var RegisterClientRequestOptionalArgs = []string{
	"ver",
	"devname",
	"appname",
	"appvers",
	"carriername",
	"authtoken",
}
var RegisterClientRequestAliasArgs = []string{}
var RegisterClientRequestComments = map[string]string{
	"ver":         "API version",
	"devname":     "App Developer Name",
	"appname":     "App Name",
	"appvers":     "App Version",
	"carriername": "carrier name, not currently used",
	"authtoken":   "authentication token",
}
var RegisterClientRequestSpecialArgs = map[string]string{}
var RegisterClientReplyRequiredArgs = []string{}
var RegisterClientReplyOptionalArgs = []string{
	"ver",
	"status",
	"sessioncookie",
	"tokenserveruri",
}
var RegisterClientReplyAliasArgs = []string{}
var RegisterClientReplyComments = map[string]string{
	"ver":            "API version",
	"status":         "Status of the reply, one of RsUndefined, RsSuccess, RsFail",
	"sessioncookie":  "Session Cookie to be used in later API calls",
	"tokenserveruri": "URI for Token Server",
}
var RegisterClientReplySpecialArgs = map[string]string{}
var FindCloudletRequestRequiredArgs = []string{}
var FindCloudletRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"carriername",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp.seconds",
	"gpslocation.timestamp.nanos",
	"devname",
	"appname",
	"appvers",
}
var FindCloudletRequestAliasArgs = []string{}
var FindCloudletRequestComments = map[string]string{
	"ver":                            "API version",
	"sessioncookie":                  "Session Cookie from RegisterClientRequest",
	"carriername":                    "The carrier name that the user is connected to (Cellular Carrier Name)",
	"gpslocation.latitude":           "latitude in WGS 84 coordinates",
	"gpslocation.longitude":          "longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy": "horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":   "vertical accuracy (meters)",
	"gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied altitude in meters",
	"gpslocation.course":             "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":              "speed (IOS) / velocity (Android) (meters/sec)",
	"devname":                        "DevName is applicable to Platform apps only",
	"appname":                        "App Name is applicable to Platform apps only",
	"appvers":                        "App Version is applicable to Platform apps only",
}
var FindCloudletRequestSpecialArgs = map[string]string{}
var FindCloudletReplyRequiredArgs = []string{}
var FindCloudletReplyOptionalArgs = []string{
	"ver",
	"status",
	"fqdn",
	"ports.proto",
	"ports.internalport",
	"ports.publicport",
	"ports.pathprefix",
	"ports.fqdnprefix",
	"ports.endport",
	"cloudletlocation.latitude",
	"cloudletlocation.longitude",
	"cloudletlocation.horizontalaccuracy",
	"cloudletlocation.verticalaccuracy",
	"cloudletlocation.altitude",
	"cloudletlocation.course",
	"cloudletlocation.speed",
	"cloudletlocation.timestamp.seconds",
	"cloudletlocation.timestamp.nanos",
}
var FindCloudletReplyAliasArgs = []string{}
var FindCloudletReplyComments = map[string]string{
	"ver":                                 "API version",
	"status":                              "Status return, one of FindUnknown, FindFound, FindNotfound",
	"fqdn":                                "Fully Qualified Domain Name of the Closest App instance",
	"ports.proto":                         "TCP (L4), UDP (L4), or HTTP (L7) protocol, one of LProtoUnknown, LProtoTcp, LProtoUdp, LProtoHttp",
	"ports.internalport":                  "Container port",
	"ports.publicport":                    "Public facing port for TCP/UDP (may be mapped on shared LB reverse proxy)",
	"ports.pathprefix":                    "Public facing path for HTTP L7 access.",
	"ports.fqdnprefix":                    "FQDN prefix to append to base FQDN in FindCloudlet response. May be empty.",
	"ports.endport":                       "A non-zero end port indicates a port range from internal port to end port, inclusive.",
	"cloudletlocation.latitude":           "latitude in WGS 84 coordinates",
	"cloudletlocation.longitude":          "longitude in WGS 84 coordinates",
	"cloudletlocation.horizontalaccuracy": "horizontal accuracy (radius in meters)",
	"cloudletlocation.verticalaccuracy":   "vertical accuracy (meters)",
	"cloudletlocation.altitude":           "On android only lat and long are guaranteed to be supplied altitude in meters",
	"cloudletlocation.course":             "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"cloudletlocation.speed":              "speed (IOS) / velocity (Android) (meters/sec)",
}
var FindCloudletReplySpecialArgs = map[string]string{}
var VerifyLocationRequestRequiredArgs = []string{}
var VerifyLocationRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"carriername",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp.seconds",
	"gpslocation.timestamp.nanos",
	"verifyloctoken",
}
var VerifyLocationRequestAliasArgs = []string{}
var VerifyLocationRequestComments = map[string]string{
	"ver":                            "API version",
	"sessioncookie":                  "Session Cookie from RegisterClientRequest",
	"carriername":                    "The carrier name that the user is connected to (Cellular Carrier Name)",
	"gpslocation.latitude":           "latitude in WGS 84 coordinates",
	"gpslocation.longitude":          "longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy": "horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":   "vertical accuracy (meters)",
	"gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied altitude in meters",
	"gpslocation.course":             "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":              "speed (IOS) / velocity (Android) (meters/sec)",
	"verifyloctoken":                 "token used for location verification, app must be retrieve from TokenServerURI",
}
var VerifyLocationRequestSpecialArgs = map[string]string{}
var VerifyLocationReplyRequiredArgs = []string{}
var VerifyLocationReplyOptionalArgs = []string{
	"ver",
	"towerstatus",
	"gpslocationstatus",
	"gpslocationaccuracykm",
}
var VerifyLocationReplyAliasArgs = []string{}
var VerifyLocationReplyComments = map[string]string{
	"ver":                   "API version",
	"towerstatus":           ", one of TowerUnknown, ConnectedToSpecifiedTower, NotConnectedToSpecifiedTower",
	"gpslocationstatus":     ", one of LocUnknown, LocVerified, LocMismatchSameCountry, LocMismatchOtherCountry, LocRoamingCountryMatch, LocRoamingCountryMismatch, LocErrorUnauthorized, LocErrorOther",
	"gpslocationaccuracykm": "location accuracy, the location is verified to be within this number of kilometers.  Negative value means no verification was performed",
}
var VerifyLocationReplySpecialArgs = map[string]string{}
var GetLocationRequestRequiredArgs = []string{}
var GetLocationRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"carriername",
}
var GetLocationRequestAliasArgs = []string{}
var GetLocationRequestComments = map[string]string{
	"ver":           "API version",
	"sessioncookie": "Session Cookie from RegisterClientRequest",
	"carriername":   "The carrier name that the user is connected to (Cellular Carrier Name)",
}
var GetLocationRequestSpecialArgs = map[string]string{}
var GetLocationReplyRequiredArgs = []string{}
var GetLocationReplyOptionalArgs = []string{
	"ver",
	"status",
	"carriername",
	"tower",
	"networklocation.latitude",
	"networklocation.longitude",
	"networklocation.horizontalaccuracy",
	"networklocation.verticalaccuracy",
	"networklocation.altitude",
	"networklocation.course",
	"networklocation.speed",
	"networklocation.timestamp.seconds",
	"networklocation.timestamp.nanos",
}
var GetLocationReplyAliasArgs = []string{}
var GetLocationReplyComments = map[string]string{
	"status":                             ", one of LocUnknown, LocFound, LocDenied",
	"carriername":                        "The carrier name that the user is connected to (Cellular Carrier Name)",
	"tower":                              "The tower that user is currently connected to",
	"networklocation.latitude":           "latitude in WGS 84 coordinates",
	"networklocation.longitude":          "longitude in WGS 84 coordinates",
	"networklocation.horizontalaccuracy": "horizontal accuracy (radius in meters)",
	"networklocation.verticalaccuracy":   "vertical accuracy (meters)",
	"networklocation.altitude":           "On android only lat and long are guaranteed to be supplied altitude in meters",
	"networklocation.course":             "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"networklocation.speed":              "speed (IOS) / velocity (Android) (meters/sec)",
}
var GetLocationReplySpecialArgs = map[string]string{}
var AppInstListRequestRequiredArgs = []string{}
var AppInstListRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"carriername",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp.seconds",
	"gpslocation.timestamp.nanos",
}
var AppInstListRequestAliasArgs = []string{}
var AppInstListRequestComments = map[string]string{
	"ver":                            "API version",
	"sessioncookie":                  "Session Cookie from RegisterClientRequest",
	"carriername":                    "The carrier name that the user is connected to (Cellular Carrier Name)",
	"gpslocation.latitude":           "latitude in WGS 84 coordinates",
	"gpslocation.longitude":          "longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy": "horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":   "vertical accuracy (meters)",
	"gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied altitude in meters",
	"gpslocation.course":             "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":              "speed (IOS) / velocity (Android) (meters/sec)",
}
var AppInstListRequestSpecialArgs = map[string]string{}
var AppinstanceRequiredArgs = []string{}
var AppinstanceOptionalArgs = []string{
	"appname",
	"appvers",
	"fqdn",
	"ports.proto",
	"ports.internalport",
	"ports.publicport",
	"ports.pathprefix",
	"ports.fqdnprefix",
	"ports.endport",
}
var AppinstanceAliasArgs = []string{}
var AppinstanceComments = map[string]string{
	"appname":            "App Instance Name",
	"appvers":            "App Instance Version",
	"fqdn":               "App Instance FQDN",
	"ports.proto":        "TCP (L4), UDP (L4), or HTTP (L7) protocol, one of LProtoUnknown, LProtoTcp, LProtoUdp, LProtoHttp",
	"ports.internalport": "Container port",
	"ports.publicport":   "Public facing port for TCP/UDP (may be mapped on shared LB reverse proxy)",
	"ports.pathprefix":   "Public facing path for HTTP L7 access.",
	"ports.fqdnprefix":   "FQDN prefix to append to base FQDN in FindCloudlet response. May be empty.",
	"ports.endport":      "A non-zero end port indicates a port range from internal port to end port, inclusive.",
}
var AppinstanceSpecialArgs = map[string]string{}
var CloudletLocationRequiredArgs = []string{}
var CloudletLocationOptionalArgs = []string{
	"carriername",
	"cloudletname",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp.seconds",
	"gpslocation.timestamp.nanos",
	"distance",
	"appinstances.appname",
	"appinstances.appvers",
	"appinstances.fqdn",
	"appinstances.ports.proto",
	"appinstances.ports.internalport",
	"appinstances.ports.publicport",
	"appinstances.ports.pathprefix",
	"appinstances.ports.fqdnprefix",
	"appinstances.ports.endport",
}
var CloudletLocationAliasArgs = []string{}
var CloudletLocationComments = map[string]string{
	"carriername":                     "The carrier name that the user is connected to (Cellular Carrier Name)",
	"cloudletname":                    "Cloudlet Name",
	"gpslocation.latitude":            "latitude in WGS 84 coordinates",
	"gpslocation.longitude":           "longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy":  "horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":    "vertical accuracy (meters)",
	"gpslocation.altitude":            "On android only lat and long are guaranteed to be supplied altitude in meters",
	"gpslocation.course":              "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":               "speed (IOS) / velocity (Android) (meters/sec)",
	"distance":                        "Distance of cloudlet vs loc in request",
	"appinstances.appname":            "App Instance Name",
	"appinstances.appvers":            "App Instance Version",
	"appinstances.fqdn":               "App Instance FQDN",
	"appinstances.ports.proto":        "TCP (L4), UDP (L4), or HTTP (L7) protocol, one of LProtoUnknown, LProtoTcp, LProtoUdp, LProtoHttp",
	"appinstances.ports.internalport": "Container port",
	"appinstances.ports.publicport":   "Public facing port for TCP/UDP (may be mapped on shared LB reverse proxy)",
	"appinstances.ports.pathprefix":   "Public facing path for HTTP L7 access.",
	"appinstances.ports.fqdnprefix":   "FQDN prefix to append to base FQDN in FindCloudlet response. May be empty.",
	"appinstances.ports.endport":      "A non-zero end port indicates a port range from internal port to end port, inclusive.",
}
var CloudletLocationSpecialArgs = map[string]string{}
var AppInstListReplyRequiredArgs = []string{}
var AppInstListReplyOptionalArgs = []string{
	"ver",
	"status",
	"cloudlets.carriername",
	"cloudlets.cloudletname",
	"cloudlets.gpslocation.latitude",
	"cloudlets.gpslocation.longitude",
	"cloudlets.gpslocation.horizontalaccuracy",
	"cloudlets.gpslocation.verticalaccuracy",
	"cloudlets.gpslocation.altitude",
	"cloudlets.gpslocation.course",
	"cloudlets.gpslocation.speed",
	"cloudlets.gpslocation.timestamp.seconds",
	"cloudlets.gpslocation.timestamp.nanos",
	"cloudlets.distance",
	"cloudlets.appinstances.appname",
	"cloudlets.appinstances.appvers",
	"cloudlets.appinstances.fqdn",
	"cloudlets.appinstances.ports.proto",
	"cloudlets.appinstances.ports.internalport",
	"cloudlets.appinstances.ports.publicport",
	"cloudlets.appinstances.ports.pathprefix",
	"cloudlets.appinstances.ports.fqdnprefix",
	"cloudlets.appinstances.ports.endport",
}
var AppInstListReplyAliasArgs = []string{}
var AppInstListReplyComments = map[string]string{
	"ver":                                       "API version",
	"status":                                    ", one of AiUndefined, AiSuccess, AiFail",
	"cloudlets.carriername":                     "The carrier name that the user is connected to (Cellular Carrier Name)",
	"cloudlets.cloudletname":                    "Cloudlet Name",
	"cloudlets.gpslocation.latitude":            "latitude in WGS 84 coordinates",
	"cloudlets.gpslocation.longitude":           "longitude in WGS 84 coordinates",
	"cloudlets.gpslocation.horizontalaccuracy":  "horizontal accuracy (radius in meters)",
	"cloudlets.gpslocation.verticalaccuracy":    "vertical accuracy (meters)",
	"cloudlets.gpslocation.altitude":            "On android only lat and long are guaranteed to be supplied altitude in meters",
	"cloudlets.gpslocation.course":              "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"cloudlets.gpslocation.speed":               "speed (IOS) / velocity (Android) (meters/sec)",
	"cloudlets.distance":                        "Distance of cloudlet vs loc in request",
	"cloudlets.appinstances.appname":            "App Instance Name",
	"cloudlets.appinstances.appvers":            "App Instance Version",
	"cloudlets.appinstances.fqdn":               "App Instance FQDN",
	"cloudlets.appinstances.ports.proto":        "TCP (L4), UDP (L4), or HTTP (L7) protocol, one of LProtoUnknown, LProtoTcp, LProtoUdp, LProtoHttp",
	"cloudlets.appinstances.ports.internalport": "Container port",
	"cloudlets.appinstances.ports.publicport":   "Public facing port for TCP/UDP (may be mapped on shared LB reverse proxy)",
	"cloudlets.appinstances.ports.pathprefix":   "Public facing path for HTTP L7 access.",
	"cloudlets.appinstances.ports.fqdnprefix":   "FQDN prefix to append to base FQDN in FindCloudlet response. May be empty.",
	"cloudlets.appinstances.ports.endport":      "A non-zero end port indicates a port range from internal port to end port, inclusive.",
}
var AppInstListReplySpecialArgs = map[string]string{}
var FqdnListRequestRequiredArgs = []string{}
var FqdnListRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
}
var FqdnListRequestAliasArgs = []string{}
var FqdnListRequestComments = map[string]string{
	"ver":           "API version",
	"sessioncookie": "Session Cookie from RegisterClientRequest",
}
var FqdnListRequestSpecialArgs = map[string]string{}
var AppFqdnRequiredArgs = []string{}
var AppFqdnOptionalArgs = []string{
	"appname",
	"appvers",
	"devname",
	"fqdns",
	"androidpackagename",
}
var AppFqdnAliasArgs = []string{}
var AppFqdnComments = map[string]string{
	"appname":            "App  Name",
	"appvers":            "App Version",
	"devname":            "developer name",
	"fqdns":              "App FQDN",
	"androidpackagename": "optional android package name",
}
var AppFqdnSpecialArgs = map[string]string{
	"fqdns": "StringArray",
}
var FqdnListReplyRequiredArgs = []string{}
var FqdnListReplyOptionalArgs = []string{
	"ver",
	"appfqdns.appname",
	"appfqdns.appvers",
	"appfqdns.devname",
	"appfqdns.fqdns",
	"appfqdns.androidpackagename",
	"status",
}
var FqdnListReplyAliasArgs = []string{}
var FqdnListReplyComments = map[string]string{
	"ver":                         "API version",
	"appfqdns.appname":            "App  Name",
	"appfqdns.appvers":            "App Version",
	"appfqdns.devname":            "developer name",
	"appfqdns.fqdns":              "App FQDN",
	"appfqdns.androidpackagename": "optional android package name",
	"status":                      ", one of FlUndefined, FlSuccess, FlFail",
}
var FqdnListReplySpecialArgs = map[string]string{
	"appfqdns.fqdns": "StringArray",
}
var DynamicLocGroupRequestRequiredArgs = []string{}
var DynamicLocGroupRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"lgid",
	"commtype",
	"userdata",
}
var DynamicLocGroupRequestAliasArgs = []string{}
var DynamicLocGroupRequestComments = map[string]string{
	"sessioncookie": "Session Cookie from RegisterClientRequest",
	"lgid":          "Dynamic Location Group Id",
	"commtype":      ", one of DlgUndefined, DlgSecure, DlgOpen",
	"userdata":      "Unused",
}
var DynamicLocGroupRequestSpecialArgs = map[string]string{}
var DynamicLocGroupReplyRequiredArgs = []string{}
var DynamicLocGroupReplyOptionalArgs = []string{
	"ver",
	"status",
	"errorcode",
	"groupcookie",
}
var DynamicLocGroupReplyAliasArgs = []string{}
var DynamicLocGroupReplyComments = map[string]string{
	"status":      "Status of the reply, one of RsUndefined, RsSuccess, RsFail",
	"errorcode":   "Error Code based on Failure",
	"groupcookie": "Group Cookie for Secure Group Communication",
}
var DynamicLocGroupReplySpecialArgs = map[string]string{}
var QosPositionRequiredArgs = []string{}
var QosPositionOptionalArgs = []string{
	"positionid",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp.seconds",
	"gpslocation.timestamp.nanos",
}
var QosPositionAliasArgs = []string{}
var QosPositionComments = map[string]string{
	"positionid":                     "as set by the client, must be unique within QosRequest",
	"gpslocation.latitude":           "latitude in WGS 84 coordinates",
	"gpslocation.longitude":          "longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy": "horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":   "vertical accuracy (meters)",
	"gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied altitude in meters",
	"gpslocation.course":             "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":              "speed (IOS) / velocity (Android) (meters/sec)",
}
var QosPositionSpecialArgs = map[string]string{}
var BandSelectionRequiredArgs = []string{}
var BandSelectionOptionalArgs = []string{
	"rat_2g",
	"rat_3g",
	"rat_4g",
	"rat_5g",
}
var BandSelectionAliasArgs = []string{}
var BandSelectionComments = map[string]string{
	"rat_2g": "Radio Access Technologies",
}
var BandSelectionSpecialArgs = map[string]string{
	"rat_2g": "StringArray",
	"rat_3g": "StringArray",
	"rat_4g": "StringArray",
	"rat_5g": "StringArray",
}
var QosPositionRequestRequiredArgs = []string{}
var QosPositionRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"positions.positionid",
	"positions.gpslocation.latitude",
	"positions.gpslocation.longitude",
	"positions.gpslocation.horizontalaccuracy",
	"positions.gpslocation.verticalaccuracy",
	"positions.gpslocation.altitude",
	"positions.gpslocation.course",
	"positions.gpslocation.speed",
	"positions.gpslocation.timestamp.seconds",
	"positions.gpslocation.timestamp.nanos",
	"ltecategory",
	"bandselection.rat_2g",
	"bandselection.rat_3g",
	"bandselection.rat_4g",
	"bandselection.rat_5g",
}
var QosPositionRequestAliasArgs = []string{}
var QosPositionRequestComments = map[string]string{
	"ver":                                      "API version",
	"sessioncookie":                            "Session Cookie from RegisterClientRequest",
	"positions.positionid":                     "as set by the client, must be unique within QosRequest",
	"positions.gpslocation.latitude":           "latitude in WGS 84 coordinates",
	"positions.gpslocation.longitude":          "longitude in WGS 84 coordinates",
	"positions.gpslocation.horizontalaccuracy": "horizontal accuracy (radius in meters)",
	"positions.gpslocation.verticalaccuracy":   "vertical accuracy (meters)",
	"positions.gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied altitude in meters",
	"positions.gpslocation.course":             "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"positions.gpslocation.speed":              "speed (IOS) / velocity (Android) (meters/sec)",
	"ltecategory":                              "clients device LTE category number, optional",
	"bandselection.rat_2g":                     "Radio Access Technologies",
}
var QosPositionRequestSpecialArgs = map[string]string{
	"bandselection.rat_2g": "StringArray",
	"bandselection.rat_3g": "StringArray",
	"bandselection.rat_4g": "StringArray",
	"bandselection.rat_5g": "StringArray",
}
var QosPositionKpiResultRequiredArgs = []string{}
var QosPositionKpiResultOptionalArgs = []string{
	"positionid",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp.seconds",
	"gpslocation.timestamp.nanos",
	"dluserthroughputmin",
	"dluserthroughputavg",
	"dluserthroughputmax",
	"uluserthroughputmin",
	"uluserthroughputavg",
	"uluserthroughputmax",
	"latencymin",
	"latencyavg",
	"latencymax",
}
var QosPositionKpiResultAliasArgs = []string{}
var QosPositionKpiResultComments = map[string]string{
	"positionid":                     "as set by the client, must be unique within one QosPositionRequest",
	"gpslocation.latitude":           "latitude in WGS 84 coordinates",
	"gpslocation.longitude":          "longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy": "horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":   "vertical accuracy (meters)",
	"gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied altitude in meters",
	"gpslocation.course":             "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":              "speed (IOS) / velocity (Android) (meters/sec)",
	"dluserthroughputmin":            "throughput",
}
var QosPositionKpiResultSpecialArgs = map[string]string{}
var QosPositionKpiReplyRequiredArgs = []string{}
var QosPositionKpiReplyOptionalArgs = []string{
	"ver",
	"status",
	"positionresults.positionid",
	"positionresults.gpslocation.latitude",
	"positionresults.gpslocation.longitude",
	"positionresults.gpslocation.horizontalaccuracy",
	"positionresults.gpslocation.verticalaccuracy",
	"positionresults.gpslocation.altitude",
	"positionresults.gpslocation.course",
	"positionresults.gpslocation.speed",
	"positionresults.gpslocation.timestamp.seconds",
	"positionresults.gpslocation.timestamp.nanos",
	"positionresults.dluserthroughputmin",
	"positionresults.dluserthroughputavg",
	"positionresults.dluserthroughputmax",
	"positionresults.uluserthroughputmin",
	"positionresults.uluserthroughputavg",
	"positionresults.uluserthroughputmax",
	"positionresults.latencymin",
	"positionresults.latencyavg",
	"positionresults.latencymax",
}
var QosPositionKpiReplyAliasArgs = []string{}
var QosPositionKpiReplyComments = map[string]string{
	"status":                                         "Status of the reply, one of RsUndefined, RsSuccess, RsFail",
	"positionresults.positionid":                     "as set by the client, must be unique within one QosPositionRequest",
	"positionresults.gpslocation.latitude":           "latitude in WGS 84 coordinates",
	"positionresults.gpslocation.longitude":          "longitude in WGS 84 coordinates",
	"positionresults.gpslocation.horizontalaccuracy": "horizontal accuracy (radius in meters)",
	"positionresults.gpslocation.verticalaccuracy":   "vertical accuracy (meters)",
	"positionresults.gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied altitude in meters",
	"positionresults.gpslocation.course":             "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"positionresults.gpslocation.speed":              "speed (IOS) / velocity (Android) (meters/sec)",
	"positionresults.dluserthroughputmin":            "throughput",
}
var QosPositionKpiReplySpecialArgs = map[string]string{}
