// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app-client.proto

package gencmd

import (
	"context"
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	proto "github.com/gogo/protobuf/proto"
	"github.com/mobiledgex/edge-cloud/cli"
	distributed_match_engine "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto"
	"github.com/spf13/cobra"
	"google.golang.org/grpc/status"
	"io"
	math "math"
	"strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Auto-generated code: DO NOT EDIT
var MatchEngineApiCmd distributed_match_engine.MatchEngineApiClient

var RegisterClientCmd = &cli.Command{
	Use:          "RegisterClient",
	RequiredArgs: strings.Join(RegisterClientRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(RegisterClientRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(RegisterClientRequestAliasArgs, " "),
	SpecialArgs:  &RegisterClientRequestSpecialArgs,
	Comments:     RegisterClientRequestComments,
	ReqData:      &distributed_match_engine.RegisterClientRequest{},
	ReplyData:    &distributed_match_engine.RegisterClientReply{},
	Run:          runRegisterClient,
}

func runRegisterClient(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.RegisterClientRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return RegisterClient(c, obj)
}

func RegisterClient(c *cli.Command, in *distributed_match_engine.RegisterClientRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.RegisterClient(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("RegisterClient failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func RegisterClients(c *cli.Command, data []distributed_match_engine.RegisterClientRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("RegisterClient %v\n", data[ii])
		myerr := RegisterClient(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var FindCloudletCmd = &cli.Command{
	Use:          "FindCloudlet",
	RequiredArgs: strings.Join(FindCloudletRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(FindCloudletRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(FindCloudletRequestAliasArgs, " "),
	SpecialArgs:  &FindCloudletRequestSpecialArgs,
	Comments:     FindCloudletRequestComments,
	ReqData:      &distributed_match_engine.FindCloudletRequest{},
	ReplyData:    &distributed_match_engine.FindCloudletReply{},
	Run:          runFindCloudlet,
}

func runFindCloudlet(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.FindCloudletRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return FindCloudlet(c, obj)
}

func FindCloudlet(c *cli.Command, in *distributed_match_engine.FindCloudletRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.FindCloudlet(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("FindCloudlet failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func FindCloudlets(c *cli.Command, data []distributed_match_engine.FindCloudletRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("FindCloudlet %v\n", data[ii])
		myerr := FindCloudlet(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var PlatformFindCloudletCmd = &cli.Command{
	Use:          "PlatformFindCloudlet",
	RequiredArgs: strings.Join(PlatformFindCloudletRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(PlatformFindCloudletRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(PlatformFindCloudletRequestAliasArgs, " "),
	SpecialArgs:  &PlatformFindCloudletRequestSpecialArgs,
	Comments:     PlatformFindCloudletRequestComments,
	ReqData:      &distributed_match_engine.PlatformFindCloudletRequest{},
	ReplyData:    &distributed_match_engine.FindCloudletReply{},
	Run:          runPlatformFindCloudlet,
}

func runPlatformFindCloudlet(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.PlatformFindCloudletRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return PlatformFindCloudlet(c, obj)
}

func PlatformFindCloudlet(c *cli.Command, in *distributed_match_engine.PlatformFindCloudletRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.PlatformFindCloudlet(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("PlatformFindCloudlet failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func PlatformFindCloudlets(c *cli.Command, data []distributed_match_engine.PlatformFindCloudletRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("PlatformFindCloudlet %v\n", data[ii])
		myerr := PlatformFindCloudlet(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var VerifyLocationCmd = &cli.Command{
	Use:          "VerifyLocation",
	RequiredArgs: strings.Join(VerifyLocationRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(VerifyLocationRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(VerifyLocationRequestAliasArgs, " "),
	SpecialArgs:  &VerifyLocationRequestSpecialArgs,
	Comments:     VerifyLocationRequestComments,
	ReqData:      &distributed_match_engine.VerifyLocationRequest{},
	ReplyData:    &distributed_match_engine.VerifyLocationReply{},
	Run:          runVerifyLocation,
}

func runVerifyLocation(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.VerifyLocationRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return VerifyLocation(c, obj)
}

func VerifyLocation(c *cli.Command, in *distributed_match_engine.VerifyLocationRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.VerifyLocation(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("VerifyLocation failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func VerifyLocations(c *cli.Command, data []distributed_match_engine.VerifyLocationRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("VerifyLocation %v\n", data[ii])
		myerr := VerifyLocation(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetLocationCmd = &cli.Command{
	Use:          "GetLocation",
	RequiredArgs: strings.Join(GetLocationRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(GetLocationRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(GetLocationRequestAliasArgs, " "),
	SpecialArgs:  &GetLocationRequestSpecialArgs,
	Comments:     GetLocationRequestComments,
	ReqData:      &distributed_match_engine.GetLocationRequest{},
	ReplyData:    &distributed_match_engine.GetLocationReply{},
	Run:          runGetLocation,
}

func runGetLocation(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.GetLocationRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetLocation(c, obj)
}

func GetLocation(c *cli.Command, in *distributed_match_engine.GetLocationRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.GetLocation(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetLocation failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetLocations(c *cli.Command, data []distributed_match_engine.GetLocationRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetLocation %v\n", data[ii])
		myerr := GetLocation(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var AddUserToGroupCmd = &cli.Command{
	Use:          "AddUserToGroup",
	RequiredArgs: strings.Join(DynamicLocGroupRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(DynamicLocGroupRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(DynamicLocGroupRequestAliasArgs, " "),
	SpecialArgs:  &DynamicLocGroupRequestSpecialArgs,
	Comments:     DynamicLocGroupRequestComments,
	ReqData:      &distributed_match_engine.DynamicLocGroupRequest{},
	ReplyData:    &distributed_match_engine.DynamicLocGroupReply{},
	Run:          runAddUserToGroup,
}

func runAddUserToGroup(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.DynamicLocGroupRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return AddUserToGroup(c, obj)
}

func AddUserToGroup(c *cli.Command, in *distributed_match_engine.DynamicLocGroupRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.AddUserToGroup(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("AddUserToGroup failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func AddUserToGroups(c *cli.Command, data []distributed_match_engine.DynamicLocGroupRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("AddUserToGroup %v\n", data[ii])
		myerr := AddUserToGroup(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetAppInstListCmd = &cli.Command{
	Use:          "GetAppInstList",
	RequiredArgs: strings.Join(AppInstListRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(AppInstListRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(AppInstListRequestAliasArgs, " "),
	SpecialArgs:  &AppInstListRequestSpecialArgs,
	Comments:     AppInstListRequestComments,
	ReqData:      &distributed_match_engine.AppInstListRequest{},
	ReplyData:    &distributed_match_engine.AppInstListReply{},
	Run:          runGetAppInstList,
}

func runGetAppInstList(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.AppInstListRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetAppInstList(c, obj)
}

func GetAppInstList(c *cli.Command, in *distributed_match_engine.AppInstListRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.GetAppInstList(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetAppInstList failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetAppInstLists(c *cli.Command, data []distributed_match_engine.AppInstListRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetAppInstList %v\n", data[ii])
		myerr := GetAppInstList(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetFqdnListCmd = &cli.Command{
	Use:          "GetFqdnList",
	RequiredArgs: strings.Join(FqdnListRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(FqdnListRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(FqdnListRequestAliasArgs, " "),
	SpecialArgs:  &FqdnListRequestSpecialArgs,
	Comments:     FqdnListRequestComments,
	ReqData:      &distributed_match_engine.FqdnListRequest{},
	ReplyData:    &distributed_match_engine.FqdnListReply{},
	Run:          runGetFqdnList,
}

func runGetFqdnList(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.FqdnListRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetFqdnList(c, obj)
}

func GetFqdnList(c *cli.Command, in *distributed_match_engine.FqdnListRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.GetFqdnList(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetFqdnList failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetFqdnLists(c *cli.Command, data []distributed_match_engine.FqdnListRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetFqdnList %v\n", data[ii])
		myerr := GetFqdnList(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetAppOfficialFqdnCmd = &cli.Command{
	Use:          "GetAppOfficialFqdn",
	RequiredArgs: strings.Join(AppOfficialFqdnRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(AppOfficialFqdnRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(AppOfficialFqdnRequestAliasArgs, " "),
	SpecialArgs:  &AppOfficialFqdnRequestSpecialArgs,
	Comments:     AppOfficialFqdnRequestComments,
	ReqData:      &distributed_match_engine.AppOfficialFqdnRequest{},
	ReplyData:    &distributed_match_engine.AppOfficialFqdnReply{},
	Run:          runGetAppOfficialFqdn,
}

func runGetAppOfficialFqdn(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.AppOfficialFqdnRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetAppOfficialFqdn(c, obj)
}

func GetAppOfficialFqdn(c *cli.Command, in *distributed_match_engine.AppOfficialFqdnRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.GetAppOfficialFqdn(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetAppOfficialFqdn failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetAppOfficialFqdns(c *cli.Command, data []distributed_match_engine.AppOfficialFqdnRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetAppOfficialFqdn %v\n", data[ii])
		myerr := GetAppOfficialFqdn(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetQosPositionKpiCmd = &cli.Command{
	Use:          "GetQosPositionKpi",
	RequiredArgs: strings.Join(QosPositionRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(QosPositionRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(QosPositionRequestAliasArgs, " "),
	SpecialArgs:  &QosPositionRequestSpecialArgs,
	Comments:     QosPositionRequestComments,
	ReqData:      &distributed_match_engine.QosPositionRequest{},
	ReplyData:    &distributed_match_engine.QosPositionKpiReply{},
	Run:          runGetQosPositionKpi,
}

func runGetQosPositionKpi(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.QosPositionRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetQosPositionKpi(c, obj)
}

func GetQosPositionKpi(c *cli.Command, in *distributed_match_engine.QosPositionRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	stream, err := MatchEngineApiCmd.GetQosPositionKpi(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetQosPositionKpi failed: %s", errstr)
	}

	objs := make([]*distributed_match_engine.QosPositionKpiReply, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("GetQosPositionKpi recv failed: %s", errstr)
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetQosPositionKpis(c *cli.Command, data []distributed_match_engine.QosPositionRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetQosPositionKpi %v\n", data[ii])
		myerr := GetQosPositionKpi(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var MatchEngineApiCmds = []*cobra.Command{
	RegisterClientCmd.GenCmd(),
	FindCloudletCmd.GenCmd(),
	PlatformFindCloudletCmd.GenCmd(),
	VerifyLocationCmd.GenCmd(),
	GetLocationCmd.GenCmd(),
	AddUserToGroupCmd.GenCmd(),
	GetAppInstListCmd.GenCmd(),
	GetFqdnListCmd.GenCmd(),
	GetAppOfficialFqdnCmd.GenCmd(),
	GetQosPositionKpiCmd.GenCmd(),
}

var RegisterClientRequestRequiredArgs = []string{}
var RegisterClientRequestOptionalArgs = []string{
	"ver",
	"orgname",
	"appname",
	"appvers",
	"carriername",
	"authtoken",
	"cellid",
	"uniqueidtype",
	"uniqueid",
	"tags",
}
var RegisterClientRequestAliasArgs = []string{}
var RegisterClientRequestComments = map[string]string{
	"ver":          "API version _(hidden)_ Reserved for future use",
	"orgname":      "App Organization Name App developer organization name.",
	"appname":      "App Name Name of your application.",
	"appvers":      "App Version Application version.",
	"carriername":  "Carrier Name _(hidden)_ Reserved for future use",
	"authtoken":    "Authentication Token _(optional)_ An authentication token supplied by the application.",
	"cellid":       "Cell ID _(optional)_ Cellular ID of where the client is connected.",
	"uniqueidtype": "Unique ID Type _(optional)_ Type of unique ID provided by the client. If left blank, a new Unique ID type will be assigned in the RegisterClient Reply.",
	"uniqueid":     "Unique ID _(optional)_ Unique identification of the client device or user. May be overridden by the server. If left blank, a new Unique ID will be assigned in the RegisterClient Reply.",
	"tags":         "Tags _(optional)_ Vendor specific data",
}
var RegisterClientRequestSpecialArgs = map[string]string{
	"tags": "StringToString",
}
var RegisterClientReplyRequiredArgs = []string{}
var RegisterClientReplyOptionalArgs = []string{
	"ver",
	"status",
	"sessioncookie",
	"tokenserveruri",
	"uniqueidtype",
	"uniqueid",
	"tags",
}
var RegisterClientReplyAliasArgs = []string{}
var RegisterClientReplyComments = map[string]string{
	"ver":            "API version _(hidden)_ Reserved for future use",
	"status":         "Status of the reply, one of Undefined, Success, Fail",
	"sessioncookie":  "Session Cookie to be used in later API calls",
	"tokenserveruri": "URI for the Token Server",
	"uniqueidtype":   "Unique ID Type _(optional)_ Type of unique ID provided by the server A unique_id_type and unique_id may be provided by the client to be registered. During registering, if a unique_id_type and unique_id are provided by the client in their request, the unique_id_type and unique_id will be left blank in the response. But, if the client does not provide a unique_id_type and unique_id, then the server generates one and provides the unique_id in the response. If possible, the unique_id should be saved by the client locally and used for subsequent RegisterClient API calls. Otherwise, a new unique_id will be generated for further API calls.",
	"uniqueid":       "Unique ID _(optional)_ Unique identification of the client device or user A unique_id_type and unique_id may be provided by the client to be registered. During registering, if a unique_id_type and unique_id are provided by the client in their request, the unique_id_type and unique_id will be left blank in the response. But, if the client does not provide a unique_id_type and unique_id, then the server generates one and provides the unique_id in the response. If possible, the unique_id should be saved by the client locally and used for subsequent RegisterClient API calls. Otherwise, a new unique_id will be generated for further API calls.",
	"tags":           "Vendor specific data _(optional)_ Array of Tags.",
}
var RegisterClientReplySpecialArgs = map[string]string{
	"tags": "StringToString",
}
var FindCloudletRequestRequiredArgs = []string{}
var FindCloudletRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"carriername",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp.seconds",
	"gpslocation.timestamp.nanos",
	"cellid",
	"tags",
}
var FindCloudletRequestAliasArgs = []string{}
var FindCloudletRequestComments = map[string]string{
	"ver":                            "API version _(hidden)_ Reserved for future use",
	"sessioncookie":                  "Session Cookie Session Cookie from RegisterClientRequest",
	"carriername":                    "Carrier Name _(optional)_ By default, all SDKs will automatically fill in this parameter with the MCC+MNC of your current provider. Only override this parameter if you need to filter for a specific carrier on the DME. The DME will filter for App instances that are associated with the specified carrier. If you wish to search for any App Instance on the DME regardless of carrier name, you can input “” to consider all carriers as “Any”.",
	"gpslocation.latitude":           "latitude in WGS 84 coordinates",
	"gpslocation.longitude":          "longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy": "horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":   "vertical accuracy (meters)",
	"gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied altitude in meters",
	"gpslocation.course":             "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":              "speed (IOS) / velocity (Android) (meters/sec)",
	"cellid":                         "Cell ID _(optional)_ Cell ID where the client is",
	"tags":                           "Tags _(optional)_ Vendor specific data",
}
var FindCloudletRequestSpecialArgs = map[string]string{
	"tags": "StringToString",
}
var PlatformFindCloudletRequestRequiredArgs = []string{}
var PlatformFindCloudletRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"carriername",
	"clienttoken",
	"tags",
}
var PlatformFindCloudletRequestAliasArgs = []string{}
var PlatformFindCloudletRequestComments = map[string]string{
	"ver":           "API version _(hidden)_ Reserved for future use",
	"sessioncookie": "Session Cookie Session Cookie from RegisterClientRequest",
	"carriername":   "Carrier Name _(optional)_ By default, all SDKs will automatically fill in this parameter with the MCC+MNC of your current provider. Only override this parameter if you need to filter for a specific carrier on the DME. The DME will filter for App instances that are associated with the specified carrier. If you wish to search for any app instance on the DME regardless of carrier name, you can input “” to consider all carriers as “Any”.",
	"clienttoken":   "Client Token Token with encoded client data",
	"tags":          "Tags _(optional)_ Vendor specific data",
}
var PlatformFindCloudletRequestSpecialArgs = map[string]string{
	"tags": "StringToString",
}
var FindCloudletReplyRequiredArgs = []string{}
var FindCloudletReplyOptionalArgs = []string{
	"ver",
	"status",
	"fqdn",
	"ports:#.proto",
	"ports:#.internalport",
	"ports:#.publicport",
	"ports:#.fqdnprefix",
	"ports:#.endport",
	"ports:#.tls",
	"ports:#.nginx",
	"cloudletlocation.latitude",
	"cloudletlocation.longitude",
	"cloudletlocation.horizontalaccuracy",
	"cloudletlocation.verticalaccuracy",
	"cloudletlocation.altitude",
	"cloudletlocation.course",
	"cloudletlocation.speed",
	"cloudletlocation.timestamp.seconds",
	"cloudletlocation.timestamp.nanos",
	"edgeeventscookie",
	"tags",
}
var FindCloudletReplyAliasArgs = []string{}
var FindCloudletReplyComments = map[string]string{
	"ver":                                 "API version _(hidden)_ Reserved for future use",
	"status":                              "Status return, one of Unknown, Found, Notfound",
	"fqdn":                                "Fully Qualified Domain Name of the Closest App instance",
	"ports:#.proto":                       "TCP (L4) or UDP (L4) protocol, one of Unknown, Tcp, Udp",
	"ports:#.internalport":                "Container port",
	"ports:#.publicport":                  "Public facing port for TCP/UDP (may be mapped on shared LB reverse proxy)",
	"ports:#.fqdnprefix":                  "skip 4 to preserve the numbering. 4 was path_prefix but was removed since we dont need it after removed http FQDN prefix to append to base FQDN in FindCloudlet response. May be empty.",
	"ports:#.endport":                     "A non-zero end port indicates a port range from internal port to end port, inclusive.",
	"ports:#.tls":                         "TLS termination for this port",
	"ports:#.nginx":                       "use nginx proxy for this port if you really need a transparent proxy (udp only)",
	"cloudletlocation.latitude":           "latitude in WGS 84 coordinates",
	"cloudletlocation.longitude":          "longitude in WGS 84 coordinates",
	"cloudletlocation.horizontalaccuracy": "horizontal accuracy (radius in meters)",
	"cloudletlocation.verticalaccuracy":   "vertical accuracy (meters)",
	"cloudletlocation.altitude":           "On android only lat and long are guaranteed to be supplied altitude in meters",
	"cloudletlocation.course":             "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"cloudletlocation.speed":              "speed (IOS) / velocity (Android) (meters/sec)",
	"edgeeventscookie":                    "Session Cookie for specific EdgeEvents for specific AppInst",
	"tags":                                "_(optional)_ Vendor specific data",
}
var FindCloudletReplySpecialArgs = map[string]string{
	"tags": "StringToString",
}
var VerifyLocationRequestRequiredArgs = []string{}
var VerifyLocationRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"carriername",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp.seconds",
	"gpslocation.timestamp.nanos",
	"verifyloctoken",
	"cellid",
	"tags",
}
var VerifyLocationRequestAliasArgs = []string{}
var VerifyLocationRequestComments = map[string]string{
	"ver":                            "API version _(hidden)_ Reserved for future use",
	"sessioncookie":                  "Session Cookie Session Cookie from RegisterClientRequest",
	"carriername":                    "Carrier Name Unique carrier identification (typically MCC + MNC)",
	"gpslocation.latitude":           "latitude in WGS 84 coordinates",
	"gpslocation.longitude":          "longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy": "horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":   "vertical accuracy (meters)",
	"gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied altitude in meters",
	"gpslocation.course":             "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":              "speed (IOS) / velocity (Android) (meters/sec)",
	"verifyloctoken":                 "Verify Location Token Must be retrieved from TokenServerURI",
	"cellid":                         "Cell ID _(optional)_ Cell ID where the client is",
	"tags":                           "Tags _(optional)_ Vendor specific data",
}
var VerifyLocationRequestSpecialArgs = map[string]string{
	"tags": "StringToString",
}
var VerifyLocationReplyRequiredArgs = []string{}
var VerifyLocationReplyOptionalArgs = []string{
	"ver",
	"towerstatus",
	"gpslocationstatus",
	"gpslocationaccuracykm",
	"tags",
}
var VerifyLocationReplyAliasArgs = []string{}
var VerifyLocationReplyComments = map[string]string{
	"ver":                   "API version _(hidden)_ Reserved for future use",
	"towerstatus":           ", one of TowerUnknown, ConnectedToSpecifiedTower, NotConnectedToSpecifiedTower",
	"gpslocationstatus":     ", one of Unknown, Verified, MismatchSameCountry, MismatchOtherCountry, RoamingCountryMatch, RoamingCountryMismatch, ErrorUnauthorized, ErrorOther",
	"gpslocationaccuracykm": "location accuracy, the location is verified to be within this number of kilometers.  Negative value means no verification was performed",
	"tags":                  "_(optional)_ Vendor specific data",
}
var VerifyLocationReplySpecialArgs = map[string]string{
	"tags": "StringToString",
}
var GetLocationRequestRequiredArgs = []string{}
var GetLocationRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"carriername",
	"cellid",
	"tags",
}
var GetLocationRequestAliasArgs = []string{}
var GetLocationRequestComments = map[string]string{
	"ver":           "API version _(hidden)_ Reserved for future use",
	"sessioncookie": "Session Cookie from RegisterClientRequest",
	"carriername":   "Unique carrier identification (typically MCC + MNC)",
	"cellid":        "_(optional)_ Cell id where the client is",
	"tags":          "_(optional)_ Vendor specific data",
}
var GetLocationRequestSpecialArgs = map[string]string{
	"tags": "StringToString",
}
var GetLocationReplyRequiredArgs = []string{}
var GetLocationReplyOptionalArgs = []string{
	"ver",
	"status",
	"carriername",
	"tower",
	"networklocation.latitude",
	"networklocation.longitude",
	"networklocation.horizontalaccuracy",
	"networklocation.verticalaccuracy",
	"networklocation.altitude",
	"networklocation.course",
	"networklocation.speed",
	"networklocation.timestamp.seconds",
	"networklocation.timestamp.nanos",
	"tags",
}
var GetLocationReplyAliasArgs = []string{}
var GetLocationReplyComments = map[string]string{
	"ver":                                "API version _(hidden)_ Reserved for future use",
	"status":                             ", one of Unknown, Found, Denied",
	"carriername":                        "Unique carrier identification (typically MCC + MNC)",
	"tower":                              "The tower that the user is currently connected to",
	"networklocation.latitude":           "latitude in WGS 84 coordinates",
	"networklocation.longitude":          "longitude in WGS 84 coordinates",
	"networklocation.horizontalaccuracy": "horizontal accuracy (radius in meters)",
	"networklocation.verticalaccuracy":   "vertical accuracy (meters)",
	"networklocation.altitude":           "On android only lat and long are guaranteed to be supplied altitude in meters",
	"networklocation.course":             "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"networklocation.speed":              "speed (IOS) / velocity (Android) (meters/sec)",
	"tags":                               "_(optional)_ Vendor specific data",
}
var GetLocationReplySpecialArgs = map[string]string{
	"tags": "StringToString",
}
var AppInstListRequestRequiredArgs = []string{}
var AppInstListRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"carriername",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp.seconds",
	"gpslocation.timestamp.nanos",
	"cellid",
	"limit",
	"tags",
}
var AppInstListRequestAliasArgs = []string{}
var AppInstListRequestComments = map[string]string{
	"ver":                            "API version _(hidden)_ Reserved for future use",
	"sessioncookie":                  "Session Cookie from RegisterClientRequest",
	"carriername":                    "Carrier Name _(optional)_ By default, all SDKs will automatically fill in this parameter with the MCC+MNC of your current provider. Only override this parameter if you need to filter for a specific carrier on the DME. The DME will filter for App instances that are associated with the specified carrier. If you wish to search for any App Instance on the DME regardless of carrier name, you can input “” to consider all carriers as “Any”.",
	"gpslocation.latitude":           "latitude in WGS 84 coordinates",
	"gpslocation.longitude":          "longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy": "horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":   "vertical accuracy (meters)",
	"gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied altitude in meters",
	"gpslocation.course":             "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":              "speed (IOS) / velocity (Android) (meters/sec)",
	"cellid":                         "_(optional)_ Cell id where the client is",
	"limit":                          "_(optional)_ Limit the number of results, defaults to 3",
	"tags":                           "_(optional)_ Vendor specific data",
}
var AppInstListRequestSpecialArgs = map[string]string{
	"tags": "StringToString",
}
var AppinstanceRequiredArgs = []string{}
var AppinstanceOptionalArgs = []string{
	"appname",
	"appvers",
	"fqdn",
	"ports:#.proto",
	"ports:#.internalport",
	"ports:#.publicport",
	"ports:#.fqdnprefix",
	"ports:#.endport",
	"ports:#.tls",
	"ports:#.nginx",
	"orgname",
	"edgeeventscookie",
}
var AppinstanceAliasArgs = []string{}
var AppinstanceComments = map[string]string{
	"appname":              "App Instance Name",
	"appvers":              "App Instance Version",
	"fqdn":                 "App Instance FQDN",
	"ports:#.proto":        "TCP (L4) or UDP (L4) protocol, one of Unknown, Tcp, Udp",
	"ports:#.internalport": "Container port",
	"ports:#.publicport":   "Public facing port for TCP/UDP (may be mapped on shared LB reverse proxy)",
	"ports:#.fqdnprefix":   "skip 4 to preserve the numbering. 4 was path_prefix but was removed since we dont need it after removed http FQDN prefix to append to base FQDN in FindCloudlet response. May be empty.",
	"ports:#.endport":      "A non-zero end port indicates a port range from internal port to end port, inclusive.",
	"ports:#.tls":          "TLS termination for this port",
	"ports:#.nginx":        "use nginx proxy for this port if you really need a transparent proxy (udp only)",
	"orgname":              "App Organization Name",
	"edgeeventscookie":     "Session Cookie for specific EdgeEvents for specific AppInst",
}
var AppinstanceSpecialArgs = map[string]string{}
var CloudletLocationRequiredArgs = []string{}
var CloudletLocationOptionalArgs = []string{
	"carriername",
	"cloudletname",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp.seconds",
	"gpslocation.timestamp.nanos",
	"distance",
	"appinstances:#.appname",
	"appinstances:#.appvers",
	"appinstances:#.fqdn",
	"appinstances:#.ports:#.proto",
	"appinstances:#.ports:#.internalport",
	"appinstances:#.ports:#.publicport",
	"appinstances:#.ports:#.fqdnprefix",
	"appinstances:#.ports:#.endport",
	"appinstances:#.ports:#.tls",
	"appinstances:#.ports:#.nginx",
	"appinstances:#.orgname",
	"appinstances:#.edgeeventscookie",
}
var CloudletLocationAliasArgs = []string{}
var CloudletLocationComments = map[string]string{
	"carriername":                         "Cloudlet Organization Name",
	"cloudletname":                        "Cloudlet Name",
	"gpslocation.latitude":                "latitude in WGS 84 coordinates",
	"gpslocation.longitude":               "longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy":      "horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":        "vertical accuracy (meters)",
	"gpslocation.altitude":                "On android only lat and long are guaranteed to be supplied altitude in meters",
	"gpslocation.course":                  "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":                   "speed (IOS) / velocity (Android) (meters/sec)",
	"distance":                            "Distance of cloudlet vs loc in request",
	"appinstances:#.appname":              "App Instance Name",
	"appinstances:#.appvers":              "App Instance Version",
	"appinstances:#.fqdn":                 "App Instance FQDN",
	"appinstances:#.ports:#.proto":        "TCP (L4) or UDP (L4) protocol, one of Unknown, Tcp, Udp",
	"appinstances:#.ports:#.internalport": "Container port",
	"appinstances:#.ports:#.publicport":   "Public facing port for TCP/UDP (may be mapped on shared LB reverse proxy)",
	"appinstances:#.ports:#.fqdnprefix":   "skip 4 to preserve the numbering. 4 was path_prefix but was removed since we dont need it after removed http FQDN prefix to append to base FQDN in FindCloudlet response. May be empty.",
	"appinstances:#.ports:#.endport":      "A non-zero end port indicates a port range from internal port to end port, inclusive.",
	"appinstances:#.ports:#.tls":          "TLS termination for this port",
	"appinstances:#.ports:#.nginx":        "use nginx proxy for this port if you really need a transparent proxy (udp only)",
	"appinstances:#.orgname":              "App Organization Name",
	"appinstances:#.edgeeventscookie":     "Session Cookie for specific EdgeEvents for specific AppInst",
}
var CloudletLocationSpecialArgs = map[string]string{}
var AppInstListReplyRequiredArgs = []string{}
var AppInstListReplyOptionalArgs = []string{
	"ver",
	"status",
	"cloudlets:#.carriername",
	"cloudlets:#.cloudletname",
	"cloudlets:#.gpslocation.latitude",
	"cloudlets:#.gpslocation.longitude",
	"cloudlets:#.gpslocation.horizontalaccuracy",
	"cloudlets:#.gpslocation.verticalaccuracy",
	"cloudlets:#.gpslocation.altitude",
	"cloudlets:#.gpslocation.course",
	"cloudlets:#.gpslocation.speed",
	"cloudlets:#.gpslocation.timestamp.seconds",
	"cloudlets:#.gpslocation.timestamp.nanos",
	"cloudlets:#.distance",
	"cloudlets:#.appinstances:#.appname",
	"cloudlets:#.appinstances:#.appvers",
	"cloudlets:#.appinstances:#.fqdn",
	"cloudlets:#.appinstances:#.ports:#.proto",
	"cloudlets:#.appinstances:#.ports:#.internalport",
	"cloudlets:#.appinstances:#.ports:#.publicport",
	"cloudlets:#.appinstances:#.ports:#.fqdnprefix",
	"cloudlets:#.appinstances:#.ports:#.endport",
	"cloudlets:#.appinstances:#.ports:#.tls",
	"cloudlets:#.appinstances:#.ports:#.nginx",
	"cloudlets:#.appinstances:#.orgname",
	"cloudlets:#.appinstances:#.edgeeventscookie",
	"tags",
}
var AppInstListReplyAliasArgs = []string{}
var AppInstListReplyComments = map[string]string{
	"ver":                                             "API version _(hidden)_ Reserved for future use",
	"status":                                          ", one of Undefined, Success, Fail",
	"cloudlets:#.carriername":                         "Cloudlet Organization Name",
	"cloudlets:#.cloudletname":                        "Cloudlet Name",
	"cloudlets:#.gpslocation.latitude":                "latitude in WGS 84 coordinates",
	"cloudlets:#.gpslocation.longitude":               "longitude in WGS 84 coordinates",
	"cloudlets:#.gpslocation.horizontalaccuracy":      "horizontal accuracy (radius in meters)",
	"cloudlets:#.gpslocation.verticalaccuracy":        "vertical accuracy (meters)",
	"cloudlets:#.gpslocation.altitude":                "On android only lat and long are guaranteed to be supplied altitude in meters",
	"cloudlets:#.gpslocation.course":                  "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"cloudlets:#.gpslocation.speed":                   "speed (IOS) / velocity (Android) (meters/sec)",
	"cloudlets:#.distance":                            "Distance of cloudlet vs loc in request",
	"cloudlets:#.appinstances:#.appname":              "App Instance Name",
	"cloudlets:#.appinstances:#.appvers":              "App Instance Version",
	"cloudlets:#.appinstances:#.fqdn":                 "App Instance FQDN",
	"cloudlets:#.appinstances:#.ports:#.proto":        "TCP (L4) or UDP (L4) protocol, one of Unknown, Tcp, Udp",
	"cloudlets:#.appinstances:#.ports:#.internalport": "Container port",
	"cloudlets:#.appinstances:#.ports:#.publicport":   "Public facing port for TCP/UDP (may be mapped on shared LB reverse proxy)",
	"cloudlets:#.appinstances:#.ports:#.fqdnprefix":   "skip 4 to preserve the numbering. 4 was path_prefix but was removed since we dont need it after removed http FQDN prefix to append to base FQDN in FindCloudlet response. May be empty.",
	"cloudlets:#.appinstances:#.ports:#.endport":      "A non-zero end port indicates a port range from internal port to end port, inclusive.",
	"cloudlets:#.appinstances:#.ports:#.tls":          "TLS termination for this port",
	"cloudlets:#.appinstances:#.ports:#.nginx":        "use nginx proxy for this port if you really need a transparent proxy (udp only)",
	"cloudlets:#.appinstances:#.orgname":              "App Organization Name",
	"cloudlets:#.appinstances:#.edgeeventscookie":     "Session Cookie for specific EdgeEvents for specific AppInst",
	"tags": "_(optional)_ Vendor specific data",
}
var AppInstListReplySpecialArgs = map[string]string{
	"tags": "StringToString",
}
var FqdnListRequestRequiredArgs = []string{}
var FqdnListRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"cellid",
	"tags",
}
var FqdnListRequestAliasArgs = []string{}
var FqdnListRequestComments = map[string]string{
	"ver":           "API version _(hidden)_ Reserved for future use",
	"sessioncookie": "Session Cookie from RegisterClientRequest",
	"cellid":        "_(optional)_ Cell id where the client is",
	"tags":          "_(optional)_ Vendor specific data",
}
var FqdnListRequestSpecialArgs = map[string]string{
	"tags": "StringToString",
}
var AppFqdnRequiredArgs = []string{}
var AppFqdnOptionalArgs = []string{
	"appname",
	"appvers",
	"orgname",
	"fqdns",
	"androidpackagename",
}
var AppFqdnAliasArgs = []string{}
var AppFqdnComments = map[string]string{
	"appname":            "App  Name",
	"appvers":            "App Version",
	"orgname":            "App organization name",
	"fqdns":              "App FQDN",
	"androidpackagename": "_(optional)_ Android package name",
}
var AppFqdnSpecialArgs = map[string]string{
	"fqdns": "StringArray",
}
var FqdnListReplyRequiredArgs = []string{}
var FqdnListReplyOptionalArgs = []string{
	"ver",
	"appfqdns:#.appname",
	"appfqdns:#.appvers",
	"appfqdns:#.orgname",
	"appfqdns:#.fqdns",
	"appfqdns:#.androidpackagename",
	"status",
	"tags",
}
var FqdnListReplyAliasArgs = []string{}
var FqdnListReplyComments = map[string]string{
	"ver":                           "API version _(hidden)_ Reserved for future use",
	"appfqdns:#.appname":            "App  Name",
	"appfqdns:#.appvers":            "App Version",
	"appfqdns:#.orgname":            "App organization name",
	"appfqdns:#.fqdns":              "App FQDN",
	"appfqdns:#.androidpackagename": "_(optional)_ Android package name",
	"status":                        ", one of Undefined, Success, Fail",
	"tags":                          "_(optional)_ Vendor specific data",
}
var FqdnListReplySpecialArgs = map[string]string{
	"appfqdns:#.fqdns": "StringArray",
	"tags":             "StringToString",
}
var AppOfficialFqdnRequestRequiredArgs = []string{}
var AppOfficialFqdnRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp.seconds",
	"gpslocation.timestamp.nanos",
	"tags",
}
var AppOfficialFqdnRequestAliasArgs = []string{}
var AppOfficialFqdnRequestComments = map[string]string{
	"ver":                            "API version _(hidden)_ Reserved for future use",
	"sessioncookie":                  "Session Cookie from RegisterClientRequest",
	"gpslocation.latitude":           "latitude in WGS 84 coordinates",
	"gpslocation.longitude":          "longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy": "horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":   "vertical accuracy (meters)",
	"gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied altitude in meters",
	"gpslocation.course":             "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":              "speed (IOS) / velocity (Android) (meters/sec)",
	"tags":                           "_(optional)_ Vendor specific data",
}
var AppOfficialFqdnRequestSpecialArgs = map[string]string{
	"tags": "StringToString",
}
var AppOfficialFqdnReplyRequiredArgs = []string{}
var AppOfficialFqdnReplyOptionalArgs = []string{
	"ver",
	"appofficialfqdn",
	"clienttoken",
	"status",
	"ports:#.proto",
	"ports:#.internalport",
	"ports:#.publicport",
	"ports:#.fqdnprefix",
	"ports:#.endport",
	"ports:#.tls",
	"ports:#.nginx",
	"tags",
}
var AppOfficialFqdnReplyAliasArgs = []string{}
var AppOfficialFqdnReplyComments = map[string]string{
	"ver":                  "API version _(hidden)_ Reserved for future use",
	"appofficialfqdn":      "The FQDN to which the app is reached independent of the edge",
	"clienttoken":          "Tokenized client data",
	"status":               "Status of the reply, one of Undefined, Success, Fail",
	"ports:#.proto":        "TCP (L4) or UDP (L4) protocol, one of Unknown, Tcp, Udp",
	"ports:#.internalport": "Container port",
	"ports:#.publicport":   "Public facing port for TCP/UDP (may be mapped on shared LB reverse proxy)",
	"ports:#.fqdnprefix":   "skip 4 to preserve the numbering. 4 was path_prefix but was removed since we dont need it after removed http FQDN prefix to append to base FQDN in FindCloudlet response. May be empty.",
	"ports:#.endport":      "A non-zero end port indicates a port range from internal port to end port, inclusive.",
	"ports:#.tls":          "TLS termination for this port",
	"ports:#.nginx":        "use nginx proxy for this port if you really need a transparent proxy (udp only)",
	"tags":                 "_(optional)_ Vendor specific data",
}
var AppOfficialFqdnReplySpecialArgs = map[string]string{
	"tags": "StringToString",
}
var DynamicLocGroupRequestRequiredArgs = []string{}
var DynamicLocGroupRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"lgid",
	"commtype",
	"userdata",
	"cellid",
	"tags",
}
var DynamicLocGroupRequestAliasArgs = []string{}
var DynamicLocGroupRequestComments = map[string]string{
	"ver":           "API version _(hidden)_ Reserved for future use",
	"sessioncookie": "Session Cookie from RegisterClientRequest",
	"lgid":          "Dynamic Location Group Id",
	"commtype":      ", one of Undefined, Secure, Open",
	"userdata":      "Unused",
	"cellid":        "_(optional)_ Cell id where the client is",
	"tags":          "_(optional)_ Vendor specific data",
}
var DynamicLocGroupRequestSpecialArgs = map[string]string{
	"tags": "StringToString",
}
var DynamicLocGroupReplyRequiredArgs = []string{}
var DynamicLocGroupReplyOptionalArgs = []string{
	"ver",
	"status",
	"errorcode",
	"groupcookie",
	"tags",
}
var DynamicLocGroupReplyAliasArgs = []string{}
var DynamicLocGroupReplyComments = map[string]string{
	"ver":         "API version _(hidden)_ Reserved for future use",
	"status":      "Status of the reply, one of Undefined, Success, Fail",
	"errorcode":   "Error Code based on Failure",
	"groupcookie": "Group Cookie for Secure Group Communication",
	"tags":        "_(optional)_ Vendor specific data",
}
var DynamicLocGroupReplySpecialArgs = map[string]string{
	"tags": "StringToString",
}
var QosPositionRequiredArgs = []string{}
var QosPositionOptionalArgs = []string{
	"positionid",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp.seconds",
	"gpslocation.timestamp.nanos",
}
var QosPositionAliasArgs = []string{}
var QosPositionComments = map[string]string{
	"positionid":                     "as set by the client, must be unique within QosRequest",
	"gpslocation.latitude":           "latitude in WGS 84 coordinates",
	"gpslocation.longitude":          "longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy": "horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":   "vertical accuracy (meters)",
	"gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied altitude in meters",
	"gpslocation.course":             "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":              "speed (IOS) / velocity (Android) (meters/sec)",
}
var QosPositionSpecialArgs = map[string]string{}
var BandSelectionRequiredArgs = []string{}
var BandSelectionOptionalArgs = []string{
	"rat_2g",
	"rat_3g",
	"rat_4g",
	"rat_5g",
}
var BandSelectionAliasArgs = []string{}
var BandSelectionComments = map[string]string{
	"rat_2g": "Radio Access Technologies",
}
var BandSelectionSpecialArgs = map[string]string{
	"rat_2g": "StringArray",
	"rat_3g": "StringArray",
	"rat_4g": "StringArray",
	"rat_5g": "StringArray",
}
var QosPositionRequestRequiredArgs = []string{}
var QosPositionRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"positions:#.positionid",
	"positions:#.gpslocation.latitude",
	"positions:#.gpslocation.longitude",
	"positions:#.gpslocation.horizontalaccuracy",
	"positions:#.gpslocation.verticalaccuracy",
	"positions:#.gpslocation.altitude",
	"positions:#.gpslocation.course",
	"positions:#.gpslocation.speed",
	"positions:#.gpslocation.timestamp.seconds",
	"positions:#.gpslocation.timestamp.nanos",
	"ltecategory",
	"bandselection.rat_2g",
	"bandselection.rat_3g",
	"bandselection.rat_4g",
	"bandselection.rat_5g",
	"cellid",
	"tags",
}
var QosPositionRequestAliasArgs = []string{}
var QosPositionRequestComments = map[string]string{
	"ver":                                        "API version _(hidden)_ Reserved for future use",
	"sessioncookie":                              "Session Cookie from RegisterClientRequest",
	"positions:#.positionid":                     "as set by the client, must be unique within QosRequest",
	"positions:#.gpslocation.latitude":           "latitude in WGS 84 coordinates",
	"positions:#.gpslocation.longitude":          "longitude in WGS 84 coordinates",
	"positions:#.gpslocation.horizontalaccuracy": "horizontal accuracy (radius in meters)",
	"positions:#.gpslocation.verticalaccuracy":   "vertical accuracy (meters)",
	"positions:#.gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied altitude in meters",
	"positions:#.gpslocation.course":             "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"positions:#.gpslocation.speed":              "speed (IOS) / velocity (Android) (meters/sec)",
	"ltecategory":                                "_(optional)_ Clients device LTE category number.",
	"bandselection.rat_2g":                       "Radio Access Technologies",
	"cellid":                                     "_(optional)_ Cell id where the client is",
	"tags":                                       "_(optional)_ Vendor specific data",
}
var QosPositionRequestSpecialArgs = map[string]string{
	"bandselection.rat_2g": "StringArray",
	"bandselection.rat_3g": "StringArray",
	"bandselection.rat_4g": "StringArray",
	"bandselection.rat_5g": "StringArray",
	"tags":                 "StringToString",
}
var QosPositionKpiResultRequiredArgs = []string{}
var QosPositionKpiResultOptionalArgs = []string{
	"positionid",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp.seconds",
	"gpslocation.timestamp.nanos",
	"dluserthroughputmin",
	"dluserthroughputavg",
	"dluserthroughputmax",
	"uluserthroughputmin",
	"uluserthroughputavg",
	"uluserthroughputmax",
	"latencymin",
	"latencyavg",
	"latencymax",
}
var QosPositionKpiResultAliasArgs = []string{}
var QosPositionKpiResultComments = map[string]string{
	"positionid":                     "as set by the client, must be unique within one QosPositionRequest",
	"gpslocation.latitude":           "latitude in WGS 84 coordinates",
	"gpslocation.longitude":          "longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy": "horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":   "vertical accuracy (meters)",
	"gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied altitude in meters",
	"gpslocation.course":             "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":              "speed (IOS) / velocity (Android) (meters/sec)",
	"dluserthroughputmin":            "throughput",
}
var QosPositionKpiResultSpecialArgs = map[string]string{}
var QosPositionKpiReplyRequiredArgs = []string{}
var QosPositionKpiReplyOptionalArgs = []string{
	"ver",
	"status",
	"positionresults:#.positionid",
	"positionresults:#.gpslocation.latitude",
	"positionresults:#.gpslocation.longitude",
	"positionresults:#.gpslocation.horizontalaccuracy",
	"positionresults:#.gpslocation.verticalaccuracy",
	"positionresults:#.gpslocation.altitude",
	"positionresults:#.gpslocation.course",
	"positionresults:#.gpslocation.speed",
	"positionresults:#.gpslocation.timestamp.seconds",
	"positionresults:#.gpslocation.timestamp.nanos",
	"positionresults:#.dluserthroughputmin",
	"positionresults:#.dluserthroughputavg",
	"positionresults:#.dluserthroughputmax",
	"positionresults:#.uluserthroughputmin",
	"positionresults:#.uluserthroughputavg",
	"positionresults:#.uluserthroughputmax",
	"positionresults:#.latencymin",
	"positionresults:#.latencyavg",
	"positionresults:#.latencymax",
	"tags",
}
var QosPositionKpiReplyAliasArgs = []string{}
var QosPositionKpiReplyComments = map[string]string{
	"ver":                                    "API version _(hidden)_ Reserved for future use",
	"status":                                 "Status of the reply, one of Undefined, Success, Fail",
	"positionresults:#.positionid":           "as set by the client, must be unique within one QosPositionRequest",
	"positionresults:#.gpslocation.latitude": "latitude in WGS 84 coordinates",
	"positionresults:#.gpslocation.longitude":          "longitude in WGS 84 coordinates",
	"positionresults:#.gpslocation.horizontalaccuracy": "horizontal accuracy (radius in meters)",
	"positionresults:#.gpslocation.verticalaccuracy":   "vertical accuracy (meters)",
	"positionresults:#.gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied altitude in meters",
	"positionresults:#.gpslocation.course":             "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"positionresults:#.gpslocation.speed":              "speed (IOS) / velocity (Android) (meters/sec)",
	"positionresults:#.dluserthroughputmin":            "throughput",
	"tags":                                             "_(optional)_ Vendor specific data",
}
var QosPositionKpiReplySpecialArgs = map[string]string{
	"tags": "StringToString",
}
var ClientEdgeEventRequiredArgs = []string{}
var ClientEdgeEventOptionalArgs = []string{
	"sessioncookie",
	"edgeeventscookie",
	"eventtype",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp.seconds",
	"gpslocation.timestamp.nanos",
	"samples:#.value",
	"samples:#.timestamp.seconds",
	"samples:#.timestamp.nanos",
	"samples:#.tags",
	"deviceinfostatic.deviceos",
	"deviceinfostatic.devicemodel",
	"deviceinfodynamic.datanetworktype",
	"deviceinfodynamic.signalstrength",
	"deviceinfodynamic.carriername",
	"customevent",
	"tags",
}
var ClientEdgeEventAliasArgs = []string{}
var ClientEdgeEventComments = map[string]string{
	"sessioncookie":                     "Session Cookie from RegisterClientReply",
	"edgeeventscookie":                  "Session Cookie from FindCloudletReply",
	"eventtype":                         ", one of Unknown, InitConnection, TerminateConnection, LatencySamples, LocationUpdate, CustomEvent",
	"gpslocation.latitude":              "latitude in WGS 84 coordinates",
	"gpslocation.longitude":             "longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy":    "horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":      "vertical accuracy (meters)",
	"gpslocation.altitude":              "On android only lat and long are guaranteed to be supplied altitude in meters",
	"gpslocation.course":                "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":                 "speed (IOS) / velocity (Android) (meters/sec)",
	"samples:#.value":                   "latency value",
	"samples:#.tags":                    "_(optional)_ Vendor specific data",
	"deviceinfostatic.deviceos":         "Android or iOS",
	"deviceinfostatic.devicemodel":      "Device model",
	"deviceinfodynamic.datanetworktype": "LTE, 5G, etc.",
	"deviceinfodynamic.signalstrength":  "Device signal strength",
	"deviceinfodynamic.carriername":     "Carrier name (can be different from cloudlet org if using )",
	"customevent":                       "Custom event specified by the application",
	"tags":                              "_(optional)_ Vendor specific data",
}
var ClientEdgeEventSpecialArgs = map[string]string{
	"samples:#.tags": "StringToString",
	"tags":           "StringToString",
}
var ServerEdgeEventRequiredArgs = []string{}
var ServerEdgeEventOptionalArgs = []string{
	"eventtype",
	"cloudletstate",
	"maintenancestate",
	"healthcheck",
	"statistics.avg",
	"statistics.min",
	"statistics.max",
	"statistics.stddev",
	"statistics.variance",
	"statistics.numsamples",
	"statistics.timestamp.seconds",
	"statistics.timestamp.nanos",
	"newcloudlet.ver",
	"newcloudlet.status",
	"newcloudlet.fqdn",
	"newcloudlet.ports:#.proto",
	"newcloudlet.ports:#.internalport",
	"newcloudlet.ports:#.publicport",
	"newcloudlet.ports:#.fqdnprefix",
	"newcloudlet.ports:#.endport",
	"newcloudlet.ports:#.tls",
	"newcloudlet.ports:#.nginx",
	"newcloudlet.cloudletlocation.latitude",
	"newcloudlet.cloudletlocation.longitude",
	"newcloudlet.cloudletlocation.horizontalaccuracy",
	"newcloudlet.cloudletlocation.verticalaccuracy",
	"newcloudlet.cloudletlocation.altitude",
	"newcloudlet.cloudletlocation.course",
	"newcloudlet.cloudletlocation.speed",
	"newcloudlet.cloudletlocation.timestamp.seconds",
	"newcloudlet.cloudletlocation.timestamp.nanos",
	"newcloudlet.edgeeventscookie",
	"newcloudlet.tags",
	"errormsg",
	"tags",
}
var ServerEdgeEventAliasArgs = []string{}
var ServerEdgeEventComments = map[string]string{
	"eventtype":                                       ", one of Unknown, InitConnection, LatencyRequest, LatencyProcessed, CloudletState, CloudletMaintenance, AppinstHealth, CloudletUpdate, Error",
	"cloudletstate":                                   "Cloudlet state information, one of Unknown, Errors, Ready, Offline, NotPresent, Init, Upgrade, NeedSync",
	"maintenancestate":                                "Cloudlet maintenance state information, one of NormalOperation, MaintenanceStart, FailoverRequested, FailoverDone, FailoverError, MaintenanceStartNoFailover, CrmRequested, CrmUnderMaintenance, CrmError, NormalOperationInit, UnderMaintenance",
	"healthcheck":                                     "AppInst health state information, one of Unknown, FailRootlbOffline, FailServerFail, Ok, CloudletOffline",
	"statistics.avg":                                  "average",
	"statistics.min":                                  "minimum",
	"statistics.max":                                  "maximum",
	"statistics.stddev":                               "square root of unbiased variance",
	"statistics.variance":                             "unbiased variance",
	"statistics.numsamples":                           "number of samples to create stats",
	"newcloudlet.ver":                                 "API version _(hidden)_ Reserved for future use",
	"newcloudlet.status":                              "Status return, one of Unknown, Found, Notfound",
	"newcloudlet.fqdn":                                "Fully Qualified Domain Name of the Closest App instance",
	"newcloudlet.ports:#.proto":                       "TCP (L4) or UDP (L4) protocol, one of Unknown, Tcp, Udp",
	"newcloudlet.ports:#.internalport":                "Container port",
	"newcloudlet.ports:#.publicport":                  "Public facing port for TCP/UDP (may be mapped on shared LB reverse proxy)",
	"newcloudlet.ports:#.fqdnprefix":                  "skip 4 to preserve the numbering. 4 was path_prefix but was removed since we dont need it after removed http FQDN prefix to append to base FQDN in FindCloudlet response. May be empty.",
	"newcloudlet.ports:#.endport":                     "A non-zero end port indicates a port range from internal port to end port, inclusive.",
	"newcloudlet.ports:#.tls":                         "TLS termination for this port",
	"newcloudlet.ports:#.nginx":                       "use nginx proxy for this port if you really need a transparent proxy (udp only)",
	"newcloudlet.cloudletlocation.latitude":           "latitude in WGS 84 coordinates",
	"newcloudlet.cloudletlocation.longitude":          "longitude in WGS 84 coordinates",
	"newcloudlet.cloudletlocation.horizontalaccuracy": "horizontal accuracy (radius in meters)",
	"newcloudlet.cloudletlocation.verticalaccuracy":   "vertical accuracy (meters)",
	"newcloudlet.cloudletlocation.altitude":           "On android only lat and long are guaranteed to be supplied altitude in meters",
	"newcloudlet.cloudletlocation.course":             "course (IOS) / bearing (Android) (degrees east relative to true north)",
	"newcloudlet.cloudletlocation.speed":              "speed (IOS) / velocity (Android) (meters/sec)",
	"newcloudlet.edgeeventscookie":                    "Session Cookie for specific EdgeEvents for specific AppInst",
	"newcloudlet.tags":                                "_(optional)_ Vendor specific data",
	"errormsg":                                        "Error message if event_type is EVENT_ERROR",
	"tags":                                            "_(optional)_ Vendor specific data",
}
var ServerEdgeEventSpecialArgs = map[string]string{
	"newcloudlet.tags": "StringToString",
	"tags":             "StringToString",
}
