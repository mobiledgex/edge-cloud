// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app-client.proto

/*
Package gencmd is a generated protocol buffer package.

It is generated from these files:
	app-client.proto
	dynamic-location-group.proto
	loc.proto

It has these top-level messages:
	Match_Engine_Request
	Match_Engine_Reply
	Match_Engine_Loc_Verify
	Match_Engine_Loc
	Match_Engine_Status
	DynamicLocGroupAdd
	DlgMessage
	DlgReply
	Loc
*/
package gencmd

import distributed_match_engine "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto"
import google_protobuf "github.com/gogo/protobuf/types"
import "strings"
import "time"
import "strconv"
import "github.com/spf13/cobra"
import "context"
import "os"
import "text/tabwriter"
import "github.com/spf13/pflag"
import "errors"
import "encoding/json"
import "github.com/mobiledgex/edge-cloud/protoc-gen-cmd/cmdsup"
import "github.com/mobiledgex/edge-cloud/protoc-gen-cmd/yaml"
import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Auto-generated code: DO NOT EDIT
var Match_Engine_ApiCmd distributed_match_engine.Match_Engine_ApiClient
var DynamicLocGroupAddIn distributed_match_engine.DynamicLocGroupAdd
var DynamicLocGroupAddFlagSet = pflag.NewFlagSet("DynamicLocGroupAdd", pflag.ExitOnError)
var DynamicLocGroupAddInIdType string
var DynamicLocGroupAddInCommType string
var Match_Engine_RequestIn distributed_match_engine.Match_Engine_Request
var Match_Engine_RequestFlagSet = pflag.NewFlagSet("Match_Engine_Request", pflag.ExitOnError)
var Match_Engine_RequestInIdType string
var IDTypesStrings = []string{
	"IMEI",
	"MSISDN",
	"IPADDR",
}

var Find_StatusStrings = []string{
	"FIND_UNKNOWN",
	"FIND_FOUND",
	"FIND_NOTFOUND",
}

var Tower_StatusStrings = []string{
	"UNKNOWN",
	"CONNECTED_TO_SPECIFIED_TOWER",
	"NOT_CONNECTED_TO_SPECIFIED_TOWER",
}

var GPS_Location_StatusStrings = []string{
	"LOC_UNKNOWN",
	"LOC_WITHIN_2KM",
	"LOC_WITHIN_10KM",
	"LOC_WITHIN_100KM",
	"LOC_MISMATCH",
	"LOC_OTHER_COUNTRY",
}

var Loc_StatusStrings = []string{
	"LOC_UNKNOWN",
	"LOC_FOUND",
	"LOC_DENIED",
}

var ME_StatusStrings = []string{
	"ME_SUCCESS",
	"ME_FAIL",
}

var IDTypeStrings = []string{
	"IMEI",
	"MSISDN",
	"IPADDR",
}

var DlgCommTypeStrings = []string{
	"DlgSecure",
	"DlgOpen",
}

func Match_Engine_RequestSlicer(in *distributed_match_engine.Match_Engine_Request) []string {
	s := make([]string, 0, 16)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, distributed_match_engine.Match_Engine_Request_IDTypes_name[int32(in.IdType)])
	s = append(s, in.Id)
	s = append(s, in.Uuid)
	s = append(s, strconv.FormatUint(uint64(in.CarrierID), 10))
	s = append(s, in.CarrierName)
	s = append(s, strconv.FormatUint(uint64(in.Tower), 10))
	if in.GpsLocation == nil {
		in.GpsLocation = &distributed_match_engine.Loc{}
	}
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Lat), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Long), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.HorizontalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.VerticalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Altitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Course), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Speed), 'e', -1, 32))
	if in.GpsLocation.Timestamp == nil {
		in.GpsLocation.Timestamp = &google_protobuf.Timestamp{}
	}
	_GpsLocation_TimestampTime := time.Unix(in.GpsLocation.Timestamp.Seconds, int64(in.GpsLocation.Timestamp.Nanos))
	s = append(s, _GpsLocation_TimestampTime.String())
	s = append(s, strconv.FormatUint(uint64(in.AppId), 10))
	s = append(s, "")
	for _, b := range in.Protocol {
		s[len(s)-1] += fmt.Sprintf("%v", b)
	}
	s = append(s, "")
	for _, b := range in.ServerPort {
		s[len(s)-1] += fmt.Sprintf("%v", b)
	}
	s = append(s, in.DevName)
	s = append(s, in.AppName)
	s = append(s, in.AppVers)
	s = append(s, in.CommCookie)
	s = append(s, in.VerifyLocToken)
	return s
}

func Match_Engine_RequestHeaderSlicer() []string {
	s := make([]string, 0, 16)
	s = append(s, "Ver")
	s = append(s, "IdType")
	s = append(s, "Id")
	s = append(s, "Uuid")
	s = append(s, "CarrierID")
	s = append(s, "CarrierName")
	s = append(s, "Tower")
	s = append(s, "GpsLocation-Lat")
	s = append(s, "GpsLocation-Long")
	s = append(s, "GpsLocation-HorizontalAccuracy")
	s = append(s, "GpsLocation-VerticalAccuracy")
	s = append(s, "GpsLocation-Altitude")
	s = append(s, "GpsLocation-Course")
	s = append(s, "GpsLocation-Speed")
	s = append(s, "GpsLocation-Timestamp")
	s = append(s, "AppId")
	s = append(s, "Protocol")
	s = append(s, "ServerPort")
	s = append(s, "DevName")
	s = append(s, "AppName")
	s = append(s, "AppVers")
	s = append(s, "CommCookie")
	s = append(s, "VerifyLocToken")
	return s
}

func Match_Engine_ReplySlicer(in *distributed_match_engine.Match_Engine_Reply) []string {
	s := make([]string, 0, 7)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, in.Uri)
	s = append(s, "")
	for i, b := range in.ServiceIp {
		s[len(s)-1] += fmt.Sprintf("%v", b)
		if i < 3 {
			s[len(s)-1] += "."
		}
	}
	s = append(s, strconv.FormatUint(uint64(in.ServicePort), 10))
	if in.CloudletLocation == nil {
		in.CloudletLocation = &distributed_match_engine.Loc{}
	}
	s = append(s, strconv.FormatFloat(float64(in.CloudletLocation.Lat), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.CloudletLocation.Long), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.CloudletLocation.HorizontalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.CloudletLocation.VerticalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.CloudletLocation.Altitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.CloudletLocation.Course), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.CloudletLocation.Speed), 'e', -1, 32))
	if in.CloudletLocation.Timestamp == nil {
		in.CloudletLocation.Timestamp = &google_protobuf.Timestamp{}
	}
	_CloudletLocation_TimestampTime := time.Unix(in.CloudletLocation.Timestamp.Seconds, int64(in.CloudletLocation.Timestamp.Nanos))
	s = append(s, _CloudletLocation_TimestampTime.String())
	s = append(s, distributed_match_engine.Match_Engine_Reply_Find_Status_name[int32(in.Status)])
	s = append(s, in.CommCookie)
	return s
}

func Match_Engine_ReplyHeaderSlicer() []string {
	s := make([]string, 0, 7)
	s = append(s, "Ver")
	s = append(s, "Uri")
	s = append(s, "ServiceIp")
	s = append(s, "ServicePort")
	s = append(s, "CloudletLocation-Lat")
	s = append(s, "CloudletLocation-Long")
	s = append(s, "CloudletLocation-HorizontalAccuracy")
	s = append(s, "CloudletLocation-VerticalAccuracy")
	s = append(s, "CloudletLocation-Altitude")
	s = append(s, "CloudletLocation-Course")
	s = append(s, "CloudletLocation-Speed")
	s = append(s, "CloudletLocation-Timestamp")
	s = append(s, "Status")
	s = append(s, "CommCookie")
	return s
}

func Match_Engine_Loc_VerifySlicer(in *distributed_match_engine.Match_Engine_Loc_Verify) []string {
	s := make([]string, 0, 4)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, distributed_match_engine.Match_Engine_Loc_Verify_Tower_Status_name[int32(in.TowerStatus)])
	s = append(s, distributed_match_engine.Match_Engine_Loc_Verify_GPS_Location_Status_name[int32(in.GpsLocationStatus)])
	s = append(s, in.CommCookie)
	return s
}

func Match_Engine_Loc_VerifyHeaderSlicer() []string {
	s := make([]string, 0, 4)
	s = append(s, "Ver")
	s = append(s, "TowerStatus")
	s = append(s, "GpsLocationStatus")
	s = append(s, "CommCookie")
	return s
}

func Match_Engine_LocSlicer(in *distributed_match_engine.Match_Engine_Loc) []string {
	s := make([]string, 0, 6)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, distributed_match_engine.Match_Engine_Loc_Loc_Status_name[int32(in.Status)])
	s = append(s, in.CarrierName)
	s = append(s, strconv.FormatUint(uint64(in.Tower), 10))
	if in.NetworkLocation == nil {
		in.NetworkLocation = &distributed_match_engine.Loc{}
	}
	s = append(s, strconv.FormatFloat(float64(in.NetworkLocation.Lat), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.NetworkLocation.Long), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.NetworkLocation.HorizontalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.NetworkLocation.VerticalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.NetworkLocation.Altitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.NetworkLocation.Course), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.NetworkLocation.Speed), 'e', -1, 32))
	if in.NetworkLocation.Timestamp == nil {
		in.NetworkLocation.Timestamp = &google_protobuf.Timestamp{}
	}
	_NetworkLocation_TimestampTime := time.Unix(in.NetworkLocation.Timestamp.Seconds, int64(in.NetworkLocation.Timestamp.Nanos))
	s = append(s, _NetworkLocation_TimestampTime.String())
	s = append(s, in.CommCookie)
	return s
}

func Match_Engine_LocHeaderSlicer() []string {
	s := make([]string, 0, 6)
	s = append(s, "Ver")
	s = append(s, "Status")
	s = append(s, "CarrierName")
	s = append(s, "Tower")
	s = append(s, "NetworkLocation-Lat")
	s = append(s, "NetworkLocation-Long")
	s = append(s, "NetworkLocation-HorizontalAccuracy")
	s = append(s, "NetworkLocation-VerticalAccuracy")
	s = append(s, "NetworkLocation-Altitude")
	s = append(s, "NetworkLocation-Course")
	s = append(s, "NetworkLocation-Speed")
	s = append(s, "NetworkLocation-Timestamp")
	s = append(s, "CommCookie")
	return s
}

func Match_Engine_StatusSlicer(in *distributed_match_engine.Match_Engine_Status) []string {
	s := make([]string, 0, 6)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, distributed_match_engine.Match_Engine_Status_ME_Status_name[int32(in.Status)])
	s = append(s, strconv.FormatUint(uint64(in.ErrorCode), 10))
	s = append(s, in.CommCookie)
	s = append(s, in.GroupCookie)
	s = append(s, in.TokenServerURI)
	return s
}

func Match_Engine_StatusHeaderSlicer() []string {
	s := make([]string, 0, 6)
	s = append(s, "Ver")
	s = append(s, "Status")
	s = append(s, "ErrorCode")
	s = append(s, "CommCookie")
	s = append(s, "GroupCookie")
	s = append(s, "TokenServerURI")
	return s
}

func DynamicLocGroupAddSlicer(in *distributed_match_engine.DynamicLocGroupAdd) []string {
	s := make([]string, 0, 12)
	s = append(s, strconv.FormatUint(uint64(in.Ver), 10))
	s = append(s, distributed_match_engine.DynamicLocGroupAdd_IDType_name[int32(in.IdType)])
	s = append(s, in.Id)
	s = append(s, in.Uuid)
	s = append(s, strconv.FormatUint(uint64(in.CarrierID), 10))
	s = append(s, in.CarrierName)
	s = append(s, strconv.FormatUint(uint64(in.Tower), 10))
	if in.GpsLocation == nil {
		in.GpsLocation = &distributed_match_engine.Loc{}
	}
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Lat), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Long), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.HorizontalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.VerticalAccuracy), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Altitude), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Course), 'e', -1, 32))
	s = append(s, strconv.FormatFloat(float64(in.GpsLocation.Speed), 'e', -1, 32))
	if in.GpsLocation.Timestamp == nil {
		in.GpsLocation.Timestamp = &google_protobuf.Timestamp{}
	}
	_GpsLocation_TimestampTime := time.Unix(in.GpsLocation.Timestamp.Seconds, int64(in.GpsLocation.Timestamp.Nanos))
	s = append(s, _GpsLocation_TimestampTime.String())
	s = append(s, strconv.FormatUint(uint64(in.LgId), 10))
	s = append(s, in.CommCookie)
	s = append(s, distributed_match_engine.DynamicLocGroupAdd_DlgCommType_name[int32(in.CommType)])
	s = append(s, in.UserData)
	return s
}

func DynamicLocGroupAddHeaderSlicer() []string {
	s := make([]string, 0, 12)
	s = append(s, "Ver")
	s = append(s, "IdType")
	s = append(s, "Id")
	s = append(s, "Uuid")
	s = append(s, "CarrierID")
	s = append(s, "CarrierName")
	s = append(s, "Tower")
	s = append(s, "GpsLocation-Lat")
	s = append(s, "GpsLocation-Long")
	s = append(s, "GpsLocation-HorizontalAccuracy")
	s = append(s, "GpsLocation-VerticalAccuracy")
	s = append(s, "GpsLocation-Altitude")
	s = append(s, "GpsLocation-Course")
	s = append(s, "GpsLocation-Speed")
	s = append(s, "GpsLocation-Timestamp")
	s = append(s, "LgId")
	s = append(s, "CommCookie")
	s = append(s, "CommType")
	s = append(s, "UserData")
	return s
}

var FindCloudletCmd = &cobra.Command{
	Use: "FindCloudlet",
	Run: func(cmd *cobra.Command, args []string) {
		if Match_Engine_ApiCmd == nil {
			fmt.Println("Match_Engine_Api client not initialized")
			return
		}
		var err error
		err = parseMatch_Engine_RequestEnums()
		if err != nil {
			fmt.Println("FindCloudlet: ", err)
			return
		}
		ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
		objs, err := Match_Engine_ApiCmd.FindCloudlet(ctx, &Match_Engine_RequestIn)
		cancel()
		if err != nil {
			fmt.Println("FindCloudlet failed: ", err)
			return
		}
		switch cmdsup.OutputFormat {
		case cmdsup.OutputFormatYaml:
			output, err := yaml.Marshal(objs)
			if err != nil {
				fmt.Printf("Yaml failed to marshal: %s\n", err)
				return
			}
			fmt.Print(string(output))
		case cmdsup.OutputFormatJson:
			output, err := json.MarshalIndent(objs, "", "  ")
			if err != nil {
				fmt.Printf("Json failed to marshal: %s\n", err)
				return
			}
			fmt.Println(string(output))
		case cmdsup.OutputFormatJsonCompact:
			output, err := json.Marshal(objs)
			if err != nil {
				fmt.Printf("Json failed to marshal: %s\n", err)
				return
			}
			fmt.Println(string(output))
		case cmdsup.OutputFormatTable:
			output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
			fmt.Fprintln(output, strings.Join(Match_Engine_ReplyHeaderSlicer(), "\t"))
			fmt.Fprintln(output, strings.Join(Match_Engine_ReplySlicer(objs), "\t"))
			output.Flush()
		}
	},
}

var VerifyLocationCmd = &cobra.Command{
	Use: "VerifyLocation",
	Run: func(cmd *cobra.Command, args []string) {
		if Match_Engine_ApiCmd == nil {
			fmt.Println("Match_Engine_Api client not initialized")
			return
		}
		var err error
		err = parseMatch_Engine_RequestEnums()
		if err != nil {
			fmt.Println("VerifyLocation: ", err)
			return
		}
		ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
		objs, err := Match_Engine_ApiCmd.VerifyLocation(ctx, &Match_Engine_RequestIn)
		cancel()
		if err != nil {
			fmt.Println("VerifyLocation failed: ", err)
			return
		}
		switch cmdsup.OutputFormat {
		case cmdsup.OutputFormatYaml:
			output, err := yaml.Marshal(objs)
			if err != nil {
				fmt.Printf("Yaml failed to marshal: %s\n", err)
				return
			}
			fmt.Print(string(output))
		case cmdsup.OutputFormatJson:
			output, err := json.MarshalIndent(objs, "", "  ")
			if err != nil {
				fmt.Printf("Json failed to marshal: %s\n", err)
				return
			}
			fmt.Println(string(output))
		case cmdsup.OutputFormatJsonCompact:
			output, err := json.Marshal(objs)
			if err != nil {
				fmt.Printf("Json failed to marshal: %s\n", err)
				return
			}
			fmt.Println(string(output))
		case cmdsup.OutputFormatTable:
			output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
			fmt.Fprintln(output, strings.Join(Match_Engine_Loc_VerifyHeaderSlicer(), "\t"))
			fmt.Fprintln(output, strings.Join(Match_Engine_Loc_VerifySlicer(objs), "\t"))
			output.Flush()
		}
	},
}

var GetLocationCmd = &cobra.Command{
	Use: "GetLocation",
	Run: func(cmd *cobra.Command, args []string) {
		if Match_Engine_ApiCmd == nil {
			fmt.Println("Match_Engine_Api client not initialized")
			return
		}
		var err error
		err = parseMatch_Engine_RequestEnums()
		if err != nil {
			fmt.Println("GetLocation: ", err)
			return
		}
		ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
		objs, err := Match_Engine_ApiCmd.GetLocation(ctx, &Match_Engine_RequestIn)
		cancel()
		if err != nil {
			fmt.Println("GetLocation failed: ", err)
			return
		}
		switch cmdsup.OutputFormat {
		case cmdsup.OutputFormatYaml:
			output, err := yaml.Marshal(objs)
			if err != nil {
				fmt.Printf("Yaml failed to marshal: %s\n", err)
				return
			}
			fmt.Print(string(output))
		case cmdsup.OutputFormatJson:
			output, err := json.MarshalIndent(objs, "", "  ")
			if err != nil {
				fmt.Printf("Json failed to marshal: %s\n", err)
				return
			}
			fmt.Println(string(output))
		case cmdsup.OutputFormatJsonCompact:
			output, err := json.Marshal(objs)
			if err != nil {
				fmt.Printf("Json failed to marshal: %s\n", err)
				return
			}
			fmt.Println(string(output))
		case cmdsup.OutputFormatTable:
			output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
			fmt.Fprintln(output, strings.Join(Match_Engine_LocHeaderSlicer(), "\t"))
			fmt.Fprintln(output, strings.Join(Match_Engine_LocSlicer(objs), "\t"))
			output.Flush()
		}
	},
}

var RegisterClientCmd = &cobra.Command{
	Use: "RegisterClient",
	Run: func(cmd *cobra.Command, args []string) {
		if Match_Engine_ApiCmd == nil {
			fmt.Println("Match_Engine_Api client not initialized")
			return
		}
		var err error
		err = parseMatch_Engine_RequestEnums()
		if err != nil {
			fmt.Println("RegisterClient: ", err)
			return
		}
		ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
		objs, err := Match_Engine_ApiCmd.RegisterClient(ctx, &Match_Engine_RequestIn)
		cancel()
		if err != nil {
			fmt.Println("RegisterClient failed: ", err)
			return
		}
		switch cmdsup.OutputFormat {
		case cmdsup.OutputFormatYaml:
			output, err := yaml.Marshal(objs)
			if err != nil {
				fmt.Printf("Yaml failed to marshal: %s\n", err)
				return
			}
			fmt.Print(string(output))
		case cmdsup.OutputFormatJson:
			output, err := json.MarshalIndent(objs, "", "  ")
			if err != nil {
				fmt.Printf("Json failed to marshal: %s\n", err)
				return
			}
			fmt.Println(string(output))
		case cmdsup.OutputFormatJsonCompact:
			output, err := json.Marshal(objs)
			if err != nil {
				fmt.Printf("Json failed to marshal: %s\n", err)
				return
			}
			fmt.Println(string(output))
		case cmdsup.OutputFormatTable:
			output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
			fmt.Fprintln(output, strings.Join(Match_Engine_StatusHeaderSlicer(), "\t"))
			fmt.Fprintln(output, strings.Join(Match_Engine_StatusSlicer(objs), "\t"))
			output.Flush()
		}
	},
}

var AddUserToGroupCmd = &cobra.Command{
	Use: "AddUserToGroup",
	Run: func(cmd *cobra.Command, args []string) {
		if Match_Engine_ApiCmd == nil {
			fmt.Println("Match_Engine_Api client not initialized")
			return
		}
		var err error
		err = parseDynamicLocGroupAddEnums()
		if err != nil {
			fmt.Println("AddUserToGroup: ", err)
			return
		}
		ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
		objs, err := Match_Engine_ApiCmd.AddUserToGroup(ctx, &DynamicLocGroupAddIn)
		cancel()
		if err != nil {
			fmt.Println("AddUserToGroup failed: ", err)
			return
		}
		switch cmdsup.OutputFormat {
		case cmdsup.OutputFormatYaml:
			output, err := yaml.Marshal(objs)
			if err != nil {
				fmt.Printf("Yaml failed to marshal: %s\n", err)
				return
			}
			fmt.Print(string(output))
		case cmdsup.OutputFormatJson:
			output, err := json.MarshalIndent(objs, "", "  ")
			if err != nil {
				fmt.Printf("Json failed to marshal: %s\n", err)
				return
			}
			fmt.Println(string(output))
		case cmdsup.OutputFormatJsonCompact:
			output, err := json.Marshal(objs)
			if err != nil {
				fmt.Printf("Json failed to marshal: %s\n", err)
				return
			}
			fmt.Println(string(output))
		case cmdsup.OutputFormatTable:
			output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
			fmt.Fprintln(output, strings.Join(Match_Engine_StatusHeaderSlicer(), "\t"))
			fmt.Fprintln(output, strings.Join(Match_Engine_StatusSlicer(objs), "\t"))
			output.Flush()
		}
	},
}

var Match_Engine_ApiCmds = []*cobra.Command{
	FindCloudletCmd,
	VerifyLocationCmd,
	GetLocationCmd,
	RegisterClientCmd,
	AddUserToGroupCmd,
}

func init() {
	Match_Engine_RequestFlagSet.Uint32Var(&Match_Engine_RequestIn.Ver, "ver", 0, "Ver")
	Match_Engine_RequestFlagSet.StringVar(&Match_Engine_RequestInIdType, "idtype", "", "one of [IMEI MSISDN IPADDR]")
	Match_Engine_RequestFlagSet.StringVar(&Match_Engine_RequestIn.Id, "id", "", "Id")
	Match_Engine_RequestFlagSet.StringVar(&Match_Engine_RequestIn.Uuid, "uuid", "", "Uuid")
	Match_Engine_RequestFlagSet.Uint64Var(&Match_Engine_RequestIn.CarrierID, "carrierid", 0, "CarrierID")
	Match_Engine_RequestFlagSet.StringVar(&Match_Engine_RequestIn.CarrierName, "carriername", "", "CarrierName")
	Match_Engine_RequestFlagSet.Uint64Var(&Match_Engine_RequestIn.Tower, "tower", 0, "Tower")
	Match_Engine_RequestIn.GpsLocation = &distributed_match_engine.Loc{}
	Match_Engine_RequestFlagSet.Float64Var(&Match_Engine_RequestIn.GpsLocation.Lat, "gpslocation-lat", 0, "GpsLocation.Lat")
	Match_Engine_RequestFlagSet.Float64Var(&Match_Engine_RequestIn.GpsLocation.Long, "gpslocation-long", 0, "GpsLocation.Long")
	Match_Engine_RequestFlagSet.Float64Var(&Match_Engine_RequestIn.GpsLocation.HorizontalAccuracy, "gpslocation-horizontalaccuracy", 0, "GpsLocation.HorizontalAccuracy")
	Match_Engine_RequestFlagSet.Float64Var(&Match_Engine_RequestIn.GpsLocation.VerticalAccuracy, "gpslocation-verticalaccuracy", 0, "GpsLocation.VerticalAccuracy")
	Match_Engine_RequestFlagSet.Float64Var(&Match_Engine_RequestIn.GpsLocation.Altitude, "gpslocation-altitude", 0, "GpsLocation.Altitude")
	Match_Engine_RequestFlagSet.Float64Var(&Match_Engine_RequestIn.GpsLocation.Course, "gpslocation-course", 0, "GpsLocation.Course")
	Match_Engine_RequestFlagSet.Float64Var(&Match_Engine_RequestIn.GpsLocation.Speed, "gpslocation-speed", 0, "GpsLocation.Speed")
	Match_Engine_RequestIn.GpsLocation.Timestamp = &google_protobuf.Timestamp{}
	Match_Engine_RequestFlagSet.Int64Var(&Match_Engine_RequestIn.GpsLocation.Timestamp.Seconds, "gpslocation-timestamp-seconds", 0, "GpsLocation.Timestamp.Seconds")
	Match_Engine_RequestFlagSet.Int32Var(&Match_Engine_RequestIn.GpsLocation.Timestamp.Nanos, "gpslocation-timestamp-nanos", 0, "GpsLocation.Timestamp.Nanos")
	Match_Engine_RequestFlagSet.Uint64Var(&Match_Engine_RequestIn.AppId, "appid", 0, "AppId")
	Match_Engine_RequestFlagSet.BytesHexVar(&Match_Engine_RequestIn.Protocol, "protocol", nil, "Protocol")
	Match_Engine_RequestFlagSet.BytesHexVar(&Match_Engine_RequestIn.ServerPort, "serverport", nil, "ServerPort")
	Match_Engine_RequestFlagSet.StringVar(&Match_Engine_RequestIn.DevName, "devname", "", "DevName")
	Match_Engine_RequestFlagSet.StringVar(&Match_Engine_RequestIn.AppName, "appname", "", "AppName")
	Match_Engine_RequestFlagSet.StringVar(&Match_Engine_RequestIn.AppVers, "appvers", "", "AppVers")
	Match_Engine_RequestFlagSet.StringVar(&Match_Engine_RequestIn.CommCookie, "commcookie", "", "CommCookie")
	Match_Engine_RequestFlagSet.StringVar(&Match_Engine_RequestIn.VerifyLocToken, "verifyloctoken", "", "VerifyLocToken")
	DynamicLocGroupAddFlagSet.Uint32Var(&DynamicLocGroupAddIn.Ver, "ver", 0, "Ver")
	DynamicLocGroupAddFlagSet.StringVar(&DynamicLocGroupAddInIdType, "idtype", "", "one of [IMEI MSISDN IPADDR]")
	DynamicLocGroupAddFlagSet.StringVar(&DynamicLocGroupAddIn.Id, "id", "", "Id")
	DynamicLocGroupAddFlagSet.StringVar(&DynamicLocGroupAddIn.Uuid, "uuid", "", "Uuid")
	DynamicLocGroupAddFlagSet.Uint64Var(&DynamicLocGroupAddIn.CarrierID, "carrierid", 0, "CarrierID")
	DynamicLocGroupAddFlagSet.StringVar(&DynamicLocGroupAddIn.CarrierName, "carriername", "", "CarrierName")
	DynamicLocGroupAddFlagSet.Uint64Var(&DynamicLocGroupAddIn.Tower, "tower", 0, "Tower")
	DynamicLocGroupAddIn.GpsLocation = &distributed_match_engine.Loc{}
	DynamicLocGroupAddFlagSet.Float64Var(&DynamicLocGroupAddIn.GpsLocation.Lat, "gpslocation-lat", 0, "GpsLocation.Lat")
	DynamicLocGroupAddFlagSet.Float64Var(&DynamicLocGroupAddIn.GpsLocation.Long, "gpslocation-long", 0, "GpsLocation.Long")
	DynamicLocGroupAddFlagSet.Float64Var(&DynamicLocGroupAddIn.GpsLocation.HorizontalAccuracy, "gpslocation-horizontalaccuracy", 0, "GpsLocation.HorizontalAccuracy")
	DynamicLocGroupAddFlagSet.Float64Var(&DynamicLocGroupAddIn.GpsLocation.VerticalAccuracy, "gpslocation-verticalaccuracy", 0, "GpsLocation.VerticalAccuracy")
	DynamicLocGroupAddFlagSet.Float64Var(&DynamicLocGroupAddIn.GpsLocation.Altitude, "gpslocation-altitude", 0, "GpsLocation.Altitude")
	DynamicLocGroupAddFlagSet.Float64Var(&DynamicLocGroupAddIn.GpsLocation.Course, "gpslocation-course", 0, "GpsLocation.Course")
	DynamicLocGroupAddFlagSet.Float64Var(&DynamicLocGroupAddIn.GpsLocation.Speed, "gpslocation-speed", 0, "GpsLocation.Speed")
	DynamicLocGroupAddIn.GpsLocation.Timestamp = &google_protobuf.Timestamp{}
	DynamicLocGroupAddFlagSet.Int64Var(&DynamicLocGroupAddIn.GpsLocation.Timestamp.Seconds, "gpslocation-timestamp-seconds", 0, "GpsLocation.Timestamp.Seconds")
	DynamicLocGroupAddFlagSet.Int32Var(&DynamicLocGroupAddIn.GpsLocation.Timestamp.Nanos, "gpslocation-timestamp-nanos", 0, "GpsLocation.Timestamp.Nanos")
	DynamicLocGroupAddFlagSet.Uint64Var(&DynamicLocGroupAddIn.LgId, "lgid", 0, "LgId")
	DynamicLocGroupAddFlagSet.StringVar(&DynamicLocGroupAddIn.CommCookie, "commcookie", "", "CommCookie")
	DynamicLocGroupAddFlagSet.StringVar(&DynamicLocGroupAddInCommType, "commtype", "", "one of [DlgSecure DlgOpen]")
	DynamicLocGroupAddFlagSet.StringVar(&DynamicLocGroupAddIn.UserData, "userdata", "", "UserData")
	FindCloudletCmd.Flags().AddFlagSet(Match_Engine_RequestFlagSet)
	VerifyLocationCmd.Flags().AddFlagSet(Match_Engine_RequestFlagSet)
	GetLocationCmd.Flags().AddFlagSet(Match_Engine_RequestFlagSet)
	RegisterClientCmd.Flags().AddFlagSet(Match_Engine_RequestFlagSet)
	AddUserToGroupCmd.Flags().AddFlagSet(DynamicLocGroupAddFlagSet)
}

func parseDynamicLocGroupAddEnums() error {
	if DynamicLocGroupAddInIdType != "" {
		switch DynamicLocGroupAddInIdType {
		case "IMEI":
			DynamicLocGroupAddIn.IdType = distributed_match_engine.DynamicLocGroupAdd_IDType(0)
		case "MSISDN":
			DynamicLocGroupAddIn.IdType = distributed_match_engine.DynamicLocGroupAdd_IDType(1)
		case "IPADDR":
			DynamicLocGroupAddIn.IdType = distributed_match_engine.DynamicLocGroupAdd_IDType(2)
		default:
			return errors.New("Invalid value for DynamicLocGroupAddInIdType")
		}
	}
	if DynamicLocGroupAddInCommType != "" {
		switch DynamicLocGroupAddInCommType {
		case "DlgSecure":
			DynamicLocGroupAddIn.CommType = distributed_match_engine.DynamicLocGroupAdd_DlgCommType(0)
		case "DlgOpen":
			DynamicLocGroupAddIn.CommType = distributed_match_engine.DynamicLocGroupAdd_DlgCommType(1)
		default:
			return errors.New("Invalid value for DynamicLocGroupAddInCommType")
		}
	}
	return nil
}

func parseMatch_Engine_RequestEnums() error {
	if Match_Engine_RequestInIdType != "" {
		switch Match_Engine_RequestInIdType {
		case "IMEI":
			Match_Engine_RequestIn.IdType = distributed_match_engine.Match_Engine_Request_IDTypes(0)
		case "MSISDN":
			Match_Engine_RequestIn.IdType = distributed_match_engine.Match_Engine_Request_IDTypes(1)
		case "IPADDR":
			Match_Engine_RequestIn.IdType = distributed_match_engine.Match_Engine_Request_IDTypes(2)
		default:
			return errors.New("Invalid value for Match_Engine_RequestInIdType")
		}
	}
	return nil
}
