// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app-client.proto

package gencmd

import (
	"context"
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	proto "github.com/gogo/protobuf/proto"
	"github.com/mobiledgex/edge-cloud/cli"
	distributed_match_engine "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto"
	"github.com/spf13/cobra"
	"google.golang.org/grpc/status"
	"io"
	math "math"
	"strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Auto-generated code: DO NOT EDIT
var MatchEngineApiCmd distributed_match_engine.MatchEngineApiClient

var RegisterClientCmd = &cli.Command{
	Use:          "RegisterClient",
	RequiredArgs: strings.Join(RegisterClientRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(RegisterClientRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(RegisterClientRequestAliasArgs, " "),
	SpecialArgs:  &RegisterClientRequestSpecialArgs,
	Comments:     RegisterClientRequestComments,
	ReqData:      &distributed_match_engine.RegisterClientRequest{},
	ReplyData:    &distributed_match_engine.RegisterClientReply{},
	Run:          runRegisterClient,
}

func runRegisterClient(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.RegisterClientRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return RegisterClient(c, obj)
}

func RegisterClient(c *cli.Command, in *distributed_match_engine.RegisterClientRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.RegisterClient(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("RegisterClient failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func RegisterClients(c *cli.Command, data []distributed_match_engine.RegisterClientRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("RegisterClient %v\n", data[ii])
		myerr := RegisterClient(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var FindCloudletCmd = &cli.Command{
	Use:          "FindCloudlet",
	RequiredArgs: strings.Join(FindCloudletRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(FindCloudletRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(FindCloudletRequestAliasArgs, " "),
	SpecialArgs:  &FindCloudletRequestSpecialArgs,
	Comments:     FindCloudletRequestComments,
	ReqData:      &distributed_match_engine.FindCloudletRequest{},
	ReplyData:    &distributed_match_engine.FindCloudletReply{},
	Run:          runFindCloudlet,
}

func runFindCloudlet(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.FindCloudletRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return FindCloudlet(c, obj)
}

func FindCloudlet(c *cli.Command, in *distributed_match_engine.FindCloudletRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.FindCloudlet(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("FindCloudlet failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func FindCloudlets(c *cli.Command, data []distributed_match_engine.FindCloudletRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("FindCloudlet %v\n", data[ii])
		myerr := FindCloudlet(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var PlatformFindCloudletCmd = &cli.Command{
	Use:          "PlatformFindCloudlet",
	RequiredArgs: strings.Join(PlatformFindCloudletRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(PlatformFindCloudletRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(PlatformFindCloudletRequestAliasArgs, " "),
	SpecialArgs:  &PlatformFindCloudletRequestSpecialArgs,
	Comments:     PlatformFindCloudletRequestComments,
	ReqData:      &distributed_match_engine.PlatformFindCloudletRequest{},
	ReplyData:    &distributed_match_engine.FindCloudletReply{},
	Run:          runPlatformFindCloudlet,
}

func runPlatformFindCloudlet(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.PlatformFindCloudletRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return PlatformFindCloudlet(c, obj)
}

func PlatformFindCloudlet(c *cli.Command, in *distributed_match_engine.PlatformFindCloudletRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.PlatformFindCloudlet(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("PlatformFindCloudlet failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func PlatformFindCloudlets(c *cli.Command, data []distributed_match_engine.PlatformFindCloudletRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("PlatformFindCloudlet %v\n", data[ii])
		myerr := PlatformFindCloudlet(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var QosPrioritySessionCreateCmd = &cli.Command{
	Use:          "QosPrioritySessionCreate",
	RequiredArgs: strings.Join(QosPrioritySessionCreateRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(QosPrioritySessionCreateRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(QosPrioritySessionCreateRequestAliasArgs, " "),
	SpecialArgs:  &QosPrioritySessionCreateRequestSpecialArgs,
	Comments:     QosPrioritySessionCreateRequestComments,
	ReqData:      &distributed_match_engine.QosPrioritySessionCreateRequest{},
	ReplyData:    &distributed_match_engine.QosPrioritySessionReply{},
	Run:          runQosPrioritySessionCreate,
}

func runQosPrioritySessionCreate(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.QosPrioritySessionCreateRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return QosPrioritySessionCreate(c, obj)
}

func QosPrioritySessionCreate(c *cli.Command, in *distributed_match_engine.QosPrioritySessionCreateRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.QosPrioritySessionCreate(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("QosPrioritySessionCreate failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func QosPrioritySessionCreates(c *cli.Command, data []distributed_match_engine.QosPrioritySessionCreateRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("QosPrioritySessionCreate %v\n", data[ii])
		myerr := QosPrioritySessionCreate(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var QosPrioritySessionDeleteCmd = &cli.Command{
	Use:          "QosPrioritySessionDelete",
	RequiredArgs: strings.Join(QosPrioritySessionDeleteRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(QosPrioritySessionDeleteRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(QosPrioritySessionDeleteRequestAliasArgs, " "),
	SpecialArgs:  &QosPrioritySessionDeleteRequestSpecialArgs,
	Comments:     QosPrioritySessionDeleteRequestComments,
	ReqData:      &distributed_match_engine.QosPrioritySessionDeleteRequest{},
	ReplyData:    &distributed_match_engine.QosPrioritySessionDeleteReply{},
	Run:          runQosPrioritySessionDelete,
}

func runQosPrioritySessionDelete(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.QosPrioritySessionDeleteRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return QosPrioritySessionDelete(c, obj)
}

func QosPrioritySessionDelete(c *cli.Command, in *distributed_match_engine.QosPrioritySessionDeleteRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.QosPrioritySessionDelete(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("QosPrioritySessionDelete failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func QosPrioritySessionDeletes(c *cli.Command, data []distributed_match_engine.QosPrioritySessionDeleteRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("QosPrioritySessionDelete %v\n", data[ii])
		myerr := QosPrioritySessionDelete(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var VerifyLocationCmd = &cli.Command{
	Use:          "VerifyLocation",
	RequiredArgs: strings.Join(VerifyLocationRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(VerifyLocationRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(VerifyLocationRequestAliasArgs, " "),
	SpecialArgs:  &VerifyLocationRequestSpecialArgs,
	Comments:     VerifyLocationRequestComments,
	ReqData:      &distributed_match_engine.VerifyLocationRequest{},
	ReplyData:    &distributed_match_engine.VerifyLocationReply{},
	Run:          runVerifyLocation,
}

func runVerifyLocation(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.VerifyLocationRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return VerifyLocation(c, obj)
}

func VerifyLocation(c *cli.Command, in *distributed_match_engine.VerifyLocationRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.VerifyLocation(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("VerifyLocation failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func VerifyLocations(c *cli.Command, data []distributed_match_engine.VerifyLocationRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("VerifyLocation %v\n", data[ii])
		myerr := VerifyLocation(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetLocationCmd = &cli.Command{
	Use:          "GetLocation",
	RequiredArgs: strings.Join(GetLocationRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(GetLocationRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(GetLocationRequestAliasArgs, " "),
	SpecialArgs:  &GetLocationRequestSpecialArgs,
	Comments:     GetLocationRequestComments,
	ReqData:      &distributed_match_engine.GetLocationRequest{},
	ReplyData:    &distributed_match_engine.GetLocationReply{},
	Run:          runGetLocation,
}

func runGetLocation(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.GetLocationRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetLocation(c, obj)
}

func GetLocation(c *cli.Command, in *distributed_match_engine.GetLocationRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.GetLocation(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetLocation failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetLocations(c *cli.Command, data []distributed_match_engine.GetLocationRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetLocation %v\n", data[ii])
		myerr := GetLocation(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var AddUserToGroupCmd = &cli.Command{
	Use:          "AddUserToGroup",
	RequiredArgs: strings.Join(DynamicLocGroupRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(DynamicLocGroupRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(DynamicLocGroupRequestAliasArgs, " "),
	SpecialArgs:  &DynamicLocGroupRequestSpecialArgs,
	Comments:     DynamicLocGroupRequestComments,
	ReqData:      &distributed_match_engine.DynamicLocGroupRequest{},
	ReplyData:    &distributed_match_engine.DynamicLocGroupReply{},
	Run:          runAddUserToGroup,
}

func runAddUserToGroup(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.DynamicLocGroupRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return AddUserToGroup(c, obj)
}

func AddUserToGroup(c *cli.Command, in *distributed_match_engine.DynamicLocGroupRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.AddUserToGroup(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("AddUserToGroup failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func AddUserToGroups(c *cli.Command, data []distributed_match_engine.DynamicLocGroupRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("AddUserToGroup %v\n", data[ii])
		myerr := AddUserToGroup(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetAppInstListCmd = &cli.Command{
	Use:          "GetAppInstList",
	RequiredArgs: strings.Join(AppInstListRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(AppInstListRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(AppInstListRequestAliasArgs, " "),
	SpecialArgs:  &AppInstListRequestSpecialArgs,
	Comments:     AppInstListRequestComments,
	ReqData:      &distributed_match_engine.AppInstListRequest{},
	ReplyData:    &distributed_match_engine.AppInstListReply{},
	Run:          runGetAppInstList,
}

func runGetAppInstList(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.AppInstListRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetAppInstList(c, obj)
}

func GetAppInstList(c *cli.Command, in *distributed_match_engine.AppInstListRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.GetAppInstList(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetAppInstList failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetAppInstLists(c *cli.Command, data []distributed_match_engine.AppInstListRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetAppInstList %v\n", data[ii])
		myerr := GetAppInstList(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetFqdnListCmd = &cli.Command{
	Use:          "GetFqdnList",
	RequiredArgs: strings.Join(FqdnListRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(FqdnListRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(FqdnListRequestAliasArgs, " "),
	SpecialArgs:  &FqdnListRequestSpecialArgs,
	Comments:     FqdnListRequestComments,
	ReqData:      &distributed_match_engine.FqdnListRequest{},
	ReplyData:    &distributed_match_engine.FqdnListReply{},
	Run:          runGetFqdnList,
}

func runGetFqdnList(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.FqdnListRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetFqdnList(c, obj)
}

func GetFqdnList(c *cli.Command, in *distributed_match_engine.FqdnListRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.GetFqdnList(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetFqdnList failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetFqdnLists(c *cli.Command, data []distributed_match_engine.FqdnListRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetFqdnList %v\n", data[ii])
		myerr := GetFqdnList(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetAppOfficialFqdnCmd = &cli.Command{
	Use:          "GetAppOfficialFqdn",
	RequiredArgs: strings.Join(AppOfficialFqdnRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(AppOfficialFqdnRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(AppOfficialFqdnRequestAliasArgs, " "),
	SpecialArgs:  &AppOfficialFqdnRequestSpecialArgs,
	Comments:     AppOfficialFqdnRequestComments,
	ReqData:      &distributed_match_engine.AppOfficialFqdnRequest{},
	ReplyData:    &distributed_match_engine.AppOfficialFqdnReply{},
	Run:          runGetAppOfficialFqdn,
}

func runGetAppOfficialFqdn(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.AppOfficialFqdnRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetAppOfficialFqdn(c, obj)
}

func GetAppOfficialFqdn(c *cli.Command, in *distributed_match_engine.AppOfficialFqdnRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	obj, err := MatchEngineApiCmd.GetAppOfficialFqdn(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetAppOfficialFqdn failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetAppOfficialFqdns(c *cli.Command, data []distributed_match_engine.AppOfficialFqdnRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetAppOfficialFqdn %v\n", data[ii])
		myerr := GetAppOfficialFqdn(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetQosPositionKpiCmd = &cli.Command{
	Use:          "GetQosPositionKpi",
	RequiredArgs: strings.Join(QosPositionRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(QosPositionRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(QosPositionRequestAliasArgs, " "),
	SpecialArgs:  &QosPositionRequestSpecialArgs,
	Comments:     QosPositionRequestComments,
	ReqData:      &distributed_match_engine.QosPositionRequest{},
	ReplyData:    &distributed_match_engine.QosPositionKpiReply{},
	Run:          runGetQosPositionKpi,
}

func runGetQosPositionKpi(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*distributed_match_engine.QosPositionRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetQosPositionKpi(c, obj)
}

func GetQosPositionKpi(c *cli.Command, in *distributed_match_engine.QosPositionRequest) error {
	if MatchEngineApiCmd == nil {
		return fmt.Errorf("MatchEngineApi client not initialized")
	}
	ctx := context.Background()
	stream, err := MatchEngineApiCmd.GetQosPositionKpi(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetQosPositionKpi failed: %s", errstr)
	}

	objs := make([]*distributed_match_engine.QosPositionKpiReply, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("GetQosPositionKpi recv failed: %s", errstr)
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetQosPositionKpis(c *cli.Command, data []distributed_match_engine.QosPositionRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetQosPositionKpi %v\n", data[ii])
		myerr := GetQosPositionKpi(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var MatchEngineApiCmds = []*cobra.Command{
	RegisterClientCmd.GenCmd(),
	FindCloudletCmd.GenCmd(),
	PlatformFindCloudletCmd.GenCmd(),
	QosPrioritySessionCreateCmd.GenCmd(),
	QosPrioritySessionDeleteCmd.GenCmd(),
	VerifyLocationCmd.GenCmd(),
	GetLocationCmd.GenCmd(),
	AddUserToGroupCmd.GenCmd(),
	GetAppInstListCmd.GenCmd(),
	GetFqdnListCmd.GenCmd(),
	GetAppOfficialFqdnCmd.GenCmd(),
	GetQosPositionKpiCmd.GenCmd(),
}

var RegisterClientRequestRequiredArgs = []string{}
var RegisterClientRequestOptionalArgs = []string{
	"ver",
	"orgname",
	"appname",
	"appvers",
	"carriername",
	"authtoken",
	"uniqueidtype",
	"uniqueid",
	"tags",
}
var RegisterClientRequestAliasArgs = []string{}
var RegisterClientRequestComments = map[string]string{
	"ver":          "API version _(hidden)_ Reserved for future use",
	"orgname":      "App Organization Name App developer organization name.",
	"appname":      "App Name Name of your application.",
	"appvers":      "App Version Application version.",
	"carriername":  "Carrier Name _(hidden)_ Reserved for future use",
	"authtoken":    "Authentication Token _(optional)_ An authentication token supplied by the application.",
	"uniqueidtype": "Unique ID Type _(optional)_ Type of unique ID provided by the client. If left blank, a new Unique ID type will be assigned in the RegisterClient Reply.",
	"uniqueid":     "Unique ID _(optional)_ Unique identification of the client device or user. May be overridden by the server. If left blank, a new Unique ID will be assigned in the RegisterClient Reply.",
	"tags":         "Tags _(optional)_ Vendor specific data",
}
var RegisterClientRequestSpecialArgs = map[string]string{
	"tags": "StringToString",
}
var RegisterClientReplyRequiredArgs = []string{}
var RegisterClientReplyOptionalArgs = []string{
	"ver",
	"status",
	"sessioncookie",
	"tokenserveruri",
	"uniqueidtype",
	"uniqueid",
	"tags",
}
var RegisterClientReplyAliasArgs = []string{}
var RegisterClientReplyComments = map[string]string{
	"ver":            "API version _(hidden)_ Reserved for future use",
	"status":         "Status of the reply, one of Undefined, Success, Fail",
	"sessioncookie":  "Session Cookie to be used in later API calls",
	"tokenserveruri": "URI for the Token Server",
	"uniqueidtype":   "Unique ID Type _(optional)_ Type of unique ID provided by the server A unique_id_type and unique_id may be provided by the client to be registered. During registering, if a unique_id_type and unique_id are provided by the client in their request, the unique_id_type and unique_id will be left blank in the response. But, if the client does not provide a unique_id_type and unique_id, then the server generates one and provides the unique_id in the response. If possible, the unique_id should be saved by the client locally and used for subsequent RegisterClient API calls. Otherwise, a new unique_id will be generated for further API calls.",
	"uniqueid":       "Unique ID _(optional)_ Unique identification of the client device or user A unique_id_type and unique_id may be provided by the client to be registered. During registering, if a unique_id_type and unique_id are provided by the client in their request, the unique_id_type and unique_id will be left blank in the response. But, if the client does not provide a unique_id_type and unique_id, then the server generates one and provides the unique_id in the response. If possible, the unique_id should be saved by the client locally and used for subsequent RegisterClient API calls. Otherwise, a new unique_id will be generated for further API calls.",
	"tags":           "Vendor specific data _(optional)_ Array of Tags.",
}
var RegisterClientReplySpecialArgs = map[string]string{
	"tags": "StringToString",
}
var FindCloudletRequestRequiredArgs = []string{}
var FindCloudletRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"carriername",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp",
	"tags",
}
var FindCloudletRequestAliasArgs = []string{}
var FindCloudletRequestComments = map[string]string{
	"ver":                            "API version _(hidden)_ Reserved for future use",
	"sessioncookie":                  "Session Cookie Session Cookie from RegisterClientRequest",
	"carriername":                    "Carrier Name _(optional)_ By default, all SDKs will automatically fill in this parameter with the MCC+MNC of your current provider. Only override this parameter if you need to filter for a specific carrier on the DME. The DME will filter for App instances that are associated with the specified carrier. If you wish to search for any App Instance on the DME regardless of carrier name, you can input “” to consider all carriers as “Any”.",
	"gpslocation.latitude":           "Latitude in WGS 84 coordinates",
	"gpslocation.longitude":          "Longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy": "Horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":   "Vertical accuracy (meters)",
	"gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied Altitude in meters",
	"gpslocation.course":             "Course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":              "Speed (IOS) / velocity (Android) (meters/sec)",
	"gpslocation.timestamp":          "Timestamp",
	"tags":                           "Tags _(optional)_ Vendor specific data",
}
var FindCloudletRequestSpecialArgs = map[string]string{
	"tags": "StringToString",
}
var PlatformFindCloudletRequestRequiredArgs = []string{}
var PlatformFindCloudletRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"carriername",
	"clienttoken",
	"tags",
}
var PlatformFindCloudletRequestAliasArgs = []string{}
var PlatformFindCloudletRequestComments = map[string]string{
	"ver":           "API version _(hidden)_ Reserved for future use",
	"sessioncookie": "Session Cookie Session Cookie from RegisterClientRequest",
	"carriername":   "Carrier Name _(optional)_ By default, all SDKs will automatically fill in this parameter with the MCC+MNC of your current provider. Only override this parameter if you need to filter for a specific carrier on the DME. The DME will filter for App instances that are associated with the specified carrier. If you wish to search for any app instance on the DME regardless of carrier name, you can input “” to consider all carriers as “Any”.",
	"clienttoken":   "Client Token Token with encoded client data",
	"tags":          "Tags _(optional)_ Vendor specific data",
}
var PlatformFindCloudletRequestSpecialArgs = map[string]string{
	"tags": "StringToString",
}
var FindCloudletReplyRequiredArgs = []string{}
var FindCloudletReplyOptionalArgs = []string{
	"ver",
	"status",
	"fqdn",
	"ports:#.proto",
	"ports:#.internalport",
	"ports:#.publicport",
	"ports:#.fqdnprefix",
	"ports:#.endport",
	"ports:#.tls",
	"ports:#.nginx",
	"ports:#.maxpktsize",
	"cloudletlocation.latitude",
	"cloudletlocation.longitude",
	"cloudletlocation.horizontalaccuracy",
	"cloudletlocation.verticalaccuracy",
	"cloudletlocation.altitude",
	"cloudletlocation.course",
	"cloudletlocation.speed",
	"cloudletlocation.timestamp",
	"edgeeventscookie",
	"qosresult",
	"qoserrormsg",
	"tags",
}
var FindCloudletReplyAliasArgs = []string{}
var FindCloudletReplyComments = map[string]string{
	"ver":                                 "API version _(hidden)_ Reserved for future use",
	"status":                              "Status return, one of Unknown, Found, Notfound",
	"fqdn":                                "Fully Qualified Domain Name of the Closest App instance",
	"ports:#.proto":                       "TCP (L4) or UDP (L4) protocol, one of Unknown, Tcp, Udp",
	"ports:#.internalport":                "Container port",
	"ports:#.publicport":                  "Public facing port for TCP/UDP (may be mapped on shared LB reverse proxy)",
	"ports:#.fqdnprefix":                  "skip 4 to preserve the numbering. 4 was path_prefix but was removed since we dont need it after removed http FQDN prefix to append to base FQDN in FindCloudlet response. May be empty.",
	"ports:#.endport":                     "A non-zero end port indicates a port range from internal port to end port, inclusive.",
	"ports:#.tls":                         "TLS termination for this port",
	"ports:#.nginx":                       "Use nginx proxy for this port if you really need a transparent proxy (udp only)",
	"ports:#.maxpktsize":                  "Maximum datagram size (udp only)",
	"cloudletlocation.latitude":           "Latitude in WGS 84 coordinates",
	"cloudletlocation.longitude":          "Longitude in WGS 84 coordinates",
	"cloudletlocation.horizontalaccuracy": "Horizontal accuracy (radius in meters)",
	"cloudletlocation.verticalaccuracy":   "Vertical accuracy (meters)",
	"cloudletlocation.altitude":           "On android only lat and long are guaranteed to be supplied Altitude in meters",
	"cloudletlocation.course":             "Course (IOS) / bearing (Android) (degrees east relative to true north)",
	"cloudletlocation.speed":              "Speed (IOS) / velocity (Android) (meters/sec)",
	"cloudletlocation.timestamp":          "Timestamp",
	"edgeeventscookie":                    "Session Cookie for specific EdgeEvents for specific AppInst",
	"qosresult":                           "Result of QOS priority session creation attempt, one of NotAttempted, SessionCreated, SessionFailed",
	"qoserrormsg":                         "Error message in case of QOS_SESSION_FAILED",
	"tags":                                "_(optional)_ Vendor specific data",
}
var FindCloudletReplySpecialArgs = map[string]string{
	"tags": "StringToString",
}
var QosPrioritySessionCreateRequestRequiredArgs = []string{}
var QosPrioritySessionCreateRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"sessionduration",
	"ipuserequipment",
	"ipapplicationserver",
	"portuserequipment",
	"portapplicationserver",
	"protocolin",
	"protocolout",
	"profile",
	"notificationuri",
	"notificationauthtoken",
	"tags",
}
var QosPrioritySessionCreateRequestAliasArgs = []string{}
var QosPrioritySessionCreateRequestComments = map[string]string{
	"ver":                   "API version _(hidden)_ Reserved for future use",
	"sessioncookie":         "Session Cookie from RegisterClientRequest",
	"sessionduration":       "_(optional)_ QOS Priority Session duration in seconds",
	"ipuserequipment":       "IP address of mobile device",
	"ipapplicationserver":   "IP address of the application server",
	"portuserequipment":     "_(optional)_ A list of single ports or port ranges on the user equipment.",
	"portapplicationserver": "_(optional)_ A list of single ports or port ranges on the application server",
	"protocolin":            "_(optional)_ The used transport protocol for the uplink, one of Tcp, Udp, Any",
	"protocolout":           "_(optional)_ The used transport protocol for the downlink, one of Tcp, Udp, Any",
	"profile":               "QOS Priority Session profile name, one of NoPriority, LowLatency, ThroughputDownS, ThroughputDownM, ThroughputDownL",
	"notificationuri":       "_(optional)_ URI of the callback receiver. Allows asynchronous delivery of session related events.",
	"notificationauthtoken": "_(optional)_ Authentification token for callback API",
	"tags":                  "_(optional)_ Vendor specific data",
}
var QosPrioritySessionCreateRequestSpecialArgs = map[string]string{
	"tags": "StringToString",
}
var QosPrioritySessionReplyRequiredArgs = []string{}
var QosPrioritySessionReplyOptionalArgs = []string{
	"ver",
	"sessionduration",
	"profile",
	"sessionid",
	"startedat",
	"expiresat",
	"httpstatus",
	"tags",
}
var QosPrioritySessionReplyAliasArgs = []string{}
var QosPrioritySessionReplyComments = map[string]string{
	"ver":             "API version _(hidden)_ Reserved for future use",
	"sessionduration": "QOS Priority Session duration in seconds",
	"profile":         "QOS Priority Session profile name, one of NoPriority, LowLatency, ThroughputDownS, ThroughputDownM, ThroughputDownL",
	"sessionid":       "Session ID in UUID format",
	"startedat":       "Timestamp of session start in seconds since unix epoch",
	"expiresat":       "Timestamp of session expiration if the session was not deleted in seconds since unix epoch",
	"httpstatus":      "HTTP Status Code of call to operators API server.",
	"tags":            "_(optional)_ Vendor specific data",
}
var QosPrioritySessionReplySpecialArgs = map[string]string{
	"tags": "StringToString",
}
var QosPrioritySessionDeleteRequestRequiredArgs = []string{}
var QosPrioritySessionDeleteRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"profile",
	"sessionid",
	"tags",
}
var QosPrioritySessionDeleteRequestAliasArgs = []string{}
var QosPrioritySessionDeleteRequestComments = map[string]string{
	"ver":           "API version _(hidden)_ Reserved for future use",
	"sessioncookie": "Session Cookie from RegisterClientRequest",
	"profile":       "QOS Priority Session profile name, one of NoPriority, LowLatency, ThroughputDownS, ThroughputDownM, ThroughputDownL",
	"sessionid":     "QOS Priority Session ID to be deleted",
	"tags":          "_(optional)_ Vendor specific data",
}
var QosPrioritySessionDeleteRequestSpecialArgs = map[string]string{
	"tags": "StringToString",
}
var QosPrioritySessionDeleteReplyRequiredArgs = []string{}
var QosPrioritySessionDeleteReplyOptionalArgs = []string{
	"ver",
	"status",
	"tags",
}
var QosPrioritySessionDeleteReplyAliasArgs = []string{}
var QosPrioritySessionDeleteReplyComments = map[string]string{
	"ver":    "API version _(hidden)_ Reserved for future use",
	"status": "Status return., one of Unknown, Deleted, NotFound",
	"tags":   "_(optional)_ Vendor specific data",
}
var QosPrioritySessionDeleteReplySpecialArgs = map[string]string{
	"tags": "StringToString",
}
var VerifyLocationRequestRequiredArgs = []string{}
var VerifyLocationRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"carriername",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp",
	"verifyloctoken",
	"tags",
}
var VerifyLocationRequestAliasArgs = []string{}
var VerifyLocationRequestComments = map[string]string{
	"ver":                            "API version _(hidden)_ Reserved for future use",
	"sessioncookie":                  "Session Cookie Session Cookie from RegisterClientRequest",
	"carriername":                    "Carrier Name Unique carrier identification (typically MCC + MNC)",
	"gpslocation.latitude":           "Latitude in WGS 84 coordinates",
	"gpslocation.longitude":          "Longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy": "Horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":   "Vertical accuracy (meters)",
	"gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied Altitude in meters",
	"gpslocation.course":             "Course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":              "Speed (IOS) / velocity (Android) (meters/sec)",
	"gpslocation.timestamp":          "Timestamp",
	"verifyloctoken":                 "Verify Location Token Must be retrieved from TokenServerURI",
	"tags":                           "Tags _(optional)_ Vendor specific data",
}
var VerifyLocationRequestSpecialArgs = map[string]string{
	"tags": "StringToString",
}
var VerifyLocationReplyRequiredArgs = []string{}
var VerifyLocationReplyOptionalArgs = []string{
	"ver",
	"towerstatus",
	"gpslocationstatus",
	"gpslocationaccuracykm",
	"tags",
}
var VerifyLocationReplyAliasArgs = []string{}
var VerifyLocationReplyComments = map[string]string{
	"ver":                   "API version _(hidden)_ Reserved for future use",
	"towerstatus":           ", one of TowerUnknown, ConnectedToSpecifiedTower, NotConnectedToSpecifiedTower",
	"gpslocationstatus":     ", one of Unknown, Verified, MismatchSameCountry, MismatchOtherCountry, RoamingCountryMatch, RoamingCountryMismatch, ErrorUnauthorized, ErrorOther",
	"gpslocationaccuracykm": "location accuracy, the location is verified to be within this number of kilometers.  Negative value means no verification was performed",
	"tags":                  "_(optional)_ Vendor specific data",
}
var VerifyLocationReplySpecialArgs = map[string]string{
	"tags": "StringToString",
}
var GetLocationRequestRequiredArgs = []string{}
var GetLocationRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"carriername",
	"tags",
}
var GetLocationRequestAliasArgs = []string{}
var GetLocationRequestComments = map[string]string{
	"ver":           "API version _(hidden)_ Reserved for future use",
	"sessioncookie": "Session Cookie from RegisterClientRequest",
	"carriername":   "Unique carrier identification (typically MCC + MNC)",
	"tags":          "_(optional)_ Vendor specific data",
}
var GetLocationRequestSpecialArgs = map[string]string{
	"tags": "StringToString",
}
var GetLocationReplyRequiredArgs = []string{}
var GetLocationReplyOptionalArgs = []string{
	"ver",
	"status",
	"carriername",
	"tower",
	"networklocation.latitude",
	"networklocation.longitude",
	"networklocation.horizontalaccuracy",
	"networklocation.verticalaccuracy",
	"networklocation.altitude",
	"networklocation.course",
	"networklocation.speed",
	"networklocation.timestamp",
	"tags",
}
var GetLocationReplyAliasArgs = []string{}
var GetLocationReplyComments = map[string]string{
	"ver":                                "API version _(hidden)_ Reserved for future use",
	"status":                             ", one of Unknown, Found, Denied",
	"carriername":                        "Unique carrier identification (typically MCC + MNC)",
	"tower":                              "The tower that the user is currently connected to",
	"networklocation.latitude":           "Latitude in WGS 84 coordinates",
	"networklocation.longitude":          "Longitude in WGS 84 coordinates",
	"networklocation.horizontalaccuracy": "Horizontal accuracy (radius in meters)",
	"networklocation.verticalaccuracy":   "Vertical accuracy (meters)",
	"networklocation.altitude":           "On android only lat and long are guaranteed to be supplied Altitude in meters",
	"networklocation.course":             "Course (IOS) / bearing (Android) (degrees east relative to true north)",
	"networklocation.speed":              "Speed (IOS) / velocity (Android) (meters/sec)",
	"networklocation.timestamp":          "Timestamp",
	"tags":                               "_(optional)_ Vendor specific data",
}
var GetLocationReplySpecialArgs = map[string]string{
	"tags": "StringToString",
}
var AppInstListRequestRequiredArgs = []string{}
var AppInstListRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"carriername",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp",
	"limit",
	"tags",
}
var AppInstListRequestAliasArgs = []string{}
var AppInstListRequestComments = map[string]string{
	"ver":                            "API version _(hidden)_ Reserved for future use",
	"sessioncookie":                  "Session Cookie from RegisterClientRequest",
	"carriername":                    "Carrier Name _(optional)_ By default, all SDKs will automatically fill in this parameter with the MCC+MNC of your current provider. Only override this parameter if you need to filter for a specific carrier on the DME. The DME will filter for App instances that are associated with the specified carrier. If you wish to search for any App Instance on the DME regardless of carrier name, you can input “” to consider all carriers as “Any”.",
	"gpslocation.latitude":           "Latitude in WGS 84 coordinates",
	"gpslocation.longitude":          "Longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy": "Horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":   "Vertical accuracy (meters)",
	"gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied Altitude in meters",
	"gpslocation.course":             "Course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":              "Speed (IOS) / velocity (Android) (meters/sec)",
	"gpslocation.timestamp":          "Timestamp",
	"limit":                          "_(optional)_ Limit the number of results, defaults to 3",
	"tags":                           "_(optional)_ Vendor specific data",
}
var AppInstListRequestSpecialArgs = map[string]string{
	"tags": "StringToString",
}
var AppinstanceRequiredArgs = []string{}
var AppinstanceOptionalArgs = []string{
	"appname",
	"appvers",
	"fqdn",
	"ports:#.proto",
	"ports:#.internalport",
	"ports:#.publicport",
	"ports:#.fqdnprefix",
	"ports:#.endport",
	"ports:#.tls",
	"ports:#.nginx",
	"ports:#.maxpktsize",
	"orgname",
	"edgeeventscookie",
}
var AppinstanceAliasArgs = []string{}
var AppinstanceComments = map[string]string{
	"appname":              "App Instance Name",
	"appvers":              "App Instance Version",
	"fqdn":                 "App Instance FQDN",
	"ports:#.proto":        "TCP (L4) or UDP (L4) protocol, one of Unknown, Tcp, Udp",
	"ports:#.internalport": "Container port",
	"ports:#.publicport":   "Public facing port for TCP/UDP (may be mapped on shared LB reverse proxy)",
	"ports:#.fqdnprefix":   "skip 4 to preserve the numbering. 4 was path_prefix but was removed since we dont need it after removed http FQDN prefix to append to base FQDN in FindCloudlet response. May be empty.",
	"ports:#.endport":      "A non-zero end port indicates a port range from internal port to end port, inclusive.",
	"ports:#.tls":          "TLS termination for this port",
	"ports:#.nginx":        "Use nginx proxy for this port if you really need a transparent proxy (udp only)",
	"ports:#.maxpktsize":   "Maximum datagram size (udp only)",
	"orgname":              "App Organization Name",
	"edgeeventscookie":     "Session Cookie for specific EdgeEvents for specific AppInst",
}
var AppinstanceSpecialArgs = map[string]string{}
var CloudletLocationRequiredArgs = []string{}
var CloudletLocationOptionalArgs = []string{
	"carriername",
	"cloudletname",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp",
	"distance",
	"appinstances:#.appname",
	"appinstances:#.appvers",
	"appinstances:#.fqdn",
	"appinstances:#.ports:#.proto",
	"appinstances:#.ports:#.internalport",
	"appinstances:#.ports:#.publicport",
	"appinstances:#.ports:#.fqdnprefix",
	"appinstances:#.ports:#.endport",
	"appinstances:#.ports:#.tls",
	"appinstances:#.ports:#.nginx",
	"appinstances:#.ports:#.maxpktsize",
	"appinstances:#.orgname",
	"appinstances:#.edgeeventscookie",
}
var CloudletLocationAliasArgs = []string{}
var CloudletLocationComments = map[string]string{
	"carriername":                         "Cloudlet Organization Name",
	"cloudletname":                        "Cloudlet Name",
	"gpslocation.latitude":                "Latitude in WGS 84 coordinates",
	"gpslocation.longitude":               "Longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy":      "Horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":        "Vertical accuracy (meters)",
	"gpslocation.altitude":                "On android only lat and long are guaranteed to be supplied Altitude in meters",
	"gpslocation.course":                  "Course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":                   "Speed (IOS) / velocity (Android) (meters/sec)",
	"gpslocation.timestamp":               "Timestamp",
	"distance":                            "Distance of cloudlet vs loc in request",
	"appinstances:#.appname":              "App Instance Name",
	"appinstances:#.appvers":              "App Instance Version",
	"appinstances:#.fqdn":                 "App Instance FQDN",
	"appinstances:#.ports:#.proto":        "TCP (L4) or UDP (L4) protocol, one of Unknown, Tcp, Udp",
	"appinstances:#.ports:#.internalport": "Container port",
	"appinstances:#.ports:#.publicport":   "Public facing port for TCP/UDP (may be mapped on shared LB reverse proxy)",
	"appinstances:#.ports:#.fqdnprefix":   "skip 4 to preserve the numbering. 4 was path_prefix but was removed since we dont need it after removed http FQDN prefix to append to base FQDN in FindCloudlet response. May be empty.",
	"appinstances:#.ports:#.endport":      "A non-zero end port indicates a port range from internal port to end port, inclusive.",
	"appinstances:#.ports:#.tls":          "TLS termination for this port",
	"appinstances:#.ports:#.nginx":        "Use nginx proxy for this port if you really need a transparent proxy (udp only)",
	"appinstances:#.ports:#.maxpktsize":   "Maximum datagram size (udp only)",
	"appinstances:#.orgname":              "App Organization Name",
	"appinstances:#.edgeeventscookie":     "Session Cookie for specific EdgeEvents for specific AppInst",
}
var CloudletLocationSpecialArgs = map[string]string{}
var AppInstListReplyRequiredArgs = []string{}
var AppInstListReplyOptionalArgs = []string{
	"ver",
	"status",
	"cloudlets:#.carriername",
	"cloudlets:#.cloudletname",
	"cloudlets:#.gpslocation.latitude",
	"cloudlets:#.gpslocation.longitude",
	"cloudlets:#.gpslocation.horizontalaccuracy",
	"cloudlets:#.gpslocation.verticalaccuracy",
	"cloudlets:#.gpslocation.altitude",
	"cloudlets:#.gpslocation.course",
	"cloudlets:#.gpslocation.speed",
	"cloudlets:#.gpslocation.timestamp",
	"cloudlets:#.distance",
	"cloudlets:#.appinstances:#.appname",
	"cloudlets:#.appinstances:#.appvers",
	"cloudlets:#.appinstances:#.fqdn",
	"cloudlets:#.appinstances:#.ports:#.proto",
	"cloudlets:#.appinstances:#.ports:#.internalport",
	"cloudlets:#.appinstances:#.ports:#.publicport",
	"cloudlets:#.appinstances:#.ports:#.fqdnprefix",
	"cloudlets:#.appinstances:#.ports:#.endport",
	"cloudlets:#.appinstances:#.ports:#.tls",
	"cloudlets:#.appinstances:#.ports:#.nginx",
	"cloudlets:#.appinstances:#.ports:#.maxpktsize",
	"cloudlets:#.appinstances:#.orgname",
	"cloudlets:#.appinstances:#.edgeeventscookie",
	"tags",
}
var AppInstListReplyAliasArgs = []string{}
var AppInstListReplyComments = map[string]string{
	"ver":                                             "API version _(hidden)_ Reserved for future use",
	"status":                                          ", one of Undefined, Success, Fail",
	"cloudlets:#.carriername":                         "Cloudlet Organization Name",
	"cloudlets:#.cloudletname":                        "Cloudlet Name",
	"cloudlets:#.gpslocation.latitude":                "Latitude in WGS 84 coordinates",
	"cloudlets:#.gpslocation.longitude":               "Longitude in WGS 84 coordinates",
	"cloudlets:#.gpslocation.horizontalaccuracy":      "Horizontal accuracy (radius in meters)",
	"cloudlets:#.gpslocation.verticalaccuracy":        "Vertical accuracy (meters)",
	"cloudlets:#.gpslocation.altitude":                "On android only lat and long are guaranteed to be supplied Altitude in meters",
	"cloudlets:#.gpslocation.course":                  "Course (IOS) / bearing (Android) (degrees east relative to true north)",
	"cloudlets:#.gpslocation.speed":                   "Speed (IOS) / velocity (Android) (meters/sec)",
	"cloudlets:#.gpslocation.timestamp":               "Timestamp",
	"cloudlets:#.distance":                            "Distance of cloudlet vs loc in request",
	"cloudlets:#.appinstances:#.appname":              "App Instance Name",
	"cloudlets:#.appinstances:#.appvers":              "App Instance Version",
	"cloudlets:#.appinstances:#.fqdn":                 "App Instance FQDN",
	"cloudlets:#.appinstances:#.ports:#.proto":        "TCP (L4) or UDP (L4) protocol, one of Unknown, Tcp, Udp",
	"cloudlets:#.appinstances:#.ports:#.internalport": "Container port",
	"cloudlets:#.appinstances:#.ports:#.publicport":   "Public facing port for TCP/UDP (may be mapped on shared LB reverse proxy)",
	"cloudlets:#.appinstances:#.ports:#.fqdnprefix":   "skip 4 to preserve the numbering. 4 was path_prefix but was removed since we dont need it after removed http FQDN prefix to append to base FQDN in FindCloudlet response. May be empty.",
	"cloudlets:#.appinstances:#.ports:#.endport":      "A non-zero end port indicates a port range from internal port to end port, inclusive.",
	"cloudlets:#.appinstances:#.ports:#.tls":          "TLS termination for this port",
	"cloudlets:#.appinstances:#.ports:#.nginx":        "Use nginx proxy for this port if you really need a transparent proxy (udp only)",
	"cloudlets:#.appinstances:#.ports:#.maxpktsize":   "Maximum datagram size (udp only)",
	"cloudlets:#.appinstances:#.orgname":              "App Organization Name",
	"cloudlets:#.appinstances:#.edgeeventscookie":     "Session Cookie for specific EdgeEvents for specific AppInst",
	"tags": "_(optional)_ Vendor specific data",
}
var AppInstListReplySpecialArgs = map[string]string{
	"tags": "StringToString",
}
var FqdnListRequestRequiredArgs = []string{}
var FqdnListRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"tags",
}
var FqdnListRequestAliasArgs = []string{}
var FqdnListRequestComments = map[string]string{
	"ver":           "API version _(hidden)_ Reserved for future use",
	"sessioncookie": "Session Cookie from RegisterClientRequest",
	"tags":          "_(optional)_ Vendor specific data",
}
var FqdnListRequestSpecialArgs = map[string]string{
	"tags": "StringToString",
}
var AppFqdnRequiredArgs = []string{}
var AppFqdnOptionalArgs = []string{
	"appname",
	"appvers",
	"orgname",
	"fqdns",
	"androidpackagename",
}
var AppFqdnAliasArgs = []string{}
var AppFqdnComments = map[string]string{
	"appname":            "App  Name",
	"appvers":            "App Version",
	"orgname":            "App organization name",
	"fqdns":              "App FQDN",
	"androidpackagename": "_(optional)_ Android package name",
}
var AppFqdnSpecialArgs = map[string]string{
	"fqdns": "StringArray",
}
var FqdnListReplyRequiredArgs = []string{}
var FqdnListReplyOptionalArgs = []string{
	"ver",
	"appfqdns:#.appname",
	"appfqdns:#.appvers",
	"appfqdns:#.orgname",
	"appfqdns:#.fqdns",
	"appfqdns:#.androidpackagename",
	"status",
	"tags",
}
var FqdnListReplyAliasArgs = []string{}
var FqdnListReplyComments = map[string]string{
	"ver":                           "API version _(hidden)_ Reserved for future use",
	"appfqdns:#.appname":            "App  Name",
	"appfqdns:#.appvers":            "App Version",
	"appfqdns:#.orgname":            "App organization name",
	"appfqdns:#.fqdns":              "App FQDN",
	"appfqdns:#.androidpackagename": "_(optional)_ Android package name",
	"status":                        ", one of Undefined, Success, Fail",
	"tags":                          "_(optional)_ Vendor specific data",
}
var FqdnListReplySpecialArgs = map[string]string{
	"appfqdns:#.fqdns": "StringArray",
	"tags":             "StringToString",
}
var AppOfficialFqdnRequestRequiredArgs = []string{}
var AppOfficialFqdnRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp",
	"tags",
}
var AppOfficialFqdnRequestAliasArgs = []string{}
var AppOfficialFqdnRequestComments = map[string]string{
	"ver":                            "API version _(hidden)_ Reserved for future use",
	"sessioncookie":                  "Session Cookie from RegisterClientRequest",
	"gpslocation.latitude":           "Latitude in WGS 84 coordinates",
	"gpslocation.longitude":          "Longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy": "Horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":   "Vertical accuracy (meters)",
	"gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied Altitude in meters",
	"gpslocation.course":             "Course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":              "Speed (IOS) / velocity (Android) (meters/sec)",
	"gpslocation.timestamp":          "Timestamp",
	"tags":                           "_(optional)_ Vendor specific data",
}
var AppOfficialFqdnRequestSpecialArgs = map[string]string{
	"tags": "StringToString",
}
var AppOfficialFqdnReplyRequiredArgs = []string{}
var AppOfficialFqdnReplyOptionalArgs = []string{
	"ver",
	"appofficialfqdn",
	"clienttoken",
	"status",
	"ports:#.proto",
	"ports:#.internalport",
	"ports:#.publicport",
	"ports:#.fqdnprefix",
	"ports:#.endport",
	"ports:#.tls",
	"ports:#.nginx",
	"ports:#.maxpktsize",
	"tags",
}
var AppOfficialFqdnReplyAliasArgs = []string{}
var AppOfficialFqdnReplyComments = map[string]string{
	"ver":                  "API version _(hidden)_ Reserved for future use",
	"appofficialfqdn":      "The FQDN to which the app is reached independent of the edge",
	"clienttoken":          "Tokenized client data",
	"status":               "Status of the reply, one of Undefined, Success, Fail",
	"ports:#.proto":        "TCP (L4) or UDP (L4) protocol, one of Unknown, Tcp, Udp",
	"ports:#.internalport": "Container port",
	"ports:#.publicport":   "Public facing port for TCP/UDP (may be mapped on shared LB reverse proxy)",
	"ports:#.fqdnprefix":   "skip 4 to preserve the numbering. 4 was path_prefix but was removed since we dont need it after removed http FQDN prefix to append to base FQDN in FindCloudlet response. May be empty.",
	"ports:#.endport":      "A non-zero end port indicates a port range from internal port to end port, inclusive.",
	"ports:#.tls":          "TLS termination for this port",
	"ports:#.nginx":        "Use nginx proxy for this port if you really need a transparent proxy (udp only)",
	"ports:#.maxpktsize":   "Maximum datagram size (udp only)",
	"tags":                 "_(optional)_ Vendor specific data",
}
var AppOfficialFqdnReplySpecialArgs = map[string]string{
	"tags": "StringToString",
}
var DynamicLocGroupRequestRequiredArgs = []string{}
var DynamicLocGroupRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"lgid",
	"commtype",
	"userdata",
	"tags",
}
var DynamicLocGroupRequestAliasArgs = []string{}
var DynamicLocGroupRequestComments = map[string]string{
	"ver":           "API version _(hidden)_ Reserved for future use",
	"sessioncookie": "Session Cookie from RegisterClientRequest",
	"lgid":          "Dynamic Location Group Id",
	"commtype":      ", one of Undefined, Secure, Open",
	"userdata":      "Unused",
	"tags":          "_(optional)_ Vendor specific data",
}
var DynamicLocGroupRequestSpecialArgs = map[string]string{
	"tags": "StringToString",
}
var DynamicLocGroupReplyRequiredArgs = []string{}
var DynamicLocGroupReplyOptionalArgs = []string{
	"ver",
	"status",
	"errorcode",
	"groupcookie",
	"tags",
}
var DynamicLocGroupReplyAliasArgs = []string{}
var DynamicLocGroupReplyComments = map[string]string{
	"ver":         "API version _(hidden)_ Reserved for future use",
	"status":      "Status of the reply, one of Undefined, Success, Fail",
	"errorcode":   "Error Code based on Failure",
	"groupcookie": "Group Cookie for Secure Group Communication",
	"tags":        "_(optional)_ Vendor specific data",
}
var DynamicLocGroupReplySpecialArgs = map[string]string{
	"tags": "StringToString",
}
var QosPositionRequiredArgs = []string{}
var QosPositionOptionalArgs = []string{
	"positionid",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp",
}
var QosPositionAliasArgs = []string{}
var QosPositionComments = map[string]string{
	"positionid":                     "as set by the client, must be unique within QosRequest",
	"gpslocation.latitude":           "Latitude in WGS 84 coordinates",
	"gpslocation.longitude":          "Longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy": "Horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":   "Vertical accuracy (meters)",
	"gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied Altitude in meters",
	"gpslocation.course":             "Course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":              "Speed (IOS) / velocity (Android) (meters/sec)",
	"gpslocation.timestamp":          "Timestamp",
}
var QosPositionSpecialArgs = map[string]string{}
var BandSelectionRequiredArgs = []string{}
var BandSelectionOptionalArgs = []string{
	"rat2g",
	"rat3g",
	"rat4g",
	"rat5g",
}
var BandSelectionAliasArgs = []string{}
var BandSelectionComments = map[string]string{
	"rat2g": "Radio Access Technologies",
}
var BandSelectionSpecialArgs = map[string]string{
	"rat2g": "StringArray",
	"rat3g": "StringArray",
	"rat4g": "StringArray",
	"rat5g": "StringArray",
}
var QosPositionRequestRequiredArgs = []string{}
var QosPositionRequestOptionalArgs = []string{
	"ver",
	"sessioncookie",
	"positions:#.positionid",
	"positions:#.gpslocation.latitude",
	"positions:#.gpslocation.longitude",
	"positions:#.gpslocation.horizontalaccuracy",
	"positions:#.gpslocation.verticalaccuracy",
	"positions:#.gpslocation.altitude",
	"positions:#.gpslocation.course",
	"positions:#.gpslocation.speed",
	"positions:#.gpslocation.timestamp",
	"ltecategory",
	"bandselection.rat2g",
	"bandselection.rat3g",
	"bandselection.rat4g",
	"bandselection.rat5g",
	"tags",
}
var QosPositionRequestAliasArgs = []string{}
var QosPositionRequestComments = map[string]string{
	"ver":                                        "API version _(hidden)_ Reserved for future use",
	"sessioncookie":                              "Session Cookie from RegisterClientRequest",
	"positions:#.positionid":                     "as set by the client, must be unique within QosRequest",
	"positions:#.gpslocation.latitude":           "Latitude in WGS 84 coordinates",
	"positions:#.gpslocation.longitude":          "Longitude in WGS 84 coordinates",
	"positions:#.gpslocation.horizontalaccuracy": "Horizontal accuracy (radius in meters)",
	"positions:#.gpslocation.verticalaccuracy":   "Vertical accuracy (meters)",
	"positions:#.gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied Altitude in meters",
	"positions:#.gpslocation.course":             "Course (IOS) / bearing (Android) (degrees east relative to true north)",
	"positions:#.gpslocation.speed":              "Speed (IOS) / velocity (Android) (meters/sec)",
	"positions:#.gpslocation.timestamp":          "Timestamp",
	"ltecategory":                                "_(optional)_ Clients device LTE category number.",
	"bandselection.rat2g":                        "Radio Access Technologies",
	"tags":                                       "_(optional)_ Vendor specific data",
}
var QosPositionRequestSpecialArgs = map[string]string{
	"bandselection.rat2g": "StringArray",
	"bandselection.rat3g": "StringArray",
	"bandselection.rat4g": "StringArray",
	"bandselection.rat5g": "StringArray",
	"tags":                "StringToString",
}
var QosPositionKpiResultRequiredArgs = []string{}
var QosPositionKpiResultOptionalArgs = []string{
	"positionid",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp",
	"dluserthroughputmin",
	"dluserthroughputavg",
	"dluserthroughputmax",
	"uluserthroughputmin",
	"uluserthroughputavg",
	"uluserthroughputmax",
	"latencymin",
	"latencyavg",
	"latencymax",
}
var QosPositionKpiResultAliasArgs = []string{}
var QosPositionKpiResultComments = map[string]string{
	"positionid":                     "as set by the client, must be unique within one QosPositionRequest",
	"gpslocation.latitude":           "Latitude in WGS 84 coordinates",
	"gpslocation.longitude":          "Longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy": "Horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":   "Vertical accuracy (meters)",
	"gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied Altitude in meters",
	"gpslocation.course":             "Course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":              "Speed (IOS) / velocity (Android) (meters/sec)",
	"gpslocation.timestamp":          "Timestamp",
	"dluserthroughputmin":            "throughput",
}
var QosPositionKpiResultSpecialArgs = map[string]string{}
var QosPositionKpiReplyRequiredArgs = []string{}
var QosPositionKpiReplyOptionalArgs = []string{
	"ver",
	"status",
	"positionresults:#.positionid",
	"positionresults:#.gpslocation.latitude",
	"positionresults:#.gpslocation.longitude",
	"positionresults:#.gpslocation.horizontalaccuracy",
	"positionresults:#.gpslocation.verticalaccuracy",
	"positionresults:#.gpslocation.altitude",
	"positionresults:#.gpslocation.course",
	"positionresults:#.gpslocation.speed",
	"positionresults:#.gpslocation.timestamp",
	"positionresults:#.dluserthroughputmin",
	"positionresults:#.dluserthroughputavg",
	"positionresults:#.dluserthroughputmax",
	"positionresults:#.uluserthroughputmin",
	"positionresults:#.uluserthroughputavg",
	"positionresults:#.uluserthroughputmax",
	"positionresults:#.latencymin",
	"positionresults:#.latencyavg",
	"positionresults:#.latencymax",
	"tags",
}
var QosPositionKpiReplyAliasArgs = []string{}
var QosPositionKpiReplyComments = map[string]string{
	"ver":                                    "API version _(hidden)_ Reserved for future use",
	"status":                                 "Status of the reply, one of Undefined, Success, Fail",
	"positionresults:#.positionid":           "as set by the client, must be unique within one QosPositionRequest",
	"positionresults:#.gpslocation.latitude": "Latitude in WGS 84 coordinates",
	"positionresults:#.gpslocation.longitude":          "Longitude in WGS 84 coordinates",
	"positionresults:#.gpslocation.horizontalaccuracy": "Horizontal accuracy (radius in meters)",
	"positionresults:#.gpslocation.verticalaccuracy":   "Vertical accuracy (meters)",
	"positionresults:#.gpslocation.altitude":           "On android only lat and long are guaranteed to be supplied Altitude in meters",
	"positionresults:#.gpslocation.course":             "Course (IOS) / bearing (Android) (degrees east relative to true north)",
	"positionresults:#.gpslocation.speed":              "Speed (IOS) / velocity (Android) (meters/sec)",
	"positionresults:#.gpslocation.timestamp":          "Timestamp",
	"positionresults:#.dluserthroughputmin":            "throughput",
	"tags":                                             "_(optional)_ Vendor specific data",
}
var QosPositionKpiReplySpecialArgs = map[string]string{
	"tags": "StringToString",
}
var ClientEdgeEventRequiredArgs = []string{}
var ClientEdgeEventOptionalArgs = []string{
	"sessioncookie",
	"edgeeventscookie",
	"eventtype",
	"gpslocation.latitude",
	"gpslocation.longitude",
	"gpslocation.horizontalaccuracy",
	"gpslocation.verticalaccuracy",
	"gpslocation.altitude",
	"gpslocation.course",
	"gpslocation.speed",
	"gpslocation.timestamp",
	"samples:#.value",
	"samples:#.timestamp",
	"samples:#.tags",
	"deviceinfostatic.deviceos",
	"deviceinfostatic.devicemodel",
	"deviceinfodynamic.datanetworktype",
	"deviceinfodynamic.signalstrength",
	"deviceinfodynamic.carriername",
	"customevent",
	"tags",
}
var ClientEdgeEventAliasArgs = []string{}
var ClientEdgeEventComments = map[string]string{
	"sessioncookie":                     "Session Cookie from RegisterClientReply",
	"edgeeventscookie":                  "Session Cookie from FindCloudletReply",
	"eventtype":                         ", one of Unknown, InitConnection, TerminateConnection, LatencySamples, LocationUpdate, CustomEvent",
	"gpslocation.latitude":              "Latitude in WGS 84 coordinates",
	"gpslocation.longitude":             "Longitude in WGS 84 coordinates",
	"gpslocation.horizontalaccuracy":    "Horizontal accuracy (radius in meters)",
	"gpslocation.verticalaccuracy":      "Vertical accuracy (meters)",
	"gpslocation.altitude":              "On android only lat and long are guaranteed to be supplied Altitude in meters",
	"gpslocation.course":                "Course (IOS) / bearing (Android) (degrees east relative to true north)",
	"gpslocation.speed":                 "Speed (IOS) / velocity (Android) (meters/sec)",
	"gpslocation.timestamp":             "Timestamp",
	"samples:#.value":                   "Latency value",
	"samples:#.timestamp":               "Timestamp",
	"samples:#.tags":                    "_(optional)_ Vendor specific data",
	"deviceinfostatic.deviceos":         "Android or iOS",
	"deviceinfostatic.devicemodel":      "Device model",
	"deviceinfodynamic.datanetworktype": "LTE, 5G, etc.",
	"deviceinfodynamic.signalstrength":  "Device signal strength",
	"deviceinfodynamic.carriername":     "Carrier name (can be different from cloudlet org if using )",
	"customevent":                       "Custom event specified by the application",
	"tags":                              "_(optional)_ Vendor specific data",
}
var ClientEdgeEventSpecialArgs = map[string]string{
	"samples:#.tags": "StringToString",
	"tags":           "StringToString",
}
var ServerEdgeEventRequiredArgs = []string{}
var ServerEdgeEventOptionalArgs = []string{
	"eventtype",
	"cloudletstate",
	"maintenancestate",
	"healthcheck",
	"statistics.avg",
	"statistics.min",
	"statistics.max",
	"statistics.stddev",
	"statistics.variance",
	"statistics.numsamples",
	"statistics.timestamp",
	"newcloudlet.ver",
	"newcloudlet.status",
	"newcloudlet.fqdn",
	"newcloudlet.ports:#.proto",
	"newcloudlet.ports:#.internalport",
	"newcloudlet.ports:#.publicport",
	"newcloudlet.ports:#.fqdnprefix",
	"newcloudlet.ports:#.endport",
	"newcloudlet.ports:#.tls",
	"newcloudlet.ports:#.nginx",
	"newcloudlet.ports:#.maxpktsize",
	"newcloudlet.cloudletlocation.latitude",
	"newcloudlet.cloudletlocation.longitude",
	"newcloudlet.cloudletlocation.horizontalaccuracy",
	"newcloudlet.cloudletlocation.verticalaccuracy",
	"newcloudlet.cloudletlocation.altitude",
	"newcloudlet.cloudletlocation.course",
	"newcloudlet.cloudletlocation.speed",
	"newcloudlet.cloudletlocation.timestamp",
	"newcloudlet.edgeeventscookie",
	"newcloudlet.qosresult",
	"newcloudlet.qoserrormsg",
	"newcloudlet.tags",
	"errormsg",
	"tags",
}
var ServerEdgeEventAliasArgs = []string{}
var ServerEdgeEventComments = map[string]string{
	"eventtype":                                       ", one of Unknown, InitConnection, LatencyRequest, LatencyProcessed, CloudletState, CloudletMaintenance, AppinstHealth, CloudletUpdate, Error",
	"cloudletstate":                                   "Cloudlet state information if cloudlet state is not CLOUDLET_STATE_READY, one of Unknown, Errors, Ready, Offline, NotPresent, Init, Upgrade, NeedSync",
	"maintenancestate":                                "Cloudlet maintenance state information if maintenance state is not NORMAL_OPERATION, one of NormalOperation, MaintenanceStart, MaintenanceStartNoFailover",
	"healthcheck":                                     "AppInst health state information if health check is not HEALTH_CHECK_OK, one of Unknown, FailRootlbOffline, FailServerFail, Ok, CloudletOffline",
	"statistics.avg":                                  "Average",
	"statistics.min":                                  "Minimum",
	"statistics.max":                                  "Maximum",
	"statistics.stddev":                               "Square root of unbiased variance",
	"statistics.variance":                             "Unbiased variance",
	"statistics.numsamples":                           "Number of samples to create stats",
	"statistics.timestamp":                            "Timestamp",
	"newcloudlet.ver":                                 "API version _(hidden)_ Reserved for future use",
	"newcloudlet.status":                              "Status return, one of Unknown, Found, Notfound",
	"newcloudlet.fqdn":                                "Fully Qualified Domain Name of the Closest App instance",
	"newcloudlet.ports:#.proto":                       "TCP (L4) or UDP (L4) protocol, one of Unknown, Tcp, Udp",
	"newcloudlet.ports:#.internalport":                "Container port",
	"newcloudlet.ports:#.publicport":                  "Public facing port for TCP/UDP (may be mapped on shared LB reverse proxy)",
	"newcloudlet.ports:#.fqdnprefix":                  "skip 4 to preserve the numbering. 4 was path_prefix but was removed since we dont need it after removed http FQDN prefix to append to base FQDN in FindCloudlet response. May be empty.",
	"newcloudlet.ports:#.endport":                     "A non-zero end port indicates a port range from internal port to end port, inclusive.",
	"newcloudlet.ports:#.tls":                         "TLS termination for this port",
	"newcloudlet.ports:#.nginx":                       "Use nginx proxy for this port if you really need a transparent proxy (udp only)",
	"newcloudlet.ports:#.maxpktsize":                  "Maximum datagram size (udp only)",
	"newcloudlet.cloudletlocation.latitude":           "Latitude in WGS 84 coordinates",
	"newcloudlet.cloudletlocation.longitude":          "Longitude in WGS 84 coordinates",
	"newcloudlet.cloudletlocation.horizontalaccuracy": "Horizontal accuracy (radius in meters)",
	"newcloudlet.cloudletlocation.verticalaccuracy":   "Vertical accuracy (meters)",
	"newcloudlet.cloudletlocation.altitude":           "On android only lat and long are guaranteed to be supplied Altitude in meters",
	"newcloudlet.cloudletlocation.course":             "Course (IOS) / bearing (Android) (degrees east relative to true north)",
	"newcloudlet.cloudletlocation.speed":              "Speed (IOS) / velocity (Android) (meters/sec)",
	"newcloudlet.cloudletlocation.timestamp":          "Timestamp",
	"newcloudlet.edgeeventscookie":                    "Session Cookie for specific EdgeEvents for specific AppInst",
	"newcloudlet.qosresult":                           "Result of QOS priority session creation attempt, one of NotAttempted, SessionCreated, SessionFailed",
	"newcloudlet.qoserrormsg":                         "Error message in case of QOS_SESSION_FAILED",
	"newcloudlet.tags":                                "_(optional)_ Vendor specific data",
	"errormsg":                                        "Error message if event_type is EVENT_ERROR",
	"tags":                                            "_(optional)_ Vendor specific data",
}
var ServerEdgeEventSpecialArgs = map[string]string{
	"newcloudlet.tags": "StringToString",
	"tags":             "StringToString",
}
