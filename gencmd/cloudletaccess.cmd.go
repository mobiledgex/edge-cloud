// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cloudletaccess.proto

package gencmd

import (
	"context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/mobiledgex/edge-cloud/cli"
	edgeproto "github.com/mobiledgex/edge-cloud/edgeproto"
	"github.com/spf13/cobra"
	"google.golang.org/grpc/status"
	math "math"
	"strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Auto-generated code: DO NOT EDIT
var CloudletAccessApiCmd edgeproto.CloudletAccessApiClient

var IssueCertCmd = &cli.Command{
	Use:          "IssueCert",
	RequiredArgs: strings.Join(IssueCertRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(IssueCertRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(IssueCertRequestAliasArgs, " "),
	SpecialArgs:  &IssueCertRequestSpecialArgs,
	Comments:     IssueCertRequestComments,
	ReqData:      &edgeproto.IssueCertRequest{},
	ReplyData:    &edgeproto.IssueCertReply{},
	Run:          runIssueCert,
}

func runIssueCert(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.IssueCertRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return IssueCert(c, obj)
}

func IssueCert(c *cli.Command, in *edgeproto.IssueCertRequest) error {
	if CloudletAccessApiCmd == nil {
		return fmt.Errorf("CloudletAccessApi client not initialized")
	}
	ctx := context.Background()
	obj, err := CloudletAccessApiCmd.IssueCert(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("IssueCert failed: %s", errstr)
	}
	c.WriteOutput(obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func IssueCerts(c *cli.Command, data []edgeproto.IssueCertRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("IssueCert %v\n", data[ii])
		myerr := IssueCert(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetCasCmd = &cli.Command{
	Use:          "GetCas",
	RequiredArgs: strings.Join(GetCasRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(GetCasRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(GetCasRequestAliasArgs, " "),
	SpecialArgs:  &GetCasRequestSpecialArgs,
	Comments:     GetCasRequestComments,
	ReqData:      &edgeproto.GetCasRequest{},
	ReplyData:    &edgeproto.GetCasReply{},
	Run:          runGetCas,
}

func runGetCas(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.GetCasRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetCas(c, obj)
}

func GetCas(c *cli.Command, in *edgeproto.GetCasRequest) error {
	if CloudletAccessApiCmd == nil {
		return fmt.Errorf("CloudletAccessApi client not initialized")
	}
	ctx := context.Background()
	obj, err := CloudletAccessApiCmd.GetCas(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetCas failed: %s", errstr)
	}
	c.WriteOutput(obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetCass(c *cli.Command, data []edgeproto.GetCasRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetCas %v\n", data[ii])
		myerr := GetCas(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetAccessDataCmd = &cli.Command{
	Use:          "GetAccessData",
	RequiredArgs: strings.Join(AccessDataRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(AccessDataRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(AccessDataRequestAliasArgs, " "),
	SpecialArgs:  &AccessDataRequestSpecialArgs,
	Comments:     AccessDataRequestComments,
	ReqData:      &edgeproto.AccessDataRequest{},
	ReplyData:    &edgeproto.AccessDataReply{},
	Run:          runGetAccessData,
}

func runGetAccessData(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.AccessDataRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetAccessData(c, obj)
}

func GetAccessData(c *cli.Command, in *edgeproto.AccessDataRequest) error {
	if CloudletAccessApiCmd == nil {
		return fmt.Errorf("CloudletAccessApi client not initialized")
	}
	ctx := context.Background()
	obj, err := CloudletAccessApiCmd.GetAccessData(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetAccessData failed: %s", errstr)
	}
	c.WriteOutput(obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetAccessDatas(c *cli.Command, data []edgeproto.AccessDataRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetAccessData %v\n", data[ii])
		myerr := GetAccessData(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetPublicCertCmd = &cli.Command{
	Use:          "GetPublicCert",
	RequiredArgs: strings.Join(PublicCertRequestRequiredArgs, " "),
	OptionalArgs: strings.Join(PublicCertRequestOptionalArgs, " "),
	AliasArgs:    strings.Join(PublicCertRequestAliasArgs, " "),
	SpecialArgs:  &PublicCertRequestSpecialArgs,
	Comments:     PublicCertRequestComments,
	ReqData:      &edgeproto.PublicCertRequest{},
	ReplyData:    &edgeproto.PublicCertReply{},
	Run:          runGetPublicCert,
}

func runGetPublicCert(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.PublicCertRequest)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetPublicCert(c, obj)
}

func GetPublicCert(c *cli.Command, in *edgeproto.PublicCertRequest) error {
	if CloudletAccessApiCmd == nil {
		return fmt.Errorf("CloudletAccessApi client not initialized")
	}
	ctx := context.Background()
	obj, err := CloudletAccessApiCmd.GetPublicCert(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetPublicCert failed: %s", errstr)
	}
	c.WriteOutput(obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetPublicCerts(c *cli.Command, data []edgeproto.PublicCertRequest, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetPublicCert %v\n", data[ii])
		myerr := GetPublicCert(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var CloudletAccessApiCmds = []*cobra.Command{
	IssueCertCmd.GenCmd(),
	GetCasCmd.GenCmd(),
	GetAccessDataCmd.GenCmd(),
	GetPublicCertCmd.GenCmd(),
}

var CloudletAccessKeyApiCmd edgeproto.CloudletAccessKeyApiClient
var IssueCertRequestRequiredArgs = []string{}
var IssueCertRequestOptionalArgs = []string{
	"commonname",
}
var IssueCertRequestAliasArgs = []string{}
var IssueCertRequestComments = map[string]string{
	"commonname": "Certificate common name",
}
var IssueCertRequestSpecialArgs = map[string]string{}
var IssueCertReplyRequiredArgs = []string{}
var IssueCertReplyOptionalArgs = []string{
	"publiccertpem",
	"privatekeypem",
}
var IssueCertReplyAliasArgs = []string{}
var IssueCertReplyComments = map[string]string{
	"publiccertpem": "Public certificate in PEM format",
	"privatekeypem": "Private key in PEM format",
}
var IssueCertReplySpecialArgs = map[string]string{}
var GetCasRequestRequiredArgs = []string{}
var GetCasRequestOptionalArgs = []string{
	"issuer",
}
var GetCasRequestAliasArgs = []string{}
var GetCasRequestComments = map[string]string{
	"issuer": "Issuer",
}
var GetCasRequestSpecialArgs = map[string]string{}
var GetCasReplyRequiredArgs = []string{}
var GetCasReplyOptionalArgs = []string{
	"cachainpem",
}
var GetCasReplyAliasArgs = []string{}
var GetCasReplyComments = map[string]string{
	"cachainpem": "CA chain in PEM format",
}
var GetCasReplySpecialArgs = map[string]string{}
var UpgradeAccessKeyClientMsgRequiredArgs = []string{}
var UpgradeAccessKeyClientMsgOptionalArgs = []string{
	"msg",
	"verifyonly",
}
var UpgradeAccessKeyClientMsgAliasArgs = []string{}
var UpgradeAccessKeyClientMsgComments = map[string]string{
	"msg":        "Message type",
	"verifyonly": "Client node type",
}
var UpgradeAccessKeyClientMsgSpecialArgs = map[string]string{}
var UpgradeAccessKeyServerMsgRequiredArgs = []string{}
var UpgradeAccessKeyServerMsgOptionalArgs = []string{
	"msg",
	"crmprivateaccesskey",
}
var UpgradeAccessKeyServerMsgAliasArgs = []string{}
var UpgradeAccessKeyServerMsgComments = map[string]string{
	"msg":                 "Message type",
	"crmprivateaccesskey": "New Access key in PEM format (may be blank)",
}
var UpgradeAccessKeyServerMsgSpecialArgs = map[string]string{}
var AccessDataRequestRequiredArgs = []string{}
var AccessDataRequestOptionalArgs = []string{
	"type",
	"data",
}
var AccessDataRequestAliasArgs = []string{}
var AccessDataRequestComments = map[string]string{
	"type": "Data type",
	"data": "Any request data (type specific)",
}
var AccessDataRequestSpecialArgs = map[string]string{}
var AccessDataReplyRequiredArgs = []string{}
var AccessDataReplyOptionalArgs = []string{
	"data",
}
var AccessDataReplyAliasArgs = []string{}
var AccessDataReplyComments = map[string]string{
	"data": "Reply data (type specific)",
}
var AccessDataReplySpecialArgs = map[string]string{}
var PublicCertRequestRequiredArgs = []string{}
var PublicCertRequestOptionalArgs = []string{
	"commonname",
}
var PublicCertRequestAliasArgs = []string{}
var PublicCertRequestComments = map[string]string{
	"commonname": "Certificate common name",
}
var PublicCertRequestSpecialArgs = map[string]string{}
var PublicCertReplyRequiredArgs = []string{}
var PublicCertReplyOptionalArgs = []string{
	"publiccert",
}
var PublicCertReplyAliasArgs = []string{}
var PublicCertReplyComments = map[string]string{
	"publiccert": "Marshalled vault.PublicCert",
}
var PublicCertReplySpecialArgs = map[string]string{}
