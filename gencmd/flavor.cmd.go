// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: flavor.proto

package gencmd

import edgeproto "github.com/mobiledgex/edge-cloud/edgeproto"
import "strings"
import "strconv"
import "github.com/spf13/cobra"
import "context"
import "os"
import "io"
import "text/tabwriter"
import "github.com/spf13/pflag"
import "github.com/mobiledgex/edge-cloud/protoc-gen-cmd/cmdsup"
import "google.golang.org/grpc/status"
import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/mobiledgex/edge-cloud/protogen"
import _ "github.com/mobiledgex/edge-cloud/protoc-gen-cmd/protocmd"
import _ "github.com/gogo/protobuf/gogoproto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Auto-generated code: DO NOT EDIT
var FlavorApiCmd edgeproto.FlavorApiClient
var FlavorIn edgeproto.Flavor
var FlavorFlagSet = pflag.NewFlagSet("Flavor", pflag.ExitOnError)
var FlavorNoConfigFlagSet = pflag.NewFlagSet("FlavorNoConfig", pflag.ExitOnError)

func FlavorKeySlicer(in *edgeproto.FlavorKey) []string {
	s := make([]string, 0, 1)
	s = append(s, in.Name)
	return s
}

func FlavorKeyHeaderSlicer() []string {
	s := make([]string, 0, 1)
	s = append(s, "Name")
	return s
}

func FlavorKeyWriteOutputArray(objs []*edgeproto.FlavorKey) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(FlavorKeyHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(FlavorKeySlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func FlavorKeyWriteOutputOne(obj *edgeproto.FlavorKey) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(FlavorKeyHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(FlavorKeySlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}
func FlavorSlicer(in *edgeproto.Flavor) []string {
	s := make([]string, 0, 5)
	if in.Fields == nil {
		in.Fields = make([]string, 1)
	}
	s = append(s, in.Fields[0])
	s = append(s, in.Key.Name)
	s = append(s, strconv.FormatUint(uint64(in.Ram), 10))
	s = append(s, strconv.FormatUint(uint64(in.Vcpus), 10))
	s = append(s, strconv.FormatUint(uint64(in.Disk), 10))
	return s
}

func FlavorHeaderSlicer() []string {
	s := make([]string, 0, 5)
	s = append(s, "Fields")
	s = append(s, "Key-Name")
	s = append(s, "Ram")
	s = append(s, "Vcpus")
	s = append(s, "Disk")
	return s
}

func FlavorWriteOutputArray(objs []*edgeproto.Flavor) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(FlavorHeaderSlicer(), "\t"))
		for _, obj := range objs {
			fmt.Fprintln(output, strings.Join(FlavorSlicer(obj), "\t"))
		}
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(objs)
	}
}

func FlavorWriteOutputOne(obj *edgeproto.Flavor) {
	if cmdsup.OutputFormat == cmdsup.OutputFormatTable {
		output := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
		fmt.Fprintln(output, strings.Join(FlavorHeaderSlicer(), "\t"))
		fmt.Fprintln(output, strings.Join(FlavorSlicer(obj), "\t"))
		output.Flush()
	} else {
		cmdsup.WriteOutputGeneric(obj)
	}
}

var CreateFlavorCmd = &cobra.Command{
	Use: "CreateFlavor",
	RunE: func(cmd *cobra.Command, args []string) error {
		// if we got this far, usage has been met.
		cmd.SilenceUsage = true
		return CreateFlavor(&FlavorIn)
	},
}

func CreateFlavor(in *edgeproto.Flavor) error {
	if FlavorApiCmd == nil {
		return fmt.Errorf("FlavorApi client not initialized")
	}
	ctx := context.Background()
	obj, err := FlavorApiCmd.CreateFlavor(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("CreateFlavor failed: %s", errstr)
	}
	ResultWriteOutputOne(obj)
	return nil
}

func CreateFlavors(data []edgeproto.Flavor, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("CreateFlavor %v\n", data[ii])
		myerr := CreateFlavor(&data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var DeleteFlavorCmd = &cobra.Command{
	Use: "DeleteFlavor",
	RunE: func(cmd *cobra.Command, args []string) error {
		// if we got this far, usage has been met.
		cmd.SilenceUsage = true
		return DeleteFlavor(&FlavorIn)
	},
}

func DeleteFlavor(in *edgeproto.Flavor) error {
	if FlavorApiCmd == nil {
		return fmt.Errorf("FlavorApi client not initialized")
	}
	ctx := context.Background()
	obj, err := FlavorApiCmd.DeleteFlavor(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("DeleteFlavor failed: %s", errstr)
	}
	ResultWriteOutputOne(obj)
	return nil
}

func DeleteFlavors(data []edgeproto.Flavor, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("DeleteFlavor %v\n", data[ii])
		myerr := DeleteFlavor(&data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var UpdateFlavorCmd = &cobra.Command{
	Use: "UpdateFlavor",
	RunE: func(cmd *cobra.Command, args []string) error {
		// if we got this far, usage has been met.
		cmd.SilenceUsage = true
		FlavorSetFields()
		return UpdateFlavor(&FlavorIn)
	},
}

func UpdateFlavor(in *edgeproto.Flavor) error {
	if FlavorApiCmd == nil {
		return fmt.Errorf("FlavorApi client not initialized")
	}
	ctx := context.Background()
	obj, err := FlavorApiCmd.UpdateFlavor(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("UpdateFlavor failed: %s", errstr)
	}
	ResultWriteOutputOne(obj)
	return nil
}

func UpdateFlavors(data []edgeproto.Flavor, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("UpdateFlavor %v\n", data[ii])
		myerr := UpdateFlavor(&data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var ShowFlavorCmd = &cobra.Command{
	Use: "ShowFlavor",
	RunE: func(cmd *cobra.Command, args []string) error {
		// if we got this far, usage has been met.
		cmd.SilenceUsage = true
		return ShowFlavor(&FlavorIn)
	},
}

func ShowFlavor(in *edgeproto.Flavor) error {
	if FlavorApiCmd == nil {
		return fmt.Errorf("FlavorApi client not initialized")
	}
	ctx := context.Background()
	stream, err := FlavorApiCmd.ShowFlavor(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("ShowFlavor failed: %s", errstr)
	}
	objs := make([]*edgeproto.Flavor, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			return fmt.Errorf("ShowFlavor recv failed: %s", err.Error())
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	FlavorWriteOutputArray(objs)
	return nil
}

func ShowFlavors(data []edgeproto.Flavor, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("ShowFlavor %v\n", data[ii])
		myerr := ShowFlavor(&data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var FlavorApiCmds = []*cobra.Command{
	CreateFlavorCmd,
	DeleteFlavorCmd,
	UpdateFlavorCmd,
	ShowFlavorCmd,
}

func init() {
	FlavorFlagSet.StringVar(&FlavorIn.Key.Name, "key-name", "", "Key.Name")
	FlavorFlagSet.Uint64Var(&FlavorIn.Ram, "ram", 0, "Ram")
	FlavorFlagSet.Uint64Var(&FlavorIn.Vcpus, "vcpus", 0, "Vcpus")
	FlavorFlagSet.Uint64Var(&FlavorIn.Disk, "disk", 0, "Disk")
	CreateFlavorCmd.Flags().AddFlagSet(FlavorFlagSet)
	DeleteFlavorCmd.Flags().AddFlagSet(FlavorFlagSet)
	UpdateFlavorCmd.Flags().AddFlagSet(FlavorFlagSet)
	ShowFlavorCmd.Flags().AddFlagSet(FlavorFlagSet)
}

func FlavorApiAllowNoConfig() {
	CreateFlavorCmd.Flags().AddFlagSet(FlavorNoConfigFlagSet)
	DeleteFlavorCmd.Flags().AddFlagSet(FlavorNoConfigFlagSet)
	UpdateFlavorCmd.Flags().AddFlagSet(FlavorNoConfigFlagSet)
	ShowFlavorCmd.Flags().AddFlagSet(FlavorNoConfigFlagSet)
}

func FlavorSetFields() {
	FlavorIn.Fields = make([]string, 0)
	if FlavorFlagSet.Lookup("key-name").Changed {
		FlavorIn.Fields = append(FlavorIn.Fields, "2.1")
	}
	if FlavorFlagSet.Lookup("ram").Changed {
		FlavorIn.Fields = append(FlavorIn.Fields, "3")
	}
	if FlavorFlagSet.Lookup("vcpus").Changed {
		FlavorIn.Fields = append(FlavorIn.Fields, "4")
	}
	if FlavorFlagSet.Lookup("disk").Changed {
		FlavorIn.Fields = append(FlavorIn.Fields, "5")
	}
}
