// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: clusterflavor.proto

package testutil

import "google.golang.org/grpc"
import "github.com/mobiledgex/edge-cloud/edgeproto"
import "io"
import "testing"
import "context"
import "time"
import "github.com/stretchr/testify/assert"
import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/mobiledgex/edge-cloud/protogen"
import _ "github.com/mobiledgex/edge-cloud/protoc-gen-cmd/protocmd"
import _ "github.com/gogo/protobuf/gogoproto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Auto-generated code: DO NOT EDIT

type ShowClusterFlavor struct {
	Data map[string]edgeproto.ClusterFlavor
	grpc.ServerStream
}

func (x *ShowClusterFlavor) Init() {
	x.Data = make(map[string]edgeproto.ClusterFlavor)
}

func (x *ShowClusterFlavor) Send(m *edgeproto.ClusterFlavor) error {
	x.Data[m.Key.GetKeyString()] = *m
	return nil
}

func (x *ShowClusterFlavor) ReadStream(stream edgeproto.ClusterFlavorApi_ShowClusterFlavorClient, err error) {
	x.Data = make(map[string]edgeproto.ClusterFlavor)
	if err != nil {
		return
	}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			break
		}
		x.Data[obj.Key.GetKeyString()] = *obj
	}
}

func (x *ShowClusterFlavor) CheckFound(obj *edgeproto.ClusterFlavor) bool {
	_, found := x.Data[obj.Key.GetKeyString()]
	return found
}

func (x *ShowClusterFlavor) AssertFound(t *testing.T, obj *edgeproto.ClusterFlavor) {
	check, found := x.Data[obj.Key.GetKeyString()]
	assert.True(t, found, "find ClusterFlavor %s", obj.Key.GetKeyString())
	if found && !check.Matches(obj, edgeproto.MatchIgnoreBackend(), edgeproto.MatchSortArrayedKeys()) {
		assert.Equal(t, *obj, check, "ClusterFlavor are equal")
	}
	if found {
		// remove in case there are dups in the list, so the
		// same object cannot be used again
		delete(x.Data, obj.Key.GetKeyString())
	}
}

func (x *ShowClusterFlavor) AssertNotFound(t *testing.T, obj *edgeproto.ClusterFlavor) {
	_, found := x.Data[obj.Key.GetKeyString()]
	assert.False(t, found, "do not find ClusterFlavor %s", obj.Key.GetKeyString())
}

func WaitAssertFoundClusterFlavor(t *testing.T, api edgeproto.ClusterFlavorApiClient, obj *edgeproto.ClusterFlavor, count int, retry time.Duration) {
	show := ShowClusterFlavor{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowClusterFlavor(ctx, obj)
		show.ReadStream(stream, err)
		cancel()
		if show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertFound(t, obj)
}

func WaitAssertNotFoundClusterFlavor(t *testing.T, api edgeproto.ClusterFlavorApiClient, obj *edgeproto.ClusterFlavor, count int, retry time.Duration) {
	show := ShowClusterFlavor{}
	filterNone := edgeproto.ClusterFlavor{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowClusterFlavor(ctx, &filterNone)
		show.ReadStream(stream, err)
		cancel()
		if !show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertNotFound(t, obj)
}

// Wrap the api with a common interface
type ClusterFlavorCommonApi struct {
	internal_api edgeproto.ClusterFlavorApiServer
	client_api   edgeproto.ClusterFlavorApiClient
}

func (x *ClusterFlavorCommonApi) CreateClusterFlavor(ctx context.Context, in *edgeproto.ClusterFlavor) (*edgeproto.Result, error) {
	if x.internal_api != nil {
		return x.internal_api.CreateClusterFlavor(ctx, in)
	} else {
		return x.client_api.CreateClusterFlavor(ctx, in)
	}
}

func (x *ClusterFlavorCommonApi) UpdateClusterFlavor(ctx context.Context, in *edgeproto.ClusterFlavor) (*edgeproto.Result, error) {
	if x.internal_api != nil {
		return x.internal_api.UpdateClusterFlavor(ctx, in)
	} else {
		return x.client_api.UpdateClusterFlavor(ctx, in)
	}
}

func (x *ClusterFlavorCommonApi) DeleteClusterFlavor(ctx context.Context, in *edgeproto.ClusterFlavor) (*edgeproto.Result, error) {
	if x.internal_api != nil {
		return x.internal_api.DeleteClusterFlavor(ctx, in)
	} else {
		return x.client_api.DeleteClusterFlavor(ctx, in)
	}
}

func (x *ClusterFlavorCommonApi) ShowClusterFlavor(ctx context.Context, filter *edgeproto.ClusterFlavor, showData *ShowClusterFlavor) error {
	if x.internal_api != nil {
		return x.internal_api.ShowClusterFlavor(filter, showData)
	} else {
		stream, err := x.client_api.ShowClusterFlavor(ctx, filter)
		showData.ReadStream(stream, err)
		return err
	}
}

func NewInternalClusterFlavorApi(api edgeproto.ClusterFlavorApiServer) *ClusterFlavorCommonApi {
	apiWrap := ClusterFlavorCommonApi{}
	apiWrap.internal_api = api
	return &apiWrap
}

func NewClientClusterFlavorApi(api edgeproto.ClusterFlavorApiClient) *ClusterFlavorCommonApi {
	apiWrap := ClusterFlavorCommonApi{}
	apiWrap.client_api = api
	return &apiWrap
}

func InternalClusterFlavorTest(t *testing.T, test string, api edgeproto.ClusterFlavorApiServer, testData []edgeproto.ClusterFlavor) {
	switch test {
	case "cud":
		basicClusterFlavorCudTest(t, NewInternalClusterFlavorApi(api), testData)
	case "show":
		basicClusterFlavorShowTest(t, NewInternalClusterFlavorApi(api), testData)
	}
}

func ClientClusterFlavorTest(t *testing.T, test string, api edgeproto.ClusterFlavorApiClient, testData []edgeproto.ClusterFlavor) {
	switch test {
	case "cud":
		basicClusterFlavorCudTest(t, NewClientClusterFlavorApi(api), testData)
	case "show":
		basicClusterFlavorShowTest(t, NewClientClusterFlavorApi(api), testData)
	}
}

func basicClusterFlavorShowTest(t *testing.T, api *ClusterFlavorCommonApi, testData []edgeproto.ClusterFlavor) {
	var err error
	ctx := context.TODO()

	show := ShowClusterFlavor{}
	show.Init()
	filterNone := edgeproto.ClusterFlavor{}
	err = api.ShowClusterFlavor(ctx, &filterNone, &show)
	assert.Nil(t, err, "show data")
	assert.Equal(t, len(testData), len(show.Data), "Show count")
	for _, obj := range testData {
		show.AssertFound(t, &obj)
	}
}

func GetClusterFlavor(t *testing.T, api *ClusterFlavorCommonApi, key *edgeproto.ClusterFlavorKey, out *edgeproto.ClusterFlavor) bool {
	var err error
	ctx := context.TODO()

	show := ShowClusterFlavor{}
	show.Init()
	filter := edgeproto.ClusterFlavor{}
	filter.Key = *key
	err = api.ShowClusterFlavor(ctx, &filter, &show)
	assert.Nil(t, err, "show data")
	obj, found := show.Data[key.GetKeyString()]
	if found {
		*out = obj
	}
	return found
}

func basicClusterFlavorCudTest(t *testing.T, api *ClusterFlavorCommonApi, testData []edgeproto.ClusterFlavor) {
	var err error
	ctx := context.TODO()

	if len(testData) < 3 {
		assert.True(t, false, "Need at least 3 test data objects")
		return
	}

	// test create
	createClusterFlavorData(t, api, testData)

	// test duplicate create - should fail
	_, err = api.CreateClusterFlavor(ctx, &testData[0])
	assert.NotNil(t, err, "Create duplicate ClusterFlavor")

	// test show all items
	basicClusterFlavorShowTest(t, api, testData)

	// test delete
	_, err = api.DeleteClusterFlavor(ctx, &testData[0])
	assert.Nil(t, err, "delete ClusterFlavor %s", testData[0].Key.GetKeyString())
	show := ShowClusterFlavor{}
	show.Init()
	filterNone := edgeproto.ClusterFlavor{}
	err = api.ShowClusterFlavor(ctx, &filterNone, &show)
	assert.Nil(t, err, "show data")
	assert.Equal(t, len(testData)-1, len(show.Data), "Show count")
	show.AssertNotFound(t, &testData[0])
	// create it back
	_, err = api.CreateClusterFlavor(ctx, &testData[0])
	assert.Nil(t, err, "Create ClusterFlavor %s", testData[0].Key.GetKeyString())

	// test invalid keys
	bad := edgeproto.ClusterFlavor{}
	_, err = api.CreateClusterFlavor(ctx, &bad)
	assert.NotNil(t, err, "Create ClusterFlavor with no key info")

}

func InternalClusterFlavorCreate(t *testing.T, api edgeproto.ClusterFlavorApiServer, testData []edgeproto.ClusterFlavor) {
	createClusterFlavorData(t, NewInternalClusterFlavorApi(api), testData)
}

func ClientClusterFlavorCreate(t *testing.T, api edgeproto.ClusterFlavorApiClient, testData []edgeproto.ClusterFlavor) {
	createClusterFlavorData(t, NewClientClusterFlavorApi(api), testData)
}

func createClusterFlavorData(t *testing.T, api *ClusterFlavorCommonApi, testData []edgeproto.ClusterFlavor) {
	var err error
	ctx := context.TODO()

	for _, obj := range testData {
		_, err = api.CreateClusterFlavor(ctx, &obj)
		assert.Nil(t, err, "Create ClusterFlavor %s", obj.Key.GetKeyString())
	}
}
