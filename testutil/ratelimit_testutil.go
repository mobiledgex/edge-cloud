// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ratelimit.proto

package testutil

import (
	"context"
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/mobiledgex/edge-cloud/cli"
	"github.com/mobiledgex/edge-cloud/edgectl/wrapper"
	"github.com/mobiledgex/edge-cloud/edgeproto"
	"github.com/mobiledgex/edge-cloud/log"
	_ "github.com/mobiledgex/edge-cloud/protogen"
	"io"
	math "math"
	"time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Auto-generated code: DO NOT EDIT
type RateLimitSettingsDataOut struct {
	Errors []Err
}

// used to intersperse other creates/deletes/checks
// note the objs value is the previous one for create,
// but the next one for delete
type RunRateLimitSettingsDataApiCallback func(objs string)

func RunRateLimitSettingsDataApis(run *Run, in *edgeproto.RateLimitSettingsData, inMap map[string]interface{}, out *RateLimitSettingsDataOut, apicb RunRateLimitSettingsDataApiCallback) {
	apicb("")
	out.Errors = run.Errs
}

func RunRateLimitSettingsDataReverseApis(run *Run, in *edgeproto.RateLimitSettingsData, inMap map[string]interface{}, out *RateLimitSettingsDataOut, apicb RunRateLimitSettingsDataApiCallback) {
	apicb("")
	out.Errors = run.Errs
}

func RunRateLimitSettingsDataShowApis(run *Run, in *edgeproto.RateLimitSettingsData, out *edgeproto.RateLimitSettingsData) {
	run.RateLimitSettingsApi(&in.Settings, nil, &out.Settings)
}

func (r *Run) RateLimitSettingsApi_FlowRateLimitSettings(data *[]edgeproto.FlowRateLimitSettings, dataMap interface{}, dataOut interface{}) {
	log.DebugLog(log.DebugLevelApi, "API for FlowRateLimitSettings", "mode", r.Mode)
	if r.Mode == "show" {
		obj := &edgeproto.FlowRateLimitSettings{}
		out, err := r.client.ShowFlowRateLimitSettings(r.ctx, obj)
		if err != nil {
			r.logErr("RateLimitSettingsApi_FlowRateLimitSettings", err)
		} else {
			outp, ok := dataOut.(*[]edgeproto.FlowRateLimitSettings)
			if !ok {
				panic(fmt.Sprintf("RunRateLimitSettingsApi_FlowRateLimitSettings expected dataOut type *[]edgeproto.FlowRateLimitSettings, but was %T", dataOut))
			}
			*outp = append(*outp, out...)
		}
		return
	}
	for ii, objD := range *data {
		obj := &objD
		switch r.Mode {
		case "create":
			out, err := r.client.CreateFlowRateLimitSettings(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("RateLimitSettingsApi_FlowRateLimitSettings[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunRateLimitSettingsApi_FlowRateLimitSettings expected dataOut type *[]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		case "update":
			// set specified fields
			objMap, err := cli.GetGenericObjFromList(dataMap, ii)
			if err != nil {
				log.DebugLog(log.DebugLevelApi, "bad dataMap for FlowRateLimitSettings", "err", err)
				*r.Rc = false
				return
			}
			yamlData := cli.MapData{
				Namespace: cli.YamlNamespace,
				Data:      objMap,
			}
			obj.Fields = cli.GetSpecifiedFields(&yamlData, obj)

			out, err := r.client.UpdateFlowRateLimitSettings(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("RateLimitSettingsApi_FlowRateLimitSettings[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunRateLimitSettingsApi_FlowRateLimitSettings expected dataOut type *[]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		case "delete":
			out, err := r.client.DeleteFlowRateLimitSettings(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("RateLimitSettingsApi_FlowRateLimitSettings[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunRateLimitSettingsApi_FlowRateLimitSettings expected dataOut type *[]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		case "showfiltered":
			out, err := r.client.ShowFlowRateLimitSettings(r.ctx, obj)
			if err != nil {
				r.logErr(fmt.Sprintf("RateLimitSettingsApi_FlowRateLimitSettings[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.FlowRateLimitSettings)
				if !ok {
					panic(fmt.Sprintf("RunRateLimitSettingsApi_FlowRateLimitSettings expected dataOut type *[]edgeproto.FlowRateLimitSettings, but was %T", dataOut))
				}
				*outp = append(*outp, out...)
			}
		}
	}
}

func (r *Run) RateLimitSettingsApi_MaxReqsRateLimitSettings(data *[]edgeproto.MaxReqsRateLimitSettings, dataMap interface{}, dataOut interface{}) {
	log.DebugLog(log.DebugLevelApi, "API for MaxReqsRateLimitSettings", "mode", r.Mode)
	if r.Mode == "show" {
		obj := &edgeproto.MaxReqsRateLimitSettings{}
		out, err := r.client.ShowMaxReqsRateLimitSettings(r.ctx, obj)
		if err != nil {
			r.logErr("RateLimitSettingsApi_MaxReqsRateLimitSettings", err)
		} else {
			outp, ok := dataOut.(*[]edgeproto.MaxReqsRateLimitSettings)
			if !ok {
				panic(fmt.Sprintf("RunRateLimitSettingsApi_MaxReqsRateLimitSettings expected dataOut type *[]edgeproto.MaxReqsRateLimitSettings, but was %T", dataOut))
			}
			*outp = append(*outp, out...)
		}
		return
	}
	for ii, objD := range *data {
		obj := &objD
		switch r.Mode {
		case "create":
			out, err := r.client.CreateMaxReqsRateLimitSettings(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("RateLimitSettingsApi_MaxReqsRateLimitSettings[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunRateLimitSettingsApi_MaxReqsRateLimitSettings expected dataOut type *[]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		case "update":
			// set specified fields
			objMap, err := cli.GetGenericObjFromList(dataMap, ii)
			if err != nil {
				log.DebugLog(log.DebugLevelApi, "bad dataMap for MaxReqsRateLimitSettings", "err", err)
				*r.Rc = false
				return
			}
			yamlData := cli.MapData{
				Namespace: cli.YamlNamespace,
				Data:      objMap,
			}
			obj.Fields = cli.GetSpecifiedFields(&yamlData, obj)

			out, err := r.client.UpdateMaxReqsRateLimitSettings(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("RateLimitSettingsApi_MaxReqsRateLimitSettings[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunRateLimitSettingsApi_MaxReqsRateLimitSettings expected dataOut type *[]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		case "delete":
			out, err := r.client.DeleteMaxReqsRateLimitSettings(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("RateLimitSettingsApi_MaxReqsRateLimitSettings[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunRateLimitSettingsApi_MaxReqsRateLimitSettings expected dataOut type *[]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		case "showfiltered":
			out, err := r.client.ShowMaxReqsRateLimitSettings(r.ctx, obj)
			if err != nil {
				r.logErr(fmt.Sprintf("RateLimitSettingsApi_MaxReqsRateLimitSettings[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.MaxReqsRateLimitSettings)
				if !ok {
					panic(fmt.Sprintf("RunRateLimitSettingsApi_MaxReqsRateLimitSettings expected dataOut type *[]edgeproto.MaxReqsRateLimitSettings, but was %T", dataOut))
				}
				*outp = append(*outp, out...)
			}
		}
	}
}

func (r *Run) RateLimitSettingsApi(data *[]edgeproto.RateLimitSettings, dataMap interface{}, dataOut interface{}) {
	log.DebugLog(log.DebugLevelApi, "API for RateLimitSettings", "mode", r.Mode)
	if r.Mode == "show" {
		obj := &edgeproto.RateLimitSettings{}
		out, err := r.client.ShowRateLimitSettings(r.ctx, obj)
		if err != nil {
			r.logErr("RateLimitSettingsApi", err)
		} else {
			outp, ok := dataOut.(*[]edgeproto.RateLimitSettings)
			if !ok {
				panic(fmt.Sprintf("RunRateLimitSettingsApi expected dataOut type *[]edgeproto.RateLimitSettings, but was %T", dataOut))
			}
			*outp = append(*outp, out...)
		}
		return
	}
	for ii, objD := range *data {
		obj := &objD
		switch r.Mode {
		case "showfiltered":
			out, err := r.client.ShowRateLimitSettings(r.ctx, obj)
			if err != nil {
				r.logErr(fmt.Sprintf("RateLimitSettingsApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.RateLimitSettings)
				if !ok {
					panic(fmt.Sprintf("RunRateLimitSettingsApi expected dataOut type *[]edgeproto.RateLimitSettings, but was %T", dataOut))
				}
				*outp = append(*outp, out...)
			}
		}
	}
}

func (s *DummyServer) ShowRateLimitSettings(in *edgeproto.RateLimitSettings, server edgeproto.RateLimitSettingsApi_ShowRateLimitSettingsServer) error {
	var err error
	obj := &edgeproto.RateLimitSettings{}
	if obj.Matches(in, edgeproto.MatchFilter()) {
		for ii := 0; ii < s.ShowDummyCount; ii++ {
			server.Send(&edgeproto.RateLimitSettings{})
		}
		if ch, ok := s.MidstreamFailChs["ShowRateLimitSettings"]; ok {
			// Wait until client receives the SendMsg, since they
			// are buffered and dropped once we return err here.
			select {
			case <-ch:
			case <-time.After(5 * time.Second):
			}
			return fmt.Errorf("midstream failure!")
		}
	}
	return err
}

func (s *DummyServer) CreateFlowRateLimitSettings(ctx context.Context, in *edgeproto.FlowRateLimitSettings) (*edgeproto.Result, error) {
	if s.CudNoop {
		return &edgeproto.Result{}, nil
	}
	s.FlowRateLimitSettingsCache.Update(ctx, in, 0)
	return &edgeproto.Result{}, nil
}

func (s *DummyServer) UpdateFlowRateLimitSettings(ctx context.Context, in *edgeproto.FlowRateLimitSettings) (*edgeproto.Result, error) {
	if s.CudNoop {
		return &edgeproto.Result{}, nil
	}
	s.FlowRateLimitSettingsCache.Update(ctx, in, 0)
	return &edgeproto.Result{}, nil
}

func (s *DummyServer) DeleteFlowRateLimitSettings(ctx context.Context, in *edgeproto.FlowRateLimitSettings) (*edgeproto.Result, error) {
	if s.CudNoop {
		return &edgeproto.Result{}, nil
	}
	s.FlowRateLimitSettingsCache.Delete(ctx, in, 0)
	return &edgeproto.Result{}, nil
}

func (s *DummyServer) ShowFlowRateLimitSettings(in *edgeproto.FlowRateLimitSettings, server edgeproto.RateLimitSettingsApi_ShowFlowRateLimitSettingsServer) error {
	var err error
	obj := &edgeproto.FlowRateLimitSettings{}
	if obj.Matches(in, edgeproto.MatchFilter()) {
		for ii := 0; ii < s.ShowDummyCount; ii++ {
			server.Send(&edgeproto.FlowRateLimitSettings{})
		}
		if ch, ok := s.MidstreamFailChs["ShowFlowRateLimitSettings"]; ok {
			// Wait until client receives the SendMsg, since they
			// are buffered and dropped once we return err here.
			select {
			case <-ch:
			case <-time.After(5 * time.Second):
			}
			return fmt.Errorf("midstream failure!")
		}
	}
	err = s.FlowRateLimitSettingsCache.Show(in, func(obj *edgeproto.FlowRateLimitSettings) error {
		err := server.Send(obj)
		return err
	})
	return err
}

func (s *DummyServer) CreateMaxReqsRateLimitSettings(ctx context.Context, in *edgeproto.MaxReqsRateLimitSettings) (*edgeproto.Result, error) {
	if s.CudNoop {
		return &edgeproto.Result{}, nil
	}
	s.MaxReqsRateLimitSettingsCache.Update(ctx, in, 0)
	return &edgeproto.Result{}, nil
}

func (s *DummyServer) UpdateMaxReqsRateLimitSettings(ctx context.Context, in *edgeproto.MaxReqsRateLimitSettings) (*edgeproto.Result, error) {
	if s.CudNoop {
		return &edgeproto.Result{}, nil
	}
	s.MaxReqsRateLimitSettingsCache.Update(ctx, in, 0)
	return &edgeproto.Result{}, nil
}

func (s *DummyServer) DeleteMaxReqsRateLimitSettings(ctx context.Context, in *edgeproto.MaxReqsRateLimitSettings) (*edgeproto.Result, error) {
	if s.CudNoop {
		return &edgeproto.Result{}, nil
	}
	s.MaxReqsRateLimitSettingsCache.Delete(ctx, in, 0)
	return &edgeproto.Result{}, nil
}

func (s *DummyServer) ShowMaxReqsRateLimitSettings(in *edgeproto.MaxReqsRateLimitSettings, server edgeproto.RateLimitSettingsApi_ShowMaxReqsRateLimitSettingsServer) error {
	var err error
	obj := &edgeproto.MaxReqsRateLimitSettings{}
	if obj.Matches(in, edgeproto.MatchFilter()) {
		for ii := 0; ii < s.ShowDummyCount; ii++ {
			server.Send(&edgeproto.MaxReqsRateLimitSettings{})
		}
		if ch, ok := s.MidstreamFailChs["ShowMaxReqsRateLimitSettings"]; ok {
			// Wait until client receives the SendMsg, since they
			// are buffered and dropped once we return err here.
			select {
			case <-ch:
			case <-time.After(5 * time.Second):
			}
			return fmt.Errorf("midstream failure!")
		}
	}
	err = s.MaxReqsRateLimitSettingsCache.Show(in, func(obj *edgeproto.MaxReqsRateLimitSettings) error {
		err := server.Send(obj)
		return err
	})
	return err
}

type RateLimitSettingsStream interface {
	Recv() (*edgeproto.RateLimitSettings, error)
}

func RateLimitSettingsReadStream(stream RateLimitSettingsStream) ([]edgeproto.RateLimitSettings, error) {
	output := []edgeproto.RateLimitSettings{}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			return output, fmt.Errorf("read RateLimitSettings stream failed, %v", err)
		}
		output = append(output, *obj)
	}
	return output, nil
}

func (s *ApiClient) ShowRateLimitSettings(ctx context.Context, in *edgeproto.RateLimitSettings) ([]edgeproto.RateLimitSettings, error) {
	api := edgeproto.NewRateLimitSettingsApiClient(s.Conn)
	stream, err := api.ShowRateLimitSettings(ctx, in)
	if err != nil {
		return nil, err
	}
	return RateLimitSettingsReadStream(stream)
}

func (s *CliClient) ShowRateLimitSettings(ctx context.Context, in *edgeproto.RateLimitSettings) ([]edgeproto.RateLimitSettings, error) {
	output := []edgeproto.RateLimitSettings{}
	args := append(s.BaseArgs, "controller", "ShowRateLimitSettings")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

func (s *ApiClient) CreateFlowRateLimitSettings(ctx context.Context, in *edgeproto.FlowRateLimitSettings) (*edgeproto.Result, error) {
	api := edgeproto.NewRateLimitSettingsApiClient(s.Conn)
	return api.CreateFlowRateLimitSettings(ctx, in)
}

func (s *CliClient) CreateFlowRateLimitSettings(ctx context.Context, in *edgeproto.FlowRateLimitSettings) (*edgeproto.Result, error) {
	out := edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "CreateFlowRateLimitSettings")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

func (s *ApiClient) UpdateFlowRateLimitSettings(ctx context.Context, in *edgeproto.FlowRateLimitSettings) (*edgeproto.Result, error) {
	api := edgeproto.NewRateLimitSettingsApiClient(s.Conn)
	return api.UpdateFlowRateLimitSettings(ctx, in)
}

func (s *CliClient) UpdateFlowRateLimitSettings(ctx context.Context, in *edgeproto.FlowRateLimitSettings) (*edgeproto.Result, error) {
	out := edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "UpdateFlowRateLimitSettings")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

func (s *ApiClient) DeleteFlowRateLimitSettings(ctx context.Context, in *edgeproto.FlowRateLimitSettings) (*edgeproto.Result, error) {
	api := edgeproto.NewRateLimitSettingsApiClient(s.Conn)
	return api.DeleteFlowRateLimitSettings(ctx, in)
}

func (s *CliClient) DeleteFlowRateLimitSettings(ctx context.Context, in *edgeproto.FlowRateLimitSettings) (*edgeproto.Result, error) {
	out := edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "DeleteFlowRateLimitSettings")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

type FlowRateLimitSettingsStream interface {
	Recv() (*edgeproto.FlowRateLimitSettings, error)
}

func FlowRateLimitSettingsReadStream(stream FlowRateLimitSettingsStream) ([]edgeproto.FlowRateLimitSettings, error) {
	output := []edgeproto.FlowRateLimitSettings{}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			return output, fmt.Errorf("read FlowRateLimitSettings stream failed, %v", err)
		}
		output = append(output, *obj)
	}
	return output, nil
}

func (s *ApiClient) ShowFlowRateLimitSettings(ctx context.Context, in *edgeproto.FlowRateLimitSettings) ([]edgeproto.FlowRateLimitSettings, error) {
	api := edgeproto.NewRateLimitSettingsApiClient(s.Conn)
	stream, err := api.ShowFlowRateLimitSettings(ctx, in)
	if err != nil {
		return nil, err
	}
	return FlowRateLimitSettingsReadStream(stream)
}

func (s *CliClient) ShowFlowRateLimitSettings(ctx context.Context, in *edgeproto.FlowRateLimitSettings) ([]edgeproto.FlowRateLimitSettings, error) {
	output := []edgeproto.FlowRateLimitSettings{}
	args := append(s.BaseArgs, "controller", "ShowFlowRateLimitSettings")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

func (s *ApiClient) CreateMaxReqsRateLimitSettings(ctx context.Context, in *edgeproto.MaxReqsRateLimitSettings) (*edgeproto.Result, error) {
	api := edgeproto.NewRateLimitSettingsApiClient(s.Conn)
	return api.CreateMaxReqsRateLimitSettings(ctx, in)
}

func (s *CliClient) CreateMaxReqsRateLimitSettings(ctx context.Context, in *edgeproto.MaxReqsRateLimitSettings) (*edgeproto.Result, error) {
	out := edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "CreateMaxReqsRateLimitSettings")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

func (s *ApiClient) UpdateMaxReqsRateLimitSettings(ctx context.Context, in *edgeproto.MaxReqsRateLimitSettings) (*edgeproto.Result, error) {
	api := edgeproto.NewRateLimitSettingsApiClient(s.Conn)
	return api.UpdateMaxReqsRateLimitSettings(ctx, in)
}

func (s *CliClient) UpdateMaxReqsRateLimitSettings(ctx context.Context, in *edgeproto.MaxReqsRateLimitSettings) (*edgeproto.Result, error) {
	out := edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "UpdateMaxReqsRateLimitSettings")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

func (s *ApiClient) DeleteMaxReqsRateLimitSettings(ctx context.Context, in *edgeproto.MaxReqsRateLimitSettings) (*edgeproto.Result, error) {
	api := edgeproto.NewRateLimitSettingsApiClient(s.Conn)
	return api.DeleteMaxReqsRateLimitSettings(ctx, in)
}

func (s *CliClient) DeleteMaxReqsRateLimitSettings(ctx context.Context, in *edgeproto.MaxReqsRateLimitSettings) (*edgeproto.Result, error) {
	out := edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "DeleteMaxReqsRateLimitSettings")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

type MaxReqsRateLimitSettingsStream interface {
	Recv() (*edgeproto.MaxReqsRateLimitSettings, error)
}

func MaxReqsRateLimitSettingsReadStream(stream MaxReqsRateLimitSettingsStream) ([]edgeproto.MaxReqsRateLimitSettings, error) {
	output := []edgeproto.MaxReqsRateLimitSettings{}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			return output, fmt.Errorf("read MaxReqsRateLimitSettings stream failed, %v", err)
		}
		output = append(output, *obj)
	}
	return output, nil
}

func (s *ApiClient) ShowMaxReqsRateLimitSettings(ctx context.Context, in *edgeproto.MaxReqsRateLimitSettings) ([]edgeproto.MaxReqsRateLimitSettings, error) {
	api := edgeproto.NewRateLimitSettingsApiClient(s.Conn)
	stream, err := api.ShowMaxReqsRateLimitSettings(ctx, in)
	if err != nil {
		return nil, err
	}
	return MaxReqsRateLimitSettingsReadStream(stream)
}

func (s *CliClient) ShowMaxReqsRateLimitSettings(ctx context.Context, in *edgeproto.MaxReqsRateLimitSettings) ([]edgeproto.MaxReqsRateLimitSettings, error) {
	output := []edgeproto.MaxReqsRateLimitSettings{}
	args := append(s.BaseArgs, "controller", "ShowMaxReqsRateLimitSettings")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

type RateLimitSettingsApiClient interface {
	ShowRateLimitSettings(ctx context.Context, in *edgeproto.RateLimitSettings) ([]edgeproto.RateLimitSettings, error)
	CreateFlowRateLimitSettings(ctx context.Context, in *edgeproto.FlowRateLimitSettings) (*edgeproto.Result, error)
	UpdateFlowRateLimitSettings(ctx context.Context, in *edgeproto.FlowRateLimitSettings) (*edgeproto.Result, error)
	DeleteFlowRateLimitSettings(ctx context.Context, in *edgeproto.FlowRateLimitSettings) (*edgeproto.Result, error)
	ShowFlowRateLimitSettings(ctx context.Context, in *edgeproto.FlowRateLimitSettings) ([]edgeproto.FlowRateLimitSettings, error)
	CreateMaxReqsRateLimitSettings(ctx context.Context, in *edgeproto.MaxReqsRateLimitSettings) (*edgeproto.Result, error)
	UpdateMaxReqsRateLimitSettings(ctx context.Context, in *edgeproto.MaxReqsRateLimitSettings) (*edgeproto.Result, error)
	DeleteMaxReqsRateLimitSettings(ctx context.Context, in *edgeproto.MaxReqsRateLimitSettings) (*edgeproto.Result, error)
	ShowMaxReqsRateLimitSettings(ctx context.Context, in *edgeproto.MaxReqsRateLimitSettings) ([]edgeproto.MaxReqsRateLimitSettings, error)
}
