// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: operator.proto

package testutil

import "google.golang.org/grpc"
import "github.com/mobiledgex/edge-cloud/edgeproto"
import "io"
import "testing"
import "context"
import "time"
import "github.com/stretchr/testify/require"
import "github.com/mobiledgex/edge-cloud/log"
import "github.com/mobiledgex/edge-cloud/cli"
import "github.com/mobiledgex/edge-cloud/edgectl/wrapper"
import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/mobiledgex/edge-cloud/protogen"
import _ "github.com/gogo/protobuf/gogoproto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Auto-generated code: DO NOT EDIT

type ShowOperator struct {
	Data map[string]edgeproto.Operator
	grpc.ServerStream
	Ctx context.Context
}

func (x *ShowOperator) Init() {
	x.Data = make(map[string]edgeproto.Operator)
}

func (x *ShowOperator) Send(m *edgeproto.Operator) error {
	x.Data[m.GetKey().GetKeyString()] = *m
	return nil
}

func (x *ShowOperator) Context() context.Context {
	return x.Ctx
}

var OperatorShowExtraCount = 0

func (x *ShowOperator) ReadStream(stream edgeproto.OperatorApi_ShowOperatorClient, err error) {
	x.Data = make(map[string]edgeproto.Operator)
	if err != nil {
		return
	}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			break
		}
		x.Data[obj.GetKey().GetKeyString()] = *obj
	}
}

func (x *ShowOperator) CheckFound(obj *edgeproto.Operator) bool {
	_, found := x.Data[obj.GetKey().GetKeyString()]
	return found
}

func (x *ShowOperator) AssertFound(t *testing.T, obj *edgeproto.Operator) {
	check, found := x.Data[obj.GetKey().GetKeyString()]
	require.True(t, found, "find Operator %s", obj.GetKey().GetKeyString())
	if found && !check.Matches(obj, edgeproto.MatchIgnoreBackend(), edgeproto.MatchSortArrayedKeys()) {
		require.Equal(t, *obj, check, "Operator are equal")
	}
	if found {
		// remove in case there are dups in the list, so the
		// same object cannot be used again
		delete(x.Data, obj.GetKey().GetKeyString())
	}
}

func (x *ShowOperator) AssertNotFound(t *testing.T, obj *edgeproto.Operator) {
	_, found := x.Data[obj.GetKey().GetKeyString()]
	require.False(t, found, "do not find Operator %s", obj.GetKey().GetKeyString())
}

func WaitAssertFoundOperator(t *testing.T, api edgeproto.OperatorApiClient, obj *edgeproto.Operator, count int, retry time.Duration) {
	show := ShowOperator{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowOperator(ctx, obj)
		show.ReadStream(stream, err)
		cancel()
		if show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertFound(t, obj)
}

func WaitAssertNotFoundOperator(t *testing.T, api edgeproto.OperatorApiClient, obj *edgeproto.Operator, count int, retry time.Duration) {
	show := ShowOperator{}
	filterNone := edgeproto.Operator{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowOperator(ctx, &filterNone)
		show.ReadStream(stream, err)
		cancel()
		if !show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertNotFound(t, obj)
}

// Wrap the api with a common interface
type OperatorCommonApi struct {
	internal_api edgeproto.OperatorApiServer
	client_api   edgeproto.OperatorApiClient
}

func (x *OperatorCommonApi) CreateOperator(ctx context.Context, in *edgeproto.Operator) (*edgeproto.Result, error) {
	copy := &edgeproto.Operator{}
	*copy = *in
	if x.internal_api != nil {
		return x.internal_api.CreateOperator(ctx, copy)
	} else {
		return x.client_api.CreateOperator(ctx, copy)
	}
}

func (x *OperatorCommonApi) DeleteOperator(ctx context.Context, in *edgeproto.Operator) (*edgeproto.Result, error) {
	copy := &edgeproto.Operator{}
	*copy = *in
	if x.internal_api != nil {
		return x.internal_api.DeleteOperator(ctx, copy)
	} else {
		return x.client_api.DeleteOperator(ctx, copy)
	}
}

func (x *OperatorCommonApi) UpdateOperator(ctx context.Context, in *edgeproto.Operator) (*edgeproto.Result, error) {
	copy := &edgeproto.Operator{}
	*copy = *in
	if x.internal_api != nil {
		return x.internal_api.UpdateOperator(ctx, copy)
	} else {
		return x.client_api.UpdateOperator(ctx, copy)
	}
}

func (x *OperatorCommonApi) ShowOperator(ctx context.Context, filter *edgeproto.Operator, showData *ShowOperator) error {
	if x.internal_api != nil {
		showData.Ctx = ctx
		return x.internal_api.ShowOperator(filter, showData)
	} else {
		stream, err := x.client_api.ShowOperator(ctx, filter)
		showData.ReadStream(stream, err)
		return err
	}
}

func NewInternalOperatorApi(api edgeproto.OperatorApiServer) *OperatorCommonApi {
	apiWrap := OperatorCommonApi{}
	apiWrap.internal_api = api
	return &apiWrap
}

func NewClientOperatorApi(api edgeproto.OperatorApiClient) *OperatorCommonApi {
	apiWrap := OperatorCommonApi{}
	apiWrap.client_api = api
	return &apiWrap
}

func InternalOperatorTest(t *testing.T, test string, api edgeproto.OperatorApiServer, testData []edgeproto.Operator) {
	span := log.StartSpan(log.DebugLevelApi, "InternalOperatorTest")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	switch test {
	case "cud":
		basicOperatorCudTest(t, ctx, NewInternalOperatorApi(api), testData)
	case "show":
		basicOperatorShowTest(t, ctx, NewInternalOperatorApi(api), testData)
	}
}

func ClientOperatorTest(t *testing.T, test string, api edgeproto.OperatorApiClient, testData []edgeproto.Operator) {
	span := log.StartSpan(log.DebugLevelApi, "ClientOperatorTest")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	switch test {
	case "cud":
		basicOperatorCudTest(t, ctx, NewClientOperatorApi(api), testData)
	case "show":
		basicOperatorShowTest(t, ctx, NewClientOperatorApi(api), testData)
	}
}

func basicOperatorShowTest(t *testing.T, ctx context.Context, api *OperatorCommonApi, testData []edgeproto.Operator) {
	var err error

	show := ShowOperator{}
	show.Init()
	filterNone := edgeproto.Operator{}
	err = api.ShowOperator(ctx, &filterNone, &show)
	require.Nil(t, err, "show data")
	require.Equal(t, len(testData)+OperatorShowExtraCount, len(show.Data), "Show count")
	for _, obj := range testData {
		show.AssertFound(t, &obj)
	}
}

func GetOperator(t *testing.T, ctx context.Context, api *OperatorCommonApi, key *edgeproto.OperatorKey, out *edgeproto.Operator) bool {
	var err error

	show := ShowOperator{}
	show.Init()
	filter := edgeproto.Operator{}
	filter.SetKey(key)
	err = api.ShowOperator(ctx, &filter, &show)
	require.Nil(t, err, "show data")
	obj, found := show.Data[key.GetKeyString()]
	if found {
		*out = obj
	}
	return found
}

func basicOperatorCudTest(t *testing.T, ctx context.Context, api *OperatorCommonApi, testData []edgeproto.Operator) {
	var err error

	if len(testData) < 3 {
		require.True(t, false, "Need at least 3 test data objects")
		return
	}

	// test create
	CreateOperatorData(t, ctx, api, testData)

	// test duplicate Create - should fail
	_, err = api.CreateOperator(ctx, &testData[0])
	require.NotNil(t, err, "Create duplicate Operator")

	// test show all items
	basicOperatorShowTest(t, ctx, api, testData)

	// test Delete
	_, err = api.DeleteOperator(ctx, &testData[0])
	require.Nil(t, err, "Delete Operator %s", testData[0].GetKey().GetKeyString())
	show := ShowOperator{}
	show.Init()
	filterNone := edgeproto.Operator{}
	err = api.ShowOperator(ctx, &filterNone, &show)
	require.Nil(t, err, "show data")
	require.Equal(t, len(testData)-1+OperatorShowExtraCount, len(show.Data), "Show count")
	show.AssertNotFound(t, &testData[0])
	// test update of missing object
	_, err = api.UpdateOperator(ctx, &testData[0])
	require.NotNil(t, err, "Update missing object")
	// Create it back
	_, err = api.CreateOperator(ctx, &testData[0])
	require.Nil(t, err, "Create Operator %s", testData[0].GetKey().GetKeyString())

	// test invalid keys
	bad := edgeproto.Operator{}
	_, err = api.CreateOperator(ctx, &bad)
	require.NotNil(t, err, "Create Operator with no key info")

}

func InternalOperatorCreate(t *testing.T, api edgeproto.OperatorApiServer, testData []edgeproto.Operator) {
	span := log.StartSpan(log.DebugLevelApi, "InternalOperatorCreate")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	CreateOperatorData(t, ctx, NewInternalOperatorApi(api), testData)
}

func ClientOperatorCreate(t *testing.T, api edgeproto.OperatorApiClient, testData []edgeproto.Operator) {
	span := log.StartSpan(log.DebugLevelApi, "ClientOperatorCreate")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	CreateOperatorData(t, ctx, NewClientOperatorApi(api), testData)
}

func CreateOperatorData(t *testing.T, ctx context.Context, api *OperatorCommonApi, testData []edgeproto.Operator) {
	var err error

	for _, obj := range testData {
		_, err = api.CreateOperator(ctx, &obj)
		require.Nil(t, err, "Create Operator %s", obj.GetKey().GetKeyString())
	}
}

func FindOperatorData(key *edgeproto.OperatorKey, testData []edgeproto.Operator) (*edgeproto.Operator, bool) {
	for ii, _ := range testData {
		if testData[ii].GetKey().Matches(key) {
			return &testData[ii], true
		}
	}
	return nil, false
}

type ShowOperatorCode struct {
	Data map[string]edgeproto.OperatorCode
	grpc.ServerStream
	Ctx context.Context
}

func (x *ShowOperatorCode) Init() {
	x.Data = make(map[string]edgeproto.OperatorCode)
}

func (x *ShowOperatorCode) Send(m *edgeproto.OperatorCode) error {
	x.Data[m.GetKey().GetKeyString()] = *m
	return nil
}

func (x *ShowOperatorCode) Context() context.Context {
	return x.Ctx
}

var OperatorCodeShowExtraCount = 0

func (x *ShowOperatorCode) ReadStream(stream edgeproto.OperatorCodeApi_ShowOperatorCodeClient, err error) {
	x.Data = make(map[string]edgeproto.OperatorCode)
	if err != nil {
		return
	}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			break
		}
		x.Data[obj.GetKey().GetKeyString()] = *obj
	}
}

func (x *ShowOperatorCode) CheckFound(obj *edgeproto.OperatorCode) bool {
	_, found := x.Data[obj.GetKey().GetKeyString()]
	return found
}

func (x *ShowOperatorCode) AssertFound(t *testing.T, obj *edgeproto.OperatorCode) {
	check, found := x.Data[obj.GetKey().GetKeyString()]
	require.True(t, found, "find OperatorCode %s", obj.GetKey().GetKeyString())
	if found && !check.Matches(obj, edgeproto.MatchIgnoreBackend(), edgeproto.MatchSortArrayedKeys()) {
		require.Equal(t, *obj, check, "OperatorCode are equal")
	}
	if found {
		// remove in case there are dups in the list, so the
		// same object cannot be used again
		delete(x.Data, obj.GetKey().GetKeyString())
	}
}

func (x *ShowOperatorCode) AssertNotFound(t *testing.T, obj *edgeproto.OperatorCode) {
	_, found := x.Data[obj.GetKey().GetKeyString()]
	require.False(t, found, "do not find OperatorCode %s", obj.GetKey().GetKeyString())
}

func WaitAssertFoundOperatorCode(t *testing.T, api edgeproto.OperatorCodeApiClient, obj *edgeproto.OperatorCode, count int, retry time.Duration) {
	show := ShowOperatorCode{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowOperatorCode(ctx, obj)
		show.ReadStream(stream, err)
		cancel()
		if show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertFound(t, obj)
}

func WaitAssertNotFoundOperatorCode(t *testing.T, api edgeproto.OperatorCodeApiClient, obj *edgeproto.OperatorCode, count int, retry time.Duration) {
	show := ShowOperatorCode{}
	filterNone := edgeproto.OperatorCode{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowOperatorCode(ctx, &filterNone)
		show.ReadStream(stream, err)
		cancel()
		if !show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertNotFound(t, obj)
}

// Wrap the api with a common interface
type OperatorCodeCommonApi struct {
	internal_api edgeproto.OperatorCodeApiServer
	client_api   edgeproto.OperatorCodeApiClient
}

func (x *OperatorCodeCommonApi) CreateOperatorCode(ctx context.Context, in *edgeproto.OperatorCode) (*edgeproto.Result, error) {
	copy := &edgeproto.OperatorCode{}
	*copy = *in
	if x.internal_api != nil {
		return x.internal_api.CreateOperatorCode(ctx, copy)
	} else {
		return x.client_api.CreateOperatorCode(ctx, copy)
	}
}

func (x *OperatorCodeCommonApi) DeleteOperatorCode(ctx context.Context, in *edgeproto.OperatorCode) (*edgeproto.Result, error) {
	copy := &edgeproto.OperatorCode{}
	*copy = *in
	if x.internal_api != nil {
		return x.internal_api.DeleteOperatorCode(ctx, copy)
	} else {
		return x.client_api.DeleteOperatorCode(ctx, copy)
	}
}

func (x *OperatorCodeCommonApi) ShowOperatorCode(ctx context.Context, filter *edgeproto.OperatorCode, showData *ShowOperatorCode) error {
	if x.internal_api != nil {
		showData.Ctx = ctx
		return x.internal_api.ShowOperatorCode(filter, showData)
	} else {
		stream, err := x.client_api.ShowOperatorCode(ctx, filter)
		showData.ReadStream(stream, err)
		return err
	}
}

func NewInternalOperatorCodeApi(api edgeproto.OperatorCodeApiServer) *OperatorCodeCommonApi {
	apiWrap := OperatorCodeCommonApi{}
	apiWrap.internal_api = api
	return &apiWrap
}

func NewClientOperatorCodeApi(api edgeproto.OperatorCodeApiClient) *OperatorCodeCommonApi {
	apiWrap := OperatorCodeCommonApi{}
	apiWrap.client_api = api
	return &apiWrap
}

func InternalOperatorCodeTest(t *testing.T, test string, api edgeproto.OperatorCodeApiServer, testData []edgeproto.OperatorCode) {
	span := log.StartSpan(log.DebugLevelApi, "InternalOperatorCodeTest")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	switch test {
	case "cud":
		basicOperatorCodeCudTest(t, ctx, NewInternalOperatorCodeApi(api), testData)
	case "show":
		basicOperatorCodeShowTest(t, ctx, NewInternalOperatorCodeApi(api), testData)
	}
}

func ClientOperatorCodeTest(t *testing.T, test string, api edgeproto.OperatorCodeApiClient, testData []edgeproto.OperatorCode) {
	span := log.StartSpan(log.DebugLevelApi, "ClientOperatorCodeTest")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	switch test {
	case "cud":
		basicOperatorCodeCudTest(t, ctx, NewClientOperatorCodeApi(api), testData)
	case "show":
		basicOperatorCodeShowTest(t, ctx, NewClientOperatorCodeApi(api), testData)
	}
}

func basicOperatorCodeShowTest(t *testing.T, ctx context.Context, api *OperatorCodeCommonApi, testData []edgeproto.OperatorCode) {
	var err error

	show := ShowOperatorCode{}
	show.Init()
	filterNone := edgeproto.OperatorCode{}
	err = api.ShowOperatorCode(ctx, &filterNone, &show)
	require.Nil(t, err, "show data")
	require.Equal(t, len(testData)+OperatorCodeShowExtraCount, len(show.Data), "Show count")
	for _, obj := range testData {
		show.AssertFound(t, &obj)
	}
}

func GetOperatorCode(t *testing.T, ctx context.Context, api *OperatorCodeCommonApi, key *edgeproto.OperatorCodeKey, out *edgeproto.OperatorCode) bool {
	var err error

	show := ShowOperatorCode{}
	show.Init()
	filter := edgeproto.OperatorCode{}
	filter.SetKey(key)
	err = api.ShowOperatorCode(ctx, &filter, &show)
	require.Nil(t, err, "show data")
	obj, found := show.Data[key.GetKeyString()]
	if found {
		*out = obj
	}
	return found
}

func basicOperatorCodeCudTest(t *testing.T, ctx context.Context, api *OperatorCodeCommonApi, testData []edgeproto.OperatorCode) {
	var err error

	if len(testData) < 3 {
		require.True(t, false, "Need at least 3 test data objects")
		return
	}

	// test create
	CreateOperatorCodeData(t, ctx, api, testData)

	// test duplicate Create - should fail
	_, err = api.CreateOperatorCode(ctx, &testData[0])
	require.NotNil(t, err, "Create duplicate OperatorCode")

	// test show all items
	basicOperatorCodeShowTest(t, ctx, api, testData)

	// test Delete
	_, err = api.DeleteOperatorCode(ctx, &testData[0])
	require.Nil(t, err, "Delete OperatorCode %s", testData[0].GetKey().GetKeyString())
	show := ShowOperatorCode{}
	show.Init()
	filterNone := edgeproto.OperatorCode{}
	err = api.ShowOperatorCode(ctx, &filterNone, &show)
	require.Nil(t, err, "show data")
	require.Equal(t, len(testData)-1+OperatorCodeShowExtraCount, len(show.Data), "Show count")
	show.AssertNotFound(t, &testData[0])
	// Create it back
	_, err = api.CreateOperatorCode(ctx, &testData[0])
	require.Nil(t, err, "Create OperatorCode %s", testData[0].GetKey().GetKeyString())

	// test invalid keys
	bad := edgeproto.OperatorCode{}
	_, err = api.CreateOperatorCode(ctx, &bad)
	require.NotNil(t, err, "Create OperatorCode with no key info")

}

func InternalOperatorCodeCreate(t *testing.T, api edgeproto.OperatorCodeApiServer, testData []edgeproto.OperatorCode) {
	span := log.StartSpan(log.DebugLevelApi, "InternalOperatorCodeCreate")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	CreateOperatorCodeData(t, ctx, NewInternalOperatorCodeApi(api), testData)
}

func ClientOperatorCodeCreate(t *testing.T, api edgeproto.OperatorCodeApiClient, testData []edgeproto.OperatorCode) {
	span := log.StartSpan(log.DebugLevelApi, "ClientOperatorCodeCreate")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	CreateOperatorCodeData(t, ctx, NewClientOperatorCodeApi(api), testData)
}

func CreateOperatorCodeData(t *testing.T, ctx context.Context, api *OperatorCodeCommonApi, testData []edgeproto.OperatorCode) {
	var err error

	for _, obj := range testData {
		_, err = api.CreateOperatorCode(ctx, &obj)
		require.Nil(t, err, "Create OperatorCode %s", obj.GetKey().GetKeyString())
	}
}

func FindOperatorCodeData(key *edgeproto.OperatorCodeKey, testData []edgeproto.OperatorCode) (*edgeproto.OperatorCode, bool) {
	for ii, _ := range testData {
		if testData[ii].GetKey().Matches(key) {
			return &testData[ii], true
		}
	}
	return nil, false
}

func (r *Run) OperatorApi(data *[]edgeproto.Operator, dataMap interface{}, dataOut interface{}) {
	log.DebugLog(log.DebugLevelApi, "API for Operator", "mode", r.Mode)
	if r.Mode == "show" {
		obj := &edgeproto.Operator{}
		out, err := r.client.ShowOperator(r.ctx, obj)
		if err != nil {
			r.logErr("OperatorApi", err)
		} else {
			outp, ok := dataOut.(*[]edgeproto.Operator)
			if !ok {
				panic(fmt.Sprintf("RunOperatorApi expected dataOut type *[]edgeproto.Operator, but was %T", dataOut))
			}
			*outp = append(*outp, out...)
		}
		return
	}
	for ii, objD := range *data {
		obj := &objD
		switch r.Mode {
		case "create":
			out, err := r.client.CreateOperator(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("OperatorApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunOperatorApi expected dataOut type *[]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		case "delete":
			out, err := r.client.DeleteOperator(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("OperatorApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunOperatorApi expected dataOut type *[]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		case "update":
			// set specified fields
			objMap, err := cli.GetGenericObjFromList(dataMap, ii)
			if err != nil {
				log.DebugLog(log.DebugLevelApi, "bad dataMap for Operator", "err", err)
				*r.Rc = false
				return
			}
			obj.Fields = cli.GetSpecifiedFields(objMap, obj, cli.YamlNamespace)

			out, err := r.client.UpdateOperator(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("OperatorApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunOperatorApi expected dataOut type *[]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		case "showfiltered":
			out, err := r.client.ShowOperator(r.ctx, obj)
			if err != nil {
				r.logErr(fmt.Sprintf("OperatorApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.Operator)
				if !ok {
					panic(fmt.Sprintf("RunOperatorApi expected dataOut type *[]edgeproto.Operator, but was %T", dataOut))
				}
				*outp = append(*outp, out...)
			}
		}
	}
}

func (s *DummyServer) CreateOperator(ctx context.Context, in *edgeproto.Operator) (*edgeproto.Result, error) {
	if s.CudNoop {
		return &edgeproto.Result{}, nil
	}
	s.OperatorCache.Update(ctx, in, 0)
	return &edgeproto.Result{}, nil
}

func (s *DummyServer) DeleteOperator(ctx context.Context, in *edgeproto.Operator) (*edgeproto.Result, error) {
	if s.CudNoop {
		return &edgeproto.Result{}, nil
	}
	s.OperatorCache.Delete(ctx, in, 0)
	return &edgeproto.Result{}, nil
}

func (s *DummyServer) UpdateOperator(ctx context.Context, in *edgeproto.Operator) (*edgeproto.Result, error) {
	if s.CudNoop {
		return &edgeproto.Result{}, nil
	}
	s.OperatorCache.Update(ctx, in, 0)
	return &edgeproto.Result{}, nil
}

func (s *DummyServer) ShowOperator(in *edgeproto.Operator, server edgeproto.OperatorApi_ShowOperatorServer) error {
	var err error
	obj := &edgeproto.Operator{}
	if obj.Matches(in, edgeproto.MatchFilter()) {
		for ii := 0; ii < s.ShowDummyCount; ii++ {
			server.Send(&edgeproto.Operator{})
		}
	}
	err = s.OperatorCache.Show(in, func(obj *edgeproto.Operator) error {
		err := server.Send(obj)
		return err
	})
	return err
}

func (r *Run) OperatorCodeApi(data *[]edgeproto.OperatorCode, dataMap interface{}, dataOut interface{}) {
	log.DebugLog(log.DebugLevelApi, "API for OperatorCode", "mode", r.Mode)
	if r.Mode == "show" {
		obj := &edgeproto.OperatorCode{}
		out, err := r.client.ShowOperatorCode(r.ctx, obj)
		if err != nil {
			r.logErr("OperatorCodeApi", err)
		} else {
			outp, ok := dataOut.(*[]edgeproto.OperatorCode)
			if !ok {
				panic(fmt.Sprintf("RunOperatorCodeApi expected dataOut type *[]edgeproto.OperatorCode, but was %T", dataOut))
			}
			*outp = append(*outp, out...)
		}
		return
	}
	for ii, objD := range *data {
		obj := &objD
		switch r.Mode {
		case "create":
			out, err := r.client.CreateOperatorCode(r.ctx, obj)
			if err != nil {
				r.logErr(fmt.Sprintf("OperatorCodeApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunOperatorCodeApi expected dataOut type *[]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		case "delete":
			out, err := r.client.DeleteOperatorCode(r.ctx, obj)
			if err != nil {
				r.logErr(fmt.Sprintf("OperatorCodeApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunOperatorCodeApi expected dataOut type *[]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		case "showfiltered":
			out, err := r.client.ShowOperatorCode(r.ctx, obj)
			if err != nil {
				r.logErr(fmt.Sprintf("OperatorCodeApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.OperatorCode)
				if !ok {
					panic(fmt.Sprintf("RunOperatorCodeApi expected dataOut type *[]edgeproto.OperatorCode, but was %T", dataOut))
				}
				*outp = append(*outp, out...)
			}
		}
	}
}

func (s *DummyServer) CreateOperatorCode(ctx context.Context, in *edgeproto.OperatorCode) (*edgeproto.Result, error) {
	if s.CudNoop {
		return &edgeproto.Result{}, nil
	}
	s.OperatorCodeCache.Update(ctx, in, 0)
	return &edgeproto.Result{}, nil
}

func (s *DummyServer) DeleteOperatorCode(ctx context.Context, in *edgeproto.OperatorCode) (*edgeproto.Result, error) {
	if s.CudNoop {
		return &edgeproto.Result{}, nil
	}
	s.OperatorCodeCache.Delete(ctx, in, 0)
	return &edgeproto.Result{}, nil
}

func (s *DummyServer) ShowOperatorCode(in *edgeproto.OperatorCode, server edgeproto.OperatorCodeApi_ShowOperatorCodeServer) error {
	var err error
	obj := &edgeproto.OperatorCode{}
	if obj.Matches(in, edgeproto.MatchFilter()) {
		for ii := 0; ii < s.ShowDummyCount; ii++ {
			server.Send(&edgeproto.OperatorCode{})
		}
	}
	err = s.OperatorCodeCache.Show(in, func(obj *edgeproto.OperatorCode) error {
		err := server.Send(obj)
		return err
	})
	return err
}

func (s *ApiClient) CreateOperator(ctx context.Context, in *edgeproto.Operator) (*edgeproto.Result, error) {
	api := edgeproto.NewOperatorApiClient(s.Conn)
	return api.CreateOperator(ctx, in)
}

func (s *CliClient) CreateOperator(ctx context.Context, in *edgeproto.Operator) (*edgeproto.Result, error) {
	out := edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "CreateOperator")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

func (s *ApiClient) DeleteOperator(ctx context.Context, in *edgeproto.Operator) (*edgeproto.Result, error) {
	api := edgeproto.NewOperatorApiClient(s.Conn)
	return api.DeleteOperator(ctx, in)
}

func (s *CliClient) DeleteOperator(ctx context.Context, in *edgeproto.Operator) (*edgeproto.Result, error) {
	out := edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "DeleteOperator")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

func (s *ApiClient) UpdateOperator(ctx context.Context, in *edgeproto.Operator) (*edgeproto.Result, error) {
	api := edgeproto.NewOperatorApiClient(s.Conn)
	return api.UpdateOperator(ctx, in)
}

func (s *CliClient) UpdateOperator(ctx context.Context, in *edgeproto.Operator) (*edgeproto.Result, error) {
	out := edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "UpdateOperator")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

type OperatorStream interface {
	Recv() (*edgeproto.Operator, error)
}

func OperatorReadStream(stream OperatorStream) ([]edgeproto.Operator, error) {
	output := []edgeproto.Operator{}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			return output, fmt.Errorf("read Operator stream failed, %v", err)
		}
		output = append(output, *obj)
	}
	return output, nil
}

func (s *ApiClient) ShowOperator(ctx context.Context, in *edgeproto.Operator) ([]edgeproto.Operator, error) {
	api := edgeproto.NewOperatorApiClient(s.Conn)
	stream, err := api.ShowOperator(ctx, in)
	if err != nil {
		return nil, err
	}
	return OperatorReadStream(stream)
}

func (s *CliClient) ShowOperator(ctx context.Context, in *edgeproto.Operator) ([]edgeproto.Operator, error) {
	output := []edgeproto.Operator{}
	args := append(s.BaseArgs, "controller", "ShowOperator")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

type OperatorApiClient interface {
	CreateOperator(ctx context.Context, in *edgeproto.Operator) (*edgeproto.Result, error)
	DeleteOperator(ctx context.Context, in *edgeproto.Operator) (*edgeproto.Result, error)
	UpdateOperator(ctx context.Context, in *edgeproto.Operator) (*edgeproto.Result, error)
	ShowOperator(ctx context.Context, in *edgeproto.Operator) ([]edgeproto.Operator, error)
}

func (s *ApiClient) CreateOperatorCode(ctx context.Context, in *edgeproto.OperatorCode) (*edgeproto.Result, error) {
	api := edgeproto.NewOperatorCodeApiClient(s.Conn)
	return api.CreateOperatorCode(ctx, in)
}

func (s *CliClient) CreateOperatorCode(ctx context.Context, in *edgeproto.OperatorCode) (*edgeproto.Result, error) {
	out := edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "CreateOperatorCode")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

func (s *ApiClient) DeleteOperatorCode(ctx context.Context, in *edgeproto.OperatorCode) (*edgeproto.Result, error) {
	api := edgeproto.NewOperatorCodeApiClient(s.Conn)
	return api.DeleteOperatorCode(ctx, in)
}

func (s *CliClient) DeleteOperatorCode(ctx context.Context, in *edgeproto.OperatorCode) (*edgeproto.Result, error) {
	out := edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "DeleteOperatorCode")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

type OperatorCodeStream interface {
	Recv() (*edgeproto.OperatorCode, error)
}

func OperatorCodeReadStream(stream OperatorCodeStream) ([]edgeproto.OperatorCode, error) {
	output := []edgeproto.OperatorCode{}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			return output, fmt.Errorf("read OperatorCode stream failed, %v", err)
		}
		output = append(output, *obj)
	}
	return output, nil
}

func (s *ApiClient) ShowOperatorCode(ctx context.Context, in *edgeproto.OperatorCode) ([]edgeproto.OperatorCode, error) {
	api := edgeproto.NewOperatorCodeApiClient(s.Conn)
	stream, err := api.ShowOperatorCode(ctx, in)
	if err != nil {
		return nil, err
	}
	return OperatorCodeReadStream(stream)
}

func (s *CliClient) ShowOperatorCode(ctx context.Context, in *edgeproto.OperatorCode) ([]edgeproto.OperatorCode, error) {
	output := []edgeproto.OperatorCode{}
	args := append(s.BaseArgs, "controller", "ShowOperatorCode")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

type OperatorCodeApiClient interface {
	CreateOperatorCode(ctx context.Context, in *edgeproto.OperatorCode) (*edgeproto.Result, error)
	DeleteOperatorCode(ctx context.Context, in *edgeproto.OperatorCode) (*edgeproto.Result, error)
	ShowOperatorCode(ctx context.Context, in *edgeproto.OperatorCode) ([]edgeproto.OperatorCode, error)
}
