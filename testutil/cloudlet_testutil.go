// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cloudlet.proto

package testutil

import (
	"context"
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/mobiledgex/edge-cloud/cli"
	_ "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto"
	"github.com/mobiledgex/edge-cloud/edgectl/wrapper"
	"github.com/mobiledgex/edge-cloud/edgeproto"
	"github.com/mobiledgex/edge-cloud/log"
	_ "github.com/mobiledgex/edge-cloud/protogen"
	"github.com/stretchr/testify/require"
	"google.golang.org/grpc"
	"io"
	math "math"
	"testing"
	"time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Auto-generated code: DO NOT EDIT

type ShowGPUDriver struct {
	Data map[string]edgeproto.GPUDriver
	grpc.ServerStream
	Ctx context.Context
}

func (x *ShowGPUDriver) Init() {
	x.Data = make(map[string]edgeproto.GPUDriver)
}

func (x *ShowGPUDriver) Send(m *edgeproto.GPUDriver) error {
	x.Data[m.GetKey().GetKeyString()] = *m
	return nil
}

func (x *ShowGPUDriver) Context() context.Context {
	return x.Ctx
}

var GPUDriverShowExtraCount = 0

type CudStreamoutGPUDriver struct {
	grpc.ServerStream
	Ctx context.Context
}

func (x *CudStreamoutGPUDriver) Send(res *edgeproto.Result) error {
	fmt.Println(res)
	return nil
}

func (x *CudStreamoutGPUDriver) Context() context.Context {
	return x.Ctx
}

func NewCudStreamoutGPUDriver(ctx context.Context) *CudStreamoutGPUDriver {
	return &CudStreamoutGPUDriver{
		Ctx: ctx,
	}
}

func GPUDriverReadResultStream(stream ResultStream, err error) error {
	if err != nil {
		return err
	}
	for {
		res, err := stream.Recv()
		if err == io.EOF {
			return nil
		}
		if err != nil {
			return err
		}
		fmt.Println(res)
	}
}

func (x *ShowGPUDriver) ReadStream(stream edgeproto.GPUDriverApi_ShowGPUDriverClient, err error) {
	x.Data = make(map[string]edgeproto.GPUDriver)
	if err != nil {
		return
	}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			break
		}
		x.Data[obj.GetKey().GetKeyString()] = *obj
	}
}

func (x *ShowGPUDriver) CheckFound(obj *edgeproto.GPUDriver) bool {
	_, found := x.Data[obj.GetKey().GetKeyString()]
	return found
}

func (x *ShowGPUDriver) AssertFound(t *testing.T, obj *edgeproto.GPUDriver) {
	check, found := x.Data[obj.GetKey().GetKeyString()]
	require.True(t, found, "find GPUDriver %s", obj.GetKey().GetKeyString())
	if found && !check.Matches(obj, edgeproto.MatchIgnoreBackend(), edgeproto.MatchSortArrayedKeys()) {
		require.Equal(t, *obj, check, "GPUDriver are equal")
	}
	if found {
		// remove in case there are dups in the list, so the
		// same object cannot be used again
		delete(x.Data, obj.GetKey().GetKeyString())
	}
}

func (x *ShowGPUDriver) AssertNotFound(t *testing.T, obj *edgeproto.GPUDriver) {
	_, found := x.Data[obj.GetKey().GetKeyString()]
	require.False(t, found, "do not find GPUDriver %s", obj.GetKey().GetKeyString())
}

func WaitAssertFoundGPUDriver(t *testing.T, api edgeproto.GPUDriverApiClient, obj *edgeproto.GPUDriver, count int, retry time.Duration) {
	show := ShowGPUDriver{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowGPUDriver(ctx, obj)
		show.ReadStream(stream, err)
		cancel()
		if show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertFound(t, obj)
}

func WaitAssertNotFoundGPUDriver(t *testing.T, api edgeproto.GPUDriverApiClient, obj *edgeproto.GPUDriver, count int, retry time.Duration) {
	show := ShowGPUDriver{}
	filterNone := edgeproto.GPUDriver{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowGPUDriver(ctx, &filterNone)
		show.ReadStream(stream, err)
		cancel()
		if !show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertNotFound(t, obj)
}

// Wrap the api with a common interface
type GPUDriverCommonApi struct {
	internal_api edgeproto.GPUDriverApiServer
	client_api   edgeproto.GPUDriverApiClient
}

func (x *GPUDriverCommonApi) CreateGPUDriver(ctx context.Context, in *edgeproto.GPUDriver) (*edgeproto.Result, error) {
	copy := &edgeproto.GPUDriver{}
	*copy = *in
	if x.internal_api != nil {
		err := x.internal_api.CreateGPUDriver(copy, NewCudStreamoutGPUDriver(ctx))
		return &edgeproto.Result{}, err
	} else {
		stream, err := x.client_api.CreateGPUDriver(ctx, copy)
		err = GPUDriverReadResultStream(stream, err)
		return &edgeproto.Result{}, err
	}
}

func (x *GPUDriverCommonApi) DeleteGPUDriver(ctx context.Context, in *edgeproto.GPUDriver) (*edgeproto.Result, error) {
	copy := &edgeproto.GPUDriver{}
	*copy = *in
	if x.internal_api != nil {
		err := x.internal_api.DeleteGPUDriver(copy, NewCudStreamoutGPUDriver(ctx))
		return &edgeproto.Result{}, err
	} else {
		stream, err := x.client_api.DeleteGPUDriver(ctx, copy)
		err = GPUDriverReadResultStream(stream, err)
		return &edgeproto.Result{}, err
	}
}

func (x *GPUDriverCommonApi) UpdateGPUDriver(ctx context.Context, in *edgeproto.GPUDriver) (*edgeproto.Result, error) {
	copy := &edgeproto.GPUDriver{}
	*copy = *in
	if x.internal_api != nil {
		err := x.internal_api.UpdateGPUDriver(copy, NewCudStreamoutGPUDriver(ctx))
		return &edgeproto.Result{}, err
	} else {
		stream, err := x.client_api.UpdateGPUDriver(ctx, copy)
		err = GPUDriverReadResultStream(stream, err)
		return &edgeproto.Result{}, err
	}
}

func (x *GPUDriverCommonApi) ShowGPUDriver(ctx context.Context, filter *edgeproto.GPUDriver, showData *ShowGPUDriver) error {
	if x.internal_api != nil {
		showData.Ctx = ctx
		return x.internal_api.ShowGPUDriver(filter, showData)
	} else {
		stream, err := x.client_api.ShowGPUDriver(ctx, filter)
		showData.ReadStream(stream, err)
		return err
	}
}

func NewInternalGPUDriverApi(api edgeproto.GPUDriverApiServer) *GPUDriverCommonApi {
	apiWrap := GPUDriverCommonApi{}
	apiWrap.internal_api = api
	return &apiWrap
}

func NewClientGPUDriverApi(api edgeproto.GPUDriverApiClient) *GPUDriverCommonApi {
	apiWrap := GPUDriverCommonApi{}
	apiWrap.client_api = api
	return &apiWrap
}

type GPUDriverTestOptions struct {
	createdData []edgeproto.GPUDriver
}

type GPUDriverTestOp func(opts *GPUDriverTestOptions)

func WithCreatedGPUDriverTestData(createdData []edgeproto.GPUDriver) GPUDriverTestOp {
	return func(opts *GPUDriverTestOptions) { opts.createdData = createdData }
}

func InternalGPUDriverTest(t *testing.T, test string, api edgeproto.GPUDriverApiServer, testData []edgeproto.GPUDriver, ops ...GPUDriverTestOp) {
	span := log.StartSpan(log.DebugLevelApi, "InternalGPUDriverTest")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	switch test {
	case "cud":
		basicGPUDriverCudTest(t, ctx, NewInternalGPUDriverApi(api), testData, ops...)
	case "show":
		basicGPUDriverShowTest(t, ctx, NewInternalGPUDriverApi(api), testData)
	}
}

func ClientGPUDriverTest(t *testing.T, test string, api edgeproto.GPUDriverApiClient, testData []edgeproto.GPUDriver, ops ...GPUDriverTestOp) {
	span := log.StartSpan(log.DebugLevelApi, "ClientGPUDriverTest")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	switch test {
	case "cud":
		basicGPUDriverCudTest(t, ctx, NewClientGPUDriverApi(api), testData, ops...)
	case "show":
		basicGPUDriverShowTest(t, ctx, NewClientGPUDriverApi(api), testData)
	}
}

func basicGPUDriverShowTest(t *testing.T, ctx context.Context, api *GPUDriverCommonApi, testData []edgeproto.GPUDriver) {
	var err error

	show := ShowGPUDriver{}
	show.Init()
	filterNone := edgeproto.GPUDriver{}
	err = api.ShowGPUDriver(ctx, &filterNone, &show)
	require.Nil(t, err, "show data")
	require.Equal(t, len(testData)+GPUDriverShowExtraCount, len(show.Data), "Show count")
	for _, obj := range testData {
		show.AssertFound(t, &obj)
	}
}

func GetGPUDriver(t *testing.T, ctx context.Context, api *GPUDriverCommonApi, key *edgeproto.GPUDriverKey, out *edgeproto.GPUDriver) bool {
	var err error

	show := ShowGPUDriver{}
	show.Init()
	filter := edgeproto.GPUDriver{}
	filter.SetKey(key)
	err = api.ShowGPUDriver(ctx, &filter, &show)
	require.Nil(t, err, "show data")
	obj, found := show.Data[key.GetKeyString()]
	if found {
		*out = obj
	}
	return found
}

func basicGPUDriverCudTest(t *testing.T, ctx context.Context, api *GPUDriverCommonApi, testData []edgeproto.GPUDriver, ops ...GPUDriverTestOp) {
	var err error

	if len(testData) < 3 {
		require.True(t, false, "Need at least 3 test data objects")
		return
	}
	options := GPUDriverTestOptions{}
	for _, op := range ops {
		op(&options)
	}
	createdData := testData
	if options.createdData != nil {
		createdData = options.createdData
	}

	// test create
	CreateGPUDriverData(t, ctx, api, testData)

	// test duplicate Create - should fail
	_, err = api.CreateGPUDriver(ctx, &testData[0])
	require.NotNil(t, err, "Create duplicate GPUDriver")

	// test show all items
	basicGPUDriverShowTest(t, ctx, api, createdData)

	// test Delete
	_, err = api.DeleteGPUDriver(ctx, &createdData[0])
	require.Nil(t, err, "Delete GPUDriver %s", testData[0].GetKey().GetKeyString())
	show := ShowGPUDriver{}
	show.Init()
	filterNone := edgeproto.GPUDriver{}
	err = api.ShowGPUDriver(ctx, &filterNone, &show)
	require.Nil(t, err, "show data")
	require.Equal(t, len(createdData)-1+GPUDriverShowExtraCount, len(show.Data), "Show count")
	show.AssertNotFound(t, &createdData[0])
	// test update of missing object
	_, err = api.UpdateGPUDriver(ctx, &createdData[0])
	require.NotNil(t, err, "Update missing object")
	// Create it back
	_, err = api.CreateGPUDriver(ctx, &testData[0])
	require.Nil(t, err, "Create GPUDriver %s", testData[0].GetKey().GetKeyString())

	// test invalid keys
	bad := edgeproto.GPUDriver{}
	_, err = api.CreateGPUDriver(ctx, &bad)
	require.NotNil(t, err, "Create GPUDriver with no key info")

}

func InternalGPUDriverCreate(t *testing.T, api edgeproto.GPUDriverApiServer, testData []edgeproto.GPUDriver) {
	span := log.StartSpan(log.DebugLevelApi, "InternalGPUDriverCreate")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	CreateGPUDriverData(t, ctx, NewInternalGPUDriverApi(api), testData)
}

func ClientGPUDriverCreate(t *testing.T, api edgeproto.GPUDriverApiClient, testData []edgeproto.GPUDriver) {
	span := log.StartSpan(log.DebugLevelApi, "ClientGPUDriverCreate")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	CreateGPUDriverData(t, ctx, NewClientGPUDriverApi(api), testData)
}

func CreateGPUDriverData(t *testing.T, ctx context.Context, api *GPUDriverCommonApi, testData []edgeproto.GPUDriver) {
	var err error

	for _, obj := range testData {
		_, err = api.CreateGPUDriver(ctx, &obj)
		require.Nil(t, err, "Create GPUDriver %s", obj.GetKey().GetKeyString())
	}
}

func FindGPUDriverData(key *edgeproto.GPUDriverKey, testData []edgeproto.GPUDriver) (*edgeproto.GPUDriver, bool) {
	for ii, _ := range testData {
		if testData[ii].GetKey().Matches(key) {
			return &testData[ii], true
		}
	}
	return nil, false
}

type ShowCloudlet struct {
	Data map[string]edgeproto.Cloudlet
	grpc.ServerStream
	Ctx context.Context
}

func (x *ShowCloudlet) Init() {
	x.Data = make(map[string]edgeproto.Cloudlet)
}

func (x *ShowCloudlet) Send(m *edgeproto.Cloudlet) error {
	x.Data[m.GetKey().GetKeyString()] = *m
	return nil
}

func (x *ShowCloudlet) Context() context.Context {
	return x.Ctx
}

var CloudletShowExtraCount = 0

type CudStreamoutCloudlet struct {
	grpc.ServerStream
	Ctx context.Context
}

func (x *CudStreamoutCloudlet) Send(res *edgeproto.Result) error {
	fmt.Println(res)
	return nil
}

func (x *CudStreamoutCloudlet) Context() context.Context {
	return x.Ctx
}

func NewCudStreamoutCloudlet(ctx context.Context) *CudStreamoutCloudlet {
	return &CudStreamoutCloudlet{
		Ctx: ctx,
	}
}

func CloudletReadResultStream(stream ResultStream, err error) error {
	if err != nil {
		return err
	}
	for {
		res, err := stream.Recv()
		if err == io.EOF {
			return nil
		}
		if err != nil {
			return err
		}
		fmt.Println(res)
	}
}

func (x *ShowCloudlet) ReadStream(stream edgeproto.CloudletApi_ShowCloudletClient, err error) {
	x.Data = make(map[string]edgeproto.Cloudlet)
	if err != nil {
		return
	}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			break
		}
		x.Data[obj.GetKey().GetKeyString()] = *obj
	}
}

func (x *ShowCloudlet) CheckFound(obj *edgeproto.Cloudlet) bool {
	_, found := x.Data[obj.GetKey().GetKeyString()]
	return found
}

func (x *ShowCloudlet) AssertFound(t *testing.T, obj *edgeproto.Cloudlet) {
	check, found := x.Data[obj.GetKey().GetKeyString()]
	require.True(t, found, "find Cloudlet %s", obj.GetKey().GetKeyString())
	if found && !check.Matches(obj, edgeproto.MatchIgnoreBackend(), edgeproto.MatchSortArrayedKeys()) {
		require.Equal(t, *obj, check, "Cloudlet are equal")
	}
	if found {
		// remove in case there are dups in the list, so the
		// same object cannot be used again
		delete(x.Data, obj.GetKey().GetKeyString())
	}
}

func (x *ShowCloudlet) AssertNotFound(t *testing.T, obj *edgeproto.Cloudlet) {
	_, found := x.Data[obj.GetKey().GetKeyString()]
	require.False(t, found, "do not find Cloudlet %s", obj.GetKey().GetKeyString())
}

func WaitAssertFoundCloudlet(t *testing.T, api edgeproto.CloudletApiClient, obj *edgeproto.Cloudlet, count int, retry time.Duration) {
	show := ShowCloudlet{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowCloudlet(ctx, obj)
		show.ReadStream(stream, err)
		cancel()
		if show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertFound(t, obj)
}

func WaitAssertNotFoundCloudlet(t *testing.T, api edgeproto.CloudletApiClient, obj *edgeproto.Cloudlet, count int, retry time.Duration) {
	show := ShowCloudlet{}
	filterNone := edgeproto.Cloudlet{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowCloudlet(ctx, &filterNone)
		show.ReadStream(stream, err)
		cancel()
		if !show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertNotFound(t, obj)
}

// Wrap the api with a common interface
type CloudletCommonApi struct {
	internal_api edgeproto.CloudletApiServer
	client_api   edgeproto.CloudletApiClient
}

func (x *CloudletCommonApi) CreateCloudlet(ctx context.Context, in *edgeproto.Cloudlet) (*edgeproto.Result, error) {
	copy := &edgeproto.Cloudlet{}
	*copy = *in
	if x.internal_api != nil {
		err := x.internal_api.CreateCloudlet(copy, NewCudStreamoutCloudlet(ctx))
		return &edgeproto.Result{}, err
	} else {
		stream, err := x.client_api.CreateCloudlet(ctx, copy)
		err = CloudletReadResultStream(stream, err)
		return &edgeproto.Result{}, err
	}
}

func (x *CloudletCommonApi) DeleteCloudlet(ctx context.Context, in *edgeproto.Cloudlet) (*edgeproto.Result, error) {
	copy := &edgeproto.Cloudlet{}
	*copy = *in
	if x.internal_api != nil {
		err := x.internal_api.DeleteCloudlet(copy, NewCudStreamoutCloudlet(ctx))
		return &edgeproto.Result{}, err
	} else {
		stream, err := x.client_api.DeleteCloudlet(ctx, copy)
		err = CloudletReadResultStream(stream, err)
		return &edgeproto.Result{}, err
	}
}

func (x *CloudletCommonApi) UpdateCloudlet(ctx context.Context, in *edgeproto.Cloudlet) (*edgeproto.Result, error) {
	copy := &edgeproto.Cloudlet{}
	*copy = *in
	if x.internal_api != nil {
		err := x.internal_api.UpdateCloudlet(copy, NewCudStreamoutCloudlet(ctx))
		return &edgeproto.Result{}, err
	} else {
		stream, err := x.client_api.UpdateCloudlet(ctx, copy)
		err = CloudletReadResultStream(stream, err)
		return &edgeproto.Result{}, err
	}
}

func (x *CloudletCommonApi) ShowCloudlet(ctx context.Context, filter *edgeproto.Cloudlet, showData *ShowCloudlet) error {
	if x.internal_api != nil {
		showData.Ctx = ctx
		return x.internal_api.ShowCloudlet(filter, showData)
	} else {
		stream, err := x.client_api.ShowCloudlet(ctx, filter)
		showData.ReadStream(stream, err)
		return err
	}
}

func NewInternalCloudletApi(api edgeproto.CloudletApiServer) *CloudletCommonApi {
	apiWrap := CloudletCommonApi{}
	apiWrap.internal_api = api
	return &apiWrap
}

func NewClientCloudletApi(api edgeproto.CloudletApiClient) *CloudletCommonApi {
	apiWrap := CloudletCommonApi{}
	apiWrap.client_api = api
	return &apiWrap
}

type CloudletTestOptions struct {
	createdData []edgeproto.Cloudlet
}

type CloudletTestOp func(opts *CloudletTestOptions)

func WithCreatedCloudletTestData(createdData []edgeproto.Cloudlet) CloudletTestOp {
	return func(opts *CloudletTestOptions) { opts.createdData = createdData }
}

func InternalCloudletTest(t *testing.T, test string, api edgeproto.CloudletApiServer, testData []edgeproto.Cloudlet, ops ...CloudletTestOp) {
	span := log.StartSpan(log.DebugLevelApi, "InternalCloudletTest")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	switch test {
	case "cud":
		basicCloudletCudTest(t, ctx, NewInternalCloudletApi(api), testData, ops...)
	case "show":
		basicCloudletShowTest(t, ctx, NewInternalCloudletApi(api), testData)
	}
}

func ClientCloudletTest(t *testing.T, test string, api edgeproto.CloudletApiClient, testData []edgeproto.Cloudlet, ops ...CloudletTestOp) {
	span := log.StartSpan(log.DebugLevelApi, "ClientCloudletTest")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	switch test {
	case "cud":
		basicCloudletCudTest(t, ctx, NewClientCloudletApi(api), testData, ops...)
	case "show":
		basicCloudletShowTest(t, ctx, NewClientCloudletApi(api), testData)
	}
}

func basicCloudletShowTest(t *testing.T, ctx context.Context, api *CloudletCommonApi, testData []edgeproto.Cloudlet) {
	var err error

	show := ShowCloudlet{}
	show.Init()
	filterNone := edgeproto.Cloudlet{}
	err = api.ShowCloudlet(ctx, &filterNone, &show)
	require.Nil(t, err, "show data")
	require.Equal(t, len(testData)+CloudletShowExtraCount, len(show.Data), "Show count")
	for _, obj := range testData {
		show.AssertFound(t, &obj)
	}
}

func GetCloudlet(t *testing.T, ctx context.Context, api *CloudletCommonApi, key *edgeproto.CloudletKey, out *edgeproto.Cloudlet) bool {
	var err error

	show := ShowCloudlet{}
	show.Init()
	filter := edgeproto.Cloudlet{}
	filter.SetKey(key)
	err = api.ShowCloudlet(ctx, &filter, &show)
	require.Nil(t, err, "show data")
	obj, found := show.Data[key.GetKeyString()]
	if found {
		*out = obj
	}
	return found
}

func basicCloudletCudTest(t *testing.T, ctx context.Context, api *CloudletCommonApi, testData []edgeproto.Cloudlet, ops ...CloudletTestOp) {
	var err error

	if len(testData) < 3 {
		require.True(t, false, "Need at least 3 test data objects")
		return
	}
	options := CloudletTestOptions{}
	for _, op := range ops {
		op(&options)
	}
	createdData := testData
	if options.createdData != nil {
		createdData = options.createdData
	}

	// test create
	CreateCloudletData(t, ctx, api, testData)

	// test duplicate Create - should fail
	_, err = api.CreateCloudlet(ctx, &testData[0])
	require.NotNil(t, err, "Create duplicate Cloudlet")

	// test show all items
	basicCloudletShowTest(t, ctx, api, createdData)

	// test Delete
	_, err = api.DeleteCloudlet(ctx, &createdData[0])
	require.Nil(t, err, "Delete Cloudlet %s", testData[0].GetKey().GetKeyString())
	show := ShowCloudlet{}
	show.Init()
	filterNone := edgeproto.Cloudlet{}
	err = api.ShowCloudlet(ctx, &filterNone, &show)
	require.Nil(t, err, "show data")
	require.Equal(t, len(createdData)-1+CloudletShowExtraCount, len(show.Data), "Show count")
	show.AssertNotFound(t, &createdData[0])
	// test update of missing object
	_, err = api.UpdateCloudlet(ctx, &createdData[0])
	require.NotNil(t, err, "Update missing object")
	// Create it back
	_, err = api.CreateCloudlet(ctx, &testData[0])
	require.Nil(t, err, "Create Cloudlet %s", testData[0].GetKey().GetKeyString())

	// test invalid keys
	bad := edgeproto.Cloudlet{}
	_, err = api.CreateCloudlet(ctx, &bad)
	require.NotNil(t, err, "Create Cloudlet with no key info")

}

func InternalCloudletCreate(t *testing.T, api edgeproto.CloudletApiServer, testData []edgeproto.Cloudlet) {
	span := log.StartSpan(log.DebugLevelApi, "InternalCloudletCreate")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	CreateCloudletData(t, ctx, NewInternalCloudletApi(api), testData)
}

func ClientCloudletCreate(t *testing.T, api edgeproto.CloudletApiClient, testData []edgeproto.Cloudlet) {
	span := log.StartSpan(log.DebugLevelApi, "ClientCloudletCreate")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	CreateCloudletData(t, ctx, NewClientCloudletApi(api), testData)
}

func CreateCloudletData(t *testing.T, ctx context.Context, api *CloudletCommonApi, testData []edgeproto.Cloudlet) {
	var err error

	for _, obj := range testData {
		_, err = api.CreateCloudlet(ctx, &obj)
		require.Nil(t, err, "Create Cloudlet %s", obj.GetKey().GetKeyString())
	}
}

func FindCloudletData(key *edgeproto.CloudletKey, testData []edgeproto.Cloudlet) (*edgeproto.Cloudlet, bool) {
	for ii, _ := range testData {
		if testData[ii].GetKey().Matches(key) {
			return &testData[ii], true
		}
	}
	return nil, false
}

type ShowCloudletInfo struct {
	Data map[string]edgeproto.CloudletInfo
	grpc.ServerStream
	Ctx context.Context
}

func (x *ShowCloudletInfo) Init() {
	x.Data = make(map[string]edgeproto.CloudletInfo)
}

func (x *ShowCloudletInfo) Send(m *edgeproto.CloudletInfo) error {
	x.Data[m.GetKey().GetKeyString()] = *m
	return nil
}

func (x *ShowCloudletInfo) Context() context.Context {
	return x.Ctx
}

var CloudletInfoShowExtraCount = 0

func (x *ShowCloudletInfo) ReadStream(stream edgeproto.CloudletInfoApi_ShowCloudletInfoClient, err error) {
	x.Data = make(map[string]edgeproto.CloudletInfo)
	if err != nil {
		return
	}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			break
		}
		x.Data[obj.GetKey().GetKeyString()] = *obj
	}
}

func (x *ShowCloudletInfo) CheckFound(obj *edgeproto.CloudletInfo) bool {
	_, found := x.Data[obj.GetKey().GetKeyString()]
	return found
}

func (x *ShowCloudletInfo) AssertFound(t *testing.T, obj *edgeproto.CloudletInfo) {
	check, found := x.Data[obj.GetKey().GetKeyString()]
	require.True(t, found, "find CloudletInfo %s", obj.GetKey().GetKeyString())
	if found && !check.Matches(obj, edgeproto.MatchIgnoreBackend(), edgeproto.MatchSortArrayedKeys()) {
		require.Equal(t, *obj, check, "CloudletInfo are equal")
	}
	if found {
		// remove in case there are dups in the list, so the
		// same object cannot be used again
		delete(x.Data, obj.GetKey().GetKeyString())
	}
}

func (x *ShowCloudletInfo) AssertNotFound(t *testing.T, obj *edgeproto.CloudletInfo) {
	_, found := x.Data[obj.GetKey().GetKeyString()]
	require.False(t, found, "do not find CloudletInfo %s", obj.GetKey().GetKeyString())
}

func WaitAssertFoundCloudletInfo(t *testing.T, api edgeproto.CloudletInfoApiClient, obj *edgeproto.CloudletInfo, count int, retry time.Duration) {
	show := ShowCloudletInfo{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowCloudletInfo(ctx, obj)
		show.ReadStream(stream, err)
		cancel()
		if show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertFound(t, obj)
}

func WaitAssertNotFoundCloudletInfo(t *testing.T, api edgeproto.CloudletInfoApiClient, obj *edgeproto.CloudletInfo, count int, retry time.Duration) {
	show := ShowCloudletInfo{}
	filterNone := edgeproto.CloudletInfo{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowCloudletInfo(ctx, &filterNone)
		show.ReadStream(stream, err)
		cancel()
		if !show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertNotFound(t, obj)
}

// Wrap the api with a common interface
type CloudletInfoCommonApi struct {
	internal_api edgeproto.CloudletInfoApiServer
	client_api   edgeproto.CloudletInfoApiClient
}

func (x *CloudletInfoCommonApi) ShowCloudletInfo(ctx context.Context, filter *edgeproto.CloudletInfo, showData *ShowCloudletInfo) error {
	if x.internal_api != nil {
		showData.Ctx = ctx
		return x.internal_api.ShowCloudletInfo(filter, showData)
	} else {
		stream, err := x.client_api.ShowCloudletInfo(ctx, filter)
		showData.ReadStream(stream, err)
		return err
	}
}

func NewInternalCloudletInfoApi(api edgeproto.CloudletInfoApiServer) *CloudletInfoCommonApi {
	apiWrap := CloudletInfoCommonApi{}
	apiWrap.internal_api = api
	return &apiWrap
}

func NewClientCloudletInfoApi(api edgeproto.CloudletInfoApiClient) *CloudletInfoCommonApi {
	apiWrap := CloudletInfoCommonApi{}
	apiWrap.client_api = api
	return &apiWrap
}

type CloudletInfoTestOptions struct {
	createdData []edgeproto.CloudletInfo
}

type CloudletInfoTestOp func(opts *CloudletInfoTestOptions)

func WithCreatedCloudletInfoTestData(createdData []edgeproto.CloudletInfo) CloudletInfoTestOp {
	return func(opts *CloudletInfoTestOptions) { opts.createdData = createdData }
}

func InternalCloudletInfoTest(t *testing.T, test string, api edgeproto.CloudletInfoApiServer, testData []edgeproto.CloudletInfo, ops ...CloudletInfoTestOp) {
	span := log.StartSpan(log.DebugLevelApi, "InternalCloudletInfoTest")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	switch test {
	case "show":
		basicCloudletInfoShowTest(t, ctx, NewInternalCloudletInfoApi(api), testData)
	}
}

func ClientCloudletInfoTest(t *testing.T, test string, api edgeproto.CloudletInfoApiClient, testData []edgeproto.CloudletInfo, ops ...CloudletInfoTestOp) {
	span := log.StartSpan(log.DebugLevelApi, "ClientCloudletInfoTest")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	switch test {
	case "show":
		basicCloudletInfoShowTest(t, ctx, NewClientCloudletInfoApi(api), testData)
	}
}

func basicCloudletInfoShowTest(t *testing.T, ctx context.Context, api *CloudletInfoCommonApi, testData []edgeproto.CloudletInfo) {
	var err error

	show := ShowCloudletInfo{}
	show.Init()
	filterNone := edgeproto.CloudletInfo{}
	err = api.ShowCloudletInfo(ctx, &filterNone, &show)
	require.Nil(t, err, "show data")
	require.Equal(t, len(testData)+CloudletInfoShowExtraCount, len(show.Data), "Show count")
	for _, obj := range testData {
		show.AssertFound(t, &obj)
	}
}

func GetCloudletInfo(t *testing.T, ctx context.Context, api *CloudletInfoCommonApi, key *edgeproto.CloudletKey, out *edgeproto.CloudletInfo) bool {
	var err error

	show := ShowCloudletInfo{}
	show.Init()
	filter := edgeproto.CloudletInfo{}
	filter.SetKey(key)
	err = api.ShowCloudletInfo(ctx, &filter, &show)
	require.Nil(t, err, "show data")
	obj, found := show.Data[key.GetKeyString()]
	if found {
		*out = obj
	}
	return found
}

func FindCloudletInfoData(key *edgeproto.CloudletKey, testData []edgeproto.CloudletInfo) (*edgeproto.CloudletInfo, bool) {
	for ii, _ := range testData {
		if testData[ii].GetKey().Matches(key) {
			return &testData[ii], true
		}
	}
	return nil, false
}

func (r *Run) GPUDriverApi(data *[]edgeproto.GPUDriver, dataMap interface{}, dataOut interface{}) {
	log.DebugLog(log.DebugLevelApi, "API for GPUDriver", "mode", r.Mode)
	if r.Mode == "show" {
		obj := &edgeproto.GPUDriver{}
		out, err := r.client.ShowGPUDriver(r.ctx, obj)
		if err != nil {
			r.logErr("GPUDriverApi", err)
		} else {
			outp, ok := dataOut.(*[]edgeproto.GPUDriver)
			if !ok {
				panic(fmt.Sprintf("RunGPUDriverApi expected dataOut type *[]edgeproto.GPUDriver, but was %T", dataOut))
			}
			*outp = append(*outp, out...)
		}
		return
	}
	for ii, objD := range *data {
		obj := &objD
		switch r.Mode {
		case "create":
			out, err := r.client.CreateGPUDriver(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("GPUDriverApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[][]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunGPUDriverApi expected dataOut type *[][]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, out)
			}
		case "delete":
			out, err := r.client.DeleteGPUDriver(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("GPUDriverApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[][]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunGPUDriverApi expected dataOut type *[][]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, out)
			}
		case "update":
			// set specified fields
			objMap, err := cli.GetGenericObjFromList(dataMap, ii)
			if err != nil {
				log.DebugLog(log.DebugLevelApi, "bad dataMap for GPUDriver", "err", err)
				*r.Rc = false
				return
			}
			yamlData := cli.MapData{
				Namespace: cli.YamlNamespace,
				Data:      objMap,
			}
			obj.Fields = cli.GetSpecifiedFields(&yamlData, obj)

			out, err := r.client.UpdateGPUDriver(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("GPUDriverApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[][]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunGPUDriverApi expected dataOut type *[][]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, out)
			}
		case "showfiltered":
			out, err := r.client.ShowGPUDriver(r.ctx, obj)
			if err != nil {
				r.logErr(fmt.Sprintf("GPUDriverApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.GPUDriver)
				if !ok {
					panic(fmt.Sprintf("RunGPUDriverApi expected dataOut type *[]edgeproto.GPUDriver, but was %T", dataOut))
				}
				*outp = append(*outp, out...)
			}
		}
	}
}

func (r *Run) GPUDriverApi_GPUDriverBuildMember(data *[]edgeproto.GPUDriverBuildMember, dataMap interface{}, dataOut interface{}) {
	log.DebugLog(log.DebugLevelApi, "API for GPUDriverBuildMember", "mode", r.Mode)
	for ii, objD := range *data {
		obj := &objD
		switch r.Mode {
		case "addgpudriverbuild":
			out, err := r.client.AddGPUDriverBuild(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("GPUDriverApi_GPUDriverBuildMember[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[][]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunGPUDriverApi_GPUDriverBuildMember expected dataOut type *[][]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, out)
			}
		case "removegpudriverbuild":
			out, err := r.client.RemoveGPUDriverBuild(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("GPUDriverApi_GPUDriverBuildMember[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[][]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunGPUDriverApi_GPUDriverBuildMember expected dataOut type *[][]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, out)
			}
		case "getgpudriverbuildurl":
			out, err := r.client.GetGPUDriverBuildURL(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("GPUDriverApi_GPUDriverBuildMember[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.GPUDriverBuildURL)
				if !ok {
					panic(fmt.Sprintf("RunGPUDriverApi_GPUDriverBuildMember expected dataOut type *[]edgeproto.GPUDriverBuildURL, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		}
	}
}

func (s *DummyServer) CreateGPUDriver(in *edgeproto.GPUDriver, server edgeproto.GPUDriverApi_CreateGPUDriverServer) error {
	var err error
	if true {
		for ii := 0; ii < s.ShowDummyCount; ii++ {
			server.Send(&edgeproto.Result{Message: "some message"})
		}
		if ch, ok := s.MidstreamFailChs["CreateGPUDriver"]; ok {
			// Wait until client receives the SendMsg, since they
			// are buffered and dropped once we return err here.
			select {
			case <-ch:
			case <-time.After(5 * time.Second):
			}
			return fmt.Errorf("midstream failure!")
		}
	}
	s.GPUDriverCache.Update(server.Context(), in, 0)
	return err
}

func (s *DummyServer) DeleteGPUDriver(in *edgeproto.GPUDriver, server edgeproto.GPUDriverApi_DeleteGPUDriverServer) error {
	var err error
	if true {
		for ii := 0; ii < s.ShowDummyCount; ii++ {
			server.Send(&edgeproto.Result{Message: "some message"})
		}
		if ch, ok := s.MidstreamFailChs["DeleteGPUDriver"]; ok {
			// Wait until client receives the SendMsg, since they
			// are buffered and dropped once we return err here.
			select {
			case <-ch:
			case <-time.After(5 * time.Second):
			}
			return fmt.Errorf("midstream failure!")
		}
	}
	s.GPUDriverCache.Delete(server.Context(), in, 0)
	return err
}

func (s *DummyServer) UpdateGPUDriver(in *edgeproto.GPUDriver, server edgeproto.GPUDriverApi_UpdateGPUDriverServer) error {
	var err error
	if true {
		for ii := 0; ii < s.ShowDummyCount; ii++ {
			server.Send(&edgeproto.Result{Message: "some message"})
		}
		if ch, ok := s.MidstreamFailChs["UpdateGPUDriver"]; ok {
			// Wait until client receives the SendMsg, since they
			// are buffered and dropped once we return err here.
			select {
			case <-ch:
			case <-time.After(5 * time.Second):
			}
			return fmt.Errorf("midstream failure!")
		}
	}
	s.GPUDriverCache.Update(server.Context(), in, 0)
	return err
}

func (s *DummyServer) ShowGPUDriver(in *edgeproto.GPUDriver, server edgeproto.GPUDriverApi_ShowGPUDriverServer) error {
	var err error
	obj := &edgeproto.GPUDriver{}
	if obj.Matches(in, edgeproto.MatchFilter()) {
		for ii := 0; ii < s.ShowDummyCount; ii++ {
			server.Send(&edgeproto.GPUDriver{})
		}
		if ch, ok := s.MidstreamFailChs["ShowGPUDriver"]; ok {
			// Wait until client receives the SendMsg, since they
			// are buffered and dropped once we return err here.
			select {
			case <-ch:
			case <-time.After(5 * time.Second):
			}
			return fmt.Errorf("midstream failure!")
		}
	}
	err = s.GPUDriverCache.Show(in, func(obj *edgeproto.GPUDriver) error {
		err := server.Send(obj)
		return err
	})
	return err
}

func (r *Run) CloudletApi(data *[]edgeproto.Cloudlet, dataMap interface{}, dataOut interface{}) {
	log.DebugLog(log.DebugLevelApi, "API for Cloudlet", "mode", r.Mode)
	if r.Mode == "show" {
		obj := &edgeproto.Cloudlet{}
		out, err := r.client.ShowCloudlet(r.ctx, obj)
		if err != nil {
			r.logErr("CloudletApi", err)
		} else {
			outp, ok := dataOut.(*[]edgeproto.Cloudlet)
			if !ok {
				panic(fmt.Sprintf("RunCloudletApi expected dataOut type *[]edgeproto.Cloudlet, but was %T", dataOut))
			}
			*outp = append(*outp, out...)
		}
		return
	}
	for ii, objD := range *data {
		obj := &objD
		switch r.Mode {
		case "create":
			out, err := r.client.CreateCloudlet(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("CloudletApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[][]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunCloudletApi expected dataOut type *[][]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, out)
			}
		case "delete":
			out, err := r.client.DeleteCloudlet(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("CloudletApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[][]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunCloudletApi expected dataOut type *[][]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, out)
			}
		case "update":
			// set specified fields
			objMap, err := cli.GetGenericObjFromList(dataMap, ii)
			if err != nil {
				log.DebugLog(log.DebugLevelApi, "bad dataMap for Cloudlet", "err", err)
				*r.Rc = false
				return
			}
			yamlData := cli.MapData{
				Namespace: cli.YamlNamespace,
				Data:      objMap,
			}
			obj.Fields = cli.GetSpecifiedFields(&yamlData, obj)

			out, err := r.client.UpdateCloudlet(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("CloudletApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[][]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunCloudletApi expected dataOut type *[][]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, out)
			}
		case "showfiltered":
			out, err := r.client.ShowCloudlet(r.ctx, obj)
			if err != nil {
				r.logErr(fmt.Sprintf("CloudletApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.Cloudlet)
				if !ok {
					panic(fmt.Sprintf("RunCloudletApi expected dataOut type *[]edgeproto.Cloudlet, but was %T", dataOut))
				}
				*outp = append(*outp, out...)
			}
		case "platformdeletecloudlet":
			out, err := r.client.PlatformDeleteCloudlet(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("CloudletApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[][]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunCloudletApi expected dataOut type *[][]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, out)
			}
		}
	}
}

func (r *Run) CloudletApi_CloudletKey(data *[]edgeproto.CloudletKey, dataMap interface{}, dataOut interface{}) {
	log.DebugLog(log.DebugLevelApi, "API for CloudletKey", "mode", r.Mode)
	for ii, objD := range *data {
		obj := &objD
		switch r.Mode {
		case "getcloudletmanifest":
			out, err := r.client.GetCloudletManifest(r.ctx, obj)
			if err != nil {
				r.logErr(fmt.Sprintf("CloudletApi_CloudletKey[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.CloudletManifest)
				if !ok {
					panic(fmt.Sprintf("RunCloudletApi_CloudletKey expected dataOut type *[]edgeproto.CloudletManifest, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		case "showflavorsforcloudlet":
			out, err := r.client.ShowFlavorsForCloudlet(r.ctx, obj)
			if err != nil {
				r.logErr(fmt.Sprintf("CloudletApi_CloudletKey[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[][]edgeproto.FlavorKey)
				if !ok {
					panic(fmt.Sprintf("RunCloudletApi_CloudletKey expected dataOut type *[][]edgeproto.FlavorKey, but was %T", dataOut))
				}
				*outp = append(*outp, out)
			}
		case "getorganizationsoncloudlet":
			out, err := r.client.GetOrganizationsOnCloudlet(r.ctx, obj)
			if err != nil {
				r.logErr(fmt.Sprintf("CloudletApi_CloudletKey[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[][]edgeproto.Organization)
				if !ok {
					panic(fmt.Sprintf("RunCloudletApi_CloudletKey expected dataOut type *[][]edgeproto.Organization, but was %T", dataOut))
				}
				*outp = append(*outp, out)
			}
		case "revokeaccesskey":
			out, err := r.client.RevokeAccessKey(r.ctx, obj)
			if err != nil {
				r.logErr(fmt.Sprintf("CloudletApi_CloudletKey[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunCloudletApi_CloudletKey expected dataOut type *[]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		case "generateaccesskey":
			out, err := r.client.GenerateAccessKey(r.ctx, obj)
			if err != nil {
				r.logErr(fmt.Sprintf("CloudletApi_CloudletKey[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunCloudletApi_CloudletKey expected dataOut type *[]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		}
	}
}

func (r *Run) CloudletApi_CloudletProps(data *[]edgeproto.CloudletProps, dataMap interface{}, dataOut interface{}) {
	log.DebugLog(log.DebugLevelApi, "API for CloudletProps", "mode", r.Mode)
	for ii, objD := range *data {
		obj := &objD
		switch r.Mode {
		case "get":
			out, err := r.client.GetCloudletProps(r.ctx, obj)
			if err != nil {
				r.logErr(fmt.Sprintf("CloudletApi_CloudletProps[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.CloudletProps)
				if !ok {
					panic(fmt.Sprintf("RunCloudletApi_CloudletProps expected dataOut type *[]edgeproto.CloudletProps, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		}
	}
}

func (r *Run) CloudletApi_CloudletResMap(data *[]edgeproto.CloudletResMap, dataMap interface{}, dataOut interface{}) {
	log.DebugLog(log.DebugLevelApi, "API for CloudletResMap", "mode", r.Mode)
	for ii, objD := range *data {
		obj := &objD
		switch r.Mode {
		case "addcloudletresmapping":
			out, err := r.client.AddCloudletResMapping(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("CloudletApi_CloudletResMap[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunCloudletApi_CloudletResMap expected dataOut type *[]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		case "removecloudletresmapping":
			out, err := r.client.RemoveCloudletResMapping(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("CloudletApi_CloudletResMap[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunCloudletApi_CloudletResMap expected dataOut type *[]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		}
	}
}

func (r *Run) CloudletApi_CloudletResourceQuotaProps(data *[]edgeproto.CloudletResourceQuotaProps, dataMap interface{}, dataOut interface{}) {
	log.DebugLog(log.DebugLevelApi, "API for CloudletResourceQuotaProps", "mode", r.Mode)
	for ii, objD := range *data {
		obj := &objD
		switch r.Mode {
		case "get":
			out, err := r.client.GetCloudletResourceQuotaProps(r.ctx, obj)
			if err != nil {
				r.logErr(fmt.Sprintf("CloudletApi_CloudletResourceQuotaProps[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.CloudletResourceQuotaProps)
				if !ok {
					panic(fmt.Sprintf("RunCloudletApi_CloudletResourceQuotaProps expected dataOut type *[]edgeproto.CloudletResourceQuotaProps, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		}
	}
}

func (r *Run) CloudletApi_CloudletResourceUsage(data *[]edgeproto.CloudletResourceUsage, dataMap interface{}, dataOut interface{}) {
	log.DebugLog(log.DebugLevelApi, "API for CloudletResourceUsage", "mode", r.Mode)
	for ii, objD := range *data {
		obj := &objD
		switch r.Mode {
		case "get":
			out, err := r.client.GetCloudletResourceUsage(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("CloudletApi_CloudletResourceUsage[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.CloudletResourceUsage)
				if !ok {
					panic(fmt.Sprintf("RunCloudletApi_CloudletResourceUsage expected dataOut type *[]edgeproto.CloudletResourceUsage, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		}
	}
}

func (r *Run) CloudletApi_FlavorMatch(data *[]edgeproto.FlavorMatch, dataMap interface{}, dataOut interface{}) {
	log.DebugLog(log.DebugLevelApi, "API for FlavorMatch", "mode", r.Mode)
	for ii, objD := range *data {
		obj := &objD
		switch r.Mode {
		case "find":
			out, err := r.client.FindFlavorMatch(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("CloudletApi_FlavorMatch[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.FlavorMatch)
				if !ok {
					panic(fmt.Sprintf("RunCloudletApi_FlavorMatch expected dataOut type *[]edgeproto.FlavorMatch, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		}
	}
}

func (s *DummyServer) CreateCloudlet(in *edgeproto.Cloudlet, server edgeproto.CloudletApi_CreateCloudletServer) error {
	var err error
	if true {
		for ii := 0; ii < s.ShowDummyCount; ii++ {
			server.Send(&edgeproto.Result{Message: "some message"})
		}
		if ch, ok := s.MidstreamFailChs["CreateCloudlet"]; ok {
			// Wait until client receives the SendMsg, since they
			// are buffered and dropped once we return err here.
			select {
			case <-ch:
			case <-time.After(5 * time.Second):
			}
			return fmt.Errorf("midstream failure!")
		}
	}
	s.CloudletCache.Update(server.Context(), in, 0)
	return err
}

func (s *DummyServer) DeleteCloudlet(in *edgeproto.Cloudlet, server edgeproto.CloudletApi_DeleteCloudletServer) error {
	var err error
	if true {
		for ii := 0; ii < s.ShowDummyCount; ii++ {
			server.Send(&edgeproto.Result{Message: "some message"})
		}
		if ch, ok := s.MidstreamFailChs["DeleteCloudlet"]; ok {
			// Wait until client receives the SendMsg, since they
			// are buffered and dropped once we return err here.
			select {
			case <-ch:
			case <-time.After(5 * time.Second):
			}
			return fmt.Errorf("midstream failure!")
		}
	}
	s.CloudletCache.Delete(server.Context(), in, 0)
	return err
}

func (s *DummyServer) UpdateCloudlet(in *edgeproto.Cloudlet, server edgeproto.CloudletApi_UpdateCloudletServer) error {
	var err error
	if true {
		for ii := 0; ii < s.ShowDummyCount; ii++ {
			server.Send(&edgeproto.Result{Message: "some message"})
		}
		if ch, ok := s.MidstreamFailChs["UpdateCloudlet"]; ok {
			// Wait until client receives the SendMsg, since they
			// are buffered and dropped once we return err here.
			select {
			case <-ch:
			case <-time.After(5 * time.Second):
			}
			return fmt.Errorf("midstream failure!")
		}
	}
	s.CloudletCache.Update(server.Context(), in, 0)
	return err
}

func (s *DummyServer) ShowCloudlet(in *edgeproto.Cloudlet, server edgeproto.CloudletApi_ShowCloudletServer) error {
	var err error
	obj := &edgeproto.Cloudlet{}
	if obj.Matches(in, edgeproto.MatchFilter()) {
		for ii := 0; ii < s.ShowDummyCount; ii++ {
			server.Send(&edgeproto.Cloudlet{})
		}
		if ch, ok := s.MidstreamFailChs["ShowCloudlet"]; ok {
			// Wait until client receives the SendMsg, since they
			// are buffered and dropped once we return err here.
			select {
			case <-ch:
			case <-time.After(5 * time.Second):
			}
			return fmt.Errorf("midstream failure!")
		}
	}
	err = s.CloudletCache.Show(in, func(obj *edgeproto.Cloudlet) error {
		err := server.Send(obj)
		return err
	})
	return err
}

func (s *DummyServer) PlatformDeleteCloudlet(in *edgeproto.Cloudlet, server edgeproto.CloudletApi_PlatformDeleteCloudletServer) error {
	var err error
	if true {
		for ii := 0; ii < s.ShowDummyCount; ii++ {
			server.Send(&edgeproto.Result{})
		}
		if ch, ok := s.MidstreamFailChs["PlatformDeleteCloudlet"]; ok {
			// Wait until client receives the SendMsg, since they
			// are buffered and dropped once we return err here.
			select {
			case <-ch:
			case <-time.After(5 * time.Second):
			}
			return fmt.Errorf("midstream failure!")
		}
	}
	return err
}

func (r *Run) CloudletInfoApi(data *[]edgeproto.CloudletInfo, dataMap interface{}, dataOut interface{}) {
	log.DebugLog(log.DebugLevelApi, "API for CloudletInfo", "mode", r.Mode)
	if r.Mode == "show" {
		obj := &edgeproto.CloudletInfo{}
		out, err := r.client.ShowCloudletInfo(r.ctx, obj)
		if err != nil {
			r.logErr("CloudletInfoApi", err)
		} else {
			outp, ok := dataOut.(*[]edgeproto.CloudletInfo)
			if !ok {
				panic(fmt.Sprintf("RunCloudletInfoApi expected dataOut type *[]edgeproto.CloudletInfo, but was %T", dataOut))
			}
			*outp = append(*outp, out...)
		}
		return
	}
	for ii, objD := range *data {
		obj := &objD
		switch r.Mode {
		case "showfiltered":
			out, err := r.client.ShowCloudletInfo(r.ctx, obj)
			if err != nil {
				r.logErr(fmt.Sprintf("CloudletInfoApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.CloudletInfo)
				if !ok {
					panic(fmt.Sprintf("RunCloudletInfoApi expected dataOut type *[]edgeproto.CloudletInfo, but was %T", dataOut))
				}
				*outp = append(*outp, out...)
			}
		case "inject":
			out, err := r.client.InjectCloudletInfo(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("CloudletInfoApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunCloudletInfoApi expected dataOut type *[]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		case "evict":
			out, err := r.client.EvictCloudletInfo(r.ctx, obj)
			if err != nil {
				err = ignoreExpectedErrors(r.Mode, obj.GetKey(), err)
				r.logErr(fmt.Sprintf("CloudletInfoApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.Result)
				if !ok {
					panic(fmt.Sprintf("RunCloudletInfoApi expected dataOut type *[]edgeproto.Result, but was %T", dataOut))
				}
				*outp = append(*outp, *out)
			}
		}
	}
}

func (s *DummyServer) ShowCloudletInfo(in *edgeproto.CloudletInfo, server edgeproto.CloudletInfoApi_ShowCloudletInfoServer) error {
	var err error
	obj := &edgeproto.CloudletInfo{}
	if obj.Matches(in, edgeproto.MatchFilter()) {
		for ii := 0; ii < s.ShowDummyCount; ii++ {
			server.Send(&edgeproto.CloudletInfo{})
		}
		if ch, ok := s.MidstreamFailChs["ShowCloudletInfo"]; ok {
			// Wait until client receives the SendMsg, since they
			// are buffered and dropped once we return err here.
			select {
			case <-ch:
			case <-time.After(5 * time.Second):
			}
			return fmt.Errorf("midstream failure!")
		}
	}
	err = s.CloudletInfoCache.Show(in, func(obj *edgeproto.CloudletInfo) error {
		err := server.Send(obj)
		return err
	})
	return err
}

func (s *DummyServer) InjectCloudletInfo(ctx context.Context, in *edgeproto.CloudletInfo) (*edgeproto.Result, error) {
	if s.CudNoop {
		return &edgeproto.Result{}, nil
	}
	return &edgeproto.Result{}, nil
}

func (s *DummyServer) EvictCloudletInfo(ctx context.Context, in *edgeproto.CloudletInfo) (*edgeproto.Result, error) {
	if s.CudNoop {
		return &edgeproto.Result{}, nil
	}
	return &edgeproto.Result{}, nil
}

func (r *Run) CloudletMetricsApi(data *[]edgeproto.CloudletMetrics, dataMap interface{}, dataOut interface{}) {
	log.DebugLog(log.DebugLevelApi, "API for CloudletMetrics", "mode", r.Mode)
	if r.Mode == "show" {
		obj := &edgeproto.CloudletMetrics{}
		out, err := r.client.ShowCloudletMetrics(r.ctx, obj)
		if err != nil {
			r.logErr("CloudletMetricsApi", err)
		} else {
			outp, ok := dataOut.(*[]edgeproto.CloudletMetrics)
			if !ok {
				panic(fmt.Sprintf("RunCloudletMetricsApi expected dataOut type *[]edgeproto.CloudletMetrics, but was %T", dataOut))
			}
			*outp = append(*outp, out...)
		}
		return
	}
	for ii, objD := range *data {
		obj := &objD
		switch r.Mode {
		case "showfiltered":
			out, err := r.client.ShowCloudletMetrics(r.ctx, obj)
			if err != nil {
				r.logErr(fmt.Sprintf("CloudletMetricsApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.CloudletMetrics)
				if !ok {
					panic(fmt.Sprintf("RunCloudletMetricsApi expected dataOut type *[]edgeproto.CloudletMetrics, but was %T", dataOut))
				}
				*outp = append(*outp, out...)
			}
		}
	}
}

func (s *ApiClient) CreateGPUDriver(ctx context.Context, in *edgeproto.GPUDriver) ([]edgeproto.Result, error) {
	api := edgeproto.NewGPUDriverApiClient(s.Conn)
	stream, err := api.CreateGPUDriver(ctx, in)
	if err != nil {
		return nil, err
	}
	return ResultReadStream(stream)
}

func (s *CliClient) CreateGPUDriver(ctx context.Context, in *edgeproto.GPUDriver) ([]edgeproto.Result, error) {
	output := []edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "CreateGPUDriver")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

func (s *ApiClient) DeleteGPUDriver(ctx context.Context, in *edgeproto.GPUDriver) ([]edgeproto.Result, error) {
	api := edgeproto.NewGPUDriverApiClient(s.Conn)
	stream, err := api.DeleteGPUDriver(ctx, in)
	if err != nil {
		return nil, err
	}
	return ResultReadStream(stream)
}

func (s *CliClient) DeleteGPUDriver(ctx context.Context, in *edgeproto.GPUDriver) ([]edgeproto.Result, error) {
	output := []edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "DeleteGPUDriver")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

func (s *ApiClient) UpdateGPUDriver(ctx context.Context, in *edgeproto.GPUDriver) ([]edgeproto.Result, error) {
	api := edgeproto.NewGPUDriverApiClient(s.Conn)
	stream, err := api.UpdateGPUDriver(ctx, in)
	if err != nil {
		return nil, err
	}
	return ResultReadStream(stream)
}

func (s *CliClient) UpdateGPUDriver(ctx context.Context, in *edgeproto.GPUDriver) ([]edgeproto.Result, error) {
	output := []edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "UpdateGPUDriver")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

type GPUDriverStream interface {
	Recv() (*edgeproto.GPUDriver, error)
}

func GPUDriverReadStream(stream GPUDriverStream) ([]edgeproto.GPUDriver, error) {
	output := []edgeproto.GPUDriver{}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			return output, fmt.Errorf("read GPUDriver stream failed, %v", err)
		}
		output = append(output, *obj)
	}
	return output, nil
}

func (s *ApiClient) ShowGPUDriver(ctx context.Context, in *edgeproto.GPUDriver) ([]edgeproto.GPUDriver, error) {
	api := edgeproto.NewGPUDriverApiClient(s.Conn)
	stream, err := api.ShowGPUDriver(ctx, in)
	if err != nil {
		return nil, err
	}
	return GPUDriverReadStream(stream)
}

func (s *CliClient) ShowGPUDriver(ctx context.Context, in *edgeproto.GPUDriver) ([]edgeproto.GPUDriver, error) {
	output := []edgeproto.GPUDriver{}
	args := append(s.BaseArgs, "controller", "ShowGPUDriver")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

func (s *ApiClient) AddGPUDriverBuild(ctx context.Context, in *edgeproto.GPUDriverBuildMember) ([]edgeproto.Result, error) {
	api := edgeproto.NewGPUDriverApiClient(s.Conn)
	stream, err := api.AddGPUDriverBuild(ctx, in)
	if err != nil {
		return nil, err
	}
	return ResultReadStream(stream)
}

func (s *CliClient) AddGPUDriverBuild(ctx context.Context, in *edgeproto.GPUDriverBuildMember) ([]edgeproto.Result, error) {
	output := []edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "AddGPUDriverBuild")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

func (s *ApiClient) RemoveGPUDriverBuild(ctx context.Context, in *edgeproto.GPUDriverBuildMember) ([]edgeproto.Result, error) {
	api := edgeproto.NewGPUDriverApiClient(s.Conn)
	stream, err := api.RemoveGPUDriverBuild(ctx, in)
	if err != nil {
		return nil, err
	}
	return ResultReadStream(stream)
}

func (s *CliClient) RemoveGPUDriverBuild(ctx context.Context, in *edgeproto.GPUDriverBuildMember) ([]edgeproto.Result, error) {
	output := []edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "RemoveGPUDriverBuild")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

func (s *ApiClient) GetGPUDriverBuildURL(ctx context.Context, in *edgeproto.GPUDriverBuildMember) (*edgeproto.GPUDriverBuildURL, error) {
	api := edgeproto.NewGPUDriverApiClient(s.Conn)
	return api.GetGPUDriverBuildURL(ctx, in)
}

func (s *CliClient) GetGPUDriverBuildURL(ctx context.Context, in *edgeproto.GPUDriverBuildMember) (*edgeproto.GPUDriverBuildURL, error) {
	out := edgeproto.GPUDriverBuildURL{}
	args := append(s.BaseArgs, "controller", "GetGPUDriverBuildURL")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

type GPUDriverApiClient interface {
	CreateGPUDriver(ctx context.Context, in *edgeproto.GPUDriver) ([]edgeproto.Result, error)
	DeleteGPUDriver(ctx context.Context, in *edgeproto.GPUDriver) ([]edgeproto.Result, error)
	UpdateGPUDriver(ctx context.Context, in *edgeproto.GPUDriver) ([]edgeproto.Result, error)
	ShowGPUDriver(ctx context.Context, in *edgeproto.GPUDriver) ([]edgeproto.GPUDriver, error)
	AddGPUDriverBuild(ctx context.Context, in *edgeproto.GPUDriverBuildMember) ([]edgeproto.Result, error)
	RemoveGPUDriverBuild(ctx context.Context, in *edgeproto.GPUDriverBuildMember) ([]edgeproto.Result, error)
	GetGPUDriverBuildURL(ctx context.Context, in *edgeproto.GPUDriverBuildMember) (*edgeproto.GPUDriverBuildURL, error)
}

func (s *ApiClient) CreateCloudlet(ctx context.Context, in *edgeproto.Cloudlet) ([]edgeproto.Result, error) {
	api := edgeproto.NewCloudletApiClient(s.Conn)
	stream, err := api.CreateCloudlet(ctx, in)
	if err != nil {
		return nil, err
	}
	return ResultReadStream(stream)
}

func (s *CliClient) CreateCloudlet(ctx context.Context, in *edgeproto.Cloudlet) ([]edgeproto.Result, error) {
	output := []edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "CreateCloudlet")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

func (s *ApiClient) DeleteCloudlet(ctx context.Context, in *edgeproto.Cloudlet) ([]edgeproto.Result, error) {
	api := edgeproto.NewCloudletApiClient(s.Conn)
	stream, err := api.DeleteCloudlet(ctx, in)
	if err != nil {
		return nil, err
	}
	return ResultReadStream(stream)
}

func (s *CliClient) DeleteCloudlet(ctx context.Context, in *edgeproto.Cloudlet) ([]edgeproto.Result, error) {
	output := []edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "DeleteCloudlet")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

func (s *ApiClient) UpdateCloudlet(ctx context.Context, in *edgeproto.Cloudlet) ([]edgeproto.Result, error) {
	api := edgeproto.NewCloudletApiClient(s.Conn)
	stream, err := api.UpdateCloudlet(ctx, in)
	if err != nil {
		return nil, err
	}
	return ResultReadStream(stream)
}

func (s *CliClient) UpdateCloudlet(ctx context.Context, in *edgeproto.Cloudlet) ([]edgeproto.Result, error) {
	output := []edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "UpdateCloudlet")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

type CloudletStream interface {
	Recv() (*edgeproto.Cloudlet, error)
}

func CloudletReadStream(stream CloudletStream) ([]edgeproto.Cloudlet, error) {
	output := []edgeproto.Cloudlet{}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			return output, fmt.Errorf("read Cloudlet stream failed, %v", err)
		}
		output = append(output, *obj)
	}
	return output, nil
}

func (s *ApiClient) ShowCloudlet(ctx context.Context, in *edgeproto.Cloudlet) ([]edgeproto.Cloudlet, error) {
	api := edgeproto.NewCloudletApiClient(s.Conn)
	stream, err := api.ShowCloudlet(ctx, in)
	if err != nil {
		return nil, err
	}
	return CloudletReadStream(stream)
}

func (s *CliClient) ShowCloudlet(ctx context.Context, in *edgeproto.Cloudlet) ([]edgeproto.Cloudlet, error) {
	output := []edgeproto.Cloudlet{}
	args := append(s.BaseArgs, "controller", "ShowCloudlet")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

func (s *ApiClient) GetCloudletManifest(ctx context.Context, in *edgeproto.CloudletKey) (*edgeproto.CloudletManifest, error) {
	api := edgeproto.NewCloudletApiClient(s.Conn)
	return api.GetCloudletManifest(ctx, in)
}

func (s *CliClient) GetCloudletManifest(ctx context.Context, in *edgeproto.CloudletKey) (*edgeproto.CloudletManifest, error) {
	out := edgeproto.CloudletManifest{}
	args := append(s.BaseArgs, "controller", "GetCloudletManifest")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

func (s *ApiClient) GetCloudletProps(ctx context.Context, in *edgeproto.CloudletProps) (*edgeproto.CloudletProps, error) {
	api := edgeproto.NewCloudletApiClient(s.Conn)
	return api.GetCloudletProps(ctx, in)
}

func (s *CliClient) GetCloudletProps(ctx context.Context, in *edgeproto.CloudletProps) (*edgeproto.CloudletProps, error) {
	out := edgeproto.CloudletProps{}
	args := append(s.BaseArgs, "controller", "GetCloudletProps")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

func (s *ApiClient) GetCloudletResourceQuotaProps(ctx context.Context, in *edgeproto.CloudletResourceQuotaProps) (*edgeproto.CloudletResourceQuotaProps, error) {
	api := edgeproto.NewCloudletApiClient(s.Conn)
	return api.GetCloudletResourceQuotaProps(ctx, in)
}

func (s *CliClient) GetCloudletResourceQuotaProps(ctx context.Context, in *edgeproto.CloudletResourceQuotaProps) (*edgeproto.CloudletResourceQuotaProps, error) {
	out := edgeproto.CloudletResourceQuotaProps{}
	args := append(s.BaseArgs, "controller", "GetCloudletResourceQuotaProps")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

func (s *ApiClient) GetCloudletResourceUsage(ctx context.Context, in *edgeproto.CloudletResourceUsage) (*edgeproto.CloudletResourceUsage, error) {
	api := edgeproto.NewCloudletApiClient(s.Conn)
	return api.GetCloudletResourceUsage(ctx, in)
}

func (s *CliClient) GetCloudletResourceUsage(ctx context.Context, in *edgeproto.CloudletResourceUsage) (*edgeproto.CloudletResourceUsage, error) {
	out := edgeproto.CloudletResourceUsage{}
	args := append(s.BaseArgs, "controller", "GetCloudletResourceUsage")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

func (s *ApiClient) AddCloudletResMapping(ctx context.Context, in *edgeproto.CloudletResMap) (*edgeproto.Result, error) {
	api := edgeproto.NewCloudletApiClient(s.Conn)
	return api.AddCloudletResMapping(ctx, in)
}

func (s *CliClient) AddCloudletResMapping(ctx context.Context, in *edgeproto.CloudletResMap) (*edgeproto.Result, error) {
	out := edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "AddCloudletResMapping")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

func (s *ApiClient) RemoveCloudletResMapping(ctx context.Context, in *edgeproto.CloudletResMap) (*edgeproto.Result, error) {
	api := edgeproto.NewCloudletApiClient(s.Conn)
	return api.RemoveCloudletResMapping(ctx, in)
}

func (s *CliClient) RemoveCloudletResMapping(ctx context.Context, in *edgeproto.CloudletResMap) (*edgeproto.Result, error) {
	out := edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "RemoveCloudletResMapping")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

func (s *ApiClient) FindFlavorMatch(ctx context.Context, in *edgeproto.FlavorMatch) (*edgeproto.FlavorMatch, error) {
	api := edgeproto.NewCloudletApiClient(s.Conn)
	return api.FindFlavorMatch(ctx, in)
}

func (s *CliClient) FindFlavorMatch(ctx context.Context, in *edgeproto.FlavorMatch) (*edgeproto.FlavorMatch, error) {
	out := edgeproto.FlavorMatch{}
	args := append(s.BaseArgs, "controller", "FindFlavorMatch")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

type FlavorKeyStream interface {
	Recv() (*edgeproto.FlavorKey, error)
}

func FlavorKeyReadStream(stream FlavorKeyStream) ([]edgeproto.FlavorKey, error) {
	output := []edgeproto.FlavorKey{}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			return output, fmt.Errorf("read FlavorKey stream failed, %v", err)
		}
		output = append(output, *obj)
	}
	return output, nil
}

func (s *ApiClient) ShowFlavorsForCloudlet(ctx context.Context, in *edgeproto.CloudletKey) ([]edgeproto.FlavorKey, error) {
	api := edgeproto.NewCloudletApiClient(s.Conn)
	stream, err := api.ShowFlavorsForCloudlet(ctx, in)
	if err != nil {
		return nil, err
	}
	return FlavorKeyReadStream(stream)
}

func (s *CliClient) ShowFlavorsForCloudlet(ctx context.Context, in *edgeproto.CloudletKey) ([]edgeproto.FlavorKey, error) {
	output := []edgeproto.FlavorKey{}
	args := append(s.BaseArgs, "controller", "ShowFlavorsForCloudlet")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

type OrganizationStream interface {
	Recv() (*edgeproto.Organization, error)
}

func OrganizationReadStream(stream OrganizationStream) ([]edgeproto.Organization, error) {
	output := []edgeproto.Organization{}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			return output, fmt.Errorf("read Organization stream failed, %v", err)
		}
		output = append(output, *obj)
	}
	return output, nil
}

func (s *ApiClient) GetOrganizationsOnCloudlet(ctx context.Context, in *edgeproto.CloudletKey) ([]edgeproto.Organization, error) {
	api := edgeproto.NewCloudletApiClient(s.Conn)
	stream, err := api.GetOrganizationsOnCloudlet(ctx, in)
	if err != nil {
		return nil, err
	}
	return OrganizationReadStream(stream)
}

func (s *CliClient) GetOrganizationsOnCloudlet(ctx context.Context, in *edgeproto.CloudletKey) ([]edgeproto.Organization, error) {
	output := []edgeproto.Organization{}
	args := append(s.BaseArgs, "controller", "GetOrganizationsOnCloudlet")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

func (s *ApiClient) RevokeAccessKey(ctx context.Context, in *edgeproto.CloudletKey) (*edgeproto.Result, error) {
	api := edgeproto.NewCloudletApiClient(s.Conn)
	return api.RevokeAccessKey(ctx, in)
}

func (s *CliClient) RevokeAccessKey(ctx context.Context, in *edgeproto.CloudletKey) (*edgeproto.Result, error) {
	out := edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "RevokeAccessKey")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

func (s *ApiClient) GenerateAccessKey(ctx context.Context, in *edgeproto.CloudletKey) (*edgeproto.Result, error) {
	api := edgeproto.NewCloudletApiClient(s.Conn)
	return api.GenerateAccessKey(ctx, in)
}

func (s *CliClient) GenerateAccessKey(ctx context.Context, in *edgeproto.CloudletKey) (*edgeproto.Result, error) {
	out := edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "GenerateAccessKey")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

func (s *ApiClient) PlatformDeleteCloudlet(ctx context.Context, in *edgeproto.Cloudlet) ([]edgeproto.Result, error) {
	api := edgeproto.NewCloudletApiClient(s.Conn)
	stream, err := api.PlatformDeleteCloudlet(ctx, in)
	if err != nil {
		return nil, err
	}
	return ResultReadStream(stream)
}

func (s *CliClient) PlatformDeleteCloudlet(ctx context.Context, in *edgeproto.Cloudlet) ([]edgeproto.Result, error) {
	output := []edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "PlatformDeleteCloudlet")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

type CloudletApiClient interface {
	CreateCloudlet(ctx context.Context, in *edgeproto.Cloudlet) ([]edgeproto.Result, error)
	DeleteCloudlet(ctx context.Context, in *edgeproto.Cloudlet) ([]edgeproto.Result, error)
	UpdateCloudlet(ctx context.Context, in *edgeproto.Cloudlet) ([]edgeproto.Result, error)
	ShowCloudlet(ctx context.Context, in *edgeproto.Cloudlet) ([]edgeproto.Cloudlet, error)
	GetCloudletManifest(ctx context.Context, in *edgeproto.CloudletKey) (*edgeproto.CloudletManifest, error)
	GetCloudletProps(ctx context.Context, in *edgeproto.CloudletProps) (*edgeproto.CloudletProps, error)
	GetCloudletResourceQuotaProps(ctx context.Context, in *edgeproto.CloudletResourceQuotaProps) (*edgeproto.CloudletResourceQuotaProps, error)
	GetCloudletResourceUsage(ctx context.Context, in *edgeproto.CloudletResourceUsage) (*edgeproto.CloudletResourceUsage, error)
	AddCloudletResMapping(ctx context.Context, in *edgeproto.CloudletResMap) (*edgeproto.Result, error)
	RemoveCloudletResMapping(ctx context.Context, in *edgeproto.CloudletResMap) (*edgeproto.Result, error)
	FindFlavorMatch(ctx context.Context, in *edgeproto.FlavorMatch) (*edgeproto.FlavorMatch, error)
	ShowFlavorsForCloudlet(ctx context.Context, in *edgeproto.CloudletKey) ([]edgeproto.FlavorKey, error)
	GetOrganizationsOnCloudlet(ctx context.Context, in *edgeproto.CloudletKey) ([]edgeproto.Organization, error)
	RevokeAccessKey(ctx context.Context, in *edgeproto.CloudletKey) (*edgeproto.Result, error)
	GenerateAccessKey(ctx context.Context, in *edgeproto.CloudletKey) (*edgeproto.Result, error)
	PlatformDeleteCloudlet(ctx context.Context, in *edgeproto.Cloudlet) ([]edgeproto.Result, error)
}

type CloudletInfoStream interface {
	Recv() (*edgeproto.CloudletInfo, error)
}

func CloudletInfoReadStream(stream CloudletInfoStream) ([]edgeproto.CloudletInfo, error) {
	output := []edgeproto.CloudletInfo{}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			return output, fmt.Errorf("read CloudletInfo stream failed, %v", err)
		}
		output = append(output, *obj)
	}
	return output, nil
}

func (s *ApiClient) ShowCloudletInfo(ctx context.Context, in *edgeproto.CloudletInfo) ([]edgeproto.CloudletInfo, error) {
	api := edgeproto.NewCloudletInfoApiClient(s.Conn)
	stream, err := api.ShowCloudletInfo(ctx, in)
	if err != nil {
		return nil, err
	}
	return CloudletInfoReadStream(stream)
}

func (s *CliClient) ShowCloudletInfo(ctx context.Context, in *edgeproto.CloudletInfo) ([]edgeproto.CloudletInfo, error) {
	output := []edgeproto.CloudletInfo{}
	args := append(s.BaseArgs, "controller", "ShowCloudletInfo")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

func (s *ApiClient) InjectCloudletInfo(ctx context.Context, in *edgeproto.CloudletInfo) (*edgeproto.Result, error) {
	api := edgeproto.NewCloudletInfoApiClient(s.Conn)
	return api.InjectCloudletInfo(ctx, in)
}

func (s *CliClient) InjectCloudletInfo(ctx context.Context, in *edgeproto.CloudletInfo) (*edgeproto.Result, error) {
	out := edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "InjectCloudletInfo")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

func (s *ApiClient) EvictCloudletInfo(ctx context.Context, in *edgeproto.CloudletInfo) (*edgeproto.Result, error) {
	api := edgeproto.NewCloudletInfoApiClient(s.Conn)
	return api.EvictCloudletInfo(ctx, in)
}

func (s *CliClient) EvictCloudletInfo(ctx context.Context, in *edgeproto.CloudletInfo) (*edgeproto.Result, error) {
	out := edgeproto.Result{}
	args := append(s.BaseArgs, "controller", "EvictCloudletInfo")
	err := wrapper.RunEdgectlObjs(args, in, &out, s.RunOps...)
	return &out, err
}

type CloudletInfoApiClient interface {
	ShowCloudletInfo(ctx context.Context, in *edgeproto.CloudletInfo) ([]edgeproto.CloudletInfo, error)
	InjectCloudletInfo(ctx context.Context, in *edgeproto.CloudletInfo) (*edgeproto.Result, error)
	EvictCloudletInfo(ctx context.Context, in *edgeproto.CloudletInfo) (*edgeproto.Result, error)
}

type CloudletMetricsStream interface {
	Recv() (*edgeproto.CloudletMetrics, error)
}

func CloudletMetricsReadStream(stream CloudletMetricsStream) ([]edgeproto.CloudletMetrics, error) {
	output := []edgeproto.CloudletMetrics{}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			return output, fmt.Errorf("read CloudletMetrics stream failed, %v", err)
		}
		output = append(output, *obj)
	}
	return output, nil
}

func (s *ApiClient) ShowCloudletMetrics(ctx context.Context, in *edgeproto.CloudletMetrics) ([]edgeproto.CloudletMetrics, error) {
	api := edgeproto.NewCloudletMetricsApiClient(s.Conn)
	stream, err := api.ShowCloudletMetrics(ctx, in)
	if err != nil {
		return nil, err
	}
	return CloudletMetricsReadStream(stream)
}

func (s *CliClient) ShowCloudletMetrics(ctx context.Context, in *edgeproto.CloudletMetrics) ([]edgeproto.CloudletMetrics, error) {
	output := []edgeproto.CloudletMetrics{}
	args := append(s.BaseArgs, "controller", "ShowCloudletMetrics")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

type CloudletMetricsApiClient interface {
	ShowCloudletMetrics(ctx context.Context, in *edgeproto.CloudletMetrics) ([]edgeproto.CloudletMetrics, error)
}
