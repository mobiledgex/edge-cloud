// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cloudlet.proto

package testutil

import "google.golang.org/grpc"
import "github.com/mobiledgex/edge-cloud/edgeproto"
import "io"
import "testing"
import "context"
import "time"
import "github.com/stretchr/testify/require"
import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/mobiledgex/edge-cloud/protogen"
import _ "github.com/mobiledgex/edge-cloud/protoc-gen-cmd/protocmd"
import _ "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto"
import _ "github.com/gogo/protobuf/gogoproto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Auto-generated code: DO NOT EDIT

type ShowPlatform struct {
	Data map[string]edgeproto.Platform
	grpc.ServerStream
}

func (x *ShowPlatform) Init() {
	x.Data = make(map[string]edgeproto.Platform)
}

func (x *ShowPlatform) Send(m *edgeproto.Platform) error {
	x.Data[m.Key.GetKeyString()] = *m
	return nil
}

type CudStreamoutPlatform struct {
	grpc.ServerStream
}

func (x *CudStreamoutPlatform) Send(res *edgeproto.Result) error {
	fmt.Println(res)
	return nil
}
func (x *CudStreamoutPlatform) Context() context.Context {
	return context.TODO()
}

type PlatformStream interface {
	Recv() (*edgeproto.Result, error)
}

func PlatformReadResultStream(stream PlatformStream, err error) error {
	if err != nil {
		return err
	}
	for {
		res, err := stream.Recv()
		if err == io.EOF {
			return nil
		}
		if err != nil {
			return err
		}
		fmt.Println(res)
	}
}

func (x *ShowPlatform) ReadStream(stream edgeproto.PlatformApi_ShowPlatformClient, err error) {
	x.Data = make(map[string]edgeproto.Platform)
	if err != nil {
		return
	}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			break
		}
		x.Data[obj.Key.GetKeyString()] = *obj
	}
}

func (x *ShowPlatform) CheckFound(obj *edgeproto.Platform) bool {
	_, found := x.Data[obj.Key.GetKeyString()]
	return found
}

func (x *ShowPlatform) AssertFound(t *testing.T, obj *edgeproto.Platform) {
	check, found := x.Data[obj.Key.GetKeyString()]
	require.True(t, found, "find Platform %s", obj.Key.GetKeyString())
	if found && !check.Matches(obj, edgeproto.MatchIgnoreBackend(), edgeproto.MatchSortArrayedKeys()) {
		require.Equal(t, *obj, check, "Platform are equal")
	}
	if found {
		// remove in case there are dups in the list, so the
		// same object cannot be used again
		delete(x.Data, obj.Key.GetKeyString())
	}
}

func (x *ShowPlatform) AssertNotFound(t *testing.T, obj *edgeproto.Platform) {
	_, found := x.Data[obj.Key.GetKeyString()]
	require.False(t, found, "do not find Platform %s", obj.Key.GetKeyString())
}

func WaitAssertFoundPlatform(t *testing.T, api edgeproto.PlatformApiClient, obj *edgeproto.Platform, count int, retry time.Duration) {
	show := ShowPlatform{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowPlatform(ctx, obj)
		show.ReadStream(stream, err)
		cancel()
		if show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertFound(t, obj)
}

func WaitAssertNotFoundPlatform(t *testing.T, api edgeproto.PlatformApiClient, obj *edgeproto.Platform, count int, retry time.Duration) {
	show := ShowPlatform{}
	filterNone := edgeproto.Platform{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowPlatform(ctx, &filterNone)
		show.ReadStream(stream, err)
		cancel()
		if !show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertNotFound(t, obj)
}

// Wrap the api with a common interface
type PlatformCommonApi struct {
	internal_api edgeproto.PlatformApiServer
	client_api   edgeproto.PlatformApiClient
}

func (x *PlatformCommonApi) CreatePlatform(ctx context.Context, in *edgeproto.Platform) (*edgeproto.Result, error) {
	copy := &edgeproto.Platform{}
	*copy = *in
	if x.internal_api != nil {
		err := x.internal_api.CreatePlatform(copy, &CudStreamoutPlatform{})
		return &edgeproto.Result{}, err
	} else {
		stream, err := x.client_api.CreatePlatform(ctx, copy)
		err = PlatformReadResultStream(stream, err)
		return &edgeproto.Result{}, err
	}
}

func (x *PlatformCommonApi) UpdatePlatform(ctx context.Context, in *edgeproto.Platform) (*edgeproto.Result, error) {
	copy := &edgeproto.Platform{}
	*copy = *in
	if x.internal_api != nil {
		err := x.internal_api.UpdatePlatform(copy, &CudStreamoutPlatform{})
		return &edgeproto.Result{}, err
	} else {
		stream, err := x.client_api.UpdatePlatform(ctx, copy)
		err = PlatformReadResultStream(stream, err)
		return &edgeproto.Result{}, err
	}
}

func (x *PlatformCommonApi) DeletePlatform(ctx context.Context, in *edgeproto.Platform) (*edgeproto.Result, error) {
	copy := &edgeproto.Platform{}
	*copy = *in
	if x.internal_api != nil {
		err := x.internal_api.DeletePlatform(copy, &CudStreamoutPlatform{})
		return &edgeproto.Result{}, err
	} else {
		stream, err := x.client_api.DeletePlatform(ctx, copy)
		err = PlatformReadResultStream(stream, err)
		return &edgeproto.Result{}, err
	}
}

func (x *PlatformCommonApi) ShowPlatform(ctx context.Context, filter *edgeproto.Platform, showData *ShowPlatform) error {
	if x.internal_api != nil {
		return x.internal_api.ShowPlatform(filter, showData)
	} else {
		stream, err := x.client_api.ShowPlatform(ctx, filter)
		showData.ReadStream(stream, err)
		return err
	}
}

func NewInternalPlatformApi(api edgeproto.PlatformApiServer) *PlatformCommonApi {
	apiWrap := PlatformCommonApi{}
	apiWrap.internal_api = api
	return &apiWrap
}

func NewClientPlatformApi(api edgeproto.PlatformApiClient) *PlatformCommonApi {
	apiWrap := PlatformCommonApi{}
	apiWrap.client_api = api
	return &apiWrap
}

func InternalPlatformTest(t *testing.T, test string, api edgeproto.PlatformApiServer, testData []edgeproto.Platform) {
	switch test {
	case "cud":
		basicPlatformCudTest(t, NewInternalPlatformApi(api), testData)
	case "show":
		basicPlatformShowTest(t, NewInternalPlatformApi(api), testData)
	}
}

func ClientPlatformTest(t *testing.T, test string, api edgeproto.PlatformApiClient, testData []edgeproto.Platform) {
	switch test {
	case "cud":
		basicPlatformCudTest(t, NewClientPlatformApi(api), testData)
	case "show":
		basicPlatformShowTest(t, NewClientPlatformApi(api), testData)
	}
}

func basicPlatformShowTest(t *testing.T, api *PlatformCommonApi, testData []edgeproto.Platform) {
	var err error
	ctx := context.TODO()

	show := ShowPlatform{}
	show.Init()
	filterNone := edgeproto.Platform{}
	err = api.ShowPlatform(ctx, &filterNone, &show)
	require.Nil(t, err, "show data")
	require.Equal(t, len(testData), len(show.Data), "Show count")
	for _, obj := range testData {
		show.AssertFound(t, &obj)
	}
}

func GetPlatform(t *testing.T, api *PlatformCommonApi, key *edgeproto.PlatformKey, out *edgeproto.Platform) bool {
	var err error
	ctx := context.TODO()

	show := ShowPlatform{}
	show.Init()
	filter := edgeproto.Platform{}
	filter.Key = *key
	err = api.ShowPlatform(ctx, &filter, &show)
	require.Nil(t, err, "show data")
	obj, found := show.Data[key.GetKeyString()]
	if found {
		*out = obj
	}
	return found
}

func basicPlatformCudTest(t *testing.T, api *PlatformCommonApi, testData []edgeproto.Platform) {
	var err error
	ctx := context.TODO()

	if len(testData) < 3 {
		require.True(t, false, "Need at least 3 test data objects")
		return
	}

	// test create
	createPlatformData(t, api, testData)

	// test duplicate create - should fail
	_, err = api.CreatePlatform(ctx, &testData[0])
	require.NotNil(t, err, "Create duplicate Platform")

	// test show all items
	basicPlatformShowTest(t, api, testData)

	// test delete
	_, err = api.DeletePlatform(ctx, &testData[0])
	require.Nil(t, err, "delete Platform %s", testData[0].Key.GetKeyString())
	show := ShowPlatform{}
	show.Init()
	filterNone := edgeproto.Platform{}
	err = api.ShowPlatform(ctx, &filterNone, &show)
	require.Nil(t, err, "show data")
	require.Equal(t, len(testData)-1, len(show.Data), "Show count")
	show.AssertNotFound(t, &testData[0])
	// test update of missing object
	_, err = api.UpdatePlatform(ctx, &testData[0])
	require.NotNil(t, err, "Update missing object")
	// create it back
	_, err = api.CreatePlatform(ctx, &testData[0])
	require.Nil(t, err, "Create Platform %s", testData[0].Key.GetKeyString())

	// test invalid keys
	bad := edgeproto.Platform{}
	_, err = api.CreatePlatform(ctx, &bad)
	require.NotNil(t, err, "Create Platform with no key info")

}

func InternalPlatformCreate(t *testing.T, api edgeproto.PlatformApiServer, testData []edgeproto.Platform) {
	createPlatformData(t, NewInternalPlatformApi(api), testData)
}

func ClientPlatformCreate(t *testing.T, api edgeproto.PlatformApiClient, testData []edgeproto.Platform) {
	createPlatformData(t, NewClientPlatformApi(api), testData)
}

func createPlatformData(t *testing.T, api *PlatformCommonApi, testData []edgeproto.Platform) {
	var err error
	ctx := context.TODO()

	for _, obj := range testData {
		_, err = api.CreatePlatform(ctx, &obj)
		require.Nil(t, err, "Create Platform %s", obj.Key.GetKeyString())
	}
}

type ShowCloudlet struct {
	Data map[string]edgeproto.Cloudlet
	grpc.ServerStream
}

func (x *ShowCloudlet) Init() {
	x.Data = make(map[string]edgeproto.Cloudlet)
}

func (x *ShowCloudlet) Send(m *edgeproto.Cloudlet) error {
	x.Data[m.Key.GetKeyString()] = *m
	return nil
}

type CudStreamoutCloudlet struct {
	grpc.ServerStream
}

func (x *CudStreamoutCloudlet) Send(res *edgeproto.Result) error {
	fmt.Println(res)
	return nil
}
func (x *CudStreamoutCloudlet) Context() context.Context {
	return context.TODO()
}

type CloudletStream interface {
	Recv() (*edgeproto.Result, error)
}

func CloudletReadResultStream(stream CloudletStream, err error) error {
	if err != nil {
		return err
	}
	for {
		res, err := stream.Recv()
		if err == io.EOF {
			return nil
		}
		if err != nil {
			return err
		}
		fmt.Println(res)
	}
}

func (x *ShowCloudlet) ReadStream(stream edgeproto.CloudletApi_ShowCloudletClient, err error) {
	x.Data = make(map[string]edgeproto.Cloudlet)
	if err != nil {
		return
	}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			break
		}
		x.Data[obj.Key.GetKeyString()] = *obj
	}
}

func (x *ShowCloudlet) CheckFound(obj *edgeproto.Cloudlet) bool {
	_, found := x.Data[obj.Key.GetKeyString()]
	return found
}

func (x *ShowCloudlet) AssertFound(t *testing.T, obj *edgeproto.Cloudlet) {
	check, found := x.Data[obj.Key.GetKeyString()]
	require.True(t, found, "find Cloudlet %s", obj.Key.GetKeyString())
	if found && !check.Matches(obj, edgeproto.MatchIgnoreBackend(), edgeproto.MatchSortArrayedKeys()) {
		require.Equal(t, *obj, check, "Cloudlet are equal")
	}
	if found {
		// remove in case there are dups in the list, so the
		// same object cannot be used again
		delete(x.Data, obj.Key.GetKeyString())
	}
}

func (x *ShowCloudlet) AssertNotFound(t *testing.T, obj *edgeproto.Cloudlet) {
	_, found := x.Data[obj.Key.GetKeyString()]
	require.False(t, found, "do not find Cloudlet %s", obj.Key.GetKeyString())
}

func WaitAssertFoundCloudlet(t *testing.T, api edgeproto.CloudletApiClient, obj *edgeproto.Cloudlet, count int, retry time.Duration) {
	show := ShowCloudlet{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowCloudlet(ctx, obj)
		show.ReadStream(stream, err)
		cancel()
		if show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertFound(t, obj)
}

func WaitAssertNotFoundCloudlet(t *testing.T, api edgeproto.CloudletApiClient, obj *edgeproto.Cloudlet, count int, retry time.Duration) {
	show := ShowCloudlet{}
	filterNone := edgeproto.Cloudlet{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowCloudlet(ctx, &filterNone)
		show.ReadStream(stream, err)
		cancel()
		if !show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertNotFound(t, obj)
}

// Wrap the api with a common interface
type CloudletCommonApi struct {
	internal_api edgeproto.CloudletApiServer
	client_api   edgeproto.CloudletApiClient
}

func (x *CloudletCommonApi) CreateCloudlet(ctx context.Context, in *edgeproto.Cloudlet) (*edgeproto.Result, error) {
	copy := &edgeproto.Cloudlet{}
	*copy = *in
	if x.internal_api != nil {
		err := x.internal_api.CreateCloudlet(copy, &CudStreamoutCloudlet{})
		return &edgeproto.Result{}, err
	} else {
		stream, err := x.client_api.CreateCloudlet(ctx, copy)
		err = CloudletReadResultStream(stream, err)
		return &edgeproto.Result{}, err
	}
}

func (x *CloudletCommonApi) UpdateCloudlet(ctx context.Context, in *edgeproto.Cloudlet) (*edgeproto.Result, error) {
	copy := &edgeproto.Cloudlet{}
	*copy = *in
	if x.internal_api != nil {
		err := x.internal_api.UpdateCloudlet(copy, &CudStreamoutCloudlet{})
		return &edgeproto.Result{}, err
	} else {
		stream, err := x.client_api.UpdateCloudlet(ctx, copy)
		err = CloudletReadResultStream(stream, err)
		return &edgeproto.Result{}, err
	}
}

func (x *CloudletCommonApi) DeleteCloudlet(ctx context.Context, in *edgeproto.Cloudlet) (*edgeproto.Result, error) {
	copy := &edgeproto.Cloudlet{}
	*copy = *in
	if x.internal_api != nil {
		err := x.internal_api.DeleteCloudlet(copy, &CudStreamoutCloudlet{})
		return &edgeproto.Result{}, err
	} else {
		stream, err := x.client_api.DeleteCloudlet(ctx, copy)
		err = CloudletReadResultStream(stream, err)
		return &edgeproto.Result{}, err
	}
}

func (x *CloudletCommonApi) ShowCloudlet(ctx context.Context, filter *edgeproto.Cloudlet, showData *ShowCloudlet) error {
	if x.internal_api != nil {
		return x.internal_api.ShowCloudlet(filter, showData)
	} else {
		stream, err := x.client_api.ShowCloudlet(ctx, filter)
		showData.ReadStream(stream, err)
		return err
	}
}

func NewInternalCloudletApi(api edgeproto.CloudletApiServer) *CloudletCommonApi {
	apiWrap := CloudletCommonApi{}
	apiWrap.internal_api = api
	return &apiWrap
}

func NewClientCloudletApi(api edgeproto.CloudletApiClient) *CloudletCommonApi {
	apiWrap := CloudletCommonApi{}
	apiWrap.client_api = api
	return &apiWrap
}

func InternalCloudletTest(t *testing.T, test string, api edgeproto.CloudletApiServer, testData []edgeproto.Cloudlet) {
	switch test {
	case "cud":
		basicCloudletCudTest(t, NewInternalCloudletApi(api), testData)
	case "show":
		basicCloudletShowTest(t, NewInternalCloudletApi(api), testData)
	}
}

func ClientCloudletTest(t *testing.T, test string, api edgeproto.CloudletApiClient, testData []edgeproto.Cloudlet) {
	switch test {
	case "cud":
		basicCloudletCudTest(t, NewClientCloudletApi(api), testData)
	case "show":
		basicCloudletShowTest(t, NewClientCloudletApi(api), testData)
	}
}

func basicCloudletShowTest(t *testing.T, api *CloudletCommonApi, testData []edgeproto.Cloudlet) {
	var err error
	ctx := context.TODO()

	show := ShowCloudlet{}
	show.Init()
	filterNone := edgeproto.Cloudlet{}
	err = api.ShowCloudlet(ctx, &filterNone, &show)
	require.Nil(t, err, "show data")
	require.Equal(t, len(testData), len(show.Data), "Show count")
	for _, obj := range testData {
		show.AssertFound(t, &obj)
	}
}

func GetCloudlet(t *testing.T, api *CloudletCommonApi, key *edgeproto.CloudletKey, out *edgeproto.Cloudlet) bool {
	var err error
	ctx := context.TODO()

	show := ShowCloudlet{}
	show.Init()
	filter := edgeproto.Cloudlet{}
	filter.Key = *key
	err = api.ShowCloudlet(ctx, &filter, &show)
	require.Nil(t, err, "show data")
	obj, found := show.Data[key.GetKeyString()]
	if found {
		*out = obj
	}
	return found
}

func basicCloudletCudTest(t *testing.T, api *CloudletCommonApi, testData []edgeproto.Cloudlet) {
	var err error
	ctx := context.TODO()

	if len(testData) < 3 {
		require.True(t, false, "Need at least 3 test data objects")
		return
	}

	// test create
	createCloudletData(t, api, testData)

	// test duplicate create - should fail
	_, err = api.CreateCloudlet(ctx, &testData[0])
	require.NotNil(t, err, "Create duplicate Cloudlet")

	// test show all items
	basicCloudletShowTest(t, api, testData)

	// test delete
	_, err = api.DeleteCloudlet(ctx, &testData[0])
	require.Nil(t, err, "delete Cloudlet %s", testData[0].Key.GetKeyString())
	show := ShowCloudlet{}
	show.Init()
	filterNone := edgeproto.Cloudlet{}
	err = api.ShowCloudlet(ctx, &filterNone, &show)
	require.Nil(t, err, "show data")
	require.Equal(t, len(testData)-1, len(show.Data), "Show count")
	show.AssertNotFound(t, &testData[0])
	// test update of missing object
	_, err = api.UpdateCloudlet(ctx, &testData[0])
	require.NotNil(t, err, "Update missing object")
	// create it back
	_, err = api.CreateCloudlet(ctx, &testData[0])
	require.Nil(t, err, "Create Cloudlet %s", testData[0].Key.GetKeyString())

	// test invalid keys
	bad := edgeproto.Cloudlet{}
	_, err = api.CreateCloudlet(ctx, &bad)
	require.NotNil(t, err, "Create Cloudlet with no key info")

	// test update
	updater := edgeproto.Cloudlet{}
	updater.Key = testData[0].Key
	updater.AccessCredentials = "update just this"
	updater.Fields = make([]string, 0)
	updater.Fields = append(updater.Fields, edgeproto.CloudletFieldAccessCredentials)
	_, err = api.UpdateCloudlet(ctx, &updater)
	require.Nil(t, err, "Update Cloudlet %s", testData[0].Key.GetKeyString())

	show.Init()
	updater = testData[0]
	updater.AccessCredentials = "update just this"
	err = api.ShowCloudlet(ctx, &filterNone, &show)
	require.Nil(t, err, "show Cloudlet")
	show.AssertFound(t, &updater)

	// revert change
	updater.AccessCredentials = testData[0].AccessCredentials
	_, err = api.UpdateCloudlet(ctx, &updater)
	require.Nil(t, err, "Update back Cloudlet")
}

func InternalCloudletCreate(t *testing.T, api edgeproto.CloudletApiServer, testData []edgeproto.Cloudlet) {
	createCloudletData(t, NewInternalCloudletApi(api), testData)
}

func ClientCloudletCreate(t *testing.T, api edgeproto.CloudletApiClient, testData []edgeproto.Cloudlet) {
	createCloudletData(t, NewClientCloudletApi(api), testData)
}

func createCloudletData(t *testing.T, api *CloudletCommonApi, testData []edgeproto.Cloudlet) {
	var err error
	ctx := context.TODO()

	for _, obj := range testData {
		_, err = api.CreateCloudlet(ctx, &obj)
		require.Nil(t, err, "Create Cloudlet %s", obj.Key.GetKeyString())
	}
}

type ShowCloudletInfo struct {
	Data map[string]edgeproto.CloudletInfo
	grpc.ServerStream
}

func (x *ShowCloudletInfo) Init() {
	x.Data = make(map[string]edgeproto.CloudletInfo)
}

func (x *ShowCloudletInfo) Send(m *edgeproto.CloudletInfo) error {
	x.Data[m.Key.GetKeyString()] = *m
	return nil
}

func (x *ShowCloudletInfo) ReadStream(stream edgeproto.CloudletInfoApi_ShowCloudletInfoClient, err error) {
	x.Data = make(map[string]edgeproto.CloudletInfo)
	if err != nil {
		return
	}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			break
		}
		x.Data[obj.Key.GetKeyString()] = *obj
	}
}

func (x *ShowCloudletInfo) CheckFound(obj *edgeproto.CloudletInfo) bool {
	_, found := x.Data[obj.Key.GetKeyString()]
	return found
}

func (x *ShowCloudletInfo) AssertFound(t *testing.T, obj *edgeproto.CloudletInfo) {
	check, found := x.Data[obj.Key.GetKeyString()]
	require.True(t, found, "find CloudletInfo %s", obj.Key.GetKeyString())
	if found && !check.Matches(obj, edgeproto.MatchIgnoreBackend(), edgeproto.MatchSortArrayedKeys()) {
		require.Equal(t, *obj, check, "CloudletInfo are equal")
	}
	if found {
		// remove in case there are dups in the list, so the
		// same object cannot be used again
		delete(x.Data, obj.Key.GetKeyString())
	}
}

func (x *ShowCloudletInfo) AssertNotFound(t *testing.T, obj *edgeproto.CloudletInfo) {
	_, found := x.Data[obj.Key.GetKeyString()]
	require.False(t, found, "do not find CloudletInfo %s", obj.Key.GetKeyString())
}

func WaitAssertFoundCloudletInfo(t *testing.T, api edgeproto.CloudletInfoApiClient, obj *edgeproto.CloudletInfo, count int, retry time.Duration) {
	show := ShowCloudletInfo{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowCloudletInfo(ctx, obj)
		show.ReadStream(stream, err)
		cancel()
		if show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertFound(t, obj)
}

func WaitAssertNotFoundCloudletInfo(t *testing.T, api edgeproto.CloudletInfoApiClient, obj *edgeproto.CloudletInfo, count int, retry time.Duration) {
	show := ShowCloudletInfo{}
	filterNone := edgeproto.CloudletInfo{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowCloudletInfo(ctx, &filterNone)
		show.ReadStream(stream, err)
		cancel()
		if !show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertNotFound(t, obj)
}

// Wrap the api with a common interface
type CloudletInfoCommonApi struct {
	internal_api edgeproto.CloudletInfoApiServer
	client_api   edgeproto.CloudletInfoApiClient
}

func (x *CloudletInfoCommonApi) ShowCloudletInfo(ctx context.Context, filter *edgeproto.CloudletInfo, showData *ShowCloudletInfo) error {
	if x.internal_api != nil {
		return x.internal_api.ShowCloudletInfo(filter, showData)
	} else {
		stream, err := x.client_api.ShowCloudletInfo(ctx, filter)
		showData.ReadStream(stream, err)
		return err
	}
}

func NewInternalCloudletInfoApi(api edgeproto.CloudletInfoApiServer) *CloudletInfoCommonApi {
	apiWrap := CloudletInfoCommonApi{}
	apiWrap.internal_api = api
	return &apiWrap
}

func NewClientCloudletInfoApi(api edgeproto.CloudletInfoApiClient) *CloudletInfoCommonApi {
	apiWrap := CloudletInfoCommonApi{}
	apiWrap.client_api = api
	return &apiWrap
}

func InternalCloudletInfoTest(t *testing.T, test string, api edgeproto.CloudletInfoApiServer, testData []edgeproto.CloudletInfo) {
	switch test {
	case "show":
		basicCloudletInfoShowTest(t, NewInternalCloudletInfoApi(api), testData)
	}
}

func ClientCloudletInfoTest(t *testing.T, test string, api edgeproto.CloudletInfoApiClient, testData []edgeproto.CloudletInfo) {
	switch test {
	case "show":
		basicCloudletInfoShowTest(t, NewClientCloudletInfoApi(api), testData)
	}
}

func basicCloudletInfoShowTest(t *testing.T, api *CloudletInfoCommonApi, testData []edgeproto.CloudletInfo) {
	var err error
	ctx := context.TODO()

	show := ShowCloudletInfo{}
	show.Init()
	filterNone := edgeproto.CloudletInfo{}
	err = api.ShowCloudletInfo(ctx, &filterNone, &show)
	require.Nil(t, err, "show data")
	require.Equal(t, len(testData), len(show.Data), "Show count")
	for _, obj := range testData {
		show.AssertFound(t, &obj)
	}
}

func GetCloudletInfo(t *testing.T, api *CloudletInfoCommonApi, key *edgeproto.CloudletKey, out *edgeproto.CloudletInfo) bool {
	var err error
	ctx := context.TODO()

	show := ShowCloudletInfo{}
	show.Init()
	filter := edgeproto.CloudletInfo{}
	filter.Key = *key
	err = api.ShowCloudletInfo(ctx, &filter, &show)
	require.Nil(t, err, "show data")
	obj, found := show.Data[key.GetKeyString()]
	if found {
		*out = obj
	}
	return found
}

func (s *DummyServer) CreatePlatform(in *edgeproto.Platform, server edgeproto.PlatformApi_CreatePlatformServer) error {
	if true {
		server.Send(&edgeproto.Result{})
		server.Send(&edgeproto.Result{})
		server.Send(&edgeproto.Result{})
	}
	return nil
}

func (s *DummyServer) DeletePlatform(in *edgeproto.Platform, server edgeproto.PlatformApi_DeletePlatformServer) error {
	if true {
		server.Send(&edgeproto.Result{})
		server.Send(&edgeproto.Result{})
		server.Send(&edgeproto.Result{})
	}
	return nil
}

func (s *DummyServer) UpdatePlatform(in *edgeproto.Platform, server edgeproto.PlatformApi_UpdatePlatformServer) error {
	if true {
		server.Send(&edgeproto.Result{})
		server.Send(&edgeproto.Result{})
		server.Send(&edgeproto.Result{})
	}
	return nil
}

func (s *DummyServer) ShowPlatform(in *edgeproto.Platform, server edgeproto.PlatformApi_ShowPlatformServer) error {
	obj := &edgeproto.Platform{}
	if obj.Matches(in, edgeproto.MatchFilter()) {
		server.Send(&edgeproto.Platform{})
		server.Send(&edgeproto.Platform{})
		server.Send(&edgeproto.Platform{})
	}
	for _, out := range s.Platforms {
		if !out.Matches(in, edgeproto.MatchFilter()) {
			continue
		}
		server.Send(&out)
	}
	return nil
}

func (s *DummyServer) CreateCloudlet(in *edgeproto.Cloudlet, server edgeproto.CloudletApi_CreateCloudletServer) error {
	if true {
		server.Send(&edgeproto.Result{})
		server.Send(&edgeproto.Result{})
		server.Send(&edgeproto.Result{})
	}
	return nil
}

func (s *DummyServer) DeleteCloudlet(in *edgeproto.Cloudlet, server edgeproto.CloudletApi_DeleteCloudletServer) error {
	if true {
		server.Send(&edgeproto.Result{})
		server.Send(&edgeproto.Result{})
		server.Send(&edgeproto.Result{})
	}
	return nil
}

func (s *DummyServer) UpdateCloudlet(in *edgeproto.Cloudlet, server edgeproto.CloudletApi_UpdateCloudletServer) error {
	if true {
		server.Send(&edgeproto.Result{})
		server.Send(&edgeproto.Result{})
		server.Send(&edgeproto.Result{})
	}
	return nil
}

func (s *DummyServer) ShowCloudlet(in *edgeproto.Cloudlet, server edgeproto.CloudletApi_ShowCloudletServer) error {
	obj := &edgeproto.Cloudlet{}
	if obj.Matches(in, edgeproto.MatchFilter()) {
		server.Send(&edgeproto.Cloudlet{})
		server.Send(&edgeproto.Cloudlet{})
		server.Send(&edgeproto.Cloudlet{})
	}
	for _, out := range s.Cloudlets {
		if !out.Matches(in, edgeproto.MatchFilter()) {
			continue
		}
		server.Send(&out)
	}
	return nil
}

func (s *DummyServer) ShowCloudletInfo(in *edgeproto.CloudletInfo, server edgeproto.CloudletInfoApi_ShowCloudletInfoServer) error {
	obj := &edgeproto.CloudletInfo{}
	if obj.Matches(in, edgeproto.MatchFilter()) {
		server.Send(&edgeproto.CloudletInfo{})
		server.Send(&edgeproto.CloudletInfo{})
		server.Send(&edgeproto.CloudletInfo{})
	}
	for _, out := range s.CloudletInfos {
		if !out.Matches(in, edgeproto.MatchFilter()) {
			continue
		}
		server.Send(&out)
	}
	return nil
}

func (s *DummyServer) InjectCloudletInfo(ctx context.Context, in *edgeproto.CloudletInfo) (*edgeproto.Result, error) {
	return &edgeproto.Result{}, nil
}

func (s *DummyServer) EvictCloudletInfo(ctx context.Context, in *edgeproto.CloudletInfo) (*edgeproto.Result, error) {
	return &edgeproto.Result{}, nil
}
