// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: refs.proto

package testutil

import (
	"context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/mobiledgex/edge-cloud/edgectl/wrapper"
	"github.com/mobiledgex/edge-cloud/edgeproto"
	"github.com/mobiledgex/edge-cloud/log"
	_ "github.com/mobiledgex/edge-cloud/protogen"
	"github.com/stretchr/testify/require"
	"google.golang.org/grpc"
	"io"
	math "math"
	"testing"
	"time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Auto-generated code: DO NOT EDIT

type ShowCloudletRefs struct {
	Data map[string]edgeproto.CloudletRefs
	grpc.ServerStream
	Ctx context.Context
}

func (x *ShowCloudletRefs) Init() {
	x.Data = make(map[string]edgeproto.CloudletRefs)
}

func (x *ShowCloudletRefs) Send(m *edgeproto.CloudletRefs) error {
	x.Data[m.GetKey().GetKeyString()] = *m
	return nil
}

func (x *ShowCloudletRefs) Context() context.Context {
	return x.Ctx
}

var CloudletRefsShowExtraCount = 0

func (x *ShowCloudletRefs) ReadStream(stream edgeproto.CloudletRefsApi_ShowCloudletRefsClient, err error) {
	x.Data = make(map[string]edgeproto.CloudletRefs)
	if err != nil {
		return
	}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			break
		}
		x.Data[obj.GetKey().GetKeyString()] = *obj
	}
}

func (x *ShowCloudletRefs) CheckFound(obj *edgeproto.CloudletRefs) bool {
	_, found := x.Data[obj.GetKey().GetKeyString()]
	return found
}

func (x *ShowCloudletRefs) AssertFound(t *testing.T, obj *edgeproto.CloudletRefs) {
	check, found := x.Data[obj.GetKey().GetKeyString()]
	require.True(t, found, "find CloudletRefs %s", obj.GetKey().GetKeyString())
	if found && !check.Matches(obj, edgeproto.MatchIgnoreBackend(), edgeproto.MatchSortArrayedKeys()) {
		require.Equal(t, *obj, check, "CloudletRefs are equal")
	}
	if found {
		// remove in case there are dups in the list, so the
		// same object cannot be used again
		delete(x.Data, obj.GetKey().GetKeyString())
	}
}

func (x *ShowCloudletRefs) AssertNotFound(t *testing.T, obj *edgeproto.CloudletRefs) {
	_, found := x.Data[obj.GetKey().GetKeyString()]
	require.False(t, found, "do not find CloudletRefs %s", obj.GetKey().GetKeyString())
}

func WaitAssertFoundCloudletRefs(t *testing.T, api edgeproto.CloudletRefsApiClient, obj *edgeproto.CloudletRefs, count int, retry time.Duration) {
	show := ShowCloudletRefs{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowCloudletRefs(ctx, obj)
		show.ReadStream(stream, err)
		cancel()
		if show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertFound(t, obj)
}

func WaitAssertNotFoundCloudletRefs(t *testing.T, api edgeproto.CloudletRefsApiClient, obj *edgeproto.CloudletRefs, count int, retry time.Duration) {
	show := ShowCloudletRefs{}
	filterNone := edgeproto.CloudletRefs{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowCloudletRefs(ctx, &filterNone)
		show.ReadStream(stream, err)
		cancel()
		if !show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertNotFound(t, obj)
}

// Wrap the api with a common interface
type CloudletRefsCommonApi struct {
	internal_api edgeproto.CloudletRefsApiServer
	client_api   edgeproto.CloudletRefsApiClient
}

func (x *CloudletRefsCommonApi) ShowCloudletRefs(ctx context.Context, filter *edgeproto.CloudletRefs, showData *ShowCloudletRefs) error {
	if x.internal_api != nil {
		showData.Ctx = ctx
		return x.internal_api.ShowCloudletRefs(filter, showData)
	} else {
		stream, err := x.client_api.ShowCloudletRefs(ctx, filter)
		showData.ReadStream(stream, err)
		return err
	}
}

func NewInternalCloudletRefsApi(api edgeproto.CloudletRefsApiServer) *CloudletRefsCommonApi {
	apiWrap := CloudletRefsCommonApi{}
	apiWrap.internal_api = api
	return &apiWrap
}

func NewClientCloudletRefsApi(api edgeproto.CloudletRefsApiClient) *CloudletRefsCommonApi {
	apiWrap := CloudletRefsCommonApi{}
	apiWrap.client_api = api
	return &apiWrap
}

func InternalCloudletRefsTest(t *testing.T, test string, api edgeproto.CloudletRefsApiServer, testData []edgeproto.CloudletRefs) {
	span := log.StartSpan(log.DebugLevelApi, "InternalCloudletRefsTest")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	switch test {
	case "show":
		basicCloudletRefsShowTest(t, ctx, NewInternalCloudletRefsApi(api), testData)
	}
}

func ClientCloudletRefsTest(t *testing.T, test string, api edgeproto.CloudletRefsApiClient, testData []edgeproto.CloudletRefs) {
	span := log.StartSpan(log.DebugLevelApi, "ClientCloudletRefsTest")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	switch test {
	case "show":
		basicCloudletRefsShowTest(t, ctx, NewClientCloudletRefsApi(api), testData)
	}
}

func basicCloudletRefsShowTest(t *testing.T, ctx context.Context, api *CloudletRefsCommonApi, testData []edgeproto.CloudletRefs) {
	var err error

	show := ShowCloudletRefs{}
	show.Init()
	filterNone := edgeproto.CloudletRefs{}
	err = api.ShowCloudletRefs(ctx, &filterNone, &show)
	require.Nil(t, err, "show data")
	require.Equal(t, len(testData)+CloudletRefsShowExtraCount, len(show.Data), "Show count")
	for _, obj := range testData {
		show.AssertFound(t, &obj)
	}
}

func GetCloudletRefs(t *testing.T, ctx context.Context, api *CloudletRefsCommonApi, key *edgeproto.CloudletKey, out *edgeproto.CloudletRefs) bool {
	var err error

	show := ShowCloudletRefs{}
	show.Init()
	filter := edgeproto.CloudletRefs{}
	filter.SetKey(key)
	err = api.ShowCloudletRefs(ctx, &filter, &show)
	require.Nil(t, err, "show data")
	obj, found := show.Data[key.GetKeyString()]
	if found {
		*out = obj
	}
	return found
}

func FindCloudletRefsData(key *edgeproto.CloudletKey, testData []edgeproto.CloudletRefs) (*edgeproto.CloudletRefs, bool) {
	for ii, _ := range testData {
		if testData[ii].GetKey().Matches(key) {
			return &testData[ii], true
		}
	}
	return nil, false
}

type ShowClusterInstRefs struct {
	Data map[string]edgeproto.ClusterInstRefs
	grpc.ServerStream
	Ctx context.Context
}

func (x *ShowClusterInstRefs) Init() {
	x.Data = make(map[string]edgeproto.ClusterInstRefs)
}

func (x *ShowClusterInstRefs) Send(m *edgeproto.ClusterInstRefs) error {
	x.Data[m.GetKey().GetKeyString()] = *m
	return nil
}

func (x *ShowClusterInstRefs) Context() context.Context {
	return x.Ctx
}

var ClusterInstRefsShowExtraCount = 0

func (x *ShowClusterInstRefs) ReadStream(stream edgeproto.ClusterInstRefsApi_ShowClusterInstRefsClient, err error) {
	x.Data = make(map[string]edgeproto.ClusterInstRefs)
	if err != nil {
		return
	}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			break
		}
		x.Data[obj.GetKey().GetKeyString()] = *obj
	}
}

func (x *ShowClusterInstRefs) CheckFound(obj *edgeproto.ClusterInstRefs) bool {
	_, found := x.Data[obj.GetKey().GetKeyString()]
	return found
}

func (x *ShowClusterInstRefs) AssertFound(t *testing.T, obj *edgeproto.ClusterInstRefs) {
	check, found := x.Data[obj.GetKey().GetKeyString()]
	require.True(t, found, "find ClusterInstRefs %s", obj.GetKey().GetKeyString())
	if found && !check.Matches(obj, edgeproto.MatchIgnoreBackend(), edgeproto.MatchSortArrayedKeys()) {
		require.Equal(t, *obj, check, "ClusterInstRefs are equal")
	}
	if found {
		// remove in case there are dups in the list, so the
		// same object cannot be used again
		delete(x.Data, obj.GetKey().GetKeyString())
	}
}

func (x *ShowClusterInstRefs) AssertNotFound(t *testing.T, obj *edgeproto.ClusterInstRefs) {
	_, found := x.Data[obj.GetKey().GetKeyString()]
	require.False(t, found, "do not find ClusterInstRefs %s", obj.GetKey().GetKeyString())
}

func WaitAssertFoundClusterInstRefs(t *testing.T, api edgeproto.ClusterInstRefsApiClient, obj *edgeproto.ClusterInstRefs, count int, retry time.Duration) {
	show := ShowClusterInstRefs{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowClusterInstRefs(ctx, obj)
		show.ReadStream(stream, err)
		cancel()
		if show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertFound(t, obj)
}

func WaitAssertNotFoundClusterInstRefs(t *testing.T, api edgeproto.ClusterInstRefsApiClient, obj *edgeproto.ClusterInstRefs, count int, retry time.Duration) {
	show := ShowClusterInstRefs{}
	filterNone := edgeproto.ClusterInstRefs{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowClusterInstRefs(ctx, &filterNone)
		show.ReadStream(stream, err)
		cancel()
		if !show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertNotFound(t, obj)
}

// Wrap the api with a common interface
type ClusterInstRefsCommonApi struct {
	internal_api edgeproto.ClusterInstRefsApiServer
	client_api   edgeproto.ClusterInstRefsApiClient
}

func (x *ClusterInstRefsCommonApi) ShowClusterInstRefs(ctx context.Context, filter *edgeproto.ClusterInstRefs, showData *ShowClusterInstRefs) error {
	if x.internal_api != nil {
		showData.Ctx = ctx
		return x.internal_api.ShowClusterInstRefs(filter, showData)
	} else {
		stream, err := x.client_api.ShowClusterInstRefs(ctx, filter)
		showData.ReadStream(stream, err)
		return err
	}
}

func NewInternalClusterInstRefsApi(api edgeproto.ClusterInstRefsApiServer) *ClusterInstRefsCommonApi {
	apiWrap := ClusterInstRefsCommonApi{}
	apiWrap.internal_api = api
	return &apiWrap
}

func NewClientClusterInstRefsApi(api edgeproto.ClusterInstRefsApiClient) *ClusterInstRefsCommonApi {
	apiWrap := ClusterInstRefsCommonApi{}
	apiWrap.client_api = api
	return &apiWrap
}

func InternalClusterInstRefsTest(t *testing.T, test string, api edgeproto.ClusterInstRefsApiServer, testData []edgeproto.ClusterInstRefs) {
	span := log.StartSpan(log.DebugLevelApi, "InternalClusterInstRefsTest")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	switch test {
	case "show":
		basicClusterInstRefsShowTest(t, ctx, NewInternalClusterInstRefsApi(api), testData)
	}
}

func ClientClusterInstRefsTest(t *testing.T, test string, api edgeproto.ClusterInstRefsApiClient, testData []edgeproto.ClusterInstRefs) {
	span := log.StartSpan(log.DebugLevelApi, "ClientClusterInstRefsTest")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	switch test {
	case "show":
		basicClusterInstRefsShowTest(t, ctx, NewClientClusterInstRefsApi(api), testData)
	}
}

func basicClusterInstRefsShowTest(t *testing.T, ctx context.Context, api *ClusterInstRefsCommonApi, testData []edgeproto.ClusterInstRefs) {
	var err error

	show := ShowClusterInstRefs{}
	show.Init()
	filterNone := edgeproto.ClusterInstRefs{}
	err = api.ShowClusterInstRefs(ctx, &filterNone, &show)
	require.Nil(t, err, "show data")
	require.Equal(t, len(testData)+ClusterInstRefsShowExtraCount, len(show.Data), "Show count")
	for _, obj := range testData {
		show.AssertFound(t, &obj)
	}
}

func GetClusterInstRefs(t *testing.T, ctx context.Context, api *ClusterInstRefsCommonApi, key *edgeproto.ClusterInstKey, out *edgeproto.ClusterInstRefs) bool {
	var err error

	show := ShowClusterInstRefs{}
	show.Init()
	filter := edgeproto.ClusterInstRefs{}
	filter.SetKey(key)
	err = api.ShowClusterInstRefs(ctx, &filter, &show)
	require.Nil(t, err, "show data")
	obj, found := show.Data[key.GetKeyString()]
	if found {
		*out = obj
	}
	return found
}

func FindClusterInstRefsData(key *edgeproto.ClusterInstKey, testData []edgeproto.ClusterInstRefs) (*edgeproto.ClusterInstRefs, bool) {
	for ii, _ := range testData {
		if testData[ii].GetKey().Matches(key) {
			return &testData[ii], true
		}
	}
	return nil, false
}

type ShowAppInstRefs struct {
	Data map[string]edgeproto.AppInstRefs
	grpc.ServerStream
	Ctx context.Context
}

func (x *ShowAppInstRefs) Init() {
	x.Data = make(map[string]edgeproto.AppInstRefs)
}

func (x *ShowAppInstRefs) Send(m *edgeproto.AppInstRefs) error {
	x.Data[m.GetKey().GetKeyString()] = *m
	return nil
}

func (x *ShowAppInstRefs) Context() context.Context {
	return x.Ctx
}

var AppInstRefsShowExtraCount = 0

func (x *ShowAppInstRefs) ReadStream(stream edgeproto.AppInstRefsApi_ShowAppInstRefsClient, err error) {
	x.Data = make(map[string]edgeproto.AppInstRefs)
	if err != nil {
		return
	}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			break
		}
		x.Data[obj.GetKey().GetKeyString()] = *obj
	}
}

func (x *ShowAppInstRefs) CheckFound(obj *edgeproto.AppInstRefs) bool {
	_, found := x.Data[obj.GetKey().GetKeyString()]
	return found
}

func (x *ShowAppInstRefs) AssertFound(t *testing.T, obj *edgeproto.AppInstRefs) {
	check, found := x.Data[obj.GetKey().GetKeyString()]
	require.True(t, found, "find AppInstRefs %s", obj.GetKey().GetKeyString())
	if found && !check.Matches(obj, edgeproto.MatchIgnoreBackend(), edgeproto.MatchSortArrayedKeys()) {
		require.Equal(t, *obj, check, "AppInstRefs are equal")
	}
	if found {
		// remove in case there are dups in the list, so the
		// same object cannot be used again
		delete(x.Data, obj.GetKey().GetKeyString())
	}
}

func (x *ShowAppInstRefs) AssertNotFound(t *testing.T, obj *edgeproto.AppInstRefs) {
	_, found := x.Data[obj.GetKey().GetKeyString()]
	require.False(t, found, "do not find AppInstRefs %s", obj.GetKey().GetKeyString())
}

func WaitAssertFoundAppInstRefs(t *testing.T, api edgeproto.AppInstRefsApiClient, obj *edgeproto.AppInstRefs, count int, retry time.Duration) {
	show := ShowAppInstRefs{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowAppInstRefs(ctx, obj)
		show.ReadStream(stream, err)
		cancel()
		if show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertFound(t, obj)
}

func WaitAssertNotFoundAppInstRefs(t *testing.T, api edgeproto.AppInstRefsApiClient, obj *edgeproto.AppInstRefs, count int, retry time.Duration) {
	show := ShowAppInstRefs{}
	filterNone := edgeproto.AppInstRefs{}
	for ii := 0; ii < count; ii++ {
		ctx, cancel := context.WithTimeout(context.Background(), retry)
		stream, err := api.ShowAppInstRefs(ctx, &filterNone)
		show.ReadStream(stream, err)
		cancel()
		if !show.CheckFound(obj) {
			break
		}
		time.Sleep(retry)
	}
	show.AssertNotFound(t, obj)
}

// Wrap the api with a common interface
type AppInstRefsCommonApi struct {
	internal_api edgeproto.AppInstRefsApiServer
	client_api   edgeproto.AppInstRefsApiClient
}

func (x *AppInstRefsCommonApi) ShowAppInstRefs(ctx context.Context, filter *edgeproto.AppInstRefs, showData *ShowAppInstRefs) error {
	if x.internal_api != nil {
		showData.Ctx = ctx
		return x.internal_api.ShowAppInstRefs(filter, showData)
	} else {
		stream, err := x.client_api.ShowAppInstRefs(ctx, filter)
		showData.ReadStream(stream, err)
		return err
	}
}

func NewInternalAppInstRefsApi(api edgeproto.AppInstRefsApiServer) *AppInstRefsCommonApi {
	apiWrap := AppInstRefsCommonApi{}
	apiWrap.internal_api = api
	return &apiWrap
}

func NewClientAppInstRefsApi(api edgeproto.AppInstRefsApiClient) *AppInstRefsCommonApi {
	apiWrap := AppInstRefsCommonApi{}
	apiWrap.client_api = api
	return &apiWrap
}

func InternalAppInstRefsTest(t *testing.T, test string, api edgeproto.AppInstRefsApiServer, testData []edgeproto.AppInstRefs) {
	span := log.StartSpan(log.DebugLevelApi, "InternalAppInstRefsTest")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	switch test {
	case "show":
		basicAppInstRefsShowTest(t, ctx, NewInternalAppInstRefsApi(api), testData)
	}
}

func ClientAppInstRefsTest(t *testing.T, test string, api edgeproto.AppInstRefsApiClient, testData []edgeproto.AppInstRefs) {
	span := log.StartSpan(log.DebugLevelApi, "ClientAppInstRefsTest")
	defer span.Finish()
	ctx := log.ContextWithSpan(context.Background(), span)

	switch test {
	case "show":
		basicAppInstRefsShowTest(t, ctx, NewClientAppInstRefsApi(api), testData)
	}
}

func basicAppInstRefsShowTest(t *testing.T, ctx context.Context, api *AppInstRefsCommonApi, testData []edgeproto.AppInstRefs) {
	var err error

	show := ShowAppInstRefs{}
	show.Init()
	filterNone := edgeproto.AppInstRefs{}
	err = api.ShowAppInstRefs(ctx, &filterNone, &show)
	require.Nil(t, err, "show data")
	require.Equal(t, len(testData)+AppInstRefsShowExtraCount, len(show.Data), "Show count")
	for _, obj := range testData {
		show.AssertFound(t, &obj)
	}
}

func GetAppInstRefs(t *testing.T, ctx context.Context, api *AppInstRefsCommonApi, key *edgeproto.AppKey, out *edgeproto.AppInstRefs) bool {
	var err error

	show := ShowAppInstRefs{}
	show.Init()
	filter := edgeproto.AppInstRefs{}
	filter.SetKey(key)
	err = api.ShowAppInstRefs(ctx, &filter, &show)
	require.Nil(t, err, "show data")
	obj, found := show.Data[key.GetKeyString()]
	if found {
		*out = obj
	}
	return found
}

func FindAppInstRefsData(key *edgeproto.AppKey, testData []edgeproto.AppInstRefs) (*edgeproto.AppInstRefs, bool) {
	for ii, _ := range testData {
		if testData[ii].GetKey().Matches(key) {
			return &testData[ii], true
		}
	}
	return nil, false
}

func (r *Run) CloudletRefsApi(data *[]edgeproto.CloudletRefs, dataMap interface{}, dataOut interface{}) {
	log.DebugLog(log.DebugLevelApi, "API for CloudletRefs", "mode", r.Mode)
	if r.Mode == "show" {
		obj := &edgeproto.CloudletRefs{}
		out, err := r.client.ShowCloudletRefs(r.ctx, obj)
		if err != nil {
			r.logErr("CloudletRefsApi", err)
		} else {
			outp, ok := dataOut.(*[]edgeproto.CloudletRefs)
			if !ok {
				panic(fmt.Sprintf("RunCloudletRefsApi expected dataOut type *[]edgeproto.CloudletRefs, but was %T", dataOut))
			}
			*outp = append(*outp, out...)
		}
		return
	}
	for ii, objD := range *data {
		obj := &objD
		switch r.Mode {
		case "showfiltered":
			out, err := r.client.ShowCloudletRefs(r.ctx, obj)
			if err != nil {
				r.logErr(fmt.Sprintf("CloudletRefsApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.CloudletRefs)
				if !ok {
					panic(fmt.Sprintf("RunCloudletRefsApi expected dataOut type *[]edgeproto.CloudletRefs, but was %T", dataOut))
				}
				*outp = append(*outp, out...)
			}
		}
	}
}

func (s *DummyServer) ShowCloudletRefs(in *edgeproto.CloudletRefs, server edgeproto.CloudletRefsApi_ShowCloudletRefsServer) error {
	var err error
	obj := &edgeproto.CloudletRefs{}
	if obj.Matches(in, edgeproto.MatchFilter()) {
		for ii := 0; ii < s.ShowDummyCount; ii++ {
			server.Send(&edgeproto.CloudletRefs{})
		}
	}
	err = s.CloudletRefsCache.Show(in, func(obj *edgeproto.CloudletRefs) error {
		err := server.Send(obj)
		return err
	})
	return err
}

func (r *Run) ClusterInstRefsApi(data *[]edgeproto.ClusterInstRefs, dataMap interface{}, dataOut interface{}) {
	log.DebugLog(log.DebugLevelApi, "API for ClusterInstRefs", "mode", r.Mode)
	if r.Mode == "show" {
		obj := &edgeproto.ClusterInstRefs{}
		out, err := r.client.ShowClusterInstRefs(r.ctx, obj)
		if err != nil {
			r.logErr("ClusterInstRefsApi", err)
		} else {
			outp, ok := dataOut.(*[]edgeproto.ClusterInstRefs)
			if !ok {
				panic(fmt.Sprintf("RunClusterInstRefsApi expected dataOut type *[]edgeproto.ClusterInstRefs, but was %T", dataOut))
			}
			*outp = append(*outp, out...)
		}
		return
	}
	for ii, objD := range *data {
		obj := &objD
		switch r.Mode {
		case "showfiltered":
			out, err := r.client.ShowClusterInstRefs(r.ctx, obj)
			if err != nil {
				r.logErr(fmt.Sprintf("ClusterInstRefsApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.ClusterInstRefs)
				if !ok {
					panic(fmt.Sprintf("RunClusterInstRefsApi expected dataOut type *[]edgeproto.ClusterInstRefs, but was %T", dataOut))
				}
				*outp = append(*outp, out...)
			}
		}
	}
}

func (s *DummyServer) ShowClusterInstRefs(in *edgeproto.ClusterInstRefs, server edgeproto.ClusterInstRefsApi_ShowClusterInstRefsServer) error {
	var err error
	obj := &edgeproto.ClusterInstRefs{}
	if obj.Matches(in, edgeproto.MatchFilter()) {
		for ii := 0; ii < s.ShowDummyCount; ii++ {
			server.Send(&edgeproto.ClusterInstRefs{})
		}
	}
	err = s.ClusterInstRefsCache.Show(in, func(obj *edgeproto.ClusterInstRefs) error {
		err := server.Send(obj)
		return err
	})
	return err
}

func (r *Run) AppInstRefsApi(data *[]edgeproto.AppInstRefs, dataMap interface{}, dataOut interface{}) {
	log.DebugLog(log.DebugLevelApi, "API for AppInstRefs", "mode", r.Mode)
	if r.Mode == "show" {
		obj := &edgeproto.AppInstRefs{}
		out, err := r.client.ShowAppInstRefs(r.ctx, obj)
		if err != nil {
			r.logErr("AppInstRefsApi", err)
		} else {
			outp, ok := dataOut.(*[]edgeproto.AppInstRefs)
			if !ok {
				panic(fmt.Sprintf("RunAppInstRefsApi expected dataOut type *[]edgeproto.AppInstRefs, but was %T", dataOut))
			}
			*outp = append(*outp, out...)
		}
		return
	}
	for ii, objD := range *data {
		obj := &objD
		switch r.Mode {
		case "showfiltered":
			out, err := r.client.ShowAppInstRefs(r.ctx, obj)
			if err != nil {
				r.logErr(fmt.Sprintf("AppInstRefsApi[%d]", ii), err)
			} else {
				outp, ok := dataOut.(*[]edgeproto.AppInstRefs)
				if !ok {
					panic(fmt.Sprintf("RunAppInstRefsApi expected dataOut type *[]edgeproto.AppInstRefs, but was %T", dataOut))
				}
				*outp = append(*outp, out...)
			}
		}
	}
}

func (s *DummyServer) ShowAppInstRefs(in *edgeproto.AppInstRefs, server edgeproto.AppInstRefsApi_ShowAppInstRefsServer) error {
	var err error
	obj := &edgeproto.AppInstRefs{}
	if obj.Matches(in, edgeproto.MatchFilter()) {
		for ii := 0; ii < s.ShowDummyCount; ii++ {
			server.Send(&edgeproto.AppInstRefs{})
		}
	}
	err = s.AppInstRefsCache.Show(in, func(obj *edgeproto.AppInstRefs) error {
		err := server.Send(obj)
		return err
	})
	return err
}

type CloudletRefsStream interface {
	Recv() (*edgeproto.CloudletRefs, error)
}

func CloudletRefsReadStream(stream CloudletRefsStream) ([]edgeproto.CloudletRefs, error) {
	output := []edgeproto.CloudletRefs{}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			return output, fmt.Errorf("read CloudletRefs stream failed, %v", err)
		}
		output = append(output, *obj)
	}
	return output, nil
}

func (s *ApiClient) ShowCloudletRefs(ctx context.Context, in *edgeproto.CloudletRefs) ([]edgeproto.CloudletRefs, error) {
	api := edgeproto.NewCloudletRefsApiClient(s.Conn)
	stream, err := api.ShowCloudletRefs(ctx, in)
	if err != nil {
		return nil, err
	}
	return CloudletRefsReadStream(stream)
}

func (s *CliClient) ShowCloudletRefs(ctx context.Context, in *edgeproto.CloudletRefs) ([]edgeproto.CloudletRefs, error) {
	output := []edgeproto.CloudletRefs{}
	args := append(s.BaseArgs, "controller", "ShowCloudletRefs")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

type CloudletRefsApiClient interface {
	ShowCloudletRefs(ctx context.Context, in *edgeproto.CloudletRefs) ([]edgeproto.CloudletRefs, error)
}

type ClusterInstRefsStream interface {
	Recv() (*edgeproto.ClusterInstRefs, error)
}

func ClusterInstRefsReadStream(stream ClusterInstRefsStream) ([]edgeproto.ClusterInstRefs, error) {
	output := []edgeproto.ClusterInstRefs{}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			return output, fmt.Errorf("read ClusterInstRefs stream failed, %v", err)
		}
		output = append(output, *obj)
	}
	return output, nil
}

func (s *ApiClient) ShowClusterInstRefs(ctx context.Context, in *edgeproto.ClusterInstRefs) ([]edgeproto.ClusterInstRefs, error) {
	api := edgeproto.NewClusterInstRefsApiClient(s.Conn)
	stream, err := api.ShowClusterInstRefs(ctx, in)
	if err != nil {
		return nil, err
	}
	return ClusterInstRefsReadStream(stream)
}

func (s *CliClient) ShowClusterInstRefs(ctx context.Context, in *edgeproto.ClusterInstRefs) ([]edgeproto.ClusterInstRefs, error) {
	output := []edgeproto.ClusterInstRefs{}
	args := append(s.BaseArgs, "controller", "ShowClusterInstRefs")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

type ClusterInstRefsApiClient interface {
	ShowClusterInstRefs(ctx context.Context, in *edgeproto.ClusterInstRefs) ([]edgeproto.ClusterInstRefs, error)
}

type AppInstRefsStream interface {
	Recv() (*edgeproto.AppInstRefs, error)
}

func AppInstRefsReadStream(stream AppInstRefsStream) ([]edgeproto.AppInstRefs, error) {
	output := []edgeproto.AppInstRefs{}
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			return output, fmt.Errorf("read AppInstRefs stream failed, %v", err)
		}
		output = append(output, *obj)
	}
	return output, nil
}

func (s *ApiClient) ShowAppInstRefs(ctx context.Context, in *edgeproto.AppInstRefs) ([]edgeproto.AppInstRefs, error) {
	api := edgeproto.NewAppInstRefsApiClient(s.Conn)
	stream, err := api.ShowAppInstRefs(ctx, in)
	if err != nil {
		return nil, err
	}
	return AppInstRefsReadStream(stream)
}

func (s *CliClient) ShowAppInstRefs(ctx context.Context, in *edgeproto.AppInstRefs) ([]edgeproto.AppInstRefs, error) {
	output := []edgeproto.AppInstRefs{}
	args := append(s.BaseArgs, "controller", "ShowAppInstRefs")
	err := wrapper.RunEdgectlObjs(args, in, &output, s.RunOps...)
	return output, err
}

type AppInstRefsApiClient interface {
	ShowAppInstRefs(ctx context.Context, in *edgeproto.AppInstRefs) ([]edgeproto.AppInstRefs, error)
}
