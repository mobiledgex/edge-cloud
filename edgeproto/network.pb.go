// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: network.proto

package edgeproto

import (
	context "context"
	"encoding/json"
	"errors"
	fmt "fmt"
	"github.com/coreos/etcd/clientv3/concurrency"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/mobiledgex/edge-cloud/log"
	"github.com/mobiledgex/edge-cloud/objstore"
	_ "github.com/mobiledgex/edge-cloud/protogen"
	"github.com/mobiledgex/edge-cloud/util"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	"strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Network Connection Type
//
// NetworkConnectionType is the supported list of network types to be optionally added to a cluster instance
//
// 0: `UNDEFINED`
// 1: `CONNECT_TO_LOAD_BALANCER`
// 2: `CONNECT_TO_CLUSTER_NODES`
// 3: `CONNECT_TO_ALL`
type NetworkConnectionType int32

const (
	// Undefined
	NetworkConnectionType_UNDEFINED NetworkConnectionType = 0
	// Network connects to load balancer
	NetworkConnectionType_CONNECT_TO_LOAD_BALANCER NetworkConnectionType = 1
	// Network connects to k8s and docker cluster nodes
	NetworkConnectionType_CONNECT_TO_CLUSTER_NODES NetworkConnectionType = 2
	// Network connects to all VMs
	NetworkConnectionType_CONNECT_TO_ALL NetworkConnectionType = 3
)

var NetworkConnectionType_name = map[int32]string{
	0: "UNDEFINED",
	1: "CONNECT_TO_LOAD_BALANCER",
	2: "CONNECT_TO_CLUSTER_NODES",
	3: "CONNECT_TO_ALL",
}

var NetworkConnectionType_value = map[string]int32{
	"UNDEFINED":                0,
	"CONNECT_TO_LOAD_BALANCER": 1,
	"CONNECT_TO_CLUSTER_NODES": 2,
	"CONNECT_TO_ALL":           3,
}

func (x NetworkConnectionType) String() string {
	return proto.EnumName(NetworkConnectionType_name, int32(x))
}

func (NetworkConnectionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{0}
}

type Route struct {
	// Destination CIDR
	DestinationCidr string `protobuf:"bytes,1,opt,name=destination_cidr,json=destinationCidr,proto3" json:"destination_cidr,omitempty"`
	// Next hop IP
	NextHopIp string `protobuf:"bytes,2,opt,name=next_hop_ip,json=nextHopIp,proto3" json:"next_hop_ip,omitempty"`
}

func (m *Route) Reset()         { *m = Route{} }
func (m *Route) String() string { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()    {}
func (*Route) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{0}
}
func (m *Route) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Route) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Route.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Route) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Route.Merge(m, src)
}
func (m *Route) XXX_Size() int {
	return m.Size()
}
func (m *Route) XXX_DiscardUnknown() {
	xxx_messageInfo_Route.DiscardUnknown(m)
}

var xxx_messageInfo_Route proto.InternalMessageInfo

type NetworkKey struct {
	// Cloudlet that this network can be provisioned on
	CloudletKey CloudletKey `protobuf:"bytes,1,opt,name=cloudlet_key,json=cloudletKey,proto3" json:"cloudlet_key"`
	// Network Name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *NetworkKey) Reset()         { *m = NetworkKey{} }
func (m *NetworkKey) String() string { return proto.CompactTextString(m) }
func (*NetworkKey) ProtoMessage()    {}
func (*NetworkKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{1}
}
func (m *NetworkKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkKey.Merge(m, src)
}
func (m *NetworkKey) XXX_Size() int {
	return m.Size()
}
func (m *NetworkKey) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkKey.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkKey proto.InternalMessageInfo

// Network defines additional networks which can be optionally added to a cloudlet
type Network struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique identifier key
	Key NetworkKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// List of routes
	Routes []Route `protobuf:"bytes,3,rep,name=routes,proto3" json:"routes"`
	// Network connection type
	ConnectionType NetworkConnectionType `protobuf:"varint,4,opt,name=connection_type,json=connectionType,proto3,enum=edgeproto.NetworkConnectionType" json:"connection_type,omitempty"`
}

func (m *Network) Reset()         { *m = Network{} }
func (m *Network) String() string { return proto.CompactTextString(m) }
func (*Network) ProtoMessage()    {}
func (*Network) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{2}
}
func (m *Network) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Network) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Network.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Network) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Network.Merge(m, src)
}
func (m *Network) XXX_Size() int {
	return m.Size()
}
func (m *Network) XXX_DiscardUnknown() {
	xxx_messageInfo_Network.DiscardUnknown(m)
}

var xxx_messageInfo_Network proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("edgeproto.NetworkConnectionType", NetworkConnectionType_name, NetworkConnectionType_value)
	proto.RegisterType((*Route)(nil), "edgeproto.Route")
	proto.RegisterType((*NetworkKey)(nil), "edgeproto.NetworkKey")
	proto.RegisterType((*Network)(nil), "edgeproto.Network")
}

func init() { proto.RegisterFile("network.proto", fileDescriptor_8571034d60397816) }

var fileDescriptor_8571034d60397816 = []byte{
	// 739 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x93, 0x3d, 0x68, 0x1b, 0x49,
	0x14, 0xc7, 0x35, 0x92, 0x3f, 0xd0, 0xc8, 0xb2, 0xe5, 0xc1, 0x36, 0x83, 0x11, 0x6b, 0xa1, 0x4a,
	0x67, 0x64, 0xed, 0xa1, 0x2b, 0xee, 0xce, 0x87, 0x39, 0xa4, 0x95, 0x8e, 0x33, 0xd6, 0xad, 0x60,
	0x2d, 0x5d, 0x77, 0x2c, 0xeb, 0xdd, 0xb9, 0xd5, 0x22, 0x69, 0x67, 0xd9, 0x5d, 0x45, 0xde, 0x90,
	0x22, 0xa4, 0x49, 0x17, 0x0c, 0x29, 0x12, 0x52, 0xa5, 0x0c, 0xa9, 0x4c, 0xd2, 0xa5, 0x4a, 0xe9,
	0xd2, 0x90, 0x26, 0x55, 0x48, 0xec, 0x14, 0xc1, 0x55, 0xc0, 0xb2, 0x49, 0x19, 0x76, 0xb4, 0x92,
	0xe5, 0xf8, 0x23, 0x84, 0x14, 0x69, 0x96, 0x37, 0xef, 0xfd, 0x67, 0xe6, 0xf7, 0xfe, 0x6f, 0x16,
	0xc6, 0x4d, 0xe2, 0x76, 0xa9, 0xdd, 0xcc, 0x59, 0x36, 0x75, 0x29, 0x8a, 0x12, 0x4d, 0x27, 0x2c,
	0x5c, 0x4c, 0xea, 0x94, 0xea, 0x2d, 0xc2, 0x2b, 0x96, 0xc1, 0x2b, 0xa6, 0x49, 0x5d, 0xc5, 0x35,
	0xa8, 0xe9, 0xf4, 0x85, 0x8b, 0xb3, 0x6a, 0x8b, 0x76, 0xb4, 0x16, 0x71, 0x9b, 0xc4, 0x0b, 0x52,
	0x53, 0x36, 0x71, 0x3a, 0x2d, 0x37, 0x58, 0xfd, 0xa6, 0x1b, 0x6e, 0xa3, 0xb3, 0x95, 0x53, 0x69,
	0x9b, 0x6f, 0xd3, 0x2d, 0xa3, 0xe5, 0x9f, 0xbc, 0xcd, 0xfb, 0xdf, 0x15, 0xb6, 0x97, 0x67, 0x3a,
	0x9d, 0x98, 0xc3, 0x20, 0xd8, 0x39, 0xa7, 0x53, 0x9d, 0xb2, 0x90, 0xf7, 0xa3, 0x7e, 0x36, 0x2d,
	0xc1, 0x71, 0x89, 0x76, 0x5c, 0x82, 0x7e, 0x82, 0x09, 0x8d, 0x38, 0xae, 0x61, 0x32, 0x1e, 0x59,
	0x35, 0x34, 0x1b, 0x83, 0x14, 0xc8, 0x44, 0xa5, 0x99, 0x91, 0xbc, 0x60, 0x68, 0x36, 0xe2, 0x60,
	0xcc, 0x24, 0xdb, 0xae, 0xdc, 0xa0, 0x96, 0x6c, 0x58, 0x38, 0xcc, 0x54, 0x51, 0x3f, 0xf5, 0x37,
	0xb5, 0xd6, 0xad, 0xf4, 0x2d, 0x08, 0xc5, 0x7e, 0xfb, 0x1b, 0xc4, 0x43, 0x7f, 0xc2, 0xa9, 0x41,
	0x53, 0x72, 0x93, 0x78, 0xec, 0xd0, 0x58, 0x7e, 0x21, 0x37, 0xb4, 0x24, 0x27, 0x04, 0xe5, 0x0d,
	0xe2, 0x15, 0xc7, 0xf6, 0xde, 0x2c, 0x85, 0xa4, 0x98, 0x7a, 0x96, 0x42, 0x4b, 0x70, 0xcc, 0x54,
	0xda, 0xa4, 0x7f, 0x4f, 0x31, 0xf6, 0xe2, 0x14, 0x4f, 0x06, 0xee, 0x4a, 0xac, 0xb0, 0x3a, 0xf5,
	0xe1, 0x18, 0x83, 0x4f, 0xc7, 0x18, 0xec, 0x3e, 0x5e, 0x02, 0xe9, 0x97, 0x61, 0x38, 0x19, 0x5c,
	0x8f, 0x16, 0xe0, 0xc4, 0xff, 0x06, 0x69, 0x69, 0x0e, 0x06, 0xa9, 0x48, 0x26, 0x2a, 0x05, 0x2b,
	0xb4, 0x02, 0x23, 0x3e, 0x4a, 0x98, 0xa1, 0xcc, 0x8f, 0xa0, 0x9c, 0x71, 0x07, 0x24, 0xbe, 0x0e,
	0xe5, 0xe0, 0x84, 0xed, 0x9b, 0xe4, 0xe0, 0x48, 0x2a, 0x92, 0x89, 0xe5, 0x13, 0x23, 0x3b, 0x98,
	0x7b, 0x81, 0x38, 0x50, 0xa1, 0x75, 0x38, 0xa3, 0x52, 0xd3, 0x24, 0x2a, 0xb3, 0xd2, 0xf5, 0x2c,
	0x82, 0xc7, 0x52, 0x20, 0x33, 0x9d, 0x4f, 0x5d, 0xbc, 0x4a, 0x18, 0x0a, 0x6b, 0x9e, 0x45, 0xa4,
	0x69, 0xf5, 0xdc, 0x7a, 0xd5, 0xf1, 0x7b, 0xfb, 0x78, 0x8c, 0xc1, 0xed, 0x1e, 0x06, 0x3b, 0x3d,
	0x0c, 0x1e, 0xf6, 0x30, 0xd8, 0xed, 0x61, 0xf0, 0xe8, 0x04, 0xff, 0xea, 0x77, 0xbf, 0xb6, 0x41,
	0xbc, 0x9c, 0xa8, 0xb4, 0x49, 0x76, 0xe0, 0xd9, 0x0a, 0xb5, 0x75, 0x96, 0x1d, 0xf1, 0x35, 0x57,
	0xb5, 0x75, 0xc5, 0x34, 0x6e, 0xb2, 0x21, 0x3e, 0x3b, 0xc5, 0xc9, 0x26, 0xf1, 0xd6, 0xae, 0xaa,
	0x2f, 0xdf, 0x80, 0xf3, 0x97, 0xd2, 0xa1, 0x38, 0x8c, 0xd6, 0xc5, 0x52, 0xf9, 0xaf, 0x75, 0xb1,
	0x5c, 0x4a, 0x84, 0x50, 0x12, 0x62, 0xa1, 0x2a, 0x8a, 0x65, 0xa1, 0x26, 0xd7, 0xaa, 0x72, 0xa5,
	0x5a, 0x28, 0xc9, 0xc5, 0x42, 0xa5, 0x20, 0x0a, 0x65, 0x29, 0x01, 0xbe, 0xa8, 0x0a, 0x95, 0xfa,
	0x66, 0xad, 0x2c, 0xc9, 0x62, 0xb5, 0x54, 0xde, 0x4c, 0x84, 0x11, 0x82, 0xd3, 0x23, 0xd5, 0x42,
	0xa5, 0x92, 0x88, 0xe4, 0xef, 0x8e, 0x0f, 0x5f, 0x4e, 0xc1, 0x32, 0xd0, 0x73, 0x00, 0xe3, 0x82,
	0x4d, 0x14, 0x97, 0x0c, 0xe6, 0x89, 0x2e, 0xfa, 0xb7, 0x38, 0x3b, 0x3a, 0x0c, 0xf6, 0xab, 0xa4,
	0xbd, 0xa3, 0x1e, 0xfe, 0x43, 0x22, 0x0e, 0xed, 0xd8, 0x2a, 0x19, 0x74, 0xe9, 0x64, 0x0b, 0xac,
	0x91, 0x7f, 0x14, 0x53, 0xd1, 0x49, 0xf6, 0x3a, 0x83, 0x9e, 0x9e, 0xe2, 0xe4, 0x75, 0xf5, 0x3b,
	0xaf, 0xde, 0xdf, 0x0f, 0xcf, 0xa5, 0x67, 0x78, 0x95, 0xd1, 0xf1, 0xc1, 0x73, 0x5c, 0x05, 0xcb,
	0x3f, 0x03, 0xf4, 0x00, 0xc0, 0x78, 0x89, 0xb4, 0xc8, 0x37, 0x53, 0xff, 0xf7, 0x9d, 0xd4, 0x4f,
	0x4e, 0x30, 0x18, 0x92, 0x69, 0x8c, 0xe0, 0x22, 0x59, 0xdd, 0xd2, 0x94, 0x1f, 0x4b, 0xd6, 0x61,
	0x04, 0xe7, 0xc9, 0xee, 0x01, 0x18, 0xdb, 0x6c, 0xd0, 0xee, 0x75, 0x5c, 0x97, 0xe4, 0xd2, 0xf5,
	0xa3, 0x1e, 0xfe, 0xfd, 0x2a, 0xb0, 0x7f, 0x0d, 0xd2, 0xcd, 0x7e, 0x75, 0x8c, 0x28, 0x1d, 0xe7,
	0x9d, 0x06, 0xed, 0x9e, 0x03, 0x2a, 0x26, 0xf7, 0xde, 0x71, 0xa1, 0xbd, 0x03, 0x0e, 0xec, 0x1f,
	0x70, 0xe0, 0xed, 0x01, 0x07, 0x76, 0x0e, 0xb9, 0xd0, 0xfe, 0x21, 0x17, 0x7a, 0x7d, 0xc8, 0x85,
	0xb6, 0x26, 0x18, 0xc5, 0x2f, 0x9f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x73, 0x0a, 0x30, 0x04, 0xe6,
	0x05, 0x00, 0x00,
}

func (this *NetworkKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&edgeproto.NetworkKey{")
	s = append(s, "CloudletKey: "+strings.Replace(this.CloudletKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringNetwork(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NetworkApiClient is the client API for NetworkApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NetworkApiClient interface {
	// Create a Network
	CreateNetwork(ctx context.Context, in *Network, opts ...grpc.CallOption) (NetworkApi_CreateNetworkClient, error)
	// Delete a Network
	DeleteNetwork(ctx context.Context, in *Network, opts ...grpc.CallOption) (NetworkApi_DeleteNetworkClient, error)
	// Update a Network
	UpdateNetwork(ctx context.Context, in *Network, opts ...grpc.CallOption) (NetworkApi_UpdateNetworkClient, error)
	// Show Networks. Any fields specified will be used to filter results.
	ShowNetwork(ctx context.Context, in *Network, opts ...grpc.CallOption) (NetworkApi_ShowNetworkClient, error)
}

type networkApiClient struct {
	cc *grpc.ClientConn
}

func NewNetworkApiClient(cc *grpc.ClientConn) NetworkApiClient {
	return &networkApiClient{cc}
}

func (c *networkApiClient) CreateNetwork(ctx context.Context, in *Network, opts ...grpc.CallOption) (NetworkApi_CreateNetworkClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NetworkApi_serviceDesc.Streams[0], "/edgeproto.NetworkApi/CreateNetwork", opts...)
	if err != nil {
		return nil, err
	}
	x := &networkApiCreateNetworkClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NetworkApi_CreateNetworkClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type networkApiCreateNetworkClient struct {
	grpc.ClientStream
}

func (x *networkApiCreateNetworkClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *networkApiClient) DeleteNetwork(ctx context.Context, in *Network, opts ...grpc.CallOption) (NetworkApi_DeleteNetworkClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NetworkApi_serviceDesc.Streams[1], "/edgeproto.NetworkApi/DeleteNetwork", opts...)
	if err != nil {
		return nil, err
	}
	x := &networkApiDeleteNetworkClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NetworkApi_DeleteNetworkClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type networkApiDeleteNetworkClient struct {
	grpc.ClientStream
}

func (x *networkApiDeleteNetworkClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *networkApiClient) UpdateNetwork(ctx context.Context, in *Network, opts ...grpc.CallOption) (NetworkApi_UpdateNetworkClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NetworkApi_serviceDesc.Streams[2], "/edgeproto.NetworkApi/UpdateNetwork", opts...)
	if err != nil {
		return nil, err
	}
	x := &networkApiUpdateNetworkClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NetworkApi_UpdateNetworkClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type networkApiUpdateNetworkClient struct {
	grpc.ClientStream
}

func (x *networkApiUpdateNetworkClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *networkApiClient) ShowNetwork(ctx context.Context, in *Network, opts ...grpc.CallOption) (NetworkApi_ShowNetworkClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NetworkApi_serviceDesc.Streams[3], "/edgeproto.NetworkApi/ShowNetwork", opts...)
	if err != nil {
		return nil, err
	}
	x := &networkApiShowNetworkClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NetworkApi_ShowNetworkClient interface {
	Recv() (*Network, error)
	grpc.ClientStream
}

type networkApiShowNetworkClient struct {
	grpc.ClientStream
}

func (x *networkApiShowNetworkClient) Recv() (*Network, error) {
	m := new(Network)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NetworkApiServer is the server API for NetworkApi service.
type NetworkApiServer interface {
	// Create a Network
	CreateNetwork(*Network, NetworkApi_CreateNetworkServer) error
	// Delete a Network
	DeleteNetwork(*Network, NetworkApi_DeleteNetworkServer) error
	// Update a Network
	UpdateNetwork(*Network, NetworkApi_UpdateNetworkServer) error
	// Show Networks. Any fields specified will be used to filter results.
	ShowNetwork(*Network, NetworkApi_ShowNetworkServer) error
}

// UnimplementedNetworkApiServer can be embedded to have forward compatible implementations.
type UnimplementedNetworkApiServer struct {
}

func (*UnimplementedNetworkApiServer) CreateNetwork(req *Network, srv NetworkApi_CreateNetworkServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateNetwork not implemented")
}
func (*UnimplementedNetworkApiServer) DeleteNetwork(req *Network, srv NetworkApi_DeleteNetworkServer) error {
	return status.Errorf(codes.Unimplemented, "method DeleteNetwork not implemented")
}
func (*UnimplementedNetworkApiServer) UpdateNetwork(req *Network, srv NetworkApi_UpdateNetworkServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateNetwork not implemented")
}
func (*UnimplementedNetworkApiServer) ShowNetwork(req *Network, srv NetworkApi_ShowNetworkServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowNetwork not implemented")
}

func RegisterNetworkApiServer(s *grpc.Server, srv NetworkApiServer) {
	s.RegisterService(&_NetworkApi_serviceDesc, srv)
}

func _NetworkApi_CreateNetwork_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Network)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetworkApiServer).CreateNetwork(m, &networkApiCreateNetworkServer{stream})
}

type NetworkApi_CreateNetworkServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type networkApiCreateNetworkServer struct {
	grpc.ServerStream
}

func (x *networkApiCreateNetworkServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _NetworkApi_DeleteNetwork_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Network)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetworkApiServer).DeleteNetwork(m, &networkApiDeleteNetworkServer{stream})
}

type NetworkApi_DeleteNetworkServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type networkApiDeleteNetworkServer struct {
	grpc.ServerStream
}

func (x *networkApiDeleteNetworkServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _NetworkApi_UpdateNetwork_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Network)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetworkApiServer).UpdateNetwork(m, &networkApiUpdateNetworkServer{stream})
}

type NetworkApi_UpdateNetworkServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type networkApiUpdateNetworkServer struct {
	grpc.ServerStream
}

func (x *networkApiUpdateNetworkServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _NetworkApi_ShowNetwork_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Network)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetworkApiServer).ShowNetwork(m, &networkApiShowNetworkServer{stream})
}

type NetworkApi_ShowNetworkServer interface {
	Send(*Network) error
	grpc.ServerStream
}

type networkApiShowNetworkServer struct {
	grpc.ServerStream
}

func (x *networkApiShowNetworkServer) Send(m *Network) error {
	return x.ServerStream.SendMsg(m)
}

var _NetworkApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.NetworkApi",
	HandlerType: (*NetworkApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreateNetwork",
			Handler:       _NetworkApi_CreateNetwork_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DeleteNetwork",
			Handler:       _NetworkApi_DeleteNetwork_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdateNetwork",
			Handler:       _NetworkApi_UpdateNetwork_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowNetwork",
			Handler:       _NetworkApi_ShowNetwork_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "network.proto",
}

func (m *Route) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Route) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NextHopIp) > 0 {
		i -= len(m.NextHopIp)
		copy(dAtA[i:], m.NextHopIp)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.NextHopIp)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DestinationCidr) > 0 {
		i -= len(m.DestinationCidr)
		copy(dAtA[i:], m.DestinationCidr)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.DestinationCidr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.CloudletKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintNetwork(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Network) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Network) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Network) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConnectionType != 0 {
		i = encodeVarintNetwork(dAtA, i, uint64(m.ConnectionType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetwork(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintNetwork(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintNetwork(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintNetwork(dAtA []byte, offset int, v uint64) int {
	offset -= sovNetwork(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Route) CopyInFields(src *Route) int {
	changed := 0
	if m.DestinationCidr != src.DestinationCidr {
		m.DestinationCidr = src.DestinationCidr
		changed++
	}
	if m.NextHopIp != src.NextHopIp {
		m.NextHopIp = src.NextHopIp
		changed++
	}
	return changed
}

func (m *Route) DeepCopyIn(src *Route) {
	m.DestinationCidr = src.DestinationCidr
	m.NextHopIp = src.NextHopIp
}

// Helper method to check that enums have valid values
func (m *Route) ValidateEnums() error {
	return nil
}

func (m *NetworkKey) Matches(o *NetworkKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.CloudletKey.Matches(&o.CloudletKey, fopts...) {
		return false
	}
	if !opts.Filter || o.Name != "" {
		if o.Name != m.Name {
			return false
		}
	}
	return true
}

func (m *NetworkKey) CopyInFields(src *NetworkKey) int {
	changed := 0
	if m.CloudletKey.Organization != src.CloudletKey.Organization {
		m.CloudletKey.Organization = src.CloudletKey.Organization
		changed++
	}
	if m.CloudletKey.Name != src.CloudletKey.Name {
		m.CloudletKey.Name = src.CloudletKey.Name
		changed++
	}
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	return changed
}

func (m *NetworkKey) DeepCopyIn(src *NetworkKey) {
	m.CloudletKey.DeepCopyIn(&src.CloudletKey)
	m.Name = src.Name
}

func (m *NetworkKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal NetworkKey key string", "obj", m)
	}
	return string(key)
}

func NetworkKeyStringParse(str string, key *NetworkKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal NetworkKey key string", "str", str)
	}
}

func (m *NetworkKey) NotFoundError() error {
	return fmt.Errorf("Network key %s not found", m.GetKeyString())
}

func (m *NetworkKey) ExistsError() error {
	return fmt.Errorf("Network key %s already exists", m.GetKeyString())
}

var NetworkKeyTagName = "network"

func (m *NetworkKey) GetTags() map[string]string {
	tags := make(map[string]string)
	tags["cloudletorg"] = m.CloudletKey.Organization
	tags["cloudlet"] = m.CloudletKey.Name
	tags["network"] = m.Name
	return tags
}

// Helper method to check that enums have valid values
func (m *NetworkKey) ValidateEnums() error {
	if err := m.CloudletKey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *Network) Matches(o *Network, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.Routes != nil {
		if len(m.Routes) == 0 && len(o.Routes) > 0 || len(m.Routes) > 0 && len(o.Routes) == 0 {
			return false
		} else if m.Routes != nil && o.Routes != nil {
			if !opts.Filter && len(m.Routes) != len(o.Routes) {
				return false
			}
		}
	}
	if !opts.Filter || o.ConnectionType != 0 {
		if o.ConnectionType != m.ConnectionType {
			return false
		}
	}
	return true
}

const NetworkFieldKey = "2"
const NetworkFieldKeyCloudletKey = "2.1"
const NetworkFieldKeyCloudletKeyOrganization = "2.1.1"
const NetworkFieldKeyCloudletKeyName = "2.1.2"
const NetworkFieldKeyName = "2.2"
const NetworkFieldRoutes = "3"
const NetworkFieldRoutesDestinationCidr = "3.1"
const NetworkFieldRoutesNextHopIp = "3.2"
const NetworkFieldConnectionType = "4"

var NetworkAllFields = []string{
	NetworkFieldKeyCloudletKeyOrganization,
	NetworkFieldKeyCloudletKeyName,
	NetworkFieldKeyName,
	NetworkFieldRoutesDestinationCidr,
	NetworkFieldRoutesNextHopIp,
	NetworkFieldConnectionType,
}

var NetworkAllFieldsMap = map[string]struct{}{
	NetworkFieldKeyCloudletKeyOrganization: struct{}{},
	NetworkFieldKeyCloudletKeyName:         struct{}{},
	NetworkFieldKeyName:                    struct{}{},
	NetworkFieldRoutesDestinationCidr:      struct{}{},
	NetworkFieldRoutesNextHopIp:            struct{}{},
	NetworkFieldConnectionType:             struct{}{},
}

var NetworkAllFieldsStringMap = map[string]string{
	NetworkFieldKeyCloudletKeyOrganization: "Key Cloudlet Key Organization",
	NetworkFieldKeyCloudletKeyName:         "Key Cloudlet Key Name",
	NetworkFieldKeyName:                    "Key Name",
	NetworkFieldRoutesDestinationCidr:      "Routes Destination Cidr",
	NetworkFieldRoutesNextHopIp:            "Routes Next Hop Ip",
	NetworkFieldConnectionType:             "Connection Type",
}

func (m *Network) IsKeyField(s string) bool {
	return strings.HasPrefix(s, NetworkFieldKey+".") || s == NetworkFieldKey
}

func (m *Network) DiffFields(o *Network, fields map[string]struct{}) {
	if m.Key.CloudletKey.Organization != o.Key.CloudletKey.Organization {
		fields[NetworkFieldKeyCloudletKeyOrganization] = struct{}{}
		fields[NetworkFieldKeyCloudletKey] = struct{}{}
		fields[NetworkFieldKey] = struct{}{}
	}
	if m.Key.CloudletKey.Name != o.Key.CloudletKey.Name {
		fields[NetworkFieldKeyCloudletKeyName] = struct{}{}
		fields[NetworkFieldKeyCloudletKey] = struct{}{}
		fields[NetworkFieldKey] = struct{}{}
	}
	if m.Key.Name != o.Key.Name {
		fields[NetworkFieldKeyName] = struct{}{}
		fields[NetworkFieldKey] = struct{}{}
	}
	if len(m.Routes) != len(o.Routes) {
		fields[NetworkFieldRoutes] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.Routes); i0++ {
			if m.Routes[i0].DestinationCidr != o.Routes[i0].DestinationCidr {
				fields[NetworkFieldRoutesDestinationCidr] = struct{}{}
				fields[NetworkFieldRoutes] = struct{}{}
			}
			if m.Routes[i0].NextHopIp != o.Routes[i0].NextHopIp {
				fields[NetworkFieldRoutesNextHopIp] = struct{}{}
				fields[NetworkFieldRoutes] = struct{}{}
			}
		}
	}
	if m.ConnectionType != o.ConnectionType {
		fields[NetworkFieldConnectionType] = struct{}{}
	}
}

var UpdateNetworkFieldsMap = map[string]struct{}{
	NetworkFieldRoutes:                struct{}{},
	NetworkFieldRoutesDestinationCidr: struct{}{},
	NetworkFieldRoutesNextHopIp:       struct{}{},
	NetworkFieldConnectionType:        struct{}{},
}

func (m *Network) ValidateUpdateFields() error {
	if m.Fields == nil {
		return fmt.Errorf("nothing specified to update")
	}
	fmap := MakeFieldMap(m.Fields)
	badFieldStrs := []string{}
	for field, _ := range fmap {
		if m.IsKeyField(field) {
			continue
		}
		if _, ok := UpdateNetworkFieldsMap[field]; !ok {
			if _, ok := NetworkAllFieldsStringMap[field]; !ok {
				continue
			}
			badFieldStrs = append(badFieldStrs, NetworkAllFieldsStringMap[field])
		}
	}
	if len(badFieldStrs) > 0 {
		return fmt.Errorf("specified field(s) %s cannot be modified", strings.Join(badFieldStrs, ","))
	}
	return nil
}

func (m *Network) CopyInFields(src *Network) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if _, set := fmap["2.1.1"]; set {
				if m.Key.CloudletKey.Organization != src.Key.CloudletKey.Organization {
					m.Key.CloudletKey.Organization = src.Key.CloudletKey.Organization
					changed++
				}
			}
			if _, set := fmap["2.1.2"]; set {
				if m.Key.CloudletKey.Name != src.Key.CloudletKey.Name {
					m.Key.CloudletKey.Name = src.Key.CloudletKey.Name
					changed++
				}
			}
		}
		if _, set := fmap["2.2"]; set {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
	}
	if _, set := fmap["3"]; set {
		if src.Routes != nil {
			m.Routes = src.Routes
			changed++
		} else if m.Routes != nil {
			m.Routes = nil
			changed++
		}
	}
	if _, set := fmap["4"]; set {
		if m.ConnectionType != src.ConnectionType {
			m.ConnectionType = src.ConnectionType
			changed++
		}
	}
	return changed
}

func (m *Network) DeepCopyIn(src *Network) {
	m.Key.DeepCopyIn(&src.Key)
	if src.Routes != nil {
		m.Routes = make([]Route, len(src.Routes), len(src.Routes))
		for ii, s := range src.Routes {
			m.Routes[ii].DeepCopyIn(&s)
		}
	} else {
		m.Routes = nil
	}
	m.ConnectionType = src.ConnectionType
}

func (s *Network) HasFields() bool {
	return true
}

type NetworkStore struct {
	kvstore objstore.KVStore
}

func NewNetworkStore(kvstore objstore.KVStore) NetworkStore {
	return NetworkStore{kvstore: kvstore}
}

func (s *NetworkStore) Create(ctx context.Context, m *Network, wait func(int64)) (*Result, error) {
	err := m.Validate(NetworkAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Network", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *NetworkStore) Update(ctx context.Context, m *Network, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Network", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur Network
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *NetworkStore) Put(ctx context.Context, m *Network, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(NetworkAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Network", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *NetworkStore) Delete(ctx context.Context, m *Network, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Network", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *NetworkStore) LoadOne(key string) (*Network, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj Network
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse Network data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *NetworkStore) STMGet(stm concurrency.STM, key *NetworkKey, buf *Network) bool {
	keystr := objstore.DbKeyString("Network", key)
	valstr := stm.Get(keystr)
	if valstr == "" {
		return false
	}
	if buf != nil {
		err := json.Unmarshal([]byte(valstr), buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *NetworkStore) STMPut(stm concurrency.STM, obj *Network, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("Network", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("Network json marsahal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *NetworkStore) STMDel(stm concurrency.STM, key *NetworkKey) {
	keystr := objstore.DbKeyString("Network", key)
	stm.Del(keystr)
}

type NetworkKeyWatcher struct {
	cb func(ctx context.Context)
}

type NetworkCacheData struct {
	Obj    *Network
	ModRev int64
}

// NetworkCache caches Network objects in memory in a hash table
// and keeps them in sync with the database.
type NetworkCache struct {
	Objs          map[NetworkKey]*NetworkCacheData
	Mux           util.Mutex
	List          map[NetworkKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *NetworkKey, old *Network, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *Network, new *Network)
	DeletedCbs    []func(ctx context.Context, old *Network)
	KeyWatchers   map[NetworkKey][]*NetworkKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *NetworkKey)
	DeletedKeyCbs []func(ctx context.Context, key *NetworkKey)
}

func NewNetworkCache() *NetworkCache {
	cache := NetworkCache{}
	InitNetworkCache(&cache)
	return &cache
}

func InitNetworkCache(cache *NetworkCache) {
	cache.Objs = make(map[NetworkKey]*NetworkCacheData)
	cache.KeyWatchers = make(map[NetworkKey][]*NetworkKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *NetworkCache) GetTypeString() string {
	return "Network"
}

func (c *NetworkCache) Get(key *NetworkKey, valbuf *Network) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *NetworkCache) GetWithRev(key *NetworkKey, valbuf *Network, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *NetworkCache) HasKey(key *NetworkKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *NetworkCache) GetAllKeys(ctx context.Context, cb func(key *NetworkKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *NetworkCache) Update(ctx context.Context, in *Network, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *Network) (*Network, bool) {
		return in, true
	})
}

func (c *NetworkCache) UpdateModFunc(ctx context.Context, key *NetworkKey, modRev int64, modFunc func(old *Network) (new *Network, changed bool)) {
	c.Mux.Lock()
	var old *Network
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	for _, cb := range c.UpdatedCbs {
		newCopy := &Network{}
		newCopy.DeepCopyIn(new)
		defer cb(ctx, old, newCopy)
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			defer cb(ctx, new.GetKey(), old, modRev)
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &Network{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &NetworkCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *NetworkCache) Delete(ctx context.Context, in *Network, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *Network) bool {
		return true
	})
}

func (c *NetworkCache) DeleteCondFunc(ctx context.Context, in *Network, modRev int64, condFunc func(old *Network) bool) {
	c.Mux.Lock()
	var old *Network
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	c.Mux.Unlock()
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, in.GetKey(), old, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *NetworkCache) Prune(ctx context.Context, validKeys map[NetworkKey]struct{}) {
	notify := make(map[NetworkKey]*NetworkCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, old.Obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *NetworkCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *NetworkCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *NetworkCache) Show(filter *Network, cb func(ret *Network) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func NetworkGenericNotifyCb(fn func(key *NetworkKey, old *Network)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*NetworkKey), obj.(*Network))
	}
}

func (c *NetworkCache) SetNotifyCb(fn func(ctx context.Context, obj *NetworkKey, old *Network, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *NetworkKey, old *Network, modRev int64){fn}
}

func (c *NetworkCache) SetUpdatedCb(fn func(ctx context.Context, old *Network, new *Network)) {
	c.UpdatedCbs = []func(ctx context.Context, old *Network, new *Network){fn}
}

func (c *NetworkCache) SetDeletedCb(fn func(ctx context.Context, old *Network)) {
	c.DeletedCbs = []func(ctx context.Context, old *Network){fn}
}

func (c *NetworkCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *NetworkKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *NetworkKey){fn}
}

func (c *NetworkCache) SetDeletedKeyCb(fn func(ctx context.Context, key *NetworkKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *NetworkKey){fn}
}

func (c *NetworkCache) AddUpdatedCb(fn func(ctx context.Context, old *Network, new *Network)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *NetworkCache) AddDeletedCb(fn func(ctx context.Context, old *Network)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *NetworkCache) AddNotifyCb(fn func(ctx context.Context, obj *NetworkKey, old *Network, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *NetworkCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *NetworkKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *NetworkCache) AddDeletedKeyCb(fn func(ctx context.Context, key *NetworkKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *NetworkCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *NetworkCache) WatchKey(key *NetworkKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*NetworkKeyWatcher, 0)
	}
	watcher := NetworkKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching Network", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *NetworkCache) TriggerKeyWatchers(ctx context.Context, key *NetworkKey) {
	watchers := make([]*NetworkKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *NetworkCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := Network{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse Network data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *NetworkCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := Network{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	NetworkKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *NetworkCache) SyncListStart(ctx context.Context) {
	c.List = make(map[NetworkKey]struct{})
}

func (c *NetworkCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[NetworkKey]*NetworkCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, val.Obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *NetworkCache) UsesOrg(org string) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		if key.CloudletKey.Organization == org {
			return true
		}
	}
	return false
}

func (m *Network) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *Network) GetKey() *NetworkKey {
	return &m.Key
}

func (m *Network) GetKeyVal() NetworkKey {
	return m.Key
}

func (m *Network) SetKey(key *NetworkKey) {
	m.Key = *key
}

func CmpSortNetwork(a Network, b Network) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *Network) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.Routes {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if _, ok := NetworkConnectionType_name[int32(m.ConnectionType)]; !ok {
		return errors.New("invalid ConnectionType")
	}
	return nil
}

var NetworkConnectionTypeStrings = []string{
	"UNDEFINED",
	"CONNECT_TO_LOAD_BALANCER",
	"CONNECT_TO_CLUSTER_NODES",
	"CONNECT_TO_ALL",
}

const (
	NetworkConnectionTypeUNDEFINED                uint64 = 1 << 0
	NetworkConnectionTypeCONNECT_TO_LOAD_BALANCER uint64 = 1 << 1
	NetworkConnectionTypeCONNECT_TO_CLUSTER_NODES uint64 = 1 << 2
	NetworkConnectionTypeCONNECT_TO_ALL           uint64 = 1 << 3
)

var NetworkConnectionType_CamelName = map[int32]string{
	// UNDEFINED -> Undefined
	0: "Undefined",
	// CONNECT_TO_LOAD_BALANCER -> ConnectToLoadBalancer
	1: "ConnectToLoadBalancer",
	// CONNECT_TO_CLUSTER_NODES -> ConnectToClusterNodes
	2: "ConnectToClusterNodes",
	// CONNECT_TO_ALL -> ConnectToAll
	3: "ConnectToAll",
}
var NetworkConnectionType_CamelValue = map[string]int32{
	"Undefined":             0,
	"ConnectToLoadBalancer": 1,
	"ConnectToClusterNodes": 2,
	"ConnectToAll":          3,
}

func (e *NetworkConnectionType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := NetworkConnectionType_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = NetworkConnectionType_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = NetworkConnectionType(val)
	return nil
}

func (e NetworkConnectionType) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(NetworkConnectionType_CamelName, int32(e))
	return str, nil
}

// custom JSON encoding/decoding
func (e *NetworkConnectionType) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := NetworkConnectionType_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = NetworkConnectionType_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = NetworkConnectionType(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = NetworkConnectionType(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

/*
 * This is removed because we do not have enough time in
 * release 3.0 to update the SDK, UI, and documentation for this
 * change. It should be done in 3.1.
func (e NetworkConnectionType) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(NetworkConnectionType_CamelName, int32(e))
	return json.Marshal(str)
}
*/
func (m *Network) IsValidArgsForCreateNetwork() error {
	return nil
}

func (m *Network) IsValidArgsForDeleteNetwork() error {
	return nil
}

func (m *Network) IsValidArgsForUpdateNetwork() error {
	return nil
}

func (m *Route) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DestinationCidr)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	l = len(m.NextHopIp)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	return n
}

func (m *NetworkKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CloudletKey.Size()
	n += 1 + l + sovNetwork(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	return n
}

func (m *Network) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovNetwork(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovNetwork(uint64(l))
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovNetwork(uint64(l))
		}
	}
	if m.ConnectionType != 0 {
		n += 1 + sovNetwork(uint64(m.ConnectionType))
	}
	return n
}

func sovNetwork(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNetwork(x uint64) (n int) {
	return sovNetwork(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Route) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationCidr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationCidr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHopIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextHopIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CloudletKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Network) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Network: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Network: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, Route{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionType", wireType)
			}
			m.ConnectionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectionType |= NetworkConnectionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNetwork(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNetwork
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNetwork
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNetwork
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNetwork        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNetwork          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNetwork = fmt.Errorf("proto: unexpected end of group")
)
