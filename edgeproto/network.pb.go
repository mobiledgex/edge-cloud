// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: network.proto

package edgeproto

import (
	context "context"
	"encoding/json"
	fmt "fmt"
	"github.com/coreos/etcd/clientv3/concurrency"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/mobiledgex/edge-cloud/log"
	"github.com/mobiledgex/edge-cloud/objstore"
	_ "github.com/mobiledgex/edge-cloud/protogen"
	"github.com/mobiledgex/edge-cloud/util"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Route struct {
	// destination CIDR
	DestinationCidr string `protobuf:"bytes,1,opt,name=destination_cidr,json=destinationCidr,proto3" json:"destination_cidr,omitempty"`
	// next hop IP
	NextHopIp string `protobuf:"bytes,2,opt,name=next_hop_ip,json=nextHopIp,proto3" json:"next_hop_ip,omitempty"`
}

func (m *Route) Reset()         { *m = Route{} }
func (m *Route) String() string { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()    {}
func (*Route) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{0}
}
func (m *Route) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Route) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Route.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Route) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Route.Merge(m, src)
}
func (m *Route) XXX_Size() int {
	return m.Size()
}
func (m *Route) XXX_DiscardUnknown() {
	xxx_messageInfo_Route.DiscardUnknown(m)
}

var xxx_messageInfo_Route proto.InternalMessageInfo

type NetworkKey struct {
	// Name of the organization for the cloudlet that this network can be provisioned on
	Organization string `protobuf:"bytes,1,opt,name=organization,proto3" json:"organization,omitempty"`
	// Network Name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *NetworkKey) Reset()         { *m = NetworkKey{} }
func (m *NetworkKey) String() string { return proto.CompactTextString(m) }
func (*NetworkKey) ProtoMessage()    {}
func (*NetworkKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{1}
}
func (m *NetworkKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkKey.Merge(m, src)
}
func (m *NetworkKey) XXX_Size() int {
	return m.Size()
}
func (m *NetworkKey) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkKey.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkKey proto.InternalMessageInfo

// TrustPolicy defines security restrictions for cluster instances
// nodes scaled up or down.
type Network struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique identifier key
	Key NetworkKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// list of routes
	Routes []Route `protobuf:"bytes,3,rep,name=routes,proto3" json:"routes"`
}

func (m *Network) Reset()         { *m = Network{} }
func (m *Network) String() string { return proto.CompactTextString(m) }
func (*Network) ProtoMessage()    {}
func (*Network) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{2}
}
func (m *Network) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Network) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Network.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Network) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Network.Merge(m, src)
}
func (m *Network) XXX_Size() int {
	return m.Size()
}
func (m *Network) XXX_DiscardUnknown() {
	xxx_messageInfo_Network.DiscardUnknown(m)
}

var xxx_messageInfo_Network proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Route)(nil), "edgeproto.Route")
	proto.RegisterType((*NetworkKey)(nil), "edgeproto.NetworkKey")
	proto.RegisterType((*Network)(nil), "edgeproto.Network")
}

func init() { proto.RegisterFile("network.proto", fileDescriptor_8571034d60397816) }

var fileDescriptor_8571034d60397816 = []byte{
	// 609 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x92, 0xbf, 0x6f, 0xd3, 0x4e,
	0x18, 0xc6, 0x73, 0x4d, 0xbf, 0xad, 0x72, 0x69, 0xbe, 0x0d, 0xa7, 0x82, 0x4e, 0x55, 0xe5, 0x56,
	0x9e, 0x0a, 0x24, 0x36, 0x0a, 0x0b, 0xaa, 0xd4, 0xa1, 0x09, 0x03, 0x55, 0x45, 0x11, 0x46, 0xb0,
	0x30, 0x44, 0x8e, 0xfd, 0xe2, 0x9c, 0xe2, 0xf8, 0x2c, 0xff, 0x50, 0x1a, 0x26, 0xd4, 0x95, 0xa5,
	0x12, 0x0b, 0x62, 0x81, 0x11, 0x31, 0x55, 0x8c, 0xfd, 0x0b, 0xb2, 0x51, 0x89, 0x85, 0x05, 0x04,
	0x09, 0x03, 0xea, 0x84, 0x14, 0x37, 0x62, 0x44, 0xbe, 0x98, 0x90, 0xb4, 0x05, 0x09, 0x06, 0x96,
	0xe8, 0xbd, 0x27, 0xcf, 0xbd, 0xcf, 0xe7, 0x7d, 0xcf, 0x38, 0xe7, 0x40, 0xd0, 0xe2, 0x5e, 0x43,
	0x71, 0x3d, 0x1e, 0x70, 0x92, 0x01, 0xd3, 0x02, 0x51, 0x2e, 0x2e, 0x59, 0x9c, 0x5b, 0x36, 0xa8,
	0xba, 0xcb, 0x54, 0xdd, 0x71, 0x78, 0xa0, 0x07, 0x8c, 0x3b, 0xfe, 0xd0, 0xb8, 0x38, 0xe7, 0x81,
	0x1f, 0xda, 0x41, 0x72, 0xba, 0x66, 0xb1, 0xa0, 0x1e, 0xd6, 0x14, 0x83, 0x37, 0xd5, 0x26, 0xaf,
	0x31, 0x3b, 0x6e, 0xb3, 0xa3, 0xc6, 0xbf, 0x45, 0xc3, 0xe6, 0xa1, 0xa9, 0x0a, 0x9f, 0x05, 0xce,
	0xa8, 0x48, 0x6e, 0x2e, 0x58, 0xdc, 0xe2, 0xa2, 0x54, 0xe3, 0x6a, 0xa8, 0xca, 0x1a, 0xfe, 0x4f,
	0xe3, 0x61, 0x00, 0xe4, 0x22, 0xce, 0x9b, 0xe0, 0x07, 0xcc, 0x11, 0xe1, 0x55, 0x83, 0x99, 0x1e,
	0x45, 0x2b, 0x68, 0x35, 0xa3, 0xcd, 0x8f, 0xe9, 0x15, 0x66, 0x7a, 0x44, 0xc2, 0x59, 0x07, 0x76,
	0x82, 0x6a, 0x9d, 0xbb, 0x55, 0xe6, 0xd2, 0x29, 0xe1, 0xca, 0xc4, 0xd2, 0x0d, 0xee, 0x6e, 0xba,
	0x32, 0xc7, 0x78, 0x7b, 0x38, 0xeb, 0x16, 0xb4, 0x49, 0x09, 0xcf, 0x71, 0xcf, 0xd2, 0x1d, 0xf6,
	0x50, 0x74, 0x18, 0x36, 0x2d, 0xff, 0x7f, 0x30, 0xa0, 0x38, 0xd9, 0x08, 0xf7, 0x2c, 0x6d, 0xc2,
	0x43, 0x96, 0xf1, 0xb4, 0xa3, 0x37, 0x61, 0xd8, 0xba, 0x9c, 0x3d, 0x18, 0xd0, 0xd9, 0xc4, 0xab,
	0x89, 0x3f, 0xd6, 0xe6, 0xbe, 0xf4, 0x29, 0xfa, 0xd6, 0xa7, 0x68, 0xff, 0xc5, 0x32, 0x92, 0xdf,
	0x23, 0x3c, 0x9b, 0x24, 0x92, 0x0b, 0x78, 0xe6, 0x01, 0x03, 0xdb, 0xf4, 0x29, 0x5a, 0x49, 0xaf,
	0x66, 0xb4, 0xe4, 0x44, 0x8a, 0x38, 0xdd, 0x80, 0xb6, 0xe8, 0x98, 0x2d, 0x9d, 0x57, 0x46, 0xdb,
	0x57, 0x7e, 0xa2, 0x96, 0xa7, 0x3b, 0x1f, 0x96, 0x53, 0x5a, 0xec, 0x23, 0x0a, 0x9e, 0xf1, 0xe2,
	0xbd, 0xf8, 0x34, 0xbd, 0x92, 0x5e, 0xcd, 0x96, 0xf2, 0x63, 0x37, 0xc4, 0xc2, 0x12, 0x73, 0xe2,
	0x5a, 0xbb, 0x1f, 0x03, 0x7d, 0xed, 0x53, 0xf4, 0x28, 0xa2, 0x68, 0x2f, 0xa2, 0xe8, 0x69, 0x44,
	0xd1, 0x7e, 0x44, 0xd1, 0xb3, 0x63, 0x7a, 0x39, 0x46, 0x5e, 0xdf, 0x82, 0xb6, 0xb2, 0xad, 0x37,
	0xa1, 0x20, 0x9e, 0xc9, 0x86, 0xa0, 0xc8, 0x3d, 0x4b, 0xa8, 0xb7, 0xc6, 0x46, 0x7f, 0x3d, 0xa0,
	0xf9, 0x06, 0xb4, 0xd7, 0xc7, 0xb5, 0xd2, 0x9b, 0xe9, 0xd1, 0x46, 0x37, 0x5c, 0x46, 0x9e, 0x23,
	0x9c, 0xab, 0x78, 0xa0, 0x07, 0xf0, 0x63, 0x68, 0x72, 0x7a, 0x9e, 0xc5, 0x73, 0xe3, 0xc4, 0xe2,
	0x13, 0x92, 0xe1, 0x28, 0xa2, 0xaa, 0x06, 0x3e, 0x0f, 0x3d, 0x03, 0x2a, 0x09, 0x86, 0x5f, 0xd8,
	0x30, 0xe2, 0x94, 0x9b, 0xba, 0xa3, 0x5b, 0x50, 0x38, 0x09, 0xf4, 0xf2, 0x98, 0xa2, 0x57, 0x03,
	0x9a, 0x3f, 0xa9, 0xef, 0xbe, 0xfd, 0xfc, 0x64, 0x6a, 0x41, 0x9e, 0x57, 0x0d, 0x41, 0xa2, 0x26,
	0xef, 0xb3, 0x86, 0x2e, 0x5d, 0x41, 0xe4, 0x31, 0xc2, 0xb9, 0xeb, 0x60, 0xc3, 0x1f, 0x13, 0xde,
	0xfe, 0x4b, 0xc2, 0x11, 0x8d, 0x29, 0x52, 0x4f, 0xd3, 0xdc, 0x75, 0x4d, 0xfd, 0xdf, 0xd3, 0x84,
	0x22, 0x75, 0x92, 0x66, 0x17, 0xe1, 0xec, 0x9d, 0x3a, 0x6f, 0xfd, 0x8e, 0xe5, 0x0c, 0x4d, 0xde,
	0x3c, 0x8a, 0x68, 0xf1, 0x57, 0x30, 0xf7, 0x18, 0xb4, 0x0a, 0x67, 0x3e, 0x11, 0x91, 0x73, 0xaa,
	0x5f, 0xe7, 0xad, 0x09, 0x88, 0xf2, 0x52, 0xe7, 0x93, 0x94, 0xea, 0x74, 0x25, 0x74, 0xd8, 0x95,
	0xd0, 0xc7, 0xae, 0x84, 0xf6, 0x7a, 0x52, 0xea, 0xb0, 0x27, 0xa5, 0xde, 0xf5, 0xa4, 0x54, 0x6d,
	0x46, 0x24, 0x5f, 0xfd, 0x1e, 0x00, 0x00, 0xff, 0xff, 0xaf, 0x6e, 0xdd, 0x15, 0xb3, 0x04, 0x00,
	0x00,
}

func (this *NetworkKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&edgeproto.NetworkKey{")
	s = append(s, "Organization: "+fmt.Sprintf("%#v", this.Organization)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringNetwork(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NetworkApiClient is the client API for NetworkApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NetworkApiClient interface {
	// Create a Network
	CreateNetwork(ctx context.Context, in *Network, opts ...grpc.CallOption) (NetworkApi_CreateNetworkClient, error)
	// Delete a Trust policy
	DeleteNetwork(ctx context.Context, in *Network, opts ...grpc.CallOption) (NetworkApi_DeleteNetworkClient, error)
	// Update a Trust policy
	UpdateNetwork(ctx context.Context, in *Network, opts ...grpc.CallOption) (NetworkApi_UpdateNetworkClient, error)
	// Show Trust Policies. Any fields specified will be used to filter results.
	ShowNetwork(ctx context.Context, in *Network, opts ...grpc.CallOption) (NetworkApi_ShowNetworkClient, error)
}

type networkApiClient struct {
	cc *grpc.ClientConn
}

func NewNetworkApiClient(cc *grpc.ClientConn) NetworkApiClient {
	return &networkApiClient{cc}
}

func (c *networkApiClient) CreateNetwork(ctx context.Context, in *Network, opts ...grpc.CallOption) (NetworkApi_CreateNetworkClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NetworkApi_serviceDesc.Streams[0], "/edgeproto.NetworkApi/CreateNetwork", opts...)
	if err != nil {
		return nil, err
	}
	x := &networkApiCreateNetworkClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NetworkApi_CreateNetworkClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type networkApiCreateNetworkClient struct {
	grpc.ClientStream
}

func (x *networkApiCreateNetworkClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *networkApiClient) DeleteNetwork(ctx context.Context, in *Network, opts ...grpc.CallOption) (NetworkApi_DeleteNetworkClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NetworkApi_serviceDesc.Streams[1], "/edgeproto.NetworkApi/DeleteNetwork", opts...)
	if err != nil {
		return nil, err
	}
	x := &networkApiDeleteNetworkClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NetworkApi_DeleteNetworkClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type networkApiDeleteNetworkClient struct {
	grpc.ClientStream
}

func (x *networkApiDeleteNetworkClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *networkApiClient) UpdateNetwork(ctx context.Context, in *Network, opts ...grpc.CallOption) (NetworkApi_UpdateNetworkClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NetworkApi_serviceDesc.Streams[2], "/edgeproto.NetworkApi/UpdateNetwork", opts...)
	if err != nil {
		return nil, err
	}
	x := &networkApiUpdateNetworkClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NetworkApi_UpdateNetworkClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type networkApiUpdateNetworkClient struct {
	grpc.ClientStream
}

func (x *networkApiUpdateNetworkClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *networkApiClient) ShowNetwork(ctx context.Context, in *Network, opts ...grpc.CallOption) (NetworkApi_ShowNetworkClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NetworkApi_serviceDesc.Streams[3], "/edgeproto.NetworkApi/ShowNetwork", opts...)
	if err != nil {
		return nil, err
	}
	x := &networkApiShowNetworkClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NetworkApi_ShowNetworkClient interface {
	Recv() (*Network, error)
	grpc.ClientStream
}

type networkApiShowNetworkClient struct {
	grpc.ClientStream
}

func (x *networkApiShowNetworkClient) Recv() (*Network, error) {
	m := new(Network)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NetworkApiServer is the server API for NetworkApi service.
type NetworkApiServer interface {
	// Create a Network
	CreateNetwork(*Network, NetworkApi_CreateNetworkServer) error
	// Delete a Trust policy
	DeleteNetwork(*Network, NetworkApi_DeleteNetworkServer) error
	// Update a Trust policy
	UpdateNetwork(*Network, NetworkApi_UpdateNetworkServer) error
	// Show Trust Policies. Any fields specified will be used to filter results.
	ShowNetwork(*Network, NetworkApi_ShowNetworkServer) error
}

// UnimplementedNetworkApiServer can be embedded to have forward compatible implementations.
type UnimplementedNetworkApiServer struct {
}

func (*UnimplementedNetworkApiServer) CreateNetwork(req *Network, srv NetworkApi_CreateNetworkServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateNetwork not implemented")
}
func (*UnimplementedNetworkApiServer) DeleteNetwork(req *Network, srv NetworkApi_DeleteNetworkServer) error {
	return status.Errorf(codes.Unimplemented, "method DeleteNetwork not implemented")
}
func (*UnimplementedNetworkApiServer) UpdateNetwork(req *Network, srv NetworkApi_UpdateNetworkServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateNetwork not implemented")
}
func (*UnimplementedNetworkApiServer) ShowNetwork(req *Network, srv NetworkApi_ShowNetworkServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowNetwork not implemented")
}

func RegisterNetworkApiServer(s *grpc.Server, srv NetworkApiServer) {
	s.RegisterService(&_NetworkApi_serviceDesc, srv)
}

func _NetworkApi_CreateNetwork_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Network)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetworkApiServer).CreateNetwork(m, &networkApiCreateNetworkServer{stream})
}

type NetworkApi_CreateNetworkServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type networkApiCreateNetworkServer struct {
	grpc.ServerStream
}

func (x *networkApiCreateNetworkServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _NetworkApi_DeleteNetwork_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Network)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetworkApiServer).DeleteNetwork(m, &networkApiDeleteNetworkServer{stream})
}

type NetworkApi_DeleteNetworkServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type networkApiDeleteNetworkServer struct {
	grpc.ServerStream
}

func (x *networkApiDeleteNetworkServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _NetworkApi_UpdateNetwork_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Network)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetworkApiServer).UpdateNetwork(m, &networkApiUpdateNetworkServer{stream})
}

type NetworkApi_UpdateNetworkServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type networkApiUpdateNetworkServer struct {
	grpc.ServerStream
}

func (x *networkApiUpdateNetworkServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _NetworkApi_ShowNetwork_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Network)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetworkApiServer).ShowNetwork(m, &networkApiShowNetworkServer{stream})
}

type NetworkApi_ShowNetworkServer interface {
	Send(*Network) error
	grpc.ServerStream
}

type networkApiShowNetworkServer struct {
	grpc.ServerStream
}

func (x *networkApiShowNetworkServer) Send(m *Network) error {
	return x.ServerStream.SendMsg(m)
}

var _NetworkApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.NetworkApi",
	HandlerType: (*NetworkApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreateNetwork",
			Handler:       _NetworkApi_CreateNetwork_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DeleteNetwork",
			Handler:       _NetworkApi_DeleteNetwork_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdateNetwork",
			Handler:       _NetworkApi_UpdateNetwork_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowNetwork",
			Handler:       _NetworkApi_ShowNetwork_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "network.proto",
}

func (m *Route) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Route) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NextHopIp) > 0 {
		i -= len(m.NextHopIp)
		copy(dAtA[i:], m.NextHopIp)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.NextHopIp)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DestinationCidr) > 0 {
		i -= len(m.DestinationCidr)
		copy(dAtA[i:], m.DestinationCidr)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.DestinationCidr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Network) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Network) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Network) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetwork(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintNetwork(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintNetwork(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintNetwork(dAtA []byte, offset int, v uint64) int {
	offset -= sovNetwork(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Route) CopyInFields(src *Route) int {
	changed := 0
	if m.DestinationCidr != src.DestinationCidr {
		m.DestinationCidr = src.DestinationCidr
		changed++
	}
	if m.NextHopIp != src.NextHopIp {
		m.NextHopIp = src.NextHopIp
		changed++
	}
	return changed
}

func (m *Route) DeepCopyIn(src *Route) {
	m.DestinationCidr = src.DestinationCidr
	m.NextHopIp = src.NextHopIp
}

// Helper method to check that enums have valid values
func (m *Route) ValidateEnums() error {
	return nil
}

func (m *NetworkKey) Matches(o *NetworkKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.Organization != "" {
		if o.Organization != m.Organization {
			return false
		}
	}
	if !opts.Filter || o.Name != "" {
		if o.Name != m.Name {
			return false
		}
	}
	return true
}

func (m *NetworkKey) CopyInFields(src *NetworkKey) int {
	changed := 0
	if m.Organization != src.Organization {
		m.Organization = src.Organization
		changed++
	}
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	return changed
}

func (m *NetworkKey) DeepCopyIn(src *NetworkKey) {
	m.Organization = src.Organization
	m.Name = src.Name
}

func (m *NetworkKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal NetworkKey key string", "obj", m)
	}
	return string(key)
}

func NetworkKeyStringParse(str string, key *NetworkKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal NetworkKey key string", "str", str)
	}
}

func (m *NetworkKey) NotFoundError() error {
	return fmt.Errorf("Network key %s not found", m.GetKeyString())
}

func (m *NetworkKey) ExistsError() error {
	return fmt.Errorf("Network key %s already exists", m.GetKeyString())
}

var NetworkKeyTagOrganization = "networkorg"
var NetworkKeyTagName = "network"

func (m *NetworkKey) GetTags() map[string]string {
	tags := make(map[string]string)
	tags["networkorg"] = m.Organization
	tags["network"] = m.Name
	return tags
}

// Helper method to check that enums have valid values
func (m *NetworkKey) ValidateEnums() error {
	return nil
}

func (m *Network) Matches(o *Network, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.Routes != nil {
		if len(m.Routes) == 0 && len(o.Routes) > 0 || len(m.Routes) > 0 && len(o.Routes) == 0 {
			return false
		} else if m.Routes != nil && o.Routes != nil {
			if !opts.Filter && len(m.Routes) != len(o.Routes) {
				return false
			}
		}
	}
	return true
}

const NetworkFieldKey = "2"
const NetworkFieldKeyOrganization = "2.1"
const NetworkFieldKeyName = "2.2"
const NetworkFieldRoutes = "3"
const NetworkFieldRoutesDestinationCidr = "3.1"
const NetworkFieldRoutesNextHopIp = "3.2"

var NetworkAllFields = []string{
	NetworkFieldKeyOrganization,
	NetworkFieldKeyName,
	NetworkFieldRoutesDestinationCidr,
	NetworkFieldRoutesNextHopIp,
}

var NetworkAllFieldsMap = map[string]struct{}{
	NetworkFieldKeyOrganization:       struct{}{},
	NetworkFieldKeyName:               struct{}{},
	NetworkFieldRoutesDestinationCidr: struct{}{},
	NetworkFieldRoutesNextHopIp:       struct{}{},
}

var NetworkAllFieldsStringMap = map[string]string{
	NetworkFieldKeyOrganization:       "Key Organization",
	NetworkFieldKeyName:               "Key Name",
	NetworkFieldRoutesDestinationCidr: "Routes Destination Cidr",
	NetworkFieldRoutesNextHopIp:       "Routes Next Hop Ip",
}

func (m *Network) IsKeyField(s string) bool {
	return strings.HasPrefix(s, NetworkFieldKey+".") || s == NetworkFieldKey
}

func (m *Network) DiffFields(o *Network, fields map[string]struct{}) {
	if m.Key.Organization != o.Key.Organization {
		fields[NetworkFieldKeyOrganization] = struct{}{}
		fields[NetworkFieldKey] = struct{}{}
	}
	if m.Key.Name != o.Key.Name {
		fields[NetworkFieldKeyName] = struct{}{}
		fields[NetworkFieldKey] = struct{}{}
	}
	if len(m.Routes) != len(o.Routes) {
		fields[NetworkFieldRoutes] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.Routes); i0++ {
			if m.Routes[i0].DestinationCidr != o.Routes[i0].DestinationCidr {
				fields[NetworkFieldRoutesDestinationCidr] = struct{}{}
				fields[NetworkFieldRoutes] = struct{}{}
			}
			if m.Routes[i0].NextHopIp != o.Routes[i0].NextHopIp {
				fields[NetworkFieldRoutesNextHopIp] = struct{}{}
				fields[NetworkFieldRoutes] = struct{}{}
			}
		}
	}
}

var UpdateNetworkFieldsMap = map[string]struct{}{
	NetworkFieldRoutes:                struct{}{},
	NetworkFieldRoutesDestinationCidr: struct{}{},
	NetworkFieldRoutesNextHopIp:       struct{}{},
}

func (m *Network) ValidateUpdateFields() error {
	if m.Fields == nil {
		return fmt.Errorf("nothing specified to update")
	}
	fmap := MakeFieldMap(m.Fields)
	badFieldStrs := []string{}
	for field, _ := range fmap {
		if m.IsKeyField(field) {
			continue
		}
		if _, ok := UpdateNetworkFieldsMap[field]; !ok {
			if _, ok := NetworkAllFieldsStringMap[field]; !ok {
				continue
			}
			badFieldStrs = append(badFieldStrs, NetworkAllFieldsStringMap[field])
		}
	}
	if len(badFieldStrs) > 0 {
		return fmt.Errorf("specified field(s) %s cannot be modified", strings.Join(badFieldStrs, ","))
	}
	return nil
}

func (m *Network) CopyInFields(src *Network) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
		if _, set := fmap["2.2"]; set {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
	}
	if _, set := fmap["3"]; set {
		if src.Routes != nil {
			m.Routes = src.Routes
			changed++
		} else if m.Routes != nil {
			m.Routes = nil
			changed++
		}
	}
	return changed
}

func (m *Network) DeepCopyIn(src *Network) {
	m.Key.DeepCopyIn(&src.Key)
	if src.Routes != nil {
		m.Routes = make([]Route, len(src.Routes), len(src.Routes))
		for ii, s := range src.Routes {
			m.Routes[ii].DeepCopyIn(&s)
		}
	} else {
		m.Routes = nil
	}
}

func (s *Network) HasFields() bool {
	return true
}

type NetworkStore struct {
	kvstore objstore.KVStore
}

func NewNetworkStore(kvstore objstore.KVStore) NetworkStore {
	return NetworkStore{kvstore: kvstore}
}

func (s *NetworkStore) Create(ctx context.Context, m *Network, wait func(int64)) (*Result, error) {
	err := m.Validate(NetworkAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Network", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *NetworkStore) Update(ctx context.Context, m *Network, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Network", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur Network
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *NetworkStore) Put(ctx context.Context, m *Network, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(NetworkAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Network", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *NetworkStore) Delete(ctx context.Context, m *Network, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Network", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *NetworkStore) LoadOne(key string) (*Network, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj Network
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse Network data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *NetworkStore) STMGet(stm concurrency.STM, key *NetworkKey, buf *Network) bool {
	keystr := objstore.DbKeyString("Network", key)
	valstr := stm.Get(keystr)
	if valstr == "" {
		return false
	}
	if buf != nil {
		err := json.Unmarshal([]byte(valstr), buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *NetworkStore) STMPut(stm concurrency.STM, obj *Network, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("Network", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("Network json marsahal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *NetworkStore) STMDel(stm concurrency.STM, key *NetworkKey) {
	keystr := objstore.DbKeyString("Network", key)
	stm.Del(keystr)
}

type NetworkKeyWatcher struct {
	cb func(ctx context.Context)
}

type NetworkCacheData struct {
	Obj    *Network
	ModRev int64
}

// NetworkCache caches Network objects in memory in a hash table
// and keeps them in sync with the database.
type NetworkCache struct {
	Objs          map[NetworkKey]*NetworkCacheData
	Mux           util.Mutex
	List          map[NetworkKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *NetworkKey, old *Network, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *Network, new *Network)
	DeletedCbs    []func(ctx context.Context, old *Network)
	KeyWatchers   map[NetworkKey][]*NetworkKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *NetworkKey)
	DeletedKeyCbs []func(ctx context.Context, key *NetworkKey)
}

func NewNetworkCache() *NetworkCache {
	cache := NetworkCache{}
	InitNetworkCache(&cache)
	return &cache
}

func InitNetworkCache(cache *NetworkCache) {
	cache.Objs = make(map[NetworkKey]*NetworkCacheData)
	cache.KeyWatchers = make(map[NetworkKey][]*NetworkKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *NetworkCache) GetTypeString() string {
	return "Network"
}

func (c *NetworkCache) Get(key *NetworkKey, valbuf *Network) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *NetworkCache) GetWithRev(key *NetworkKey, valbuf *Network, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *NetworkCache) HasKey(key *NetworkKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *NetworkCache) GetAllKeys(ctx context.Context, cb func(key *NetworkKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *NetworkCache) Update(ctx context.Context, in *Network, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *Network) (*Network, bool) {
		return in, true
	})
}

func (c *NetworkCache) UpdateModFunc(ctx context.Context, key *NetworkKey, modRev int64, modFunc func(old *Network) (new *Network, changed bool)) {
	c.Mux.Lock()
	var old *Network
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	for _, cb := range c.UpdatedCbs {
		newCopy := &Network{}
		newCopy.DeepCopyIn(new)
		defer cb(ctx, old, newCopy)
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			defer cb(ctx, new.GetKey(), old, modRev)
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &Network{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &NetworkCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *NetworkCache) Delete(ctx context.Context, in *Network, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *Network) bool {
		return true
	})
}

func (c *NetworkCache) DeleteCondFunc(ctx context.Context, in *Network, modRev int64, condFunc func(old *Network) bool) {
	c.Mux.Lock()
	var old *Network
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	c.Mux.Unlock()
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, in.GetKey(), old, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *NetworkCache) Prune(ctx context.Context, validKeys map[NetworkKey]struct{}) {
	notify := make(map[NetworkKey]*NetworkCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, old.Obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *NetworkCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *NetworkCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *NetworkCache) Show(filter *Network, cb func(ret *Network) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func NetworkGenericNotifyCb(fn func(key *NetworkKey, old *Network)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*NetworkKey), obj.(*Network))
	}
}

func (c *NetworkCache) SetNotifyCb(fn func(ctx context.Context, obj *NetworkKey, old *Network, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *NetworkKey, old *Network, modRev int64){fn}
}

func (c *NetworkCache) SetUpdatedCb(fn func(ctx context.Context, old *Network, new *Network)) {
	c.UpdatedCbs = []func(ctx context.Context, old *Network, new *Network){fn}
}

func (c *NetworkCache) SetDeletedCb(fn func(ctx context.Context, old *Network)) {
	c.DeletedCbs = []func(ctx context.Context, old *Network){fn}
}

func (c *NetworkCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *NetworkKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *NetworkKey){fn}
}

func (c *NetworkCache) SetDeletedKeyCb(fn func(ctx context.Context, key *NetworkKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *NetworkKey){fn}
}

func (c *NetworkCache) AddUpdatedCb(fn func(ctx context.Context, old *Network, new *Network)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *NetworkCache) AddDeletedCb(fn func(ctx context.Context, old *Network)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *NetworkCache) AddNotifyCb(fn func(ctx context.Context, obj *NetworkKey, old *Network, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *NetworkCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *NetworkKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *NetworkCache) AddDeletedKeyCb(fn func(ctx context.Context, key *NetworkKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *NetworkCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *NetworkCache) WatchKey(key *NetworkKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*NetworkKeyWatcher, 0)
	}
	watcher := NetworkKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching Network", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *NetworkCache) TriggerKeyWatchers(ctx context.Context, key *NetworkKey) {
	watchers := make([]*NetworkKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *NetworkCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := Network{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse Network data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *NetworkCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := Network{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	NetworkKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *NetworkCache) SyncListStart(ctx context.Context) {
	c.List = make(map[NetworkKey]struct{})
}

func (c *NetworkCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[NetworkKey]*NetworkCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, val.Obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *NetworkCache) UsesOrg(org string) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		if key.Organization == org {
			return true
		}
	}
	return false
}

func (m *Network) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *Network) GetKey() *NetworkKey {
	return &m.Key
}

func (m *Network) GetKeyVal() NetworkKey {
	return m.Key
}

func (m *Network) SetKey(key *NetworkKey) {
	m.Key = *key
}

func CmpSortNetwork(a Network, b Network) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *Network) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.Routes {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *Network) IsValidArgsForCreateNetwork() error {
	return nil
}

func (m *Network) IsValidArgsForDeleteNetwork() error {
	return nil
}

func (m *Network) IsValidArgsForUpdateNetwork() error {
	return nil
}

func (m *Route) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DestinationCidr)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	l = len(m.NextHopIp)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	return n
}

func (m *NetworkKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	return n
}

func (m *Network) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovNetwork(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovNetwork(uint64(l))
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovNetwork(uint64(l))
		}
	}
	return n
}

func sovNetwork(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNetwork(x uint64) (n int) {
	return sovNetwork(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Route) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationCidr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationCidr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHopIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextHopIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Network) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Network: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Network: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, Route{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNetwork(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNetwork
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNetwork
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNetwork
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNetwork        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNetwork          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNetwork = fmt.Errorf("proto: unexpected end of group")
)
