// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: clusterflavor.proto

package edgeproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/mobiledgex/edge-cloud/protogen"
import _ "github.com/mobiledgex/edge-cloud/protoc-gen-cmd/protocmd"
import _ "github.com/gogo/protobuf/gogoproto"

import strings "strings"
import reflect "reflect"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import "encoding/json"
import "github.com/mobiledgex/edge-cloud/objstore"
import "github.com/coreos/etcd/clientv3/concurrency"
import "github.com/mobiledgex/edge-cloud/util"
import "github.com/mobiledgex/edge-cloud/log"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// ClusterFlavorKey uniquely identifies a Cluster Flavor.
type ClusterFlavorKey struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ClusterFlavorKey) Reset()                    { *m = ClusterFlavorKey{} }
func (m *ClusterFlavorKey) String() string            { return proto.CompactTextString(m) }
func (*ClusterFlavorKey) ProtoMessage()               {}
func (*ClusterFlavorKey) Descriptor() ([]byte, []int) { return fileDescriptorClusterflavor, []int{0} }

// ClusterFlavor defines a set of resources for a Cluster. ClusterFlavors should be fairly static objects that are almost never changed, and are only modified by Mobiledgex administrators.
type ClusterFlavor struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty"`
	// Unique key
	Key ClusterFlavorKey `protobuf:"bytes,2,opt,name=key" json:"key"`
	// Flavor of each node in the Cluster
	NodeFlavor FlavorKey `protobuf:"bytes,3,opt,name=node_flavor,json=nodeFlavor" json:"node_flavor"`
	// Flavor of each master node in the Cluster
	MasterFlavor FlavorKey `protobuf:"bytes,4,opt,name=master_flavor,json=masterFlavor" json:"master_flavor"`
	// Initial number of nodes in the Cluster
	NumNodes uint32 `protobuf:"varint,5,opt,name=num_nodes,json=numNodes,proto3" json:"num_nodes,omitempty"`
	// Maximum number of nodes allowed in the Cluster (for auto-scaling)
	MaxNodes uint32 `protobuf:"varint,6,opt,name=max_nodes,json=maxNodes,proto3" json:"max_nodes,omitempty"`
	// Number of master nodes in the Cluster
	NumMasters uint32 `protobuf:"varint,7,opt,name=num_masters,json=numMasters,proto3" json:"num_masters,omitempty"`
}

func (m *ClusterFlavor) Reset()                    { *m = ClusterFlavor{} }
func (m *ClusterFlavor) String() string            { return proto.CompactTextString(m) }
func (*ClusterFlavor) ProtoMessage()               {}
func (*ClusterFlavor) Descriptor() ([]byte, []int) { return fileDescriptorClusterflavor, []int{1} }

func init() {
	proto.RegisterType((*ClusterFlavorKey)(nil), "edgeproto.ClusterFlavorKey")
	proto.RegisterType((*ClusterFlavor)(nil), "edgeproto.ClusterFlavor")
}
func (this *ClusterFlavorKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&edgeproto.ClusterFlavorKey{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringClusterflavor(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ClusterFlavorApi service

type ClusterFlavorApiClient interface {
	// Create a ClusterFlavor
	CreateClusterFlavor(ctx context.Context, in *ClusterFlavor, opts ...grpc.CallOption) (*Result, error)
	// Delete a ClusterFlavor
	DeleteClusterFlavor(ctx context.Context, in *ClusterFlavor, opts ...grpc.CallOption) (*Result, error)
	// Update a ClusterFlavor
	UpdateClusterFlavor(ctx context.Context, in *ClusterFlavor, opts ...grpc.CallOption) (*Result, error)
	// Show ClusterFlavors
	ShowClusterFlavor(ctx context.Context, in *ClusterFlavor, opts ...grpc.CallOption) (ClusterFlavorApi_ShowClusterFlavorClient, error)
}

type clusterFlavorApiClient struct {
	cc *grpc.ClientConn
}

func NewClusterFlavorApiClient(cc *grpc.ClientConn) ClusterFlavorApiClient {
	return &clusterFlavorApiClient{cc}
}

func (c *clusterFlavorApiClient) CreateClusterFlavor(ctx context.Context, in *ClusterFlavor, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.ClusterFlavorApi/CreateClusterFlavor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterFlavorApiClient) DeleteClusterFlavor(ctx context.Context, in *ClusterFlavor, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.ClusterFlavorApi/DeleteClusterFlavor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterFlavorApiClient) UpdateClusterFlavor(ctx context.Context, in *ClusterFlavor, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.ClusterFlavorApi/UpdateClusterFlavor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterFlavorApiClient) ShowClusterFlavor(ctx context.Context, in *ClusterFlavor, opts ...grpc.CallOption) (ClusterFlavorApi_ShowClusterFlavorClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ClusterFlavorApi_serviceDesc.Streams[0], c.cc, "/edgeproto.ClusterFlavorApi/ShowClusterFlavor", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterFlavorApiShowClusterFlavorClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ClusterFlavorApi_ShowClusterFlavorClient interface {
	Recv() (*ClusterFlavor, error)
	grpc.ClientStream
}

type clusterFlavorApiShowClusterFlavorClient struct {
	grpc.ClientStream
}

func (x *clusterFlavorApiShowClusterFlavorClient) Recv() (*ClusterFlavor, error) {
	m := new(ClusterFlavor)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ClusterFlavorApi service

type ClusterFlavorApiServer interface {
	// Create a ClusterFlavor
	CreateClusterFlavor(context.Context, *ClusterFlavor) (*Result, error)
	// Delete a ClusterFlavor
	DeleteClusterFlavor(context.Context, *ClusterFlavor) (*Result, error)
	// Update a ClusterFlavor
	UpdateClusterFlavor(context.Context, *ClusterFlavor) (*Result, error)
	// Show ClusterFlavors
	ShowClusterFlavor(*ClusterFlavor, ClusterFlavorApi_ShowClusterFlavorServer) error
}

func RegisterClusterFlavorApiServer(s *grpc.Server, srv ClusterFlavorApiServer) {
	s.RegisterService(&_ClusterFlavorApi_serviceDesc, srv)
}

func _ClusterFlavorApi_CreateClusterFlavor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterFlavor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterFlavorApiServer).CreateClusterFlavor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.ClusterFlavorApi/CreateClusterFlavor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterFlavorApiServer).CreateClusterFlavor(ctx, req.(*ClusterFlavor))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterFlavorApi_DeleteClusterFlavor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterFlavor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterFlavorApiServer).DeleteClusterFlavor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.ClusterFlavorApi/DeleteClusterFlavor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterFlavorApiServer).DeleteClusterFlavor(ctx, req.(*ClusterFlavor))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterFlavorApi_UpdateClusterFlavor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterFlavor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterFlavorApiServer).UpdateClusterFlavor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.ClusterFlavorApi/UpdateClusterFlavor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterFlavorApiServer).UpdateClusterFlavor(ctx, req.(*ClusterFlavor))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterFlavorApi_ShowClusterFlavor_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ClusterFlavor)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClusterFlavorApiServer).ShowClusterFlavor(m, &clusterFlavorApiShowClusterFlavorServer{stream})
}

type ClusterFlavorApi_ShowClusterFlavorServer interface {
	Send(*ClusterFlavor) error
	grpc.ServerStream
}

type clusterFlavorApiShowClusterFlavorServer struct {
	grpc.ServerStream
}

func (x *clusterFlavorApiShowClusterFlavorServer) Send(m *ClusterFlavor) error {
	return x.ServerStream.SendMsg(m)
}

var _ClusterFlavorApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.ClusterFlavorApi",
	HandlerType: (*ClusterFlavorApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateClusterFlavor",
			Handler:    _ClusterFlavorApi_CreateClusterFlavor_Handler,
		},
		{
			MethodName: "DeleteClusterFlavor",
			Handler:    _ClusterFlavorApi_DeleteClusterFlavor_Handler,
		},
		{
			MethodName: "UpdateClusterFlavor",
			Handler:    _ClusterFlavorApi_UpdateClusterFlavor_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowClusterFlavor",
			Handler:       _ClusterFlavorApi_ShowClusterFlavor_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "clusterflavor.proto",
}

func (m *ClusterFlavorKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterFlavorKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintClusterflavor(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *ClusterFlavor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterFlavor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintClusterflavor(dAtA, i, uint64(m.Key.Size()))
	n1, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x1a
	i++
	i = encodeVarintClusterflavor(dAtA, i, uint64(m.NodeFlavor.Size()))
	n2, err := m.NodeFlavor.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x22
	i++
	i = encodeVarintClusterflavor(dAtA, i, uint64(m.MasterFlavor.Size()))
	n3, err := m.MasterFlavor.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if m.NumNodes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintClusterflavor(dAtA, i, uint64(m.NumNodes))
	}
	if m.MaxNodes != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintClusterflavor(dAtA, i, uint64(m.MaxNodes))
	}
	if m.NumMasters != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintClusterflavor(dAtA, i, uint64(m.NumMasters))
	}
	return i, nil
}

func encodeVarintClusterflavor(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ClusterFlavorKey) Matches(o *ClusterFlavorKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.Name != "" {
		if o.Name != m.Name {
			return false
		}
	}
	return true
}

func (m *ClusterFlavorKey) CopyInFields(src *ClusterFlavorKey) {
	m.Name = src.Name
}

func (m *ClusterFlavorKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal ClusterFlavorKey key string", "obj", m)
	}
	return string(key)
}

func ClusterFlavorKeyStringParse(str string, key *ClusterFlavorKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal ClusterFlavorKey key string", "str", str)
	}
}

// Helper method to check that enums have valid values
func (m *ClusterFlavorKey) ValidateEnums() error {
	return nil
}

func (m *ClusterFlavor) Matches(o *ClusterFlavor, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !m.NodeFlavor.Matches(&o.NodeFlavor, fopts...) {
		return false
	}
	if !m.MasterFlavor.Matches(&o.MasterFlavor, fopts...) {
		return false
	}
	if !opts.Filter || o.NumNodes != 0 {
		if o.NumNodes != m.NumNodes {
			return false
		}
	}
	if !opts.Filter || o.MaxNodes != 0 {
		if o.MaxNodes != m.MaxNodes {
			return false
		}
	}
	if !opts.Filter || o.NumMasters != 0 {
		if o.NumMasters != m.NumMasters {
			return false
		}
	}
	return true
}

const ClusterFlavorFieldKey = "2"
const ClusterFlavorFieldKeyName = "2.1"
const ClusterFlavorFieldNodeFlavor = "3"
const ClusterFlavorFieldNodeFlavorName = "3.1"
const ClusterFlavorFieldMasterFlavor = "4"
const ClusterFlavorFieldMasterFlavorName = "4.1"
const ClusterFlavorFieldNumNodes = "5"
const ClusterFlavorFieldMaxNodes = "6"
const ClusterFlavorFieldNumMasters = "7"

var ClusterFlavorAllFields = []string{
	ClusterFlavorFieldKeyName,
	ClusterFlavorFieldNodeFlavorName,
	ClusterFlavorFieldMasterFlavorName,
	ClusterFlavorFieldNumNodes,
	ClusterFlavorFieldMaxNodes,
	ClusterFlavorFieldNumMasters,
}

var ClusterFlavorAllFieldsMap = map[string]struct{}{
	ClusterFlavorFieldKeyName:          struct{}{},
	ClusterFlavorFieldNodeFlavorName:   struct{}{},
	ClusterFlavorFieldMasterFlavorName: struct{}{},
	ClusterFlavorFieldNumNodes:         struct{}{},
	ClusterFlavorFieldMaxNodes:         struct{}{},
	ClusterFlavorFieldNumMasters:       struct{}{},
}

func (m *ClusterFlavor) DiffFields(o *ClusterFlavor, fields map[string]struct{}) {
	if m.Key.Name != o.Key.Name {
		fields[ClusterFlavorFieldKeyName] = struct{}{}
		fields[ClusterFlavorFieldKey] = struct{}{}
	}
	if m.NodeFlavor.Name != o.NodeFlavor.Name {
		fields[ClusterFlavorFieldNodeFlavorName] = struct{}{}
		fields[ClusterFlavorFieldNodeFlavor] = struct{}{}
	}
	if m.MasterFlavor.Name != o.MasterFlavor.Name {
		fields[ClusterFlavorFieldMasterFlavorName] = struct{}{}
		fields[ClusterFlavorFieldMasterFlavor] = struct{}{}
	}
	if m.NumNodes != o.NumNodes {
		fields[ClusterFlavorFieldNumNodes] = struct{}{}
	}
	if m.MaxNodes != o.MaxNodes {
		fields[ClusterFlavorFieldMaxNodes] = struct{}{}
	}
	if m.NumMasters != o.NumMasters {
		fields[ClusterFlavorFieldNumMasters] = struct{}{}
	}
}

func (m *ClusterFlavor) CopyInFields(src *ClusterFlavor) {
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			m.Key.Name = src.Key.Name
		}
	}
	if _, set := fmap["3"]; set {
		if _, set := fmap["3.1"]; set {
			m.NodeFlavor.Name = src.NodeFlavor.Name
		}
	}
	if _, set := fmap["4"]; set {
		if _, set := fmap["4.1"]; set {
			m.MasterFlavor.Name = src.MasterFlavor.Name
		}
	}
	if _, set := fmap["5"]; set {
		m.NumNodes = src.NumNodes
	}
	if _, set := fmap["6"]; set {
		m.MaxNodes = src.MaxNodes
	}
	if _, set := fmap["7"]; set {
		m.NumMasters = src.NumMasters
	}
}

func (s *ClusterFlavor) HasFields() bool {
	return true
}

type ClusterFlavorStore struct {
	kvstore objstore.KVStore
}

func NewClusterFlavorStore(kvstore objstore.KVStore) ClusterFlavorStore {
	return ClusterFlavorStore{kvstore: kvstore}
}

func (s *ClusterFlavorStore) Create(m *ClusterFlavor, wait func(int64)) (*Result, error) {
	err := m.Validate(ClusterFlavorAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("ClusterFlavor", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *ClusterFlavorStore) Update(m *ClusterFlavor, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("ClusterFlavor", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur ClusterFlavor
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *ClusterFlavorStore) Put(m *ClusterFlavor, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("ClusterFlavor", m.GetKey())
	var val []byte
	curBytes, _, _, err := s.kvstore.Get(key)
	if err == nil {
		var cur ClusterFlavor
		err = json.Unmarshal(curBytes, &cur)
		if err != nil {
			return nil, err
		}
		cur.CopyInFields(m)
		// never save fields
		cur.Fields = nil
		val, err = json.Marshal(cur)
	} else {
		m.Fields = nil
		val, err = json.Marshal(m)
	}
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *ClusterFlavorStore) Delete(m *ClusterFlavor, wait func(int64)) (*Result, error) {
	err := m.GetKey().Validate()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("ClusterFlavor", m.GetKey())
	rev, err := s.kvstore.Delete(key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *ClusterFlavorStore) LoadOne(key string) (*ClusterFlavor, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj ClusterFlavor
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse ClusterFlavor data", "val", string(val))
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *ClusterFlavorStore) STMGet(stm concurrency.STM, key *ClusterFlavorKey, buf *ClusterFlavor) bool {
	keystr := objstore.DbKeyString("ClusterFlavor", key)
	valstr := stm.Get(keystr)
	if valstr == "" {
		return false
	}
	if buf != nil {
		err := json.Unmarshal([]byte(valstr), buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *ClusterFlavorStore) STMPut(stm concurrency.STM, obj *ClusterFlavor) {
	keystr := objstore.DbKeyString("ClusterFlavor", obj.GetKey())
	val, _ := json.Marshal(obj)
	stm.Put(keystr, string(val))
}

func (s *ClusterFlavorStore) STMDel(stm concurrency.STM, key *ClusterFlavorKey) {
	keystr := objstore.DbKeyString("ClusterFlavor", key)
	stm.Del(keystr)
}

type ClusterFlavorKeyWatcher struct {
	cb func()
}

// ClusterFlavorCache caches ClusterFlavor objects in memory in a hash table
// and keeps them in sync with the database.
type ClusterFlavorCache struct {
	Objs        map[ClusterFlavorKey]*ClusterFlavor
	Mux         util.Mutex
	List        map[ClusterFlavorKey]struct{}
	NotifyCb    func(obj *ClusterFlavorKey, old *ClusterFlavor)
	UpdatedCb   func(old *ClusterFlavor, new *ClusterFlavor)
	KeyWatchers map[ClusterFlavorKey][]*ClusterFlavorKeyWatcher
}

func NewClusterFlavorCache() *ClusterFlavorCache {
	cache := ClusterFlavorCache{}
	InitClusterFlavorCache(&cache)
	return &cache
}

func InitClusterFlavorCache(cache *ClusterFlavorCache) {
	cache.Objs = make(map[ClusterFlavorKey]*ClusterFlavor)
	cache.KeyWatchers = make(map[ClusterFlavorKey][]*ClusterFlavorKeyWatcher)
}

func (c *ClusterFlavorCache) GetTypeString() string {
	return "ClusterFlavor"
}

func (c *ClusterFlavorCache) Get(key *ClusterFlavorKey, valbuf *ClusterFlavor) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		*valbuf = *inst
	}
	return found
}

func (c *ClusterFlavorCache) HasKey(key *ClusterFlavorKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *ClusterFlavorCache) GetAllKeys(keys map[ClusterFlavorKey]struct{}) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		keys[key] = struct{}{}
	}
}

func (c *ClusterFlavorCache) Update(in *ClusterFlavor, rev int64) {
	c.UpdateModFunc(&in.Key, rev, func(old *ClusterFlavor) (*ClusterFlavor, bool) {
		return in, true
	})
}

func (c *ClusterFlavorCache) UpdateModFunc(key *ClusterFlavorKey, rev int64, modFunc func(old *ClusterFlavor) (new *ClusterFlavor, changed bool)) {
	c.Mux.Lock()
	old := c.Objs[*key]
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	if c.UpdatedCb != nil || c.NotifyCb != nil {
		if c.UpdatedCb != nil {
			newCopy := &ClusterFlavor{}
			*newCopy = *new
			defer c.UpdatedCb(old, newCopy)
		}
		if c.NotifyCb != nil {
			defer c.NotifyCb(&new.Key, old)
		}
	}
	c.Objs[new.Key] = new
	log.DebugLog(log.DebugLevelApi, "SyncUpdate ClusterFlavor", "obj", new, "rev", rev)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(&new.Key)
}

func (c *ClusterFlavorCache) Delete(in *ClusterFlavor, rev int64) {
	c.Mux.Lock()
	old := c.Objs[in.Key]
	delete(c.Objs, in.Key)
	log.DebugLog(log.DebugLevelApi, "SyncDelete ClusterFlavor", "key", in.Key, "rev", rev)
	c.Mux.Unlock()
	if c.NotifyCb != nil {
		c.NotifyCb(&in.Key, old)
	}
	c.TriggerKeyWatchers(&in.Key)
}

func (c *ClusterFlavorCache) Prune(validKeys map[ClusterFlavorKey]struct{}) {
	notify := make(map[ClusterFlavorKey]*ClusterFlavor)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if c.NotifyCb != nil {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		if c.NotifyCb != nil {
			c.NotifyCb(&key, old)
		}
		c.TriggerKeyWatchers(&key)
	}
}

func (c *ClusterFlavorCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *ClusterFlavorCache) Flush(notifyId int64) {
}

func (c *ClusterFlavorCache) Show(filter *ClusterFlavor, cb func(ret *ClusterFlavor) error) error {
	log.DebugLog(log.DebugLevelApi, "Show ClusterFlavor", "count", len(c.Objs))
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, obj := range c.Objs {
		if !obj.Matches(filter, MatchFilter()) {
			continue
		}
		log.DebugLog(log.DebugLevelApi, "Show ClusterFlavor", "obj", obj)
		err := cb(obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func ClusterFlavorGenericNotifyCb(fn func(key *ClusterFlavorKey, old *ClusterFlavor)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*ClusterFlavorKey), obj.(*ClusterFlavor))
	}
}

func (c *ClusterFlavorCache) SetNotifyCb(fn func(obj *ClusterFlavorKey, old *ClusterFlavor)) {
	c.NotifyCb = fn
}

func (c *ClusterFlavorCache) SetUpdatedCb(fn func(old *ClusterFlavor, new *ClusterFlavor)) {
	c.UpdatedCb = fn
}

func (c *ClusterFlavorCache) WatchKey(key *ClusterFlavorKey, cb func()) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*ClusterFlavorKeyWatcher, 0)
	}
	watcher := ClusterFlavorKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching ClusterFlavor", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *ClusterFlavorCache) TriggerKeyWatchers(key *ClusterFlavorKey) {
	watchers := make([]*ClusterFlavorKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb()
	}
}
func (c *ClusterFlavorCache) SyncUpdate(key, val []byte, rev int64) {
	obj := ClusterFlavor{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse ClusterFlavor data", "val", string(val))
		return
	}
	c.Update(&obj, rev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.Key] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *ClusterFlavorCache) SyncDelete(key []byte, rev int64) {
	obj := ClusterFlavor{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	ClusterFlavorKeyStringParse(keystr, &obj.Key)
	c.Delete(&obj, rev)
}

func (c *ClusterFlavorCache) SyncListStart() {
	c.List = make(map[ClusterFlavorKey]struct{})
}

func (c *ClusterFlavorCache) SyncListEnd() {
	deleted := make(map[ClusterFlavorKey]*ClusterFlavor)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	if c.NotifyCb != nil {
		for key, val := range deleted {
			c.NotifyCb(&key, val)
			c.TriggerKeyWatchers(&key)
		}
	}
}

func (m *ClusterFlavor) GetKey() objstore.ObjKey {
	return &m.Key
}

func CmpSortClusterFlavor(a ClusterFlavor, b ClusterFlavor) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *ClusterFlavor) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if err := m.NodeFlavor.ValidateEnums(); err != nil {
		return err
	}
	if err := m.MasterFlavor.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *ClusterFlavorKey) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovClusterflavor(uint64(l))
	}
	return n
}

func (m *ClusterFlavor) Size() (n int) {
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovClusterflavor(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovClusterflavor(uint64(l))
	l = m.NodeFlavor.Size()
	n += 1 + l + sovClusterflavor(uint64(l))
	l = m.MasterFlavor.Size()
	n += 1 + l + sovClusterflavor(uint64(l))
	if m.NumNodes != 0 {
		n += 1 + sovClusterflavor(uint64(m.NumNodes))
	}
	if m.MaxNodes != 0 {
		n += 1 + sovClusterflavor(uint64(m.MaxNodes))
	}
	if m.NumMasters != 0 {
		n += 1 + sovClusterflavor(uint64(m.NumMasters))
	}
	return n
}

func sovClusterflavor(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozClusterflavor(x uint64) (n int) {
	return sovClusterflavor(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClusterFlavorKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClusterflavor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterFlavorKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterFlavorKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterflavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterflavor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClusterflavor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClusterflavor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterFlavor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClusterflavor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterFlavor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterFlavor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterflavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterflavor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterflavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterflavor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeFlavor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterflavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterflavor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NodeFlavor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterFlavor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterflavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterflavor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MasterFlavor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumNodes", wireType)
			}
			m.NumNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterflavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumNodes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNodes", wireType)
			}
			m.MaxNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterflavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNodes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumMasters", wireType)
			}
			m.NumMasters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterflavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumMasters |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipClusterflavor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClusterflavor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipClusterflavor(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowClusterflavor
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClusterflavor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClusterflavor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthClusterflavor
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowClusterflavor
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipClusterflavor(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthClusterflavor = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowClusterflavor   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("clusterflavor.proto", fileDescriptorClusterflavor) }

var fileDescriptorClusterflavor = []byte{
	// 559 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x53, 0xcf, 0x6b, 0x13, 0x41,
	0x14, 0xee, 0x24, 0x31, 0x9a, 0x49, 0x02, 0xed, 0xa6, 0xca, 0x90, 0x4a, 0x12, 0x16, 0x0f, 0x41,
	0x92, 0xac, 0xb4, 0x1e, 0x24, 0x1e, 0xa4, 0xad, 0xa8, 0x20, 0x55, 0x58, 0xd1, 0x6b, 0x99, 0xec,
	0xbe, 0x6c, 0x96, 0xee, 0xce, 0x84, 0xfd, 0x61, 0xd2, 0x9b, 0x78, 0xf6, 0x20, 0x78, 0x11, 0x4f,
	0xfe, 0x09, 0xfe, 0x19, 0x01, 0x2f, 0x82, 0x57, 0x11, 0x0d, 0x1e, 0xa4, 0x27, 0x21, 0x39, 0x78,
	0x94, 0x99, 0xd9, 0x94, 0x24, 0xb5, 0xda, 0x53, 0x2f, 0xcb, 0x7b, 0xfb, 0xbd, 0xef, 0x7b, 0xdf,
	0x7c, 0x3b, 0x8b, 0x4b, 0x96, 0x17, 0x87, 0x11, 0x04, 0x5d, 0x8f, 0x3e, 0xe7, 0x41, 0xab, 0x1f,
	0xf0, 0x88, 0x6b, 0x39, 0xb0, 0x1d, 0x90, 0x65, 0xf9, 0xaa, 0xc3, 0xb9, 0xe3, 0x81, 0x41, 0xfb,
	0xae, 0x41, 0x19, 0xe3, 0x11, 0x8d, 0x5c, 0xce, 0x42, 0x35, 0x58, 0xbe, 0xe5, 0xb8, 0x51, 0x2f,
	0xee, 0xb4, 0x2c, 0xee, 0x1b, 0x3e, 0xef, 0xb8, 0x9e, 0x20, 0x0e, 0x0d, 0xf1, 0x6c, 0x5a, 0x1e,
	0x8f, 0x6d, 0x43, 0xce, 0x39, 0xc0, 0x8e, 0x8b, 0x84, 0x79, 0xff, 0x6c, 0x4c, 0xab, 0xe9, 0x00,
	0x6b, 0x5a, 0xfe, 0xac, 0x9d, 0x2b, 0x12, 0xa1, 0x42, 0x00, 0x61, 0xec, 0x45, 0xb3, 0x6e, 0xfe,
	0x1c, 0xe5, 0xe6, 0xdc, 0x12, 0x87, 0x3b, 0x5c, 0x71, 0x3b, 0x71, 0x57, 0x76, 0xb2, 0x91, 0x95,
	0x1a, 0xd7, 0x6f, 0xe2, 0xd5, 0x5d, 0x95, 0xc6, 0x3d, 0xa9, 0xf2, 0x10, 0x0e, 0x35, 0x0d, 0x67,
	0x18, 0xf5, 0x81, 0xa0, 0x1a, 0xaa, 0xe7, 0x4c, 0x59, 0xb7, 0x0b, 0x3f, 0x27, 0x04, 0xfd, 0x9e,
	0x10, 0xf4, 0xe1, 0x7d, 0x15, 0xe9, 0x1f, 0x53, 0xb8, 0xb8, 0x40, 0xd3, 0xae, 0xe0, 0x6c, 0xd7,
	0x05, 0xcf, 0x0e, 0x09, 0xaa, 0xa5, 0xeb, 0x39, 0x33, 0xe9, 0xb4, 0x2d, 0x9c, 0x3e, 0x80, 0x43,
	0x92, 0xaa, 0xa1, 0x7a, 0x7e, 0x73, 0xa3, 0x75, 0x1c, 0x72, 0x6b, 0x79, 0xeb, 0x4e, 0x66, 0xf4,
	0xb5, 0xba, 0x62, 0x8a, 0x69, 0xed, 0x36, 0xce, 0x33, 0x6e, 0xc3, 0xbe, 0x3a, 0x18, 0x49, 0x4b,
	0xf2, 0xfa, 0x1c, 0x79, 0x99, 0x85, 0xc5, 0x78, 0xe2, 0xe4, 0x0e, 0x2e, 0xfa, 0x54, 0x48, 0xcf,
	0xe8, 0x99, 0xff, 0xd2, 0x0b, 0x8a, 0x90, 0x08, 0x6c, 0xe0, 0x1c, 0x8b, 0xfd, 0x7d, 0x21, 0x19,
	0x92, 0x0b, 0x35, 0x54, 0x2f, 0x9a, 0x97, 0x58, 0xec, 0x3f, 0x12, 0xbd, 0x00, 0x7d, 0x3a, 0x4c,
	0xc0, 0xac, 0x02, 0x7d, 0x3a, 0x54, 0x60, 0x15, 0xe7, 0x05, 0x53, 0xa9, 0x85, 0xe4, 0xa2, 0x84,
	0x31, 0x8b, 0xfd, 0x3d, 0xf5, 0xa6, 0xbd, 0x2e, 0x52, 0xfc, 0x35, 0x21, 0xe8, 0xc5, 0x94, 0xa0,
	0xd7, 0x53, 0x82, 0xde, 0x4e, 0x09, 0xda, 0xfc, 0x92, 0x59, 0xfa, 0x08, 0xdb, 0x7d, 0x57, 0x7b,
	0x85, 0x70, 0x69, 0x37, 0x00, 0x1a, 0xc1, 0x62, 0xd0, 0xe4, 0xb4, 0x0c, 0xcb, 0x6b, 0x73, 0x88,
	0x29, 0x2f, 0x88, 0xfe, 0xe0, 0x68, 0x4a, 0xae, 0x99, 0x10, 0xf2, 0x38, 0xb0, 0x16, 0x75, 0xc2,
	0xc6, 0xb6, 0x25, 0x6e, 0xf5, 0x1e, 0x65, 0xd4, 0x81, 0xc6, 0xcb, 0xcf, 0x3f, 0xde, 0xa4, 0xca,
	0xfa, 0x65, 0xc3, 0x92, 0x2b, 0x8d, 0x85, 0x3f, 0xa4, 0x8d, 0xae, 0x4b, 0x3b, 0x77, 0xc1, 0x83,
	0x73, 0xb6, 0x63, 0xcb, 0x95, 0x7f, 0xb7, 0xf3, 0xb4, 0x6f, 0x9f, 0x77, 0x3a, 0xb1, 0x5c, 0x79,
	0xd2, 0xce, 0x3b, 0x84, 0xd7, 0x9e, 0xf4, 0xf8, 0xe0, 0xac, 0x66, 0x4e, 0x45, 0xf4, 0xc7, 0x47,
	0x53, 0xd2, 0xfc, 0xa7, 0xa7, 0x67, 0x2e, 0x0c, 0x1a, 0xe1, 0x81, 0xdb, 0x07, 0xd6, 0xe5, 0x81,
	0x05, 0xd2, 0x1c, 0xd1, 0x4b, 0x46, 0xd8, 0xe3, 0x83, 0x13, 0xd6, 0x6e, 0xa0, 0x9d, 0xd5, 0xd1,
	0xf7, 0xca, 0xca, 0x68, 0x5c, 0x41, 0x9f, 0xc6, 0x15, 0xf4, 0x6d, 0x5c, 0x41, 0x9d, 0xac, 0xdc,
	0xbc, 0xf5, 0x27, 0x00, 0x00, 0xff, 0xff, 0x13, 0x9d, 0xa6, 0x72, 0x09, 0x05, 0x00, 0x00,
}
