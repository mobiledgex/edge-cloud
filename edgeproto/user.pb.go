// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: user.proto

package edgeproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/mobiledgex/edge-cloud/protogen"
import _ "github.com/gogo/protobuf/gogoproto"

import strings "strings"
import reflect "reflect"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import "encoding/json"
import "github.com/mobiledgex/edge-cloud/objstore"
import "github.com/mobiledgex/edge-cloud/log"
import "errors"
import "strconv"
import "database/sql"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Organization the Role belongs to.
type OrgType int32

const (
	// Unknown type
	OrgType_OrgTypeUnknown OrgType = 0
	// MobiledgeX Admin
	OrgType_OrgTypeAdmin OrgType = 1
	// Developer
	OrgType_OrgTypeDeveloper OrgType = 2
	// Operator
	OrgType_OrgTypeOperator OrgType = 3
)

var OrgType_name = map[int32]string{
	0: "OrgTypeUnknown",
	1: "OrgTypeAdmin",
	2: "OrgTypeDeveloper",
	3: "OrgTypeOperator",
}
var OrgType_value = map[string]int32{
	"OrgTypeUnknown":   0,
	"OrgTypeAdmin":     1,
	"OrgTypeDeveloper": 2,
	"OrgTypeOperator":  3,
}

func (x OrgType) String() string {
	return proto.EnumName(OrgType_name, int32(x))
}
func (OrgType) EnumDescriptor() ([]byte, []int) { return fileDescriptorUser, []int{0} }

type RoleType int32

const (
	// Unknown type
	RoleType_RoleTypeUnknown RoleType = 0
	// Admin
	RoleType_RoleTypeAdmin RoleType = 1
	// Read-only
	RoleType_RoleTypeReadOnly RoleType = 2
)

var RoleType_name = map[int32]string{
	0: "RoleTypeUnknown",
	1: "RoleTypeAdmin",
	2: "RoleTypeReadOnly",
}
var RoleType_value = map[string]int32{
	"RoleTypeUnknown":  0,
	"RoleTypeAdmin":    1,
	"RoleTypeReadOnly": 2,
}

func (x RoleType) String() string {
	return proto.EnumName(RoleType_name, int32(x))
}
func (RoleType) EnumDescriptor() ([]byte, []int) { return fileDescriptorUser, []int{1} }

type UserKey struct {
	// User id is the unique identifier
	UserId int64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *UserKey) Reset()                    { *m = UserKey{} }
func (m *UserKey) String() string            { return proto.CompactTextString(m) }
func (*UserKey) ProtoMessage()               {}
func (*UserKey) Descriptor() ([]byte, []int) { return fileDescriptorUser, []int{0} }

// A User defines an account for accessing the MobiledgeX platform. Each user has their own roles and is tied to either an Operator, Developer, or Mobiledgex Admin.
type User struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty"`
	// Unique Key
	Key UserKey `protobuf:"bytes,2,opt,name=key" json:"key"`
	// Full User name
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Nickname
	Nickname string `protobuf:"bytes,4,opt,name=nickname,proto3" json:"nickname,omitempty"`
	// Email address
	Email string `protobuf:"bytes,5,opt,name=email,proto3" json:"email,omitempty"`
	// Has email been verified?
	EmailVerified bool `protobuf:"varint,6,opt,name=email_verified,json=emailVerified,proto3" json:"email_verified,omitempty"`
	// Password used during login
	Password string `protobuf:"bytes,7,opt,name=password,proto3" json:"password,omitempty"`
	// Password hash stored in database
	Passhash string `protobuf:"bytes,8,opt,name=passhash,proto3" json:"passhash,omitempty"`
	// Family name
	FamilyName string `protobuf:"bytes,9,opt,name=family_name,json=familyName,proto3" json:"family_name,omitempty"`
	// Given name
	GivenName string `protobuf:"bytes,10,opt,name=given_name,json=givenName,proto3" json:"given_name,omitempty"`
	// Picture URI (i.e. Gravatar)
	Picture string `protobuf:"bytes,11,opt,name=picture,proto3" json:"picture,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptorUser, []int{1} }

type RoleKey struct {
	// Unique id
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *RoleKey) Reset()                    { *m = RoleKey{} }
func (m *RoleKey) String() string            { return proto.CompactTextString(m) }
func (*RoleKey) ProtoMessage()               {}
func (*RoleKey) Descriptor() ([]byte, []int) { return fileDescriptorUser, []int{2} }

type Role struct {
	// unique key
	Key RoleKey `protobuf:"bytes,1,opt,name=key" json:"key"`
	// User for this role
	UserId int64 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Organization Type
	OrgType OrgType `protobuf:"varint,3,opt,name=org_type,json=orgType,proto3,enum=edgeproto.OrgType" json:"org_type,omitempty"`
	// Organization name (Developer Name or Operator Name)
	OrgName string `protobuf:"bytes,4,opt,name=org_name,json=orgName,proto3" json:"org_name,omitempty"`
	// Role type
	RoleType RoleType `protobuf:"varint,5,opt,name=role_type,json=roleType,proto3,enum=edgeproto.RoleType" json:"role_type,omitempty"`
}

func (m *Role) Reset()                    { *m = Role{} }
func (m *Role) String() string            { return proto.CompactTextString(m) }
func (*Role) ProtoMessage()               {}
func (*Role) Descriptor() ([]byte, []int) { return fileDescriptorUser, []int{3} }

func init() {
	proto.RegisterType((*UserKey)(nil), "edgeproto.UserKey")
	proto.RegisterType((*User)(nil), "edgeproto.User")
	proto.RegisterType((*RoleKey)(nil), "edgeproto.RoleKey")
	proto.RegisterType((*Role)(nil), "edgeproto.Role")
	proto.RegisterEnum("edgeproto.OrgType", OrgType_name, OrgType_value)
	proto.RegisterEnum("edgeproto.RoleType", RoleType_name, RoleType_value)
}
func (this *UserKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&edgeproto.UserKey{")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoleKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&edgeproto.RoleKey{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringUser(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for UserApi service

type UserApiClient interface {
	// Log in a user
	LoginUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*Result, error)
	// Create a User
	CreateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*Result, error)
	// Update a User
	UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*Result, error)
	// Delete a User
	DeleteUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*Result, error)
	// Show Users
	ShowUser(ctx context.Context, in *User, opts ...grpc.CallOption) (UserApi_ShowUserClient, error)
}

type userApiClient struct {
	cc *grpc.ClientConn
}

func NewUserApiClient(cc *grpc.ClientConn) UserApiClient {
	return &userApiClient{cc}
}

func (c *userApiClient) LoginUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.UserApi/LoginUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiClient) CreateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.UserApi/CreateUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiClient) UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.UserApi/UpdateUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiClient) DeleteUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.UserApi/DeleteUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiClient) ShowUser(ctx context.Context, in *User, opts ...grpc.CallOption) (UserApi_ShowUserClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_UserApi_serviceDesc.Streams[0], c.cc, "/edgeproto.UserApi/ShowUser", opts...)
	if err != nil {
		return nil, err
	}
	x := &userApiShowUserClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type UserApi_ShowUserClient interface {
	Recv() (*User, error)
	grpc.ClientStream
}

type userApiShowUserClient struct {
	grpc.ClientStream
}

func (x *userApiShowUserClient) Recv() (*User, error) {
	m := new(User)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for UserApi service

type UserApiServer interface {
	// Log in a user
	LoginUser(context.Context, *User) (*Result, error)
	// Create a User
	CreateUser(context.Context, *User) (*Result, error)
	// Update a User
	UpdateUser(context.Context, *User) (*Result, error)
	// Delete a User
	DeleteUser(context.Context, *User) (*Result, error)
	// Show Users
	ShowUser(*User, UserApi_ShowUserServer) error
}

func RegisterUserApiServer(s *grpc.Server, srv UserApiServer) {
	s.RegisterService(&_UserApi_serviceDesc, srv)
}

func _UserApi_LoginUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServer).LoginUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.UserApi/LoginUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServer).LoginUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApi_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.UserApi/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServer).CreateUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApi_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.UserApi/UpdateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServer).UpdateUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApi_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.UserApi/DeleteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServer).DeleteUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApi_ShowUser_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(User)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UserApiServer).ShowUser(m, &userApiShowUserServer{stream})
}

type UserApi_ShowUserServer interface {
	Send(*User) error
	grpc.ServerStream
}

type userApiShowUserServer struct {
	grpc.ServerStream
}

func (x *userApiShowUserServer) Send(m *User) error {
	return x.ServerStream.SendMsg(m)
}

var _UserApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.UserApi",
	HandlerType: (*UserApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LoginUser",
			Handler:    _UserApi_LoginUser_Handler,
		},
		{
			MethodName: "CreateUser",
			Handler:    _UserApi_CreateUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _UserApi_UpdateUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _UserApi_DeleteUser_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowUser",
			Handler:       _UserApi_ShowUser_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "user.proto",
}

// Client API for RoleApi service

type RoleApiClient interface {
	// Add a Role to a User
	AddRole(ctx context.Context, in *Role, opts ...grpc.CallOption) (*Result, error)
	// Remove a Role from a User
	RemoveRole(ctx context.Context, in *Role, opts ...grpc.CallOption) (*Result, error)
}

type roleApiClient struct {
	cc *grpc.ClientConn
}

func NewRoleApiClient(cc *grpc.ClientConn) RoleApiClient {
	return &roleApiClient{cc}
}

func (c *roleApiClient) AddRole(ctx context.Context, in *Role, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.RoleApi/AddRole", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleApiClient) RemoveRole(ctx context.Context, in *Role, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.RoleApi/RemoveRole", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RoleApi service

type RoleApiServer interface {
	// Add a Role to a User
	AddRole(context.Context, *Role) (*Result, error)
	// Remove a Role from a User
	RemoveRole(context.Context, *Role) (*Result, error)
}

func RegisterRoleApiServer(s *grpc.Server, srv RoleApiServer) {
	s.RegisterService(&_RoleApi_serviceDesc, srv)
}

func _RoleApi_AddRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Role)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleApiServer).AddRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.RoleApi/AddRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleApiServer).AddRole(ctx, req.(*Role))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleApi_RemoveRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Role)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleApiServer).RemoveRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.RoleApi/RemoveRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleApiServer).RemoveRole(ctx, req.(*Role))
	}
	return interceptor(ctx, in, info, handler)
}

var _RoleApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.RoleApi",
	HandlerType: (*RoleApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddRole",
			Handler:    _RoleApi_AddRole_Handler,
		},
		{
			MethodName: "RemoveRole",
			Handler:    _RoleApi_RemoveRole_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

func (m *UserKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintUser(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintUser(dAtA, i, uint64(m.Key.Size()))
	n1, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintUser(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Nickname) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintUser(dAtA, i, uint64(len(m.Nickname)))
		i += copy(dAtA[i:], m.Nickname)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintUser(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if m.EmailVerified {
		dAtA[i] = 0x30
		i++
		if m.EmailVerified {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintUser(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if len(m.Passhash) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintUser(dAtA, i, uint64(len(m.Passhash)))
		i += copy(dAtA[i:], m.Passhash)
	}
	if len(m.FamilyName) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintUser(dAtA, i, uint64(len(m.FamilyName)))
		i += copy(dAtA[i:], m.FamilyName)
	}
	if len(m.GivenName) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintUser(dAtA, i, uint64(len(m.GivenName)))
		i += copy(dAtA[i:], m.GivenName)
	}
	if len(m.Picture) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintUser(dAtA, i, uint64(len(m.Picture)))
		i += copy(dAtA[i:], m.Picture)
	}
	return i, nil
}

func (m *RoleKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintUser(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *Role) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Role) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintUser(dAtA, i, uint64(m.Key.Size()))
	n2, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintUser(dAtA, i, uint64(m.UserId))
	}
	if m.OrgType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintUser(dAtA, i, uint64(m.OrgType))
	}
	if len(m.OrgName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintUser(dAtA, i, uint64(len(m.OrgName)))
		i += copy(dAtA[i:], m.OrgName)
	}
	if m.RoleType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintUser(dAtA, i, uint64(m.RoleType))
	}
	return i, nil
}

func encodeVarintUser(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *UserKey) Matches(o *UserKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.UserId != 0 {
		if o.UserId != m.UserId {
			return false
		}
	}
	return true
}

func (m *UserKey) CopyInFields(src *UserKey) {
	m.UserId = src.UserId
}

func (m *UserKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal UserKey key string", "obj", m)
	}
	return string(key)
}

func UserKeyStringParse(str string, key *UserKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal UserKey key string", "str", str)
	}
}

// Helper method to check that enums have valid values
func (m *UserKey) ValidateEnums() error {
	return nil
}

func (m *User) Matches(o *User, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.Name != "" {
		if o.Name != m.Name {
			return false
		}
	}
	if !opts.Filter || o.Nickname != "" {
		if o.Nickname != m.Nickname {
			return false
		}
	}
	if !opts.Filter || o.Email != "" {
		if o.Email != m.Email {
			return false
		}
	}
	if !opts.Filter || o.EmailVerified != false {
		if o.EmailVerified != m.EmailVerified {
			return false
		}
	}
	if !opts.Filter || o.Password != "" {
		if o.Password != m.Password {
			return false
		}
	}
	if !opts.Filter || o.Passhash != "" {
		if o.Passhash != m.Passhash {
			return false
		}
	}
	if !opts.Filter || o.FamilyName != "" {
		if o.FamilyName != m.FamilyName {
			return false
		}
	}
	if !opts.Filter || o.GivenName != "" {
		if o.GivenName != m.GivenName {
			return false
		}
	}
	if !opts.Filter || o.Picture != "" {
		if o.Picture != m.Picture {
			return false
		}
	}
	return true
}

const UserFieldKey = "2"
const UserFieldKeyUserId = "2.1"
const UserFieldName = "3"
const UserFieldNickname = "4"
const UserFieldEmail = "5"
const UserFieldEmailVerified = "6"
const UserFieldPassword = "7"
const UserFieldPasshash = "8"
const UserFieldFamilyName = "9"
const UserFieldGivenName = "10"
const UserFieldPicture = "11"

var UserAllFields = []string{
	UserFieldKeyUserId,
	UserFieldName,
	UserFieldNickname,
	UserFieldEmail,
	UserFieldEmailVerified,
	UserFieldPassword,
	UserFieldPasshash,
	UserFieldFamilyName,
	UserFieldGivenName,
	UserFieldPicture,
}

var UserAllFieldsMap = map[string]struct{}{
	UserFieldKeyUserId:     struct{}{},
	UserFieldName:          struct{}{},
	UserFieldNickname:      struct{}{},
	UserFieldEmail:         struct{}{},
	UserFieldEmailVerified: struct{}{},
	UserFieldPassword:      struct{}{},
	UserFieldPasshash:      struct{}{},
	UserFieldFamilyName:    struct{}{},
	UserFieldGivenName:     struct{}{},
	UserFieldPicture:       struct{}{},
}

func (m *User) DiffFields(o *User, fields map[string]struct{}) {
	if m.Key.UserId != o.Key.UserId {
		fields[UserFieldKeyUserId] = struct{}{}
		fields[UserFieldKey] = struct{}{}
	}
	if m.Name != o.Name {
		fields[UserFieldName] = struct{}{}
	}
	if m.Nickname != o.Nickname {
		fields[UserFieldNickname] = struct{}{}
	}
	if m.Email != o.Email {
		fields[UserFieldEmail] = struct{}{}
	}
	if m.EmailVerified != o.EmailVerified {
		fields[UserFieldEmailVerified] = struct{}{}
	}
	if m.Password != o.Password {
		fields[UserFieldPassword] = struct{}{}
	}
	if m.Passhash != o.Passhash {
		fields[UserFieldPasshash] = struct{}{}
	}
	if m.FamilyName != o.FamilyName {
		fields[UserFieldFamilyName] = struct{}{}
	}
	if m.GivenName != o.GivenName {
		fields[UserFieldGivenName] = struct{}{}
	}
	if m.Picture != o.Picture {
		fields[UserFieldPicture] = struct{}{}
	}
}

func (m *User) CopyInFields(src *User) {
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			m.Key.UserId = src.Key.UserId
		}
	}
	if _, set := fmap["3"]; set {
		m.Name = src.Name
	}
	if _, set := fmap["4"]; set {
		m.Nickname = src.Nickname
	}
	if _, set := fmap["5"]; set {
		m.Email = src.Email
	}
	if _, set := fmap["6"]; set {
		m.EmailVerified = src.EmailVerified
	}
	if _, set := fmap["7"]; set {
		m.Password = src.Password
	}
	if _, set := fmap["8"]; set {
		m.Passhash = src.Passhash
	}
	if _, set := fmap["9"]; set {
		m.FamilyName = src.FamilyName
	}
	if _, set := fmap["10"]; set {
		m.GivenName = src.GivenName
	}
	if _, set := fmap["11"]; set {
		m.Picture = src.Picture
	}
}

func (m *User) GetKey() objstore.ObjKey {
	return &m.Key
}

type UserSql struct {
	DB    *sql.DB
	Table string
}

func (s *UserSql) Init(db *sql.DB) {
	s.DB = db
	s.Table = "Users"
}

func CreateUserSqlTable(db *sql.DB) (sql.Result, error) {
	return db.Exec("CREATE TABLE IF NOT EXISTS Users(" +
		"UserId bigserial  primary key, " +
		"Name text , " +
		"Nickname text , " +
		"Email text , " +
		"EmailVerified boolean , " +
		"Passhash text , " +
		"FamilyName text , " +
		"GivenName text , " +
		"Picture text )")
}

func (s *UserSql) Create(m *User) (sql.Result, error) {
	err := m.Validate(UserAllFieldsMap)
	if err != nil {
		return nil, err
	}
	stmt := "INSERT INTO Users(Name, Nickname, Email, EmailVerified, Passhash, FamilyName, GivenName, Picture) VALUES($2, $3, $4, $5, $6, $7, $8, $9)"
	log.DebugLog(log.DebugLevelApi, "create User", "stmt", stmt, "vals", []interface{}{m.Name, m.Nickname, m.Email, m.EmailVerified, m.Passhash, m.FamilyName, m.GivenName, m.Picture})
	return s.DB.Exec(stmt, m.Name, m.Nickname, m.Email, m.EmailVerified, m.Passhash, m.FamilyName, m.GivenName, m.Picture)
}

func (s *UserSql) Delete(m *User) (sql.Result, error) {
	err := m.GetKey().Validate()
	if err != nil {
		return nil, err
	}
	stmt := "DELETE FROM Users WHERE UserId = $1"
	log.DebugLog(log.DebugLevelApi, "delete User", "stmt", stmt, "key", m.Key.UserId)
	return s.DB.Exec(stmt, m.Key.UserId)
}

func (s *UserSql) HasKey(key *UserKey) (bool, error) {
	buf := User{}
	return s.Get(key, &buf)
}

func (s *UserSql) Get(key *UserKey, buf *User) (bool, error) {
	stmt := "SELECT UserId, Name, Nickname, Email, EmailVerified, Passhash, FamilyName, GivenName, Picture FROM Users WHERE UserId = $1"
	row := s.DB.QueryRow(stmt, key.UserId)
	err := row.Scan(&buf.Key.UserId, &buf.Name, &buf.Nickname, &buf.Email, &buf.EmailVerified, &buf.Passhash, &buf.FamilyName, &buf.GivenName, &buf.Picture)
	if err == nil {
		return true, nil
	} else if err == sql.ErrNoRows {
		return false, nil
	}
	return false, err
}

func (s *UserSql) Show(filter *User, cb func(ret *User) error) error {
	stmt := "SELECT UserId, Name, Nickname, Email, EmailVerified, Passhash, FamilyName, GivenName, Picture FROM Users"
	rows, err := s.DB.Query(stmt)
	if err != nil {
		return err
	}
	defer rows.Close()
	for rows.Next() {
		buf := User{}
		err = rows.Scan(&buf.Key.UserId, &buf.Name, &buf.Nickname, &buf.Email, &buf.EmailVerified, &buf.Passhash, &buf.FamilyName, &buf.GivenName, &buf.Picture)
		if err != nil {
			return fmt.Errorf("sql scan failed, %s", err.Error())
		}
		err = cb(&buf)
		if err != nil {
			return err
		}
	}
	// return any error encountered during iteration
	err = rows.Err()
	if err != nil {
		return err
	}
	return nil
}
func (s *UserSql) Update(m *User) (sql.Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	vars := make([]interface{}, 0)
	sets := make([]string, 0)

	vars = append(vars, m.Key.UserId) // $1
	if _, found := fmap["3"]; found {
		vars = append(vars, m.Name)
		sets = append(sets, "Name = $"+strconv.Itoa(len(vars)))
	}
	if _, found := fmap["4"]; found {
		vars = append(vars, m.Nickname)
		sets = append(sets, "Nickname = $"+strconv.Itoa(len(vars)))
	}
	if _, found := fmap["5"]; found {
		vars = append(vars, m.Email)
		sets = append(sets, "Email = $"+strconv.Itoa(len(vars)))
	}
	if _, found := fmap["6"]; found {
		vars = append(vars, m.EmailVerified)
		sets = append(sets, "EmailVerified = $"+strconv.Itoa(len(vars)))
	}
	if _, found := fmap["8"]; found {
		vars = append(vars, m.Passhash)
		sets = append(sets, "Passhash = $"+strconv.Itoa(len(vars)))
	}
	if _, found := fmap["9"]; found {
		vars = append(vars, m.FamilyName)
		sets = append(sets, "FamilyName = $"+strconv.Itoa(len(vars)))
	}
	if _, found := fmap["10"]; found {
		vars = append(vars, m.GivenName)
		sets = append(sets, "GivenName = $"+strconv.Itoa(len(vars)))
	}
	if _, found := fmap["11"]; found {
		vars = append(vars, m.Picture)
		sets = append(sets, "Picture = $"+strconv.Itoa(len(vars)))
	}
	if len(sets) == 0 {
		// nothing specified to update
		return nil, fmt.Errorf("No fields specified to update")
	}

	stmt := fmt.Sprintf("UPDATE Users SET %s WHERE UserId = $1", strings.Join(sets, ", "))
	log.DebugLog(log.DebugLevelApi, "update User", "stmt", stmt, "vars", vars)
	res, err := s.DB.Exec(stmt, vars...)
	if err != nil {
		return res, err
	}
	count, err := res.RowsAffected()
	if err != nil {
		return res, err
	}
	if count != 1 {
		return res, fmt.Errorf("Updated %d rows instead of 1", count)
	}
	return res, nil
}

func (s *UserSql) GetMatch(filter *User, buf *User) (bool, error) {
	fmap := MakeFieldMap(filter.Fields)
	vars := make([]interface{}, 0)
	reqs := make([]string, 0)
	if _, found := fmap["2.1"]; found {
		vars = append(vars, filter.Key.UserId)
		reqs = append(reqs, "UserId = $"+strconv.Itoa(len(vars)))
	}
	if _, found := fmap["3"]; found {
		vars = append(vars, filter.Name)
		reqs = append(reqs, "Name = $"+strconv.Itoa(len(vars)))
	}
	if _, found := fmap["4"]; found {
		vars = append(vars, filter.Nickname)
		reqs = append(reqs, "Nickname = $"+strconv.Itoa(len(vars)))
	}
	if _, found := fmap["5"]; found {
		vars = append(vars, filter.Email)
		reqs = append(reqs, "Email = $"+strconv.Itoa(len(vars)))
	}
	if _, found := fmap["6"]; found {
		vars = append(vars, filter.EmailVerified)
		reqs = append(reqs, "EmailVerified = $"+strconv.Itoa(len(vars)))
	}
	if _, found := fmap["8"]; found {
		vars = append(vars, filter.Passhash)
		reqs = append(reqs, "Passhash = $"+strconv.Itoa(len(vars)))
	}
	if _, found := fmap["9"]; found {
		vars = append(vars, filter.FamilyName)
		reqs = append(reqs, "FamilyName = $"+strconv.Itoa(len(vars)))
	}
	if _, found := fmap["10"]; found {
		vars = append(vars, filter.GivenName)
		reqs = append(reqs, "GivenName = $"+strconv.Itoa(len(vars)))
	}
	if _, found := fmap["11"]; found {
		vars = append(vars, filter.Picture)
		reqs = append(reqs, "Picture = $"+strconv.Itoa(len(vars)))
	}

	stmt := fmt.Sprintf("SELECT UserId, Name, Nickname, Email, EmailVerified, Passhash, FamilyName, GivenName, Picture FROM Users WHERE %s", strings.Join(reqs, " AND "))
	log.DebugLog(log.DebugLevelApi, "get match User", "stmt", stmt, "vars", vars)
	row := s.DB.QueryRow(stmt, vars...)
	err := row.Scan(&buf.Key.UserId, &buf.Name, &buf.Nickname, &buf.Email, &buf.EmailVerified, &buf.Passhash, &buf.FamilyName, &buf.GivenName, &buf.Picture)
	if err == nil {
		return true, nil
	} else if err == sql.ErrNoRows {
		return false, nil
	}
	return false, err
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *User) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *RoleKey) Matches(o *RoleKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.Id != 0 {
		if o.Id != m.Id {
			return false
		}
	}
	return true
}

func (m *RoleKey) CopyInFields(src *RoleKey) {
	m.Id = src.Id
}

func (m *RoleKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal RoleKey key string", "obj", m)
	}
	return string(key)
}

func RoleKeyStringParse(str string, key *RoleKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal RoleKey key string", "str", str)
	}
}

// Helper method to check that enums have valid values
func (m *RoleKey) ValidateEnums() error {
	return nil
}

func (m *Role) Matches(o *Role, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.UserId != 0 {
		if o.UserId != m.UserId {
			return false
		}
	}
	if !opts.Filter || o.OrgType != 0 {
		if o.OrgType != m.OrgType {
			return false
		}
	}
	if !opts.Filter || o.OrgName != "" {
		if o.OrgName != m.OrgName {
			return false
		}
	}
	if !opts.Filter || o.RoleType != 0 {
		if o.RoleType != m.RoleType {
			return false
		}
	}
	return true
}

func (m *Role) CopyInFields(src *Role) {
	m.Key.Id = src.Key.Id
	m.UserId = src.UserId
	m.OrgType = src.OrgType
	m.OrgName = src.OrgName
	m.RoleType = src.RoleType
}

func (m *Role) GetKey() objstore.ObjKey {
	return &m.Key
}

type RoleSql struct {
	DB    *sql.DB
	Table string
}

func (s *RoleSql) Init(db *sql.DB) {
	s.DB = db
	s.Table = "Roles"
}

func CreateRoleSqlTable(db *sql.DB) (sql.Result, error) {
	return db.Exec("CREATE TABLE IF NOT EXISTS Roles(" +
		"Id bigserial  primary key, " +
		"UserId bigint , " +
		"OrgType text , " +
		"OrgName text , " +
		"RoleType text )")
}

func (s *RoleSql) Create(m *Role) (sql.Result, error) {
	err := m.Validate()
	if err != nil {
		return nil, err
	}
	stmt := "INSERT INTO Roles(UserId, OrgType, OrgName, RoleType) VALUES($2, $3, $4, $5)"
	log.DebugLog(log.DebugLevelApi, "create Role", "stmt", stmt, "vals", []interface{}{m.UserId, m.OrgType, m.OrgName, m.RoleType})
	return s.DB.Exec(stmt, m.UserId, m.OrgType, m.OrgName, m.RoleType)
}

func (s *RoleSql) Delete(m *Role) (sql.Result, error) {
	err := m.GetKey().Validate()
	if err != nil {
		return nil, err
	}
	stmt := "DELETE FROM Roles WHERE Id = $1"
	log.DebugLog(log.DebugLevelApi, "delete Role", "stmt", stmt, "key", m.Key.Id)
	return s.DB.Exec(stmt, m.Key.Id)
}

func (s *RoleSql) HasKey(key *RoleKey) (bool, error) {
	buf := Role{}
	return s.Get(key, &buf)
}

func (s *RoleSql) Get(key *RoleKey, buf *Role) (bool, error) {
	stmt := "SELECT Id, UserId, OrgType, OrgName, RoleType FROM Roles WHERE Id = $1"
	row := s.DB.QueryRow(stmt, key.Id)
	err := row.Scan(&buf.Key.Id, &buf.UserId, &buf.OrgType, &buf.OrgName, &buf.RoleType)
	if err == nil {
		return true, nil
	} else if err == sql.ErrNoRows {
		return false, nil
	}
	return false, err
}

func (s *RoleSql) Show(filter *Role, cb func(ret *Role) error) error {
	stmt := "SELECT Id, UserId, OrgType, OrgName, RoleType FROM Roles"
	rows, err := s.DB.Query(stmt)
	if err != nil {
		return err
	}
	defer rows.Close()
	for rows.Next() {
		buf := Role{}
		err = rows.Scan(&buf.Key.Id, &buf.UserId, &buf.OrgType, &buf.OrgName, &buf.RoleType)
		if err != nil {
			return fmt.Errorf("sql scan failed, %s", err.Error())
		}
		err = cb(&buf)
		if err != nil {
			return err
		}
	}
	// return any error encountered during iteration
	err = rows.Err()
	if err != nil {
		return err
	}
	return nil
}

// Helper method to check that enums have valid values
func (m *Role) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := OrgType_name[int32(m.OrgType)]; !ok {
		return errors.New("invalid OrgType")
	}
	if _, ok := RoleType_name[int32(m.RoleType)]; !ok {
		return errors.New("invalid RoleType")
	}
	return nil
}

var OrgTypeStrings = []string{
	"OrgTypeUnknown",
	"OrgTypeAdmin",
	"OrgTypeDeveloper",
	"OrgTypeOperator",
}

const (
	OrgTypeOrgTypeUnknown   uint64 = 1 << 0
	OrgTypeOrgTypeAdmin     uint64 = 1 << 1
	OrgTypeOrgTypeDeveloper uint64 = 1 << 2
	OrgTypeOrgTypeOperator  uint64 = 1 << 3
)

func (e *OrgType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := OrgType_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = OrgType_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = OrgType(val)
	return nil
}

func (e OrgType) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

var RoleTypeStrings = []string{
	"RoleTypeUnknown",
	"RoleTypeAdmin",
	"RoleTypeReadOnly",
}

const (
	RoleTypeRoleTypeUnknown  uint64 = 1 << 0
	RoleTypeRoleTypeAdmin    uint64 = 1 << 1
	RoleTypeRoleTypeReadOnly uint64 = 1 << 2
)

func (e *RoleType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := RoleType_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = RoleType_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = RoleType(val)
	return nil
}

func (e RoleType) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

func (m *UserKey) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovUser(uint64(m.UserId))
	}
	return n
}

func (m *User) Size() (n int) {
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovUser(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovUser(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovUser(uint64(l))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovUser(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovUser(uint64(l))
	}
	if m.EmailVerified {
		n += 2
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovUser(uint64(l))
	}
	l = len(m.Passhash)
	if l > 0 {
		n += 1 + l + sovUser(uint64(l))
	}
	l = len(m.FamilyName)
	if l > 0 {
		n += 1 + l + sovUser(uint64(l))
	}
	l = len(m.GivenName)
	if l > 0 {
		n += 1 + l + sovUser(uint64(l))
	}
	l = len(m.Picture)
	if l > 0 {
		n += 1 + l + sovUser(uint64(l))
	}
	return n
}

func (m *RoleKey) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovUser(uint64(m.Id))
	}
	return n
}

func (m *Role) Size() (n int) {
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovUser(uint64(l))
	if m.UserId != 0 {
		n += 1 + sovUser(uint64(m.UserId))
	}
	if m.OrgType != 0 {
		n += 1 + sovUser(uint64(m.OrgType))
	}
	l = len(m.OrgName)
	if l > 0 {
		n += 1 + l + sovUser(uint64(l))
	}
	if m.RoleType != 0 {
		n += 1 + sovUser(uint64(m.RoleType))
	}
	return n
}

func sovUser(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozUser(x uint64) (n int) {
	return sovUser(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UserKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUser
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUser(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUser
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUser
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUser
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUser
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUser
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUser
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUser
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailVerified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EmailVerified = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUser
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passhash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUser
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Passhash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FamilyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUser
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FamilyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GivenName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUser
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GivenName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Picture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUser
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Picture = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUser(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUser
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUser
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUser(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUser
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Role) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUser
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Role: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Role: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUser
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgType", wireType)
			}
			m.OrgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgType |= (OrgType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUser
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleType", wireType)
			}
			m.RoleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoleType |= (RoleType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUser(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUser
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipUser(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowUser
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUser
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUser
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthUser
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowUser
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipUser(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthUser = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowUser   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("user.proto", fileDescriptorUser) }

var fileDescriptorUser = []byte{
	// 778 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x94, 0x4f, 0x6f, 0xf3, 0x44,
	0x10, 0xc6, 0xbb, 0x4e, 0x1a, 0xdb, 0x93, 0x34, 0x71, 0xb7, 0xa5, 0x35, 0x11, 0x4d, 0x23, 0x4b,
	0xa0, 0x28, 0x52, 0xe3, 0xaa, 0x48, 0x08, 0xf5, 0x82, 0x9a, 0x16, 0x41, 0x05, 0xa2, 0x92, 0xa1,
	0x1c, 0xb8, 0x44, 0x4e, 0xbc, 0x71, 0x56, 0x75, 0xbc, 0xd6, 0xda, 0x49, 0xc8, 0x95, 0xaf, 0xc0,
	0x89, 0x1b, 0x1f, 0x81, 0x8f, 0xc0, 0x31, 0x47, 0xfe, 0x9c, 0xb8, 0x20, 0xa8, 0x38, 0x70, 0x6f,
	0x0f, 0x88, 0x13, 0xda, 0xb5, 0x9d, 0x84, 0xbc, 0x7d, 0xa5, 0xaa, 0x97, 0x68, 0xe6, 0x79, 0x76,
	0x7e, 0xbb, 0x3b, 0xe3, 0x0d, 0xc0, 0x24, 0x26, 0xbc, 0x13, 0x71, 0x96, 0x30, 0xac, 0x13, 0xcf,
	0x27, 0x32, 0xac, 0x57, 0x38, 0x89, 0x27, 0x41, 0x92, 0x1a, 0xf5, 0xb7, 0x7c, 0xc6, 0xfc, 0x80,
	0xd8, 0x6e, 0x44, 0x6d, 0x37, 0x0c, 0x59, 0xe2, 0x26, 0x94, 0x85, 0x71, 0xe6, 0xbe, 0xef, 0xd3,
	0x64, 0x34, 0xe9, 0x77, 0x06, 0x6c, 0x6c, 0x8f, 0x59, 0x9f, 0x06, 0x02, 0xf3, 0xb5, 0x2d, 0x7e,
	0x4f, 0x06, 0x01, 0x9b, 0x78, 0xb6, 0x5c, 0xe7, 0x93, 0x70, 0x19, 0x64, 0x95, 0x27, 0x6b, 0x95,
	0x3e, 0xf3, 0x59, 0xea, 0xf7, 0x27, 0x43, 0x99, 0xc9, 0x44, 0x46, 0xe9, 0x72, 0xeb, 0x03, 0x50,
	0x6f, 0x63, 0xc2, 0x3f, 0x21, 0x73, 0xfc, 0x0e, 0xa8, 0xe2, 0xe0, 0x3d, 0xea, 0x99, 0xa8, 0x89,
	0x5a, 0x85, 0xee, 0xce, 0x2f, 0x8f, 0xa6, 0xde, 0xa7, 0x7e, 0x4c, 0x38, 0x75, 0x03, 0xa7, 0x24,
	0xdc, 0x6b, 0xef, 0xbc, 0xf2, 0xf7, 0x83, 0x89, 0xfe, 0x79, 0x30, 0xd1, 0x0f, 0xdf, 0x1f, 0x23,
	0xeb, 0x37, 0x05, 0x8a, 0x82, 0x80, 0x0f, 0xa0, 0x34, 0xa4, 0x24, 0xf0, 0x62, 0x13, 0x35, 0x0b,
	0x2d, 0xdd, 0xc9, 0x32, 0xdc, 0x86, 0xc2, 0x1d, 0x99, 0x9b, 0x4a, 0x13, 0xb5, 0xca, 0x67, 0xb8,
	0xb3, 0xec, 0x47, 0x27, 0xdb, 0xb7, 0x5b, 0x5c, 0xfc, 0x7e, 0xbc, 0xe5, 0x88, 0x45, 0x18, 0x43,
	0x31, 0x74, 0xc7, 0xc4, 0x2c, 0x34, 0x51, 0x4b, 0x77, 0x64, 0x8c, 0xeb, 0xa0, 0x85, 0x74, 0x70,
	0x27, 0xf5, 0xa2, 0xd4, 0x97, 0x39, 0xde, 0x87, 0x6d, 0x32, 0x76, 0x69, 0x60, 0x6e, 0x4b, 0x23,
	0x4d, 0xf0, 0xdb, 0x50, 0x95, 0x41, 0x6f, 0x4a, 0x38, 0x1d, 0x52, 0xe2, 0x99, 0xa5, 0x26, 0x6a,
	0x69, 0xce, 0x8e, 0x54, 0xbf, 0xcc, 0x44, 0xdc, 0x04, 0x2d, 0x72, 0xe3, 0x78, 0xc6, 0xb8, 0x67,
	0xaa, 0xa2, 0xbe, 0x5b, 0x5c, 0x3c, 0x9a, 0xc8, 0x59, 0xaa, 0x62, 0x6b, 0x11, 0x8f, 0xdc, 0x78,
	0x64, 0x6a, 0xe9, 0xd6, 0x79, 0x8e, 0x8f, 0xa1, 0x3c, 0x74, 0xc7, 0x34, 0x98, 0xf7, 0xe4, 0xc9,
	0x74, 0x69, 0x43, 0x2a, 0x7d, 0x26, 0xce, 0x76, 0x04, 0xe0, 0xd3, 0x29, 0x09, 0x53, 0x1f, 0xa4,
	0xaf, 0x4b, 0x45, 0xda, 0x26, 0xa8, 0x11, 0x1d, 0x24, 0x13, 0x4e, 0xcc, 0xb2, 0xf4, 0xf2, 0xf4,
	0x5c, 0x13, 0xfd, 0xfd, 0xf1, 0xd1, 0x44, 0xd6, 0x7b, 0xa0, 0x3a, 0x2c, 0x20, 0x62, 0x38, 0x47,
	0xa0, 0xbc, 0x6e, 0x2e, 0x0a, 0xdd, 0x9c, 0xc9, 0xcf, 0x08, 0x8a, 0xa2, 0x30, 0xef, 0x3d, 0x7a,
	0xa5, 0xf7, 0x19, 0x76, 0xbd, 0xf7, 0x87, 0xab, 0xf1, 0x8b, 0x59, 0x15, 0xf2, 0x79, 0xe3, 0x13,
	0xd0, 0x18, 0xf7, 0x7b, 0xc9, 0x3c, 0x4a, 0x07, 0x53, 0xfd, 0x1f, 0xe9, 0x86, 0xfb, 0x5f, 0xcc,
	0x23, 0xe2, 0xa8, 0x2c, 0x0d, 0xf0, 0x9b, 0xe9, 0xf2, 0xb5, 0x79, 0x09, 0x4b, 0xde, 0xf9, 0x14,
	0x74, 0xce, 0x02, 0x92, 0xa2, 0xb6, 0x25, 0x6a, 0x6f, 0xe3, 0x50, 0x92, 0xa5, 0xf1, 0x2c, 0x5a,
	0xf5, 0xa2, 0xfd, 0x15, 0xa8, 0xd9, 0x56, 0x18, 0x43, 0x35, 0x0b, 0x6f, 0xc3, 0xbb, 0x90, 0xcd,
	0x42, 0x63, 0x0b, 0x1b, 0x50, 0xc9, 0xb4, 0x0b, 0x6f, 0x4c, 0x43, 0x03, 0xe1, 0x7d, 0x30, 0x32,
	0xe5, 0x8a, 0x4c, 0x49, 0xc0, 0x22, 0xc2, 0x0d, 0x05, 0xef, 0x41, 0x2d, 0x53, 0x6f, 0x22, 0xc2,
	0xdd, 0x84, 0x71, 0xa3, 0xd0, 0xfe, 0x18, 0xb4, 0x7c, 0x6f, 0xb1, 0x20, 0x8f, 0x57, 0xf4, 0x5d,
	0xd8, 0xc9, 0xc5, 0x35, 0xfc, 0xf2, 0xbc, 0xc4, 0xf5, 0x6e, 0xc2, 0x60, 0x6e, 0x28, 0x67, 0xff,
	0x2a, 0xe9, 0x7b, 0xba, 0x88, 0x28, 0xfe, 0x08, 0xf4, 0x4f, 0x99, 0x4f, 0x43, 0xf9, 0x3a, 0x6a,
	0x1b, 0x1f, 0x7e, 0x7d, 0x77, 0xfd, 0xe2, 0xf2, 0x8f, 0xc1, 0x3a, 0xf8, 0xe6, 0xd7, 0xbf, 0xbe,
	0x55, 0x0c, 0xab, 0x6c, 0x07, 0xa2, 0xce, 0x16, 0xfd, 0x3f, 0x47, 0x6d, 0x7c, 0x0d, 0x70, 0xc9,
	0x89, 0x9b, 0x90, 0x67, 0x93, 0x0e, 0x25, 0x69, 0xd7, 0xaa, 0xd8, 0x03, 0x59, 0xb8, 0x8e, 0xba,
	0x8d, 0xbc, 0x97, 0xa1, 0x26, 0xb2, 0x70, 0x1d, 0x75, 0x45, 0x02, 0xf2, 0x22, 0x94, 0x27, 0x0b,
	0x97, 0xa8, 0x0f, 0x41, 0xfb, 0x7c, 0xc4, 0x66, 0x4f, 0x83, 0x36, 0x05, 0xeb, 0x0d, 0x89, 0xa9,
	0x59, 0x60, 0xc7, 0x23, 0x36, 0xcb, 0x21, 0xa7, 0xe8, 0xec, 0x3b, 0x94, 0xbe, 0x17, 0xd1, 0xfc,
	0x4b, 0x50, 0x2f, 0x3c, 0x4f, 0x3e, 0x82, 0xda, 0xc6, 0x27, 0xf6, 0xd4, 0xd1, 0xf6, 0x25, 0xb3,
	0x6a, 0xe9, 0xb6, 0xeb, 0x79, 0xb6, 0xf8, 0xfc, 0xb2, 0x2b, 0x3a, 0x64, 0xcc, 0xa6, 0xe4, 0xd9,
	0x9c, 0xd5, 0x15, 0xb9, 0x2c, 0xcc, 0x51, 0x5d, 0x63, 0xf1, 0x67, 0x63, 0x6b, 0x71, 0xdf, 0x40,
	0x3f, 0xdd, 0x37, 0xd0, 0x1f, 0xf7, 0x0d, 0xd4, 0x2f, 0xc9, 0xc2, 0x77, 0xff, 0x0b, 0x00, 0x00,
	0xff, 0xff, 0xe3, 0x92, 0x7d, 0xe0, 0x2e, 0x06, 0x00, 0x00,
}
