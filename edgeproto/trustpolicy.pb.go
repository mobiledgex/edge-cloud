// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: trustpolicy.proto

package edgeproto

import (
	context "context"
	"encoding/json"
	fmt "fmt"
	"github.com/coreos/etcd/clientv3/concurrency"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/mobiledgex/edge-cloud/log"
	"github.com/mobiledgex/edge-cloud/objstore"
	_ "github.com/mobiledgex/edge-cloud/protogen"
	"github.com/mobiledgex/edge-cloud/util"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type SecurityRule struct {
	// tcp, udp, icmp
	Protocol string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// TCP or UDP port range start
	PortRangeMin uint32 `protobuf:"varint,2,opt,name=port_range_min,json=portRangeMin,proto3" json:"port_range_min,omitempty"`
	// TCP or UDP port range end
	PortRangeMax uint32 `protobuf:"varint,3,opt,name=port_range_max,json=portRangeMax,proto3" json:"port_range_max,omitempty"`
	// remote CIDR X.X.X.X/X
	RemoteCidr string `protobuf:"bytes,4,opt,name=remote_cidr,json=remoteCidr,proto3" json:"remote_cidr,omitempty"`
}

func (m *SecurityRule) Reset()         { *m = SecurityRule{} }
func (m *SecurityRule) String() string { return proto.CompactTextString(m) }
func (*SecurityRule) ProtoMessage()    {}
func (*SecurityRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ac2a49c998f3261, []int{0}
}
func (m *SecurityRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityRule.Merge(m, src)
}
func (m *SecurityRule) XXX_Size() int {
	return m.Size()
}
func (m *SecurityRule) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityRule.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityRule proto.InternalMessageInfo

// TrustPolicy defines security restrictions for cluster instances
// nodes scaled up or down.
type TrustPolicy struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique identifier key
	Key PolicyKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// list of outbound security rules for whitelisting traffic
	OutboundSecurityRules []SecurityRule `protobuf:"bytes,3,rep,name=outbound_security_rules,json=outboundSecurityRules,proto3" json:"outbound_security_rules"`
}

func (m *TrustPolicy) Reset()         { *m = TrustPolicy{} }
func (m *TrustPolicy) String() string { return proto.CompactTextString(m) }
func (*TrustPolicy) ProtoMessage()    {}
func (*TrustPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ac2a49c998f3261, []int{1}
}
func (m *TrustPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrustPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrustPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrustPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrustPolicy.Merge(m, src)
}
func (m *TrustPolicy) XXX_Size() int {
	return m.Size()
}
func (m *TrustPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_TrustPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_TrustPolicy proto.InternalMessageInfo

func init() {
	proto.RegisterType((*SecurityRule)(nil), "edgeproto.SecurityRule")
	proto.RegisterType((*TrustPolicy)(nil), "edgeproto.TrustPolicy")
}

func init() { proto.RegisterFile("trustpolicy.proto", fileDescriptor_0ac2a49c998f3261) }

var fileDescriptor_0ac2a49c998f3261 = []byte{
	// 621 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x93, 0xbd, 0x4f, 0x14, 0x4f,
	0x18, 0xc7, 0x6f, 0x38, 0x7e, 0xe4, 0xc7, 0x1c, 0x22, 0xb7, 0xf2, 0x32, 0xb9, 0x90, 0xe5, 0x72,
	0xb1, 0xb8, 0xe8, 0x71, 0x6b, 0xb0, 0x31, 0x24, 0x14, 0x80, 0x1d, 0xc1, 0x97, 0x45, 0x6c, 0x2c,
	0x2e, 0x73, 0xbb, 0x8f, 0xcb, 0x84, 0xb9, 0x9d, 0xcb, 0xec, 0x4c, 0xe0, 0xac, 0x8c, 0x8d, 0x85,
	0x0d, 0x89, 0x89, 0x18, 0xff, 0x02, 0xa3, 0x8d, 0xf1, 0xaf, 0xa0, 0x24, 0xb1, 0xb1, 0x32, 0x0a,
	0x16, 0x86, 0xca, 0x84, 0x85, 0xda, 0xec, 0xb0, 0x5c, 0xd6, 0x43, 0x12, 0x43, 0x63, 0xb3, 0x79,
	0x9e, 0xef, 0x3c, 0x2f, 0x9f, 0xfd, 0xee, 0x2c, 0x2e, 0x2a, 0xa9, 0x23, 0xd5, 0x16, 0x9c, 0x79,
	0x9d, 0x7a, 0x5b, 0x0a, 0x25, 0xac, 0x41, 0xf0, 0x03, 0x30, 0x61, 0x69, 0x32, 0x10, 0x22, 0xe0,
	0xe0, 0xd0, 0x36, 0x73, 0x68, 0x18, 0x0a, 0x45, 0x15, 0x13, 0x61, 0x74, 0x52, 0x58, 0x1a, 0x92,
	0x10, 0x69, 0xae, 0xd2, 0xec, 0x56, 0xc0, 0xd4, 0x9a, 0x6e, 0xd6, 0x3d, 0xd1, 0x72, 0x5a, 0xa2,
	0xc9, 0x78, 0x32, 0x66, 0xd3, 0x49, 0x9e, 0xd3, 0x1e, 0x17, 0xda, 0x77, 0x4c, 0x5d, 0x00, 0x61,
	0x37, 0x48, 0x3b, 0x47, 0x03, 0x11, 0x08, 0x13, 0x3a, 0x49, 0x94, 0xaa, 0x63, 0x54, 0x2b, 0x11,
	0x79, 0x94, 0x43, 0x96, 0xae, 0xb2, 0x8d, 0xf0, 0xd0, 0x0a, 0x78, 0x5a, 0x32, 0xd5, 0x71, 0x35,
	0x07, 0xab, 0x84, 0xff, 0x37, 0x27, 0x9e, 0xe0, 0x04, 0x95, 0x51, 0x75, 0xd0, 0xed, 0xe6, 0xd6,
	0x55, 0x3c, 0xdc, 0x16, 0x52, 0x35, 0x24, 0x0d, 0x03, 0x68, 0xb4, 0x58, 0x48, 0xfa, 0xca, 0xa8,
	0x7a, 0xc9, 0x1d, 0x4a, 0x54, 0x37, 0x11, 0x97, 0x59, 0xd8, 0x5b, 0x45, 0x37, 0x49, 0xbe, 0xb7,
	0x8a, 0x6e, 0x5a, 0x53, 0xb8, 0x20, 0xa1, 0x25, 0x14, 0x34, 0x3c, 0xe6, 0x4b, 0xd2, 0x6f, 0x56,
	0xe1, 0x13, 0x69, 0x91, 0xf9, 0xb2, 0xf2, 0xbc, 0x0f, 0x17, 0x1e, 0x24, 0x6e, 0xde, 0x33, 0xbc,
	0xd6, 0x38, 0x1e, 0x78, 0xcc, 0x80, 0xfb, 0x11, 0x41, 0xe5, 0x7c, 0x75, 0xd0, 0x4d, 0x33, 0xab,
	0x86, 0xf3, 0xeb, 0xd0, 0x31, 0x24, 0x85, 0x99, 0xd1, 0x7a, 0xd7, 0xed, 0xfa, 0x49, 0xdf, 0x12,
	0x74, 0x16, 0xfa, 0x77, 0xbe, 0x4c, 0xe5, 0xdc, 0xa4, 0xcc, 0x5a, 0xc5, 0x13, 0x42, 0xab, 0xa6,
	0xd0, 0xa1, 0xdf, 0x88, 0xd2, 0xf7, 0x6e, 0x48, 0xcd, 0x21, 0x22, 0xf9, 0x72, 0xbe, 0x5a, 0x98,
	0x99, 0xc8, 0x4c, 0xc8, 0x1a, 0x93, 0x0e, 0x19, 0x3b, 0xed, 0xce, 0x9e, 0x45, 0xb3, 0x8f, 0x7e,
	0x1c, 0x12, 0xf4, 0xf3, 0x90, 0xa0, 0xa7, 0x31, 0x41, 0x5b, 0x31, 0x41, 0xaf, 0x63, 0x82, 0x3e,
	0xc4, 0x04, 0xbd, 0x39, 0x22, 0xd7, 0x43, 0xda, 0x82, 0xb9, 0x25, 0xe8, 0xd4, 0xef, 0xd0, 0x16,
	0xd4, 0xcc, 0xc7, 0xe3, 0xa0, 0xa6, 0x85, 0x0c, 0x8c, 0x7a, 0x57, 0x06, 0x34, 0x64, 0x4f, 0xcc,
	0x5d, 0xf8, 0x78, 0x4c, 0x46, 0xd6, 0xa1, 0x33, 0x97, 0xd5, 0x66, 0x5e, 0xfc, 0x87, 0x87, 0x33,
	0x4e, 0xcc, 0xb7, 0x99, 0xf5, 0x1e, 0xe1, 0xe2, 0xa2, 0x04, 0xaa, 0xe0, 0x37, 0x8b, 0x32, 0xec,
	0x19, 0xbd, 0x54, 0xcc, 0xe8, 0xae, 0xb9, 0x64, 0x15, 0x76, 0x10, 0x13, 0xc7, 0x85, 0x48, 0x68,
	0xe9, 0xc1, 0x62, 0x8a, 0x14, 0xd5, 0xe6, 0xbd, 0x64, 0xe3, 0x32, 0x0d, 0x69, 0x00, 0xb5, 0x5e,
	0xb8, 0xb7, 0x47, 0x04, 0xbd, 0x3b, 0x26, 0x23, 0xbd, 0xfa, 0xb3, 0x4f, 0xdf, 0x5f, 0xf6, 0x91,
	0xca, 0x15, 0xc7, 0x33, 0x44, 0x4e, 0xe6, 0x1f, 0x98, 0x45, 0xd7, 0x6e, 0x20, 0x6b, 0x1b, 0xe1,
	0xe2, 0x6d, 0xe0, 0x70, 0x61, 0xda, 0xd5, 0x0b, 0xd2, 0x76, 0xc9, 0x7c, 0xb3, 0xfd, 0xcf, 0x64,
	0xab, 0x6d, 0x9f, 0xfe, 0x3b, 0x32, 0x6d, 0xb6, 0x9f, 0x25, 0x7b, 0x85, 0xf0, 0xe5, 0x95, 0x35,
	0xb1, 0xf1, 0x37, 0x5c, 0xe7, 0xe8, 0x95, 0xfb, 0x07, 0x31, 0x99, 0x3e, 0x0f, 0xee, 0x21, 0x83,
	0x8d, 0x33, 0x68, 0xbb, 0xa7, 0x68, 0xe3, 0x95, 0xa2, 0x13, 0xad, 0x89, 0x8d, 0x33, 0x60, 0x0b,
	0x93, 0x3b, 0xdf, 0xec, 0xdc, 0xce, 0x9e, 0x8d, 0x76, 0xf7, 0x6c, 0xf4, 0x75, 0xcf, 0x46, 0x5b,
	0xfb, 0x76, 0x6e, 0x77, 0xdf, 0xce, 0x7d, 0xde, 0xb7, 0x73, 0xcd, 0x01, 0x43, 0x71, 0xf3, 0x57,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x0c, 0x6b, 0x43, 0xcc, 0x09, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TrustPolicyApiClient is the client API for TrustPolicyApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TrustPolicyApiClient interface {
	// Create a Trust Policy
	CreateTrustPolicy(ctx context.Context, in *TrustPolicy, opts ...grpc.CallOption) (TrustPolicyApi_CreateTrustPolicyClient, error)
	// Delete a Trust policy
	DeleteTrustPolicy(ctx context.Context, in *TrustPolicy, opts ...grpc.CallOption) (TrustPolicyApi_DeleteTrustPolicyClient, error)
	// Update a Trust policy
	UpdateTrustPolicy(ctx context.Context, in *TrustPolicy, opts ...grpc.CallOption) (TrustPolicyApi_UpdateTrustPolicyClient, error)
	// Show Trust Policies. Any fields specified will be used to filter results.
	ShowTrustPolicy(ctx context.Context, in *TrustPolicy, opts ...grpc.CallOption) (TrustPolicyApi_ShowTrustPolicyClient, error)
}

type trustPolicyApiClient struct {
	cc *grpc.ClientConn
}

func NewTrustPolicyApiClient(cc *grpc.ClientConn) TrustPolicyApiClient {
	return &trustPolicyApiClient{cc}
}

func (c *trustPolicyApiClient) CreateTrustPolicy(ctx context.Context, in *TrustPolicy, opts ...grpc.CallOption) (TrustPolicyApi_CreateTrustPolicyClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TrustPolicyApi_serviceDesc.Streams[0], "/edgeproto.TrustPolicyApi/CreateTrustPolicy", opts...)
	if err != nil {
		return nil, err
	}
	x := &trustPolicyApiCreateTrustPolicyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TrustPolicyApi_CreateTrustPolicyClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type trustPolicyApiCreateTrustPolicyClient struct {
	grpc.ClientStream
}

func (x *trustPolicyApiCreateTrustPolicyClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *trustPolicyApiClient) DeleteTrustPolicy(ctx context.Context, in *TrustPolicy, opts ...grpc.CallOption) (TrustPolicyApi_DeleteTrustPolicyClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TrustPolicyApi_serviceDesc.Streams[1], "/edgeproto.TrustPolicyApi/DeleteTrustPolicy", opts...)
	if err != nil {
		return nil, err
	}
	x := &trustPolicyApiDeleteTrustPolicyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TrustPolicyApi_DeleteTrustPolicyClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type trustPolicyApiDeleteTrustPolicyClient struct {
	grpc.ClientStream
}

func (x *trustPolicyApiDeleteTrustPolicyClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *trustPolicyApiClient) UpdateTrustPolicy(ctx context.Context, in *TrustPolicy, opts ...grpc.CallOption) (TrustPolicyApi_UpdateTrustPolicyClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TrustPolicyApi_serviceDesc.Streams[2], "/edgeproto.TrustPolicyApi/UpdateTrustPolicy", opts...)
	if err != nil {
		return nil, err
	}
	x := &trustPolicyApiUpdateTrustPolicyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TrustPolicyApi_UpdateTrustPolicyClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type trustPolicyApiUpdateTrustPolicyClient struct {
	grpc.ClientStream
}

func (x *trustPolicyApiUpdateTrustPolicyClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *trustPolicyApiClient) ShowTrustPolicy(ctx context.Context, in *TrustPolicy, opts ...grpc.CallOption) (TrustPolicyApi_ShowTrustPolicyClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TrustPolicyApi_serviceDesc.Streams[3], "/edgeproto.TrustPolicyApi/ShowTrustPolicy", opts...)
	if err != nil {
		return nil, err
	}
	x := &trustPolicyApiShowTrustPolicyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TrustPolicyApi_ShowTrustPolicyClient interface {
	Recv() (*TrustPolicy, error)
	grpc.ClientStream
}

type trustPolicyApiShowTrustPolicyClient struct {
	grpc.ClientStream
}

func (x *trustPolicyApiShowTrustPolicyClient) Recv() (*TrustPolicy, error) {
	m := new(TrustPolicy)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TrustPolicyApiServer is the server API for TrustPolicyApi service.
type TrustPolicyApiServer interface {
	// Create a Trust Policy
	CreateTrustPolicy(*TrustPolicy, TrustPolicyApi_CreateTrustPolicyServer) error
	// Delete a Trust policy
	DeleteTrustPolicy(*TrustPolicy, TrustPolicyApi_DeleteTrustPolicyServer) error
	// Update a Trust policy
	UpdateTrustPolicy(*TrustPolicy, TrustPolicyApi_UpdateTrustPolicyServer) error
	// Show Trust Policies. Any fields specified will be used to filter results.
	ShowTrustPolicy(*TrustPolicy, TrustPolicyApi_ShowTrustPolicyServer) error
}

// UnimplementedTrustPolicyApiServer can be embedded to have forward compatible implementations.
type UnimplementedTrustPolicyApiServer struct {
}

func (*UnimplementedTrustPolicyApiServer) CreateTrustPolicy(req *TrustPolicy, srv TrustPolicyApi_CreateTrustPolicyServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateTrustPolicy not implemented")
}
func (*UnimplementedTrustPolicyApiServer) DeleteTrustPolicy(req *TrustPolicy, srv TrustPolicyApi_DeleteTrustPolicyServer) error {
	return status.Errorf(codes.Unimplemented, "method DeleteTrustPolicy not implemented")
}
func (*UnimplementedTrustPolicyApiServer) UpdateTrustPolicy(req *TrustPolicy, srv TrustPolicyApi_UpdateTrustPolicyServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateTrustPolicy not implemented")
}
func (*UnimplementedTrustPolicyApiServer) ShowTrustPolicy(req *TrustPolicy, srv TrustPolicyApi_ShowTrustPolicyServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowTrustPolicy not implemented")
}

func RegisterTrustPolicyApiServer(s *grpc.Server, srv TrustPolicyApiServer) {
	s.RegisterService(&_TrustPolicyApi_serviceDesc, srv)
}

func _TrustPolicyApi_CreateTrustPolicy_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TrustPolicy)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TrustPolicyApiServer).CreateTrustPolicy(m, &trustPolicyApiCreateTrustPolicyServer{stream})
}

type TrustPolicyApi_CreateTrustPolicyServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type trustPolicyApiCreateTrustPolicyServer struct {
	grpc.ServerStream
}

func (x *trustPolicyApiCreateTrustPolicyServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _TrustPolicyApi_DeleteTrustPolicy_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TrustPolicy)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TrustPolicyApiServer).DeleteTrustPolicy(m, &trustPolicyApiDeleteTrustPolicyServer{stream})
}

type TrustPolicyApi_DeleteTrustPolicyServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type trustPolicyApiDeleteTrustPolicyServer struct {
	grpc.ServerStream
}

func (x *trustPolicyApiDeleteTrustPolicyServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _TrustPolicyApi_UpdateTrustPolicy_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TrustPolicy)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TrustPolicyApiServer).UpdateTrustPolicy(m, &trustPolicyApiUpdateTrustPolicyServer{stream})
}

type TrustPolicyApi_UpdateTrustPolicyServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type trustPolicyApiUpdateTrustPolicyServer struct {
	grpc.ServerStream
}

func (x *trustPolicyApiUpdateTrustPolicyServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _TrustPolicyApi_ShowTrustPolicy_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TrustPolicy)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TrustPolicyApiServer).ShowTrustPolicy(m, &trustPolicyApiShowTrustPolicyServer{stream})
}

type TrustPolicyApi_ShowTrustPolicyServer interface {
	Send(*TrustPolicy) error
	grpc.ServerStream
}

type trustPolicyApiShowTrustPolicyServer struct {
	grpc.ServerStream
}

func (x *trustPolicyApiShowTrustPolicyServer) Send(m *TrustPolicy) error {
	return x.ServerStream.SendMsg(m)
}

var _TrustPolicyApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.TrustPolicyApi",
	HandlerType: (*TrustPolicyApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreateTrustPolicy",
			Handler:       _TrustPolicyApi_CreateTrustPolicy_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DeleteTrustPolicy",
			Handler:       _TrustPolicyApi_DeleteTrustPolicy_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdateTrustPolicy",
			Handler:       _TrustPolicyApi_UpdateTrustPolicy_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowTrustPolicy",
			Handler:       _TrustPolicyApi_ShowTrustPolicy_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "trustpolicy.proto",
}

func (m *SecurityRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RemoteCidr) > 0 {
		i -= len(m.RemoteCidr)
		copy(dAtA[i:], m.RemoteCidr)
		i = encodeVarintTrustpolicy(dAtA, i, uint64(len(m.RemoteCidr)))
		i--
		dAtA[i] = 0x22
	}
	if m.PortRangeMax != 0 {
		i = encodeVarintTrustpolicy(dAtA, i, uint64(m.PortRangeMax))
		i--
		dAtA[i] = 0x18
	}
	if m.PortRangeMin != 0 {
		i = encodeVarintTrustpolicy(dAtA, i, uint64(m.PortRangeMin))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintTrustpolicy(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TrustPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrustPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrustPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OutboundSecurityRules) > 0 {
		for iNdEx := len(m.OutboundSecurityRules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutboundSecurityRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTrustpolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTrustpolicy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintTrustpolicy(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTrustpolicy(dAtA []byte, offset int, v uint64) int {
	offset -= sovTrustpolicy(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SecurityRule) CopyInFields(src *SecurityRule) int {
	changed := 0
	if m.Protocol != src.Protocol {
		m.Protocol = src.Protocol
		changed++
	}
	if m.PortRangeMin != src.PortRangeMin {
		m.PortRangeMin = src.PortRangeMin
		changed++
	}
	if m.PortRangeMax != src.PortRangeMax {
		m.PortRangeMax = src.PortRangeMax
		changed++
	}
	if m.RemoteCidr != src.RemoteCidr {
		m.RemoteCidr = src.RemoteCidr
		changed++
	}
	return changed
}

func (m *SecurityRule) DeepCopyIn(src *SecurityRule) {
	m.Protocol = src.Protocol
	m.PortRangeMin = src.PortRangeMin
	m.PortRangeMax = src.PortRangeMax
	m.RemoteCidr = src.RemoteCidr
}

// Helper method to check that enums have valid values
func (m *SecurityRule) ValidateEnums() error {
	return nil
}

func (m *TrustPolicy) Matches(o *TrustPolicy, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.OutboundSecurityRules != nil {
		if len(m.OutboundSecurityRules) == 0 && len(o.OutboundSecurityRules) > 0 || len(m.OutboundSecurityRules) > 0 && len(o.OutboundSecurityRules) == 0 {
			return false
		} else if m.OutboundSecurityRules != nil && o.OutboundSecurityRules != nil {
			if !opts.Filter && len(m.OutboundSecurityRules) != len(o.OutboundSecurityRules) {
				return false
			}
			for i := 0; i < len(m.OutboundSecurityRules); i++ {
			}
		}
	}
	return true
}

const TrustPolicyFieldKey = "2"
const TrustPolicyFieldKeyOrganization = "2.1"
const TrustPolicyFieldKeyName = "2.2"
const TrustPolicyFieldOutboundSecurityRules = "3"
const TrustPolicyFieldOutboundSecurityRulesProtocol = "3.1"
const TrustPolicyFieldOutboundSecurityRulesPortRangeMin = "3.2"
const TrustPolicyFieldOutboundSecurityRulesPortRangeMax = "3.3"
const TrustPolicyFieldOutboundSecurityRulesRemoteCidr = "3.4"

var TrustPolicyAllFields = []string{
	TrustPolicyFieldKeyOrganization,
	TrustPolicyFieldKeyName,
	TrustPolicyFieldOutboundSecurityRulesProtocol,
	TrustPolicyFieldOutboundSecurityRulesPortRangeMin,
	TrustPolicyFieldOutboundSecurityRulesPortRangeMax,
	TrustPolicyFieldOutboundSecurityRulesRemoteCidr,
}

var TrustPolicyAllFieldsMap = map[string]struct{}{
	TrustPolicyFieldKeyOrganization:                   struct{}{},
	TrustPolicyFieldKeyName:                           struct{}{},
	TrustPolicyFieldOutboundSecurityRulesProtocol:     struct{}{},
	TrustPolicyFieldOutboundSecurityRulesPortRangeMin: struct{}{},
	TrustPolicyFieldOutboundSecurityRulesPortRangeMax: struct{}{},
	TrustPolicyFieldOutboundSecurityRulesRemoteCidr:   struct{}{},
}

var TrustPolicyAllFieldsStringMap = map[string]string{
	TrustPolicyFieldKeyOrganization:                   "Key Organization",
	TrustPolicyFieldKeyName:                           "Key Name",
	TrustPolicyFieldOutboundSecurityRulesProtocol:     "Outbound Security Rules Protocol",
	TrustPolicyFieldOutboundSecurityRulesPortRangeMin: "Outbound Security Rules Port Range Min",
	TrustPolicyFieldOutboundSecurityRulesPortRangeMax: "Outbound Security Rules Port Range Max",
	TrustPolicyFieldOutboundSecurityRulesRemoteCidr:   "Outbound Security Rules Remote Cidr",
}

func (m *TrustPolicy) IsKeyField(s string) bool {
	return strings.HasPrefix(s, TrustPolicyFieldKey+".") || s == TrustPolicyFieldKey
}

func (m *TrustPolicy) DiffFields(o *TrustPolicy, fields map[string]struct{}) {
	if m.Key.Organization != o.Key.Organization {
		fields[TrustPolicyFieldKeyOrganization] = struct{}{}
		fields[TrustPolicyFieldKey] = struct{}{}
	}
	if m.Key.Name != o.Key.Name {
		fields[TrustPolicyFieldKeyName] = struct{}{}
		fields[TrustPolicyFieldKey] = struct{}{}
	}
	if len(m.OutboundSecurityRules) != len(o.OutboundSecurityRules) {
		fields[TrustPolicyFieldOutboundSecurityRules] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.OutboundSecurityRules); i0++ {
			if m.OutboundSecurityRules[i0].Protocol != o.OutboundSecurityRules[i0].Protocol {
				fields[TrustPolicyFieldOutboundSecurityRulesProtocol] = struct{}{}
				fields[TrustPolicyFieldOutboundSecurityRules] = struct{}{}
			}
			if m.OutboundSecurityRules[i0].PortRangeMin != o.OutboundSecurityRules[i0].PortRangeMin {
				fields[TrustPolicyFieldOutboundSecurityRulesPortRangeMin] = struct{}{}
				fields[TrustPolicyFieldOutboundSecurityRules] = struct{}{}
			}
			if m.OutboundSecurityRules[i0].PortRangeMax != o.OutboundSecurityRules[i0].PortRangeMax {
				fields[TrustPolicyFieldOutboundSecurityRulesPortRangeMax] = struct{}{}
				fields[TrustPolicyFieldOutboundSecurityRules] = struct{}{}
			}
			if m.OutboundSecurityRules[i0].RemoteCidr != o.OutboundSecurityRules[i0].RemoteCidr {
				fields[TrustPolicyFieldOutboundSecurityRulesRemoteCidr] = struct{}{}
				fields[TrustPolicyFieldOutboundSecurityRules] = struct{}{}
			}
		}
	}
}

var UpdateTrustPolicyFieldsMap = map[string]struct{}{
	TrustPolicyFieldOutboundSecurityRules:             struct{}{},
	TrustPolicyFieldOutboundSecurityRulesProtocol:     struct{}{},
	TrustPolicyFieldOutboundSecurityRulesPortRangeMin: struct{}{},
	TrustPolicyFieldOutboundSecurityRulesPortRangeMax: struct{}{},
	TrustPolicyFieldOutboundSecurityRulesRemoteCidr:   struct{}{},
}

func (m *TrustPolicy) ValidateUpdateFields() error {
	if m.Fields == nil {
		return fmt.Errorf("nothing specified to update")
	}
	fmap := MakeFieldMap(m.Fields)
	badFieldStrs := []string{}
	for field, _ := range fmap {
		if m.IsKeyField(field) {
			continue
		}
		if _, ok := UpdateTrustPolicyFieldsMap[field]; !ok {
			if _, ok := TrustPolicyAllFieldsStringMap[field]; !ok {
				continue
			}
			badFieldStrs = append(badFieldStrs, TrustPolicyAllFieldsStringMap[field])
		}
	}
	if len(badFieldStrs) > 0 {
		return fmt.Errorf("specified field(s) %s cannot be modified", strings.Join(badFieldStrs, ","))
	}
	return nil
}

func (m *TrustPolicy) CopyInFields(src *TrustPolicy) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
		if _, set := fmap["2.2"]; set {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
	}
	if _, set := fmap["3"]; set {
		if src.OutboundSecurityRules != nil {
			m.OutboundSecurityRules = src.OutboundSecurityRules
			changed++
		} else if m.OutboundSecurityRules != nil {
			m.OutboundSecurityRules = nil
			changed++
		}
	}
	return changed
}

func (m *TrustPolicy) DeepCopyIn(src *TrustPolicy) {
	m.Key.DeepCopyIn(&src.Key)
	if src.OutboundSecurityRules != nil {
		m.OutboundSecurityRules = make([]SecurityRule, len(src.OutboundSecurityRules), len(src.OutboundSecurityRules))
		for ii, s := range src.OutboundSecurityRules {
			m.OutboundSecurityRules[ii].DeepCopyIn(&s)
		}
	} else {
		m.OutboundSecurityRules = nil
	}
}

func (s *TrustPolicy) HasFields() bool {
	return true
}

type TrustPolicyStore struct {
	kvstore objstore.KVStore
}

func NewTrustPolicyStore(kvstore objstore.KVStore) TrustPolicyStore {
	return TrustPolicyStore{kvstore: kvstore}
}

func (s *TrustPolicyStore) Create(ctx context.Context, m *TrustPolicy, wait func(int64)) (*Result, error) {
	err := m.Validate(TrustPolicyAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("TrustPolicy", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *TrustPolicyStore) Update(ctx context.Context, m *TrustPolicy, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("TrustPolicy", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur TrustPolicy
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *TrustPolicyStore) Put(ctx context.Context, m *TrustPolicy, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(TrustPolicyAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("TrustPolicy", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *TrustPolicyStore) Delete(ctx context.Context, m *TrustPolicy, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("TrustPolicy", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *TrustPolicyStore) LoadOne(key string) (*TrustPolicy, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj TrustPolicy
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse TrustPolicy data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *TrustPolicyStore) STMGet(stm concurrency.STM, key *PolicyKey, buf *TrustPolicy) bool {
	keystr := objstore.DbKeyString("TrustPolicy", key)
	valstr := stm.Get(keystr)
	if valstr == "" {
		return false
	}
	if buf != nil {
		err := json.Unmarshal([]byte(valstr), buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *TrustPolicyStore) STMPut(stm concurrency.STM, obj *TrustPolicy, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("TrustPolicy", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("TrustPolicy json marsahal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *TrustPolicyStore) STMDel(stm concurrency.STM, key *PolicyKey) {
	keystr := objstore.DbKeyString("TrustPolicy", key)
	stm.Del(keystr)
}

type TrustPolicyKeyWatcher struct {
	cb func(ctx context.Context)
}

type TrustPolicyCacheData struct {
	Obj    *TrustPolicy
	ModRev int64
}

// TrustPolicyCache caches TrustPolicy objects in memory in a hash table
// and keeps them in sync with the database.
type TrustPolicyCache struct {
	Objs          map[PolicyKey]*TrustPolicyCacheData
	Mux           util.Mutex
	List          map[PolicyKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *PolicyKey, old *TrustPolicy, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *TrustPolicy, new *TrustPolicy)
	DeletedCbs    []func(ctx context.Context, old *TrustPolicy)
	KeyWatchers   map[PolicyKey][]*TrustPolicyKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *PolicyKey)
	DeletedKeyCbs []func(ctx context.Context, key *PolicyKey)
}

func NewTrustPolicyCache() *TrustPolicyCache {
	cache := TrustPolicyCache{}
	InitTrustPolicyCache(&cache)
	return &cache
}

func InitTrustPolicyCache(cache *TrustPolicyCache) {
	cache.Objs = make(map[PolicyKey]*TrustPolicyCacheData)
	cache.KeyWatchers = make(map[PolicyKey][]*TrustPolicyKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *TrustPolicyCache) GetTypeString() string {
	return "TrustPolicy"
}

func (c *TrustPolicyCache) Get(key *PolicyKey, valbuf *TrustPolicy) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *TrustPolicyCache) GetWithRev(key *PolicyKey, valbuf *TrustPolicy, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *TrustPolicyCache) HasKey(key *PolicyKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *TrustPolicyCache) GetAllKeys(ctx context.Context, cb func(key *PolicyKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *TrustPolicyCache) Update(ctx context.Context, in *TrustPolicy, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *TrustPolicy) (*TrustPolicy, bool) {
		return in, true
	})
}

func (c *TrustPolicyCache) UpdateModFunc(ctx context.Context, key *PolicyKey, modRev int64, modFunc func(old *TrustPolicy) (new *TrustPolicy, changed bool)) {
	c.Mux.Lock()
	var old *TrustPolicy
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	for _, cb := range c.UpdatedCbs {
		newCopy := &TrustPolicy{}
		newCopy.DeepCopyIn(new)
		defer cb(ctx, old, newCopy)
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			defer cb(ctx, new.GetKey(), old, modRev)
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &TrustPolicy{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &TrustPolicyCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *TrustPolicyCache) Delete(ctx context.Context, in *TrustPolicy, modRev int64) {
	c.Mux.Lock()
	var old *TrustPolicy
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	c.Mux.Unlock()
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, in.GetKey(), old, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *TrustPolicyCache) Prune(ctx context.Context, validKeys map[PolicyKey]struct{}) {
	notify := make(map[PolicyKey]*TrustPolicyCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, old.Obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *TrustPolicyCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *TrustPolicyCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *TrustPolicyCache) Show(filter *TrustPolicy, cb func(ret *TrustPolicy) error) error {
	log.DebugLog(log.DebugLevelApi, "Show TrustPolicy", "count", len(c.Objs))
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		log.DebugLog(log.DebugLevelApi, "Compare TrustPolicy", "filter", filter, "data", data)
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		log.DebugLog(log.DebugLevelApi, "Show TrustPolicy", "obj", data.Obj)
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func TrustPolicyGenericNotifyCb(fn func(key *PolicyKey, old *TrustPolicy)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*PolicyKey), obj.(*TrustPolicy))
	}
}

func (c *TrustPolicyCache) SetNotifyCb(fn func(ctx context.Context, obj *PolicyKey, old *TrustPolicy, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *PolicyKey, old *TrustPolicy, modRev int64){fn}
}

func (c *TrustPolicyCache) SetUpdatedCb(fn func(ctx context.Context, old *TrustPolicy, new *TrustPolicy)) {
	c.UpdatedCbs = []func(ctx context.Context, old *TrustPolicy, new *TrustPolicy){fn}
}

func (c *TrustPolicyCache) SetDeletedCb(fn func(ctx context.Context, old *TrustPolicy)) {
	c.DeletedCbs = []func(ctx context.Context, old *TrustPolicy){fn}
}

func (c *TrustPolicyCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *PolicyKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *PolicyKey){fn}
}

func (c *TrustPolicyCache) SetDeletedKeyCb(fn func(ctx context.Context, key *PolicyKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *PolicyKey){fn}
}

func (c *TrustPolicyCache) AddUpdatedCb(fn func(ctx context.Context, old *TrustPolicy, new *TrustPolicy)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *TrustPolicyCache) AddDeletedCb(fn func(ctx context.Context, old *TrustPolicy)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *TrustPolicyCache) AddNotifyCb(fn func(ctx context.Context, obj *PolicyKey, old *TrustPolicy, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *TrustPolicyCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *PolicyKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *TrustPolicyCache) AddDeletedKeyCb(fn func(ctx context.Context, key *PolicyKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *TrustPolicyCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *TrustPolicyCache) WatchKey(key *PolicyKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*TrustPolicyKeyWatcher, 0)
	}
	watcher := TrustPolicyKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching TrustPolicy", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *TrustPolicyCache) TriggerKeyWatchers(ctx context.Context, key *PolicyKey) {
	watchers := make([]*TrustPolicyKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *TrustPolicyCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := TrustPolicy{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse TrustPolicy data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *TrustPolicyCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := TrustPolicy{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	PolicyKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *TrustPolicyCache) SyncListStart(ctx context.Context) {
	c.List = make(map[PolicyKey]struct{})
}

func (c *TrustPolicyCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[PolicyKey]*TrustPolicyCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, val.Obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *TrustPolicyCache) UsesOrg(org string) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		if key.Organization == org {
			return true
		}
	}
	return false
}

func (m *TrustPolicy) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *TrustPolicy) GetKey() *PolicyKey {
	return &m.Key
}

func (m *TrustPolicy) GetKeyVal() PolicyKey {
	return m.Key
}

func (m *TrustPolicy) SetKey(key *PolicyKey) {
	m.Key = *key
}

func CmpSortTrustPolicy(a TrustPolicy, b TrustPolicy) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *TrustPolicy) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.OutboundSecurityRules {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *TrustPolicy) IsValidArgsForCreateTrustPolicy() error {
	return nil
}

func (m *TrustPolicy) IsValidArgsForDeleteTrustPolicy() error {
	return nil
}

func (m *TrustPolicy) IsValidArgsForUpdateTrustPolicy() error {
	return nil
}

func (m *SecurityRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTrustpolicy(uint64(l))
	}
	if m.PortRangeMin != 0 {
		n += 1 + sovTrustpolicy(uint64(m.PortRangeMin))
	}
	if m.PortRangeMax != 0 {
		n += 1 + sovTrustpolicy(uint64(m.PortRangeMax))
	}
	l = len(m.RemoteCidr)
	if l > 0 {
		n += 1 + l + sovTrustpolicy(uint64(l))
	}
	return n
}

func (m *TrustPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovTrustpolicy(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovTrustpolicy(uint64(l))
	if len(m.OutboundSecurityRules) > 0 {
		for _, e := range m.OutboundSecurityRules {
			l = e.Size()
			n += 1 + l + sovTrustpolicy(uint64(l))
		}
	}
	return n
}

func sovTrustpolicy(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTrustpolicy(x uint64) (n int) {
	return sovTrustpolicy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SecurityRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrustpolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrustpolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrustpolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortRangeMin", wireType)
			}
			m.PortRangeMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortRangeMin |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortRangeMax", wireType)
			}
			m.PortRangeMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortRangeMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteCidr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrustpolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrustpolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteCidr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrustpolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrustpolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTrustpolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrustPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrustpolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrustPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrustPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrustpolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrustpolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrustpolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTrustpolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutboundSecurityRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrustpolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTrustpolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutboundSecurityRules = append(m.OutboundSecurityRules, SecurityRule{})
			if err := m.OutboundSecurityRules[len(m.OutboundSecurityRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrustpolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrustpolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTrustpolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTrustpolicy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTrustpolicy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTrustpolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTrustpolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTrustpolicy
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTrustpolicy
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTrustpolicy
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTrustpolicy        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTrustpolicy          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTrustpolicy = fmt.Errorf("proto: unexpected end of group")
)
