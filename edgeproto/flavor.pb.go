// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: flavor.proto

package edgeproto

import (
	context "context"
	"encoding/json"
	fmt "fmt"
	"github.com/coreos/etcd/clientv3/concurrency"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/mobiledgex/edge-cloud/log"
	"github.com/mobiledgex/edge-cloud/objstore"
	_ "github.com/mobiledgex/edge-cloud/protogen"
	"github.com/mobiledgex/edge-cloud/util"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Flavor
//
// FlavorKey uniquely identifies a Flavor.
type FlavorKey struct {
	// Flavor name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *FlavorKey) Reset()         { *m = FlavorKey{} }
func (m *FlavorKey) String() string { return proto.CompactTextString(m) }
func (*FlavorKey) ProtoMessage()    {}
func (*FlavorKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_827a674ddbd1f38f, []int{0}
}
func (m *FlavorKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlavorKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlavorKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlavorKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlavorKey.Merge(m, src)
}
func (m *FlavorKey) XXX_Size() int {
	return m.Size()
}
func (m *FlavorKey) XXX_DiscardUnknown() {
	xxx_messageInfo_FlavorKey.DiscardUnknown(m)
}

var xxx_messageInfo_FlavorKey proto.InternalMessageInfo

//Flavors define the compute, memory, and storage capacity of computing instances.
//To put it simply, a flavor is an available hardware configuration for a server.
//It defines the size of a virtual server that can be launched.
type Flavor struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique key for the new flavor.
	Key FlavorKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// RAM in megabytes
	Ram uint64 `protobuf:"varint,3,opt,name=ram,proto3" json:"ram,omitempty"`
	// Number of virtual CPUs
	Vcpus uint64 `protobuf:"varint,4,opt,name=vcpus,proto3" json:"vcpus,omitempty"`
	// Amount of disk space in gigabytes
	Disk uint64 `protobuf:"varint,5,opt,name=disk,proto3" json:"disk,omitempty"`
	// Optional Resources request, key = gpu
	// form: $resource=$kind:[$alias]$count ex: optresmap=gpu=vgpu:nvidia-63:1
	OptResMap map[string]string `protobuf:"bytes,6,rep,name=opt_res_map,json=optResMap,proto3" json:"opt_res_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Preparing to be deleted
	DeletePrepare bool `protobuf:"varint,7,opt,name=delete_prepare,json=deletePrepare,proto3" json:"delete_prepare,omitempty"`
}

func (m *Flavor) Reset()         { *m = Flavor{} }
func (m *Flavor) String() string { return proto.CompactTextString(m) }
func (*Flavor) ProtoMessage()    {}
func (*Flavor) Descriptor() ([]byte, []int) {
	return fileDescriptor_827a674ddbd1f38f, []int{1}
}
func (m *Flavor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Flavor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Flavor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Flavor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Flavor.Merge(m, src)
}
func (m *Flavor) XXX_Size() int {
	return m.Size()
}
func (m *Flavor) XXX_DiscardUnknown() {
	xxx_messageInfo_Flavor.DiscardUnknown(m)
}

var xxx_messageInfo_Flavor proto.InternalMessageInfo

func init() {
	proto.RegisterType((*FlavorKey)(nil), "edgeproto.FlavorKey")
	proto.RegisterType((*Flavor)(nil), "edgeproto.Flavor")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.Flavor.OptResMapEntry")
}

func init() { proto.RegisterFile("flavor.proto", fileDescriptor_827a674ddbd1f38f) }

var fileDescriptor_827a674ddbd1f38f = []byte{
	// 673 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x92, 0x41, 0x6f, 0xd3, 0x4a,
	0x10, 0xc7, 0xb3, 0x49, 0x9a, 0xf7, 0xb2, 0x4d, 0xf3, 0x5e, 0xfd, 0xaa, 0x6a, 0x15, 0xf5, 0xb9,
	0x91, 0x0f, 0x28, 0x82, 0x10, 0xa3, 0x72, 0x29, 0x11, 0x45, 0x24, 0x14, 0x2e, 0xa5, 0x80, 0x8c,
	0xe8, 0xb5, 0xda, 0xda, 0x53, 0xd7, 0x8a, 0xed, 0xb5, 0xbc, 0x76, 0x42, 0x6e, 0xa8, 0x9f, 0xa0,
	0x82, 0x0b, 0xe2, 0xc4, 0x91, 0x23, 0xe2, 0xc8, 0x27, 0xe8, 0xb1, 0x12, 0x07, 0x38, 0x21, 0x48,
	0x39, 0xa0, 0x9e, 0x90, 0x9a, 0x16, 0x8e, 0xc8, 0xbb, 0x69, 0x48, 0x55, 0x24, 0x5a, 0x09, 0x2e,
	0xd6, 0xcc, 0x78, 0x67, 0x7f, 0xff, 0xff, 0xec, 0xe0, 0xc2, 0xba, 0x4b, 0xdb, 0x2c, 0xac, 0x05,
	0x21, 0x8b, 0x98, 0x92, 0x07, 0xcb, 0x06, 0x11, 0x96, 0x66, 0x6c, 0xc6, 0x6c, 0x17, 0x74, 0x1a,
	0x38, 0x3a, 0xf5, 0x7d, 0x16, 0xd1, 0xc8, 0x61, 0x3e, 0x97, 0x07, 0x4b, 0xf3, 0xb6, 0x13, 0x6d,
	0xc4, 0x6b, 0x35, 0x93, 0x79, 0xba, 0xc7, 0xd6, 0x1c, 0x37, 0x69, 0x7c, 0xa8, 0x27, 0xdf, 0x8b,
	0xa6, 0xcb, 0x62, 0x4b, 0x17, 0xe7, 0x6c, 0xf0, 0x87, 0xc1, 0xa0, 0xb3, 0x10, 0x02, 0x8f, 0xdd,
	0x68, 0x90, 0x4d, 0xd9, 0xcc, 0x66, 0x22, 0xd4, 0x93, 0x48, 0x56, 0xb5, 0x2b, 0x38, 0x7f, 0x4b,
	0xc8, 0x5a, 0x82, 0xae, 0xa2, 0xe2, 0xac, 0x4f, 0x3d, 0x20, 0xa8, 0x8c, 0x2a, 0xf9, 0x26, 0x7e,
	0x7d, 0x48, 0x72, 0x52, 0xb3, 0x21, 0xea, 0xf5, 0xc2, 0xe7, 0x7d, 0x82, 0xbe, 0xed, 0x13, 0xf4,
	0xf2, 0xf9, 0x2c, 0xd2, 0xbe, 0xa6, 0x71, 0x4e, 0xf6, 0x2a, 0xd3, 0x38, 0xb7, 0xee, 0x80, 0x6b,
	0x71, 0x82, 0xca, 0x99, 0x4a, 0xde, 0x18, 0x64, 0x4a, 0x15, 0x67, 0x5a, 0xd0, 0x25, 0xe9, 0x32,
	0xaa, 0x8c, 0xcf, 0x4d, 0xd5, 0x86, 0x96, 0x6b, 0x43, 0x66, 0x33, 0xbb, 0xfd, 0x7e, 0x36, 0x65,
	0x24, 0xc7, 0x94, 0x7f, 0x71, 0x26, 0xa4, 0x1e, 0xc9, 0x94, 0x51, 0x25, 0x6b, 0x24, 0xa1, 0x32,
	0x85, 0xc7, 0xda, 0x66, 0x10, 0x73, 0x92, 0x15, 0x35, 0x99, 0x28, 0x0a, 0xce, 0x5a, 0x0e, 0x6f,
	0x91, 0x31, 0x51, 0x14, 0xb1, 0x72, 0x1d, 0x8f, 0xb3, 0x20, 0x5a, 0x0d, 0x81, 0xaf, 0x7a, 0x34,
	0x20, 0xb9, 0x72, 0xa6, 0x32, 0x3e, 0x57, 0x3e, 0x41, 0xac, 0xdd, 0x0d, 0x22, 0x03, 0xf8, 0x32,
	0x0d, 0x6e, 0xfa, 0x51, 0xd8, 0x35, 0xf2, 0xec, 0x28, 0x57, 0x2e, 0xe0, 0xa2, 0x05, 0x2e, 0x44,
	0xb0, 0x1a, 0x84, 0x10, 0xd0, 0x10, 0xc8, 0x5f, 0x65, 0x54, 0xf9, 0xbb, 0x99, 0x7d, 0xd1, 0x27,
	0xc8, 0x98, 0x90, 0xff, 0xee, 0xc9, 0x5f, 0xa5, 0xab, 0xb8, 0x78, 0xfc, 0xa6, 0x44, 0x7c, 0x62,
	0x55, 0x8c, 0x4e, 0xda, 0x49, 0xc4, 0x53, 0x37, 0x06, 0x61, 0x3f, 0x6f, 0xc8, 0xa4, 0x9e, 0x9e,
	0x47, 0xf5, 0x6b, 0xc9, 0x1c, 0xbf, 0xec, 0x13, 0xf4, 0xa8, 0x4f, 0xd0, 0x56, 0x9f, 0xa0, 0xa7,
	0x7d, 0x82, 0x1e, 0x1f, 0x90, 0x89, 0xc5, 0x51, 0xc8, 0xb3, 0x03, 0x32, 0x91, 0x8c, 0x7d, 0x61,
	0x09, 0xba, 0xb5, 0x3b, 0xd4, 0x83, 0x57, 0x87, 0x24, 0xeb, 0x33, 0x1f, 0xe6, 0xde, 0x8e, 0x1d,
	0xbd, 0x5a, 0x23, 0x70, 0x94, 0x4d, 0x84, 0x0b, 0x37, 0x42, 0xa0, 0x11, 0x0c, 0x5e, 0x63, 0xf2,
	0x84, 0xed, 0xd2, 0x68, 0xc9, 0x10, 0x5b, 0xa1, 0xdd, 0xde, 0xeb, 0x93, 0xff, 0x0d, 0xe0, 0x2c,
	0x0e, 0xcd, 0x41, 0x27, 0xaf, 0x36, 0xcc, 0x64, 0xf5, 0x96, 0xa9, 0x4f, 0x6d, 0xa8, 0xf6, 0x0e,
	0x48, 0xd1, 0xa0, 0x5e, 0x75, 0x25, 0x99, 0x7a, 0x75, 0xd1, 0xe1, 0xad, 0xcd, 0x37, 0x9f, 0x9e,
	0xa4, 0xff, 0xd3, 0x8a, 0xba, 0x29, 0x78, 0xba, 0xdc, 0x8e, 0x3a, 0x3a, 0xaf, 0x04, 0xb8, 0x20,
	0xc5, 0x9f, 0x49, 0x43, 0xfd, 0x97, 0x1a, 0x86, 0x44, 0x39, 0xff, 0xe3, 0xc4, 0x07, 0x81, 0x45,
	0xff, 0x1c, 0x31, 0x16, 0xb7, 0x8f, 0x10, 0x3b, 0x18, 0xdf, 0xdf, 0x60, 0x9d, 0xd3, 0xf1, 0x64,
	0x49, 0x6b, 0xec, 0xf5, 0xc9, 0xb9, 0x9f, 0xf3, 0x56, 0x1c, 0xe8, 0x54, 0x79, 0xcb, 0x09, 0xc0,
	0x5f, 0x67, 0xa1, 0x09, 0x02, 0x3c, 0xa9, 0x15, 0x74, 0xbe, 0xc1, 0x3a, 0x3f, 0xb0, 0x97, 0x50,
	0x62, 0xb5, 0x61, 0x59, 0xb2, 0xdb, 0x00, 0xfe, 0xfb, 0xad, 0x52, 0xcb, 0x0a, 0x81, 0x8f, 0x58,
	0x6d, 0xe3, 0x7f, 0x0c, 0xf0, 0x58, 0x1b, 0xce, 0x0a, 0x5d, 0x38, 0x1d, 0x74, 0x5a, 0x9b, 0xd4,
	0x43, 0x01, 0x38, 0xc6, 0x6d, 0xce, 0x6c, 0x7f, 0x54, 0x53, 0xdb, 0x3d, 0x15, 0xed, 0xf4, 0x54,
	0xf4, 0xa1, 0xa7, 0xa2, 0xad, 0x5d, 0x35, 0xb5, 0xb3, 0xab, 0xa6, 0xde, 0xed, 0xaa, 0xa9, 0xb5,
	0x9c, 0x40, 0x5d, 0xfe, 0x1e, 0x00, 0x00, 0xff, 0xff, 0xed, 0xd4, 0x99, 0xc6, 0x4a, 0x05, 0x00,
	0x00,
}

func (this *FlavorKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&edgeproto.FlavorKey{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringFlavor(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FlavorApiClient is the client API for FlavorApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FlavorApiClient interface {
	// Create a Flavor
	CreateFlavor(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (*Result, error)
	// Delete a Flavor
	DeleteFlavor(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (*Result, error)
	// Update a Flavor
	UpdateFlavor(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (*Result, error)
	// Show Flavors
	ShowFlavor(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (FlavorApi_ShowFlavorClient, error)
	// Add Optional Resource
	AddFlavorRes(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (*Result, error)
	// Remove Optional Resource
	RemoveFlavorRes(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (*Result, error)
}

type flavorApiClient struct {
	cc *grpc.ClientConn
}

func NewFlavorApiClient(cc *grpc.ClientConn) FlavorApiClient {
	return &flavorApiClient{cc}
}

func (c *flavorApiClient) CreateFlavor(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.FlavorApi/CreateFlavor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flavorApiClient) DeleteFlavor(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.FlavorApi/DeleteFlavor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flavorApiClient) UpdateFlavor(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.FlavorApi/UpdateFlavor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flavorApiClient) ShowFlavor(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (FlavorApi_ShowFlavorClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FlavorApi_serviceDesc.Streams[0], "/edgeproto.FlavorApi/ShowFlavor", opts...)
	if err != nil {
		return nil, err
	}
	x := &flavorApiShowFlavorClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FlavorApi_ShowFlavorClient interface {
	Recv() (*Flavor, error)
	grpc.ClientStream
}

type flavorApiShowFlavorClient struct {
	grpc.ClientStream
}

func (x *flavorApiShowFlavorClient) Recv() (*Flavor, error) {
	m := new(Flavor)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flavorApiClient) AddFlavorRes(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.FlavorApi/AddFlavorRes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flavorApiClient) RemoveFlavorRes(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.FlavorApi/RemoveFlavorRes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FlavorApiServer is the server API for FlavorApi service.
type FlavorApiServer interface {
	// Create a Flavor
	CreateFlavor(context.Context, *Flavor) (*Result, error)
	// Delete a Flavor
	DeleteFlavor(context.Context, *Flavor) (*Result, error)
	// Update a Flavor
	UpdateFlavor(context.Context, *Flavor) (*Result, error)
	// Show Flavors
	ShowFlavor(*Flavor, FlavorApi_ShowFlavorServer) error
	// Add Optional Resource
	AddFlavorRes(context.Context, *Flavor) (*Result, error)
	// Remove Optional Resource
	RemoveFlavorRes(context.Context, *Flavor) (*Result, error)
}

// UnimplementedFlavorApiServer can be embedded to have forward compatible implementations.
type UnimplementedFlavorApiServer struct {
}

func (*UnimplementedFlavorApiServer) CreateFlavor(ctx context.Context, req *Flavor) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateFlavor not implemented")
}
func (*UnimplementedFlavorApiServer) DeleteFlavor(ctx context.Context, req *Flavor) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFlavor not implemented")
}
func (*UnimplementedFlavorApiServer) UpdateFlavor(ctx context.Context, req *Flavor) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateFlavor not implemented")
}
func (*UnimplementedFlavorApiServer) ShowFlavor(req *Flavor, srv FlavorApi_ShowFlavorServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowFlavor not implemented")
}
func (*UnimplementedFlavorApiServer) AddFlavorRes(ctx context.Context, req *Flavor) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddFlavorRes not implemented")
}
func (*UnimplementedFlavorApiServer) RemoveFlavorRes(ctx context.Context, req *Flavor) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveFlavorRes not implemented")
}

func RegisterFlavorApiServer(s *grpc.Server, srv FlavorApiServer) {
	s.RegisterService(&_FlavorApi_serviceDesc, srv)
}

func _FlavorApi_CreateFlavor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Flavor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlavorApiServer).CreateFlavor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.FlavorApi/CreateFlavor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlavorApiServer).CreateFlavor(ctx, req.(*Flavor))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlavorApi_DeleteFlavor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Flavor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlavorApiServer).DeleteFlavor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.FlavorApi/DeleteFlavor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlavorApiServer).DeleteFlavor(ctx, req.(*Flavor))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlavorApi_UpdateFlavor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Flavor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlavorApiServer).UpdateFlavor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.FlavorApi/UpdateFlavor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlavorApiServer).UpdateFlavor(ctx, req.(*Flavor))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlavorApi_ShowFlavor_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Flavor)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlavorApiServer).ShowFlavor(m, &flavorApiShowFlavorServer{stream})
}

type FlavorApi_ShowFlavorServer interface {
	Send(*Flavor) error
	grpc.ServerStream
}

type flavorApiShowFlavorServer struct {
	grpc.ServerStream
}

func (x *flavorApiShowFlavorServer) Send(m *Flavor) error {
	return x.ServerStream.SendMsg(m)
}

func _FlavorApi_AddFlavorRes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Flavor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlavorApiServer).AddFlavorRes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.FlavorApi/AddFlavorRes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlavorApiServer).AddFlavorRes(ctx, req.(*Flavor))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlavorApi_RemoveFlavorRes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Flavor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlavorApiServer).RemoveFlavorRes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.FlavorApi/RemoveFlavorRes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlavorApiServer).RemoveFlavorRes(ctx, req.(*Flavor))
	}
	return interceptor(ctx, in, info, handler)
}

var _FlavorApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.FlavorApi",
	HandlerType: (*FlavorApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateFlavor",
			Handler:    _FlavorApi_CreateFlavor_Handler,
		},
		{
			MethodName: "DeleteFlavor",
			Handler:    _FlavorApi_DeleteFlavor_Handler,
		},
		{
			MethodName: "UpdateFlavor",
			Handler:    _FlavorApi_UpdateFlavor_Handler,
		},
		{
			MethodName: "AddFlavorRes",
			Handler:    _FlavorApi_AddFlavorRes_Handler,
		},
		{
			MethodName: "RemoveFlavorRes",
			Handler:    _FlavorApi_RemoveFlavorRes_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowFlavor",
			Handler:       _FlavorApi_ShowFlavor_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "flavor.proto",
}

func (m *FlavorKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlavorKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlavorKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlavor(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Flavor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Flavor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flavor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeletePrepare {
		i--
		if m.DeletePrepare {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.OptResMap) > 0 {
		for k := range m.OptResMap {
			v := m.OptResMap[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintFlavor(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFlavor(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFlavor(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Disk != 0 {
		i = encodeVarintFlavor(dAtA, i, uint64(m.Disk))
		i--
		dAtA[i] = 0x28
	}
	if m.Vcpus != 0 {
		i = encodeVarintFlavor(dAtA, i, uint64(m.Vcpus))
		i--
		dAtA[i] = 0x20
	}
	if m.Ram != 0 {
		i = encodeVarintFlavor(dAtA, i, uint64(m.Ram))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlavor(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintFlavor(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintFlavor(dAtA []byte, offset int, v uint64) int {
	offset -= sovFlavor(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FlavorKey) Matches(o *FlavorKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.Name != "" {
		if o.Name != m.Name {
			return false
		}
	}
	return true
}

func (m *FlavorKey) CopyInFields(src *FlavorKey) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	return changed
}

func (m *FlavorKey) DeepCopyIn(src *FlavorKey) {
	m.Name = src.Name
}

func (m *FlavorKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal FlavorKey key string", "obj", m)
	}
	return string(key)
}

func FlavorKeyStringParse(str string, key *FlavorKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal FlavorKey key string", "str", str)
	}
}

func (m *FlavorKey) NotFoundError() error {
	return fmt.Errorf("Flavor key %s not found", m.GetKeyString())
}

func (m *FlavorKey) ExistsError() error {
	return fmt.Errorf("Flavor key %s already exists", m.GetKeyString())
}

func (m *FlavorKey) BeingDeletedError() error {
	return fmt.Errorf("Flavor %s is being deleted", m.GetKeyString())
}

var FlavorKeyTagName = "flavor"

func (m *FlavorKey) GetTags() map[string]string {
	tags := make(map[string]string)
	tags["flavor"] = m.Name
	return tags
}

// Helper method to check that enums have valid values
func (m *FlavorKey) ValidateEnums() error {
	return nil
}

func (s *FlavorKey) ClearTagged(tags map[string]struct{}) {
}

func (m *Flavor) Matches(o *Flavor, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.Ram != 0 {
		if o.Ram != m.Ram {
			return false
		}
	}
	if !opts.Filter || o.Vcpus != 0 {
		if o.Vcpus != m.Vcpus {
			return false
		}
	}
	if !opts.Filter || o.Disk != 0 {
		if o.Disk != m.Disk {
			return false
		}
	}
	if !opts.Filter || o.OptResMap != nil {
		if len(m.OptResMap) == 0 && len(o.OptResMap) > 0 || len(m.OptResMap) > 0 && len(o.OptResMap) == 0 {
			return false
		} else if m.OptResMap != nil && o.OptResMap != nil {
			if !opts.Filter && len(m.OptResMap) != len(o.OptResMap) {
				return false
			}
			for k, _ := range o.OptResMap {
				_, ok := m.OptResMap[k]
				if !ok {
					return false
				}
				if o.OptResMap[k] != m.OptResMap[k] {
					return false
				}
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DeletePrepare != false {
			if o.DeletePrepare != m.DeletePrepare {
				return false
			}
		}
	}
	return true
}

const FlavorFieldKey = "2"
const FlavorFieldKeyName = "2.1"
const FlavorFieldRam = "3"
const FlavorFieldVcpus = "4"
const FlavorFieldDisk = "5"
const FlavorFieldOptResMap = "6"
const FlavorFieldOptResMapKey = "6.1"
const FlavorFieldOptResMapValue = "6.2"
const FlavorFieldDeletePrepare = "7"

var FlavorAllFields = []string{
	FlavorFieldKeyName,
	FlavorFieldRam,
	FlavorFieldVcpus,
	FlavorFieldDisk,
	FlavorFieldOptResMapKey,
	FlavorFieldOptResMapValue,
	FlavorFieldDeletePrepare,
}

var FlavorAllFieldsMap = map[string]struct{}{
	FlavorFieldKeyName:        struct{}{},
	FlavorFieldRam:            struct{}{},
	FlavorFieldVcpus:          struct{}{},
	FlavorFieldDisk:           struct{}{},
	FlavorFieldOptResMapKey:   struct{}{},
	FlavorFieldOptResMapValue: struct{}{},
	FlavorFieldDeletePrepare:  struct{}{},
}

var FlavorAllFieldsStringMap = map[string]string{
	FlavorFieldKeyName:        "Key Name",
	FlavorFieldRam:            "Ram",
	FlavorFieldVcpus:          "Vcpus",
	FlavorFieldDisk:           "Disk",
	FlavorFieldOptResMapKey:   "Opt Res Map Key",
	FlavorFieldOptResMapValue: "Opt Res Map Value",
	FlavorFieldDeletePrepare:  "Delete Prepare",
}

func (m *Flavor) IsKeyField(s string) bool {
	return strings.HasPrefix(s, FlavorFieldKey+".") || s == FlavorFieldKey
}

func (m *Flavor) DiffFields(o *Flavor, fields map[string]struct{}) {
	if m.Key.Name != o.Key.Name {
		fields[FlavorFieldKeyName] = struct{}{}
		fields[FlavorFieldKey] = struct{}{}
	}
	if m.Ram != o.Ram {
		fields[FlavorFieldRam] = struct{}{}
	}
	if m.Vcpus != o.Vcpus {
		fields[FlavorFieldVcpus] = struct{}{}
	}
	if m.Disk != o.Disk {
		fields[FlavorFieldDisk] = struct{}{}
	}
	if m.OptResMap != nil && o.OptResMap != nil {
		if len(m.OptResMap) != len(o.OptResMap) {
			fields[FlavorFieldOptResMap] = struct{}{}
		} else {
			for k0, _ := range m.OptResMap {
				_, vok0 := o.OptResMap[k0]
				if !vok0 {
					fields[FlavorFieldOptResMap] = struct{}{}
				} else {
					if m.OptResMap[k0] != o.OptResMap[k0] {
						fields[FlavorFieldOptResMap] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.OptResMap != nil && o.OptResMap == nil) || (m.OptResMap == nil && o.OptResMap != nil) {
		fields[FlavorFieldOptResMap] = struct{}{}
	}
	if m.DeletePrepare != o.DeletePrepare {
		fields[FlavorFieldDeletePrepare] = struct{}{}
	}
}

var UpdateFlavorFieldsMap = map[string]struct{}{
	FlavorFieldRam:            struct{}{},
	FlavorFieldVcpus:          struct{}{},
	FlavorFieldDisk:           struct{}{},
	FlavorFieldOptResMap:      struct{}{},
	FlavorFieldOptResMapValue: struct{}{},
}

func (m *Flavor) ValidateUpdateFields() error {
	if m.Fields == nil {
		return fmt.Errorf("nothing specified to update")
	}
	fmap := MakeFieldMap(m.Fields)
	badFieldStrs := []string{}
	for field, _ := range fmap {
		if m.IsKeyField(field) {
			continue
		}
		if _, ok := UpdateFlavorFieldsMap[field]; !ok {
			if _, ok := FlavorAllFieldsStringMap[field]; !ok {
				continue
			}
			badFieldStrs = append(badFieldStrs, FlavorAllFieldsStringMap[field])
		}
	}
	if len(badFieldStrs) > 0 {
		return fmt.Errorf("specified field(s) %s cannot be modified", strings.Join(badFieldStrs, ","))
	}
	return nil
}

func (m *Flavor) CopyInFields(src *Flavor) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
	}
	if _, set := fmap["3"]; set {
		if m.Ram != src.Ram {
			m.Ram = src.Ram
			changed++
		}
	}
	if _, set := fmap["4"]; set {
		if m.Vcpus != src.Vcpus {
			m.Vcpus = src.Vcpus
			changed++
		}
	}
	if _, set := fmap["5"]; set {
		if m.Disk != src.Disk {
			m.Disk = src.Disk
			changed++
		}
	}
	if _, set := fmap["6"]; set {
		if src.OptResMap != nil {
			m.OptResMap = make(map[string]string)
			for k0, _ := range src.OptResMap {
				m.OptResMap[k0] = src.OptResMap[k0]
				changed++
			}
		} else if m.OptResMap != nil {
			m.OptResMap = nil
			changed++
		}
	}
	if _, set := fmap["7"]; set {
		if m.DeletePrepare != src.DeletePrepare {
			m.DeletePrepare = src.DeletePrepare
			changed++
		}
	}
	return changed
}

func (m *Flavor) DeepCopyIn(src *Flavor) {
	m.Key.DeepCopyIn(&src.Key)
	m.Ram = src.Ram
	m.Vcpus = src.Vcpus
	m.Disk = src.Disk
	if src.OptResMap != nil {
		m.OptResMap = make(map[string]string)
		for k, v := range src.OptResMap {
			m.OptResMap[k] = v
		}
	} else {
		m.OptResMap = nil
	}
	m.DeletePrepare = src.DeletePrepare
}

func (s *Flavor) HasFields() bool {
	return true
}

type FlavorStore interface {
	Create(ctx context.Context, m *Flavor, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *Flavor, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *Flavor, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *Flavor, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*Flavor, int64, error)
	Get(ctx context.Context, key *FlavorKey, buf *Flavor) bool
	STMGet(stm concurrency.STM, key *FlavorKey, buf *Flavor) bool
	STMPut(stm concurrency.STM, obj *Flavor, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *FlavorKey)
}

type FlavorStoreImpl struct {
	kvstore objstore.KVStore
}

func NewFlavorStore(kvstore objstore.KVStore) *FlavorStoreImpl {
	return &FlavorStoreImpl{kvstore: kvstore}
}

func (s *FlavorStoreImpl) Create(ctx context.Context, m *Flavor, wait func(int64)) (*Result, error) {
	err := m.Validate(FlavorAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Flavor", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *FlavorStoreImpl) Update(ctx context.Context, m *Flavor, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Flavor", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur Flavor
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *FlavorStoreImpl) Put(ctx context.Context, m *Flavor, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(FlavorAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Flavor", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *FlavorStoreImpl) Delete(ctx context.Context, m *Flavor, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Flavor", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *FlavorStoreImpl) LoadOne(key string) (*Flavor, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj Flavor
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse Flavor data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *FlavorStoreImpl) Get(ctx context.Context, key *FlavorKey, buf *Flavor) bool {
	keystr := objstore.DbKeyString("Flavor", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *FlavorStoreImpl) STMGet(stm concurrency.STM, key *FlavorKey, buf *Flavor) bool {
	keystr := objstore.DbKeyString("Flavor", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *FlavorStoreImpl) parseGetData(val []byte, buf *Flavor) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = Flavor{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *FlavorStoreImpl) STMPut(stm concurrency.STM, obj *Flavor, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("Flavor", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("Flavor json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *FlavorStoreImpl) STMDel(stm concurrency.STM, key *FlavorKey) {
	keystr := objstore.DbKeyString("Flavor", key)
	stm.Del(keystr)
}

type FlavorKeyWatcher struct {
	cb func(ctx context.Context)
}

type FlavorCacheData struct {
	Obj    *Flavor
	ModRev int64
}

// FlavorCache caches Flavor objects in memory in a hash table
// and keeps them in sync with the database.
type FlavorCache struct {
	Objs          map[FlavorKey]*FlavorCacheData
	Mux           util.Mutex
	List          map[FlavorKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *FlavorKey, old *Flavor, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *Flavor, new *Flavor)
	DeletedCbs    []func(ctx context.Context, old *Flavor)
	KeyWatchers   map[FlavorKey][]*FlavorKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *FlavorKey)
	DeletedKeyCbs []func(ctx context.Context, key *FlavorKey)
}

func NewFlavorCache() *FlavorCache {
	cache := FlavorCache{}
	InitFlavorCache(&cache)
	return &cache
}

func InitFlavorCache(cache *FlavorCache) {
	cache.Objs = make(map[FlavorKey]*FlavorCacheData)
	cache.KeyWatchers = make(map[FlavorKey][]*FlavorKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *FlavorCache) GetTypeString() string {
	return "Flavor"
}

func (c *FlavorCache) Get(key *FlavorKey, valbuf *Flavor) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *FlavorCache) GetWithRev(key *FlavorKey, valbuf *Flavor, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *FlavorCache) HasKey(key *FlavorKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *FlavorCache) GetAllKeys(ctx context.Context, cb func(key *FlavorKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *FlavorCache) Update(ctx context.Context, in *Flavor, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *Flavor) (*Flavor, bool) {
		return in, true
	})
}

func (c *FlavorCache) UpdateModFunc(ctx context.Context, key *FlavorKey, modRev int64, modFunc func(old *Flavor) (new *Flavor, changed bool)) {
	c.Mux.Lock()
	var old *Flavor
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	for _, cb := range c.UpdatedCbs {
		newCopy := &Flavor{}
		newCopy.DeepCopyIn(new)
		defer cb(ctx, old, newCopy)
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			defer cb(ctx, new.GetKey(), old, modRev)
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &Flavor{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &FlavorCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *FlavorCache) Delete(ctx context.Context, in *Flavor, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *Flavor) bool {
		return true
	})
}

func (c *FlavorCache) DeleteCondFunc(ctx context.Context, in *Flavor, modRev int64, condFunc func(old *Flavor) bool) {
	c.Mux.Lock()
	var old *Flavor
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	c.Mux.Unlock()
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, in.GetKey(), old, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *FlavorCache) Prune(ctx context.Context, validKeys map[FlavorKey]struct{}) {
	notify := make(map[FlavorKey]*FlavorCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, old.Obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *FlavorCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *FlavorCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *FlavorCache) Show(filter *Flavor, cb func(ret *Flavor) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func FlavorGenericNotifyCb(fn func(key *FlavorKey, old *Flavor)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*FlavorKey), obj.(*Flavor))
	}
}

func (c *FlavorCache) SetNotifyCb(fn func(ctx context.Context, obj *FlavorKey, old *Flavor, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *FlavorKey, old *Flavor, modRev int64){fn}
}

func (c *FlavorCache) SetUpdatedCb(fn func(ctx context.Context, old *Flavor, new *Flavor)) {
	c.UpdatedCbs = []func(ctx context.Context, old *Flavor, new *Flavor){fn}
}

func (c *FlavorCache) SetDeletedCb(fn func(ctx context.Context, old *Flavor)) {
	c.DeletedCbs = []func(ctx context.Context, old *Flavor){fn}
}

func (c *FlavorCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *FlavorKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *FlavorKey){fn}
}

func (c *FlavorCache) SetDeletedKeyCb(fn func(ctx context.Context, key *FlavorKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *FlavorKey){fn}
}

func (c *FlavorCache) AddUpdatedCb(fn func(ctx context.Context, old *Flavor, new *Flavor)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *FlavorCache) AddDeletedCb(fn func(ctx context.Context, old *Flavor)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *FlavorCache) AddNotifyCb(fn func(ctx context.Context, obj *FlavorKey, old *Flavor, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *FlavorCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *FlavorKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *FlavorCache) AddDeletedKeyCb(fn func(ctx context.Context, key *FlavorKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *FlavorCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *FlavorCache) WatchKey(key *FlavorKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*FlavorKeyWatcher, 0)
	}
	watcher := FlavorKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching Flavor", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *FlavorCache) TriggerKeyWatchers(ctx context.Context, key *FlavorKey) {
	watchers := make([]*FlavorKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *FlavorCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := Flavor{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse Flavor data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *FlavorCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := Flavor{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	FlavorKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *FlavorCache) SyncListStart(ctx context.Context) {
	c.List = make(map[FlavorKey]struct{})
}

func (c *FlavorCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[FlavorKey]*FlavorCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, val.Obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *FlavorCache) UsesOrg(org string) bool {
	return false
}

func (m *Flavor) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *Flavor) GetKey() *FlavorKey {
	return &m.Key
}

func (m *Flavor) GetKeyVal() FlavorKey {
	return m.Key
}

func (m *Flavor) SetKey(key *FlavorKey) {
	m.Key = *key
}

func CmpSortFlavor(a Flavor, b Flavor) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *Flavor) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *Flavor) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
}

func (m *Flavor) IsValidArgsForCreateFlavor() error {
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	return nil
}

func (m *Flavor) IsValidArgsForDeleteFlavor() error {
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	return nil
}

func (m *Flavor) IsValidArgsForUpdateFlavor() error {
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	return nil
}

func (m *Flavor) IsValidArgsForAddFlavorRes() error {
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	return nil
}

func (m *Flavor) IsValidArgsForRemoveFlavorRes() error {
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	return nil
}

func (m *FlavorKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlavor(uint64(l))
	}
	return n
}

func (m *Flavor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovFlavor(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovFlavor(uint64(l))
	if m.Ram != 0 {
		n += 1 + sovFlavor(uint64(m.Ram))
	}
	if m.Vcpus != 0 {
		n += 1 + sovFlavor(uint64(m.Vcpus))
	}
	if m.Disk != 0 {
		n += 1 + sovFlavor(uint64(m.Disk))
	}
	if len(m.OptResMap) > 0 {
		for k, v := range m.OptResMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFlavor(uint64(len(k))) + 1 + len(v) + sovFlavor(uint64(len(v)))
			n += mapEntrySize + 1 + sovFlavor(uint64(mapEntrySize))
		}
	}
	if m.DeletePrepare {
		n += 2
	}
	return n
}

func sovFlavor(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFlavor(x uint64) (n int) {
	return sovFlavor(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FlavorKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlavor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlavorKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlavorKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlavor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlavor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlavor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlavor
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlavor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Flavor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlavor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flavor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flavor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlavor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlavor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlavor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlavor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ram", wireType)
			}
			m.Ram = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ram |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vcpus", wireType)
			}
			m.Vcpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vcpus |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disk", wireType)
			}
			m.Disk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Disk |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptResMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlavor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlavor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptResMap == nil {
				m.OptResMap = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlavor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlavor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFlavor
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFlavor
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlavor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthFlavor
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthFlavor
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlavor(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFlavor
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.OptResMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletePrepare", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeletePrepare = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFlavor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlavor
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlavor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFlavor(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFlavor
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlavor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlavor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFlavor
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFlavor
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFlavor
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFlavor        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFlavor          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFlavor = fmt.Errorf("proto: unexpected end of group")
)
