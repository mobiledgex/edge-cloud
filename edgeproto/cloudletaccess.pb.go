// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cloudletaccess.proto

package edgeproto

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// IssueCertRequest asks for a TLS certificate from Vault
type IssueCertRequest struct {
	// Certificate common name
	CommonName string `protobuf:"bytes,1,opt,name=common_name,json=commonName,proto3" json:"common_name,omitempty"`
}

func (m *IssueCertRequest) Reset()         { *m = IssueCertRequest{} }
func (m *IssueCertRequest) String() string { return proto.CompactTextString(m) }
func (*IssueCertRequest) ProtoMessage()    {}
func (*IssueCertRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ae40f913721b930, []int{0}
}
func (m *IssueCertRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IssueCertRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IssueCertRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IssueCertRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IssueCertRequest.Merge(m, src)
}
func (m *IssueCertRequest) XXX_Size() int {
	return m.Size()
}
func (m *IssueCertRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IssueCertRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IssueCertRequest proto.InternalMessageInfo

type IssueCertReply struct {
	// Public certificate in PEM format
	PublicCertPem string `protobuf:"bytes,1,opt,name=public_cert_pem,json=publicCertPem,proto3" json:"public_cert_pem,omitempty"`
	// Private key in PEM format
	PrivateKeyPem string `protobuf:"bytes,2,opt,name=private_key_pem,json=privateKeyPem,proto3" json:"private_key_pem,omitempty"`
}

func (m *IssueCertReply) Reset()         { *m = IssueCertReply{} }
func (m *IssueCertReply) String() string { return proto.CompactTextString(m) }
func (*IssueCertReply) ProtoMessage()    {}
func (*IssueCertReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ae40f913721b930, []int{1}
}
func (m *IssueCertReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IssueCertReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IssueCertReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IssueCertReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IssueCertReply.Merge(m, src)
}
func (m *IssueCertReply) XXX_Size() int {
	return m.Size()
}
func (m *IssueCertReply) XXX_DiscardUnknown() {
	xxx_messageInfo_IssueCertReply.DiscardUnknown(m)
}

var xxx_messageInfo_IssueCertReply proto.InternalMessageInfo

type GetCasRequest struct {
	// Issuer
	Issuer string `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
}

func (m *GetCasRequest) Reset()         { *m = GetCasRequest{} }
func (m *GetCasRequest) String() string { return proto.CompactTextString(m) }
func (*GetCasRequest) ProtoMessage()    {}
func (*GetCasRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ae40f913721b930, []int{2}
}
func (m *GetCasRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCasRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCasRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCasRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCasRequest.Merge(m, src)
}
func (m *GetCasRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetCasRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCasRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetCasRequest proto.InternalMessageInfo

type GetCasReply struct {
	// CA chain in PEM format
	CaChainPem string `protobuf:"bytes,1,opt,name=ca_chain_pem,json=caChainPem,proto3" json:"ca_chain_pem,omitempty"`
}

func (m *GetCasReply) Reset()         { *m = GetCasReply{} }
func (m *GetCasReply) String() string { return proto.CompactTextString(m) }
func (*GetCasReply) ProtoMessage()    {}
func (*GetCasReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ae40f913721b930, []int{3}
}
func (m *GetCasReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCasReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCasReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCasReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCasReply.Merge(m, src)
}
func (m *GetCasReply) XXX_Size() int {
	return m.Size()
}
func (m *GetCasReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCasReply.DiscardUnknown(m)
}

var xxx_messageInfo_GetCasReply proto.InternalMessageInfo

type UpgradeAccessKeyClientMsg struct {
	// Message type
	Msg string `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	// Client node type
	VerifyOnly bool `protobuf:"varint,2,opt,name=verify_only,json=verifyOnly,proto3" json:"verify_only,omitempty"`
}

func (m *UpgradeAccessKeyClientMsg) Reset()         { *m = UpgradeAccessKeyClientMsg{} }
func (m *UpgradeAccessKeyClientMsg) String() string { return proto.CompactTextString(m) }
func (*UpgradeAccessKeyClientMsg) ProtoMessage()    {}
func (*UpgradeAccessKeyClientMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ae40f913721b930, []int{4}
}
func (m *UpgradeAccessKeyClientMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpgradeAccessKeyClientMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpgradeAccessKeyClientMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpgradeAccessKeyClientMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpgradeAccessKeyClientMsg.Merge(m, src)
}
func (m *UpgradeAccessKeyClientMsg) XXX_Size() int {
	return m.Size()
}
func (m *UpgradeAccessKeyClientMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_UpgradeAccessKeyClientMsg.DiscardUnknown(m)
}

var xxx_messageInfo_UpgradeAccessKeyClientMsg proto.InternalMessageInfo

type UpgradeAccessKeyServerMsg struct {
	// Message type
	Msg string `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	// New Access key in PEM format (may be blank)
	CrmPrivateAccessKey string `protobuf:"bytes,2,opt,name=crm_private_access_key,json=crmPrivateAccessKey,proto3" json:"crm_private_access_key,omitempty"`
}

func (m *UpgradeAccessKeyServerMsg) Reset()         { *m = UpgradeAccessKeyServerMsg{} }
func (m *UpgradeAccessKeyServerMsg) String() string { return proto.CompactTextString(m) }
func (*UpgradeAccessKeyServerMsg) ProtoMessage()    {}
func (*UpgradeAccessKeyServerMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ae40f913721b930, []int{5}
}
func (m *UpgradeAccessKeyServerMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpgradeAccessKeyServerMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpgradeAccessKeyServerMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpgradeAccessKeyServerMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpgradeAccessKeyServerMsg.Merge(m, src)
}
func (m *UpgradeAccessKeyServerMsg) XXX_Size() int {
	return m.Size()
}
func (m *UpgradeAccessKeyServerMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_UpgradeAccessKeyServerMsg.DiscardUnknown(m)
}

var xxx_messageInfo_UpgradeAccessKeyServerMsg proto.InternalMessageInfo

func init() {
	proto.RegisterType((*IssueCertRequest)(nil), "edgeproto.IssueCertRequest")
	proto.RegisterType((*IssueCertReply)(nil), "edgeproto.IssueCertReply")
	proto.RegisterType((*GetCasRequest)(nil), "edgeproto.GetCasRequest")
	proto.RegisterType((*GetCasReply)(nil), "edgeproto.GetCasReply")
	proto.RegisterType((*UpgradeAccessKeyClientMsg)(nil), "edgeproto.UpgradeAccessKeyClientMsg")
	proto.RegisterType((*UpgradeAccessKeyServerMsg)(nil), "edgeproto.UpgradeAccessKeyServerMsg")
}

func init() { proto.RegisterFile("cloudletaccess.proto", fileDescriptor_0ae40f913721b930) }

var fileDescriptor_0ae40f913721b930 = []byte{
	// 429 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x91, 0xc1, 0x6f, 0xd3, 0x30,
	0x14, 0xc6, 0x6b, 0x90, 0x2a, 0xfa, 0xc6, 0xa0, 0x98, 0xaa, 0xda, 0x0a, 0x0a, 0x53, 0x84, 0x60,
	0xa7, 0x0e, 0xad, 0x37, 0x6e, 0x23, 0x07, 0x84, 0x2a, 0x46, 0x55, 0xc4, 0x39, 0xb8, 0xee, 0x23,
	0x44, 0xd8, 0x71, 0xb0, 0xdd, 0x4a, 0xe6, 0xaf, 0xe0, 0xc0, 0x1f, 0xb5, 0xe3, 0x8e, 0x1c, 0xa1,
	0xfd, 0x47, 0x90, 0xe3, 0xb4, 0xca, 0x4a, 0xe1, 0xf6, 0xf2, 0xf9, 0x7b, 0x5f, 0x3e, 0xfd, 0x1e,
	0xf4, 0xb8, 0x50, 0x8b, 0xb9, 0x40, 0xcb, 0x38, 0x47, 0x63, 0x86, 0xa5, 0x56, 0x56, 0xd1, 0x0e,
	0xce, 0x33, 0xac, 0xc6, 0x41, 0x2f, 0x53, 0x99, 0xaa, 0xc6, 0x33, 0x3f, 0x05, 0x43, 0x3c, 0x82,
	0xee, 0x1b, 0x63, 0x16, 0x98, 0xa0, 0xb6, 0x53, 0xfc, 0xba, 0x40, 0x63, 0xe9, 0x13, 0x38, 0xe0,
	0x4a, 0x4a, 0x55, 0xa4, 0x05, 0x93, 0x78, 0x44, 0x4e, 0xc8, 0x69, 0x67, 0x0a, 0x41, 0xba, 0x64,
	0x12, 0xe3, 0x8f, 0x70, 0xaf, 0xb1, 0x54, 0x0a, 0x47, 0x9f, 0xc1, 0xfd, 0x72, 0x31, 0x13, 0x39,
	0x4f, 0x39, 0x6a, 0x9b, 0x96, 0x28, 0xeb, 0xb5, 0xc3, 0x20, 0x7b, 0xe7, 0x04, 0x65, 0xe5, 0xd3,
	0xf9, 0x92, 0x59, 0x4c, 0xbf, 0xa0, 0xab, 0x7c, 0xb7, 0x6a, 0x5f, 0x90, 0xc7, 0xe8, 0x26, 0x28,
	0xe3, 0xe7, 0x70, 0xf8, 0x1a, 0x6d, 0xc2, 0xcc, 0xa6, 0x53, 0x1f, 0xda, 0xb9, 0xff, 0xa5, 0xae,
	0x73, 0xeb, 0xaf, 0xf8, 0x0c, 0x0e, 0x36, 0x46, 0xdf, 0xe3, 0x04, 0xee, 0x72, 0x96, 0xf2, 0xcf,
	0x2c, 0x2f, 0x1a, 0x25, 0x80, 0xb3, 0xc4, 0x4b, 0x3e, 0xf9, 0x12, 0x8e, 0x3f, 0x94, 0x99, 0x66,
	0x73, 0xbc, 0xa8, 0x40, 0x8d, 0xd1, 0x25, 0x22, 0xc7, 0xc2, 0xbe, 0x35, 0x19, 0xed, 0xc2, 0x6d,
	0x69, 0xb2, 0x7a, 0xcb, 0x8f, 0x9e, 0xc5, 0x12, 0x75, 0xfe, 0xc9, 0xa5, 0xaa, 0x10, 0xae, 0x2a,
	0x7b, 0x67, 0x0a, 0x41, 0x7a, 0x57, 0x08, 0x17, 0xcf, 0xfe, 0xce, 0x7b, 0x8f, 0x7a, 0x89, 0x7a,
	0x7f, 0xde, 0x08, 0xfa, 0x5c, 0xcb, 0x74, 0x03, 0x21, 0x1c, 0xcb, 0xb3, 0xa8, 0x39, 0x3c, 0xe4,
	0x5a, 0x4e, 0xc2, 0xe3, 0x36, 0xef, 0xfc, 0x07, 0x81, 0x07, 0x49, 0x7d, 0xde, 0xa0, 0x5e, 0x94,
	0x39, 0x4d, 0xa0, 0xb3, 0xbd, 0x02, 0x7d, 0x34, 0xdc, 0x5e, 0x7a, 0xb8, 0x7b, 0xd0, 0xc1, 0xf1,
	0xfe, 0x47, 0x0f, 0xec, 0x25, 0xb4, 0x03, 0x3f, 0x7a, 0xd4, 0x30, 0xdd, 0x60, 0x3f, 0xe8, 0xef,
	0x79, 0x29, 0x85, 0x3b, 0xff, 0x06, 0xbd, 0x9b, 0xad, 0xc6, 0xe8, 0x7c, 0xb1, 0x19, 0x74, 0x77,
	0x91, 0xd0, 0xa7, 0x8d, 0x8c, 0x7f, 0xf2, 0x1f, 0xfc, 0xcf, 0xb5, 0xa5, 0x7a, 0x4a, 0x5e, 0x90,
	0x57, 0x8f, 0xaf, 0x7e, 0x47, 0xad, 0xab, 0x55, 0x44, 0xae, 0x57, 0x11, 0xf9, 0xb5, 0x8a, 0xc8,
	0xf7, 0x75, 0xd4, 0xba, 0x5e, 0x47, 0xad, 0x9f, 0xeb, 0xa8, 0x35, 0x6b, 0x57, 0x11, 0xa3, 0x3f,
	0x01, 0x00, 0x00, 0xff, 0xff, 0xed, 0x65, 0x05, 0x0e, 0x15, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CloudletAccessApiClient is the client API for CloudletAccessApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CloudletAccessApiClient interface {
	// Issue certificate
	IssueCert(ctx context.Context, in *IssueCertRequest, opts ...grpc.CallOption) (*IssueCertReply, error)
	// Get Cerficiate Authority public certs
	GetCas(ctx context.Context, in *GetCasRequest, opts ...grpc.CallOption) (*GetCasReply, error)
}

type cloudletAccessApiClient struct {
	cc *grpc.ClientConn
}

func NewCloudletAccessApiClient(cc *grpc.ClientConn) CloudletAccessApiClient {
	return &cloudletAccessApiClient{cc}
}

func (c *cloudletAccessApiClient) IssueCert(ctx context.Context, in *IssueCertRequest, opts ...grpc.CallOption) (*IssueCertReply, error) {
	out := new(IssueCertReply)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletAccessApi/IssueCert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletAccessApiClient) GetCas(ctx context.Context, in *GetCasRequest, opts ...grpc.CallOption) (*GetCasReply, error) {
	out := new(GetCasReply)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletAccessApi/GetCas", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CloudletAccessApiServer is the server API for CloudletAccessApi service.
type CloudletAccessApiServer interface {
	// Issue certificate
	IssueCert(context.Context, *IssueCertRequest) (*IssueCertReply, error)
	// Get Cerficiate Authority public certs
	GetCas(context.Context, *GetCasRequest) (*GetCasReply, error)
}

// UnimplementedCloudletAccessApiServer can be embedded to have forward compatible implementations.
type UnimplementedCloudletAccessApiServer struct {
}

func (*UnimplementedCloudletAccessApiServer) IssueCert(ctx context.Context, req *IssueCertRequest) (*IssueCertReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IssueCert not implemented")
}
func (*UnimplementedCloudletAccessApiServer) GetCas(ctx context.Context, req *GetCasRequest) (*GetCasReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCas not implemented")
}

func RegisterCloudletAccessApiServer(s *grpc.Server, srv CloudletAccessApiServer) {
	s.RegisterService(&_CloudletAccessApi_serviceDesc, srv)
}

func _CloudletAccessApi_IssueCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IssueCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletAccessApiServer).IssueCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletAccessApi/IssueCert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletAccessApiServer).IssueCert(ctx, req.(*IssueCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletAccessApi_GetCas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletAccessApiServer).GetCas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletAccessApi/GetCas",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletAccessApiServer).GetCas(ctx, req.(*GetCasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CloudletAccessApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.CloudletAccessApi",
	HandlerType: (*CloudletAccessApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IssueCert",
			Handler:    _CloudletAccessApi_IssueCert_Handler,
		},
		{
			MethodName: "GetCas",
			Handler:    _CloudletAccessApi_GetCas_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cloudletaccess.proto",
}

// CloudletAccessKeyApiClient is the client API for CloudletAccessKeyApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CloudletAccessKeyApiClient interface {
	// Upgrade AccessKey for existing Vault-CRM, or one-time key
	UpgradeAccessKey(ctx context.Context, opts ...grpc.CallOption) (CloudletAccessKeyApi_UpgradeAccessKeyClient, error)
}

type cloudletAccessKeyApiClient struct {
	cc *grpc.ClientConn
}

func NewCloudletAccessKeyApiClient(cc *grpc.ClientConn) CloudletAccessKeyApiClient {
	return &cloudletAccessKeyApiClient{cc}
}

func (c *cloudletAccessKeyApiClient) UpgradeAccessKey(ctx context.Context, opts ...grpc.CallOption) (CloudletAccessKeyApi_UpgradeAccessKeyClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CloudletAccessKeyApi_serviceDesc.Streams[0], "/edgeproto.CloudletAccessKeyApi/UpgradeAccessKey", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletAccessKeyApiUpgradeAccessKeyClient{stream}
	return x, nil
}

type CloudletAccessKeyApi_UpgradeAccessKeyClient interface {
	Send(*UpgradeAccessKeyClientMsg) error
	Recv() (*UpgradeAccessKeyServerMsg, error)
	grpc.ClientStream
}

type cloudletAccessKeyApiUpgradeAccessKeyClient struct {
	grpc.ClientStream
}

func (x *cloudletAccessKeyApiUpgradeAccessKeyClient) Send(m *UpgradeAccessKeyClientMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *cloudletAccessKeyApiUpgradeAccessKeyClient) Recv() (*UpgradeAccessKeyServerMsg, error) {
	m := new(UpgradeAccessKeyServerMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CloudletAccessKeyApiServer is the server API for CloudletAccessKeyApi service.
type CloudletAccessKeyApiServer interface {
	// Upgrade AccessKey for existing Vault-CRM, or one-time key
	UpgradeAccessKey(CloudletAccessKeyApi_UpgradeAccessKeyServer) error
}

// UnimplementedCloudletAccessKeyApiServer can be embedded to have forward compatible implementations.
type UnimplementedCloudletAccessKeyApiServer struct {
}

func (*UnimplementedCloudletAccessKeyApiServer) UpgradeAccessKey(srv CloudletAccessKeyApi_UpgradeAccessKeyServer) error {
	return status.Errorf(codes.Unimplemented, "method UpgradeAccessKey not implemented")
}

func RegisterCloudletAccessKeyApiServer(s *grpc.Server, srv CloudletAccessKeyApiServer) {
	s.RegisterService(&_CloudletAccessKeyApi_serviceDesc, srv)
}

func _CloudletAccessKeyApi_UpgradeAccessKey_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CloudletAccessKeyApiServer).UpgradeAccessKey(&cloudletAccessKeyApiUpgradeAccessKeyServer{stream})
}

type CloudletAccessKeyApi_UpgradeAccessKeyServer interface {
	Send(*UpgradeAccessKeyServerMsg) error
	Recv() (*UpgradeAccessKeyClientMsg, error)
	grpc.ServerStream
}

type cloudletAccessKeyApiUpgradeAccessKeyServer struct {
	grpc.ServerStream
}

func (x *cloudletAccessKeyApiUpgradeAccessKeyServer) Send(m *UpgradeAccessKeyServerMsg) error {
	return x.ServerStream.SendMsg(m)
}

func (x *cloudletAccessKeyApiUpgradeAccessKeyServer) Recv() (*UpgradeAccessKeyClientMsg, error) {
	m := new(UpgradeAccessKeyClientMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _CloudletAccessKeyApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.CloudletAccessKeyApi",
	HandlerType: (*CloudletAccessKeyApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UpgradeAccessKey",
			Handler:       _CloudletAccessKeyApi_UpgradeAccessKey_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "cloudletaccess.proto",
}

func (m *IssueCertRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IssueCertRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IssueCertRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CommonName) > 0 {
		i -= len(m.CommonName)
		copy(dAtA[i:], m.CommonName)
		i = encodeVarintCloudletaccess(dAtA, i, uint64(len(m.CommonName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IssueCertReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IssueCertReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IssueCertReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrivateKeyPem) > 0 {
		i -= len(m.PrivateKeyPem)
		copy(dAtA[i:], m.PrivateKeyPem)
		i = encodeVarintCloudletaccess(dAtA, i, uint64(len(m.PrivateKeyPem)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PublicCertPem) > 0 {
		i -= len(m.PublicCertPem)
		copy(dAtA[i:], m.PublicCertPem)
		i = encodeVarintCloudletaccess(dAtA, i, uint64(len(m.PublicCertPem)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetCasRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCasRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCasRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintCloudletaccess(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetCasReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCasReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCasReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CaChainPem) > 0 {
		i -= len(m.CaChainPem)
		copy(dAtA[i:], m.CaChainPem)
		i = encodeVarintCloudletaccess(dAtA, i, uint64(len(m.CaChainPem)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpgradeAccessKeyClientMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpgradeAccessKeyClientMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpgradeAccessKeyClientMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VerifyOnly {
		i--
		if m.VerifyOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintCloudletaccess(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpgradeAccessKeyServerMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpgradeAccessKeyServerMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpgradeAccessKeyServerMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CrmPrivateAccessKey) > 0 {
		i -= len(m.CrmPrivateAccessKey)
		copy(dAtA[i:], m.CrmPrivateAccessKey)
		i = encodeVarintCloudletaccess(dAtA, i, uint64(len(m.CrmPrivateAccessKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintCloudletaccess(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCloudletaccess(dAtA []byte, offset int, v uint64) int {
	offset -= sovCloudletaccess(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *IssueCertRequest) CopyInFields(src *IssueCertRequest) int {
	changed := 0
	if m.CommonName != src.CommonName {
		m.CommonName = src.CommonName
		changed++
	}
	return changed
}

func (m *IssueCertRequest) DeepCopyIn(src *IssueCertRequest) {
	m.CommonName = src.CommonName
}

// Helper method to check that enums have valid values
func (m *IssueCertRequest) ValidateEnums() error {
	return nil
}

func (m *IssueCertReply) CopyInFields(src *IssueCertReply) int {
	changed := 0
	if m.PublicCertPem != src.PublicCertPem {
		m.PublicCertPem = src.PublicCertPem
		changed++
	}
	if m.PrivateKeyPem != src.PrivateKeyPem {
		m.PrivateKeyPem = src.PrivateKeyPem
		changed++
	}
	return changed
}

func (m *IssueCertReply) DeepCopyIn(src *IssueCertReply) {
	m.PublicCertPem = src.PublicCertPem
	m.PrivateKeyPem = src.PrivateKeyPem
}

// Helper method to check that enums have valid values
func (m *IssueCertReply) ValidateEnums() error {
	return nil
}

func (m *GetCasRequest) CopyInFields(src *GetCasRequest) int {
	changed := 0
	if m.Issuer != src.Issuer {
		m.Issuer = src.Issuer
		changed++
	}
	return changed
}

func (m *GetCasRequest) DeepCopyIn(src *GetCasRequest) {
	m.Issuer = src.Issuer
}

// Helper method to check that enums have valid values
func (m *GetCasRequest) ValidateEnums() error {
	return nil
}

func (m *GetCasReply) CopyInFields(src *GetCasReply) int {
	changed := 0
	if m.CaChainPem != src.CaChainPem {
		m.CaChainPem = src.CaChainPem
		changed++
	}
	return changed
}

func (m *GetCasReply) DeepCopyIn(src *GetCasReply) {
	m.CaChainPem = src.CaChainPem
}

// Helper method to check that enums have valid values
func (m *GetCasReply) ValidateEnums() error {
	return nil
}

func (m *UpgradeAccessKeyClientMsg) CopyInFields(src *UpgradeAccessKeyClientMsg) int {
	changed := 0
	if m.Msg != src.Msg {
		m.Msg = src.Msg
		changed++
	}
	if m.VerifyOnly != src.VerifyOnly {
		m.VerifyOnly = src.VerifyOnly
		changed++
	}
	return changed
}

func (m *UpgradeAccessKeyClientMsg) DeepCopyIn(src *UpgradeAccessKeyClientMsg) {
	m.Msg = src.Msg
	m.VerifyOnly = src.VerifyOnly
}

// Helper method to check that enums have valid values
func (m *UpgradeAccessKeyClientMsg) ValidateEnums() error {
	return nil
}

func (m *UpgradeAccessKeyServerMsg) CopyInFields(src *UpgradeAccessKeyServerMsg) int {
	changed := 0
	if m.Msg != src.Msg {
		m.Msg = src.Msg
		changed++
	}
	if m.CrmPrivateAccessKey != src.CrmPrivateAccessKey {
		m.CrmPrivateAccessKey = src.CrmPrivateAccessKey
		changed++
	}
	return changed
}

func (m *UpgradeAccessKeyServerMsg) DeepCopyIn(src *UpgradeAccessKeyServerMsg) {
	m.Msg = src.Msg
	m.CrmPrivateAccessKey = src.CrmPrivateAccessKey
}

// Helper method to check that enums have valid values
func (m *UpgradeAccessKeyServerMsg) ValidateEnums() error {
	return nil
}

func (m *IssueCertRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CommonName)
	if l > 0 {
		n += 1 + l + sovCloudletaccess(uint64(l))
	}
	return n
}

func (m *IssueCertReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublicCertPem)
	if l > 0 {
		n += 1 + l + sovCloudletaccess(uint64(l))
	}
	l = len(m.PrivateKeyPem)
	if l > 0 {
		n += 1 + l + sovCloudletaccess(uint64(l))
	}
	return n
}

func (m *GetCasRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovCloudletaccess(uint64(l))
	}
	return n
}

func (m *GetCasReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CaChainPem)
	if l > 0 {
		n += 1 + l + sovCloudletaccess(uint64(l))
	}
	return n
}

func (m *UpgradeAccessKeyClientMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovCloudletaccess(uint64(l))
	}
	if m.VerifyOnly {
		n += 2
	}
	return n
}

func (m *UpgradeAccessKeyServerMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovCloudletaccess(uint64(l))
	}
	l = len(m.CrmPrivateAccessKey)
	if l > 0 {
		n += 1 + l + sovCloudletaccess(uint64(l))
	}
	return n
}

func sovCloudletaccess(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCloudletaccess(x uint64) (n int) {
	return sovCloudletaccess(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *IssueCertRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudletaccess
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IssueCertRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IssueCertRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudletaccess
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommonName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudletaccess(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IssueCertReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudletaccess
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IssueCertReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IssueCertReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicCertPem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudletaccess
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicCertPem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKeyPem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudletaccess
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateKeyPem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudletaccess(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCasRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudletaccess
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCasRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCasRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudletaccess
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudletaccess(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCasReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudletaccess
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCasReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCasReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaChainPem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudletaccess
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaChainPem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudletaccess(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpgradeAccessKeyClientMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudletaccess
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradeAccessKeyClientMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradeAccessKeyClientMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudletaccess
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudletaccess
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VerifyOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCloudletaccess(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpgradeAccessKeyServerMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudletaccess
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradeAccessKeyServerMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradeAccessKeyServerMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudletaccess
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrmPrivateAccessKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudletaccess
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrmPrivateAccessKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudletaccess(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudletaccess
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCloudletaccess(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCloudletaccess
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCloudletaccess
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCloudletaccess
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCloudletaccess
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCloudletaccess
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCloudletaccess
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCloudletaccess        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCloudletaccess          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCloudletaccess = fmt.Errorf("proto: unexpected end of group")
)
