// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: settings.proto

package edgeproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/mobiledgex/edge-cloud/protogen"
import _ "github.com/gogo/protobuf/gogoproto"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import binary "encoding/binary"

import "encoding/json"
import "github.com/mobiledgex/edge-cloud/objstore"
import "github.com/coreos/etcd/clientv3/concurrency"
import "github.com/mobiledgex/edge-cloud/util"
import "github.com/mobiledgex/edge-cloud/log"
import strings "strings"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Global settings
type Settings struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty"`
	// Shepherd metrics collection interval for k8s and docker appInstances (duration)
	ShepherdMetricsCollectionInterval Duration `protobuf:"varint,2,opt,name=shepherd_metrics_collection_interval,json=shepherdMetricsCollectionInterval,proto3,casttype=Duration" json:"shepherd_metrics_collection_interval,omitempty"`
	// Number of times Shepherd Health Check fails before we mark appInst down
	ShepherdHealthCheckRetries int32 `protobuf:"varint,3,opt,name=shepherd_health_check_retries,json=shepherdHealthCheckRetries,proto3" json:"shepherd_health_check_retries,omitempty"`
	// Health Checking probing frequency (duration)
	ShepherdHealthCheckInterval Duration `protobuf:"varint,4,opt,name=shepherd_health_check_interval,json=shepherdHealthCheckInterval,proto3,casttype=Duration" json:"shepherd_health_check_interval,omitempty"`
	// Auto Provisioning Stats push and analysis interval (seconds)
	AutoDeployIntervalSec float64 `protobuf:"fixed64,5,opt,name=auto_deploy_interval_sec,json=autoDeployIntervalSec,proto3" json:"auto_deploy_interval_sec,omitempty"`
	// Auto Provisioning analysis offset from interval (seconds)
	AutoDeployOffsetSec float64 `protobuf:"fixed64,6,opt,name=auto_deploy_offset_sec,json=autoDeployOffsetSec,proto3" json:"auto_deploy_offset_sec,omitempty"`
	// Auto Provisioning Policy max allowed intervals
	AutoDeployMaxIntervals uint32 `protobuf:"varint,7,opt,name=auto_deploy_max_intervals,json=autoDeployMaxIntervals,proto3" json:"auto_deploy_max_intervals,omitempty"`
	// Create AppInst timeout (duration)
	CreateAppInstTimeout Duration `protobuf:"varint,8,opt,name=create_app_inst_timeout,json=createAppInstTimeout,proto3,casttype=Duration" json:"create_app_inst_timeout,omitempty"`
	// Update AppInst timeout (duration)
	UpdateAppInstTimeout Duration `protobuf:"varint,9,opt,name=update_app_inst_timeout,json=updateAppInstTimeout,proto3,casttype=Duration" json:"update_app_inst_timeout,omitempty"`
	// Delete AppInst timeout (duration)
	DeleteAppInstTimeout Duration `protobuf:"varint,10,opt,name=delete_app_inst_timeout,json=deleteAppInstTimeout,proto3,casttype=Duration" json:"delete_app_inst_timeout,omitempty"`
	// Create ClusterInst timeout (duration)
	CreateClusterInstTimeout Duration `protobuf:"varint,11,opt,name=create_cluster_inst_timeout,json=createClusterInstTimeout,proto3,casttype=Duration" json:"create_cluster_inst_timeout,omitempty"`
	// Update ClusterInst timeout (duration)
	UpdateClusterInstTimeout Duration `protobuf:"varint,12,opt,name=update_cluster_inst_timeout,json=updateClusterInstTimeout,proto3,casttype=Duration" json:"update_cluster_inst_timeout,omitempty"`
	// Delete ClusterInst timeout (duration)
	DeleteClusterInstTimeout Duration `protobuf:"varint,13,opt,name=delete_cluster_inst_timeout,json=deleteClusterInstTimeout,proto3,casttype=Duration" json:"delete_cluster_inst_timeout,omitempty"`
	// Default flavor for k8s master VM and > 0  workers
	MasterNodeFlavor string `protobuf:"bytes,14,opt,name=master_node_flavor,json=masterNodeFlavor,proto3" json:"master_node_flavor,omitempty"`
	// Max IP Port range when using a load balancer
	LoadBalancerMaxPortRange int32 `protobuf:"varint,15,opt,name=load_balancer_max_port_range,json=loadBalancerMaxPortRange,proto3" json:"load_balancer_max_port_range,omitempty"`
	// Max DME clients to be tracked at the same time.
	MaxTrackedDmeClients int32 `protobuf:"varint,16,opt,name=max_tracked_dme_clients,json=maxTrackedDmeClients,proto3" json:"max_tracked_dme_clients,omitempty"`
	// Default chef client interval (duration)
	ChefClientInterval Duration `protobuf:"varint,17,opt,name=chef_client_interval,json=chefClientInterval,proto3,casttype=Duration" json:"chef_client_interval,omitempty"`
	// Default influxDB metrics retention policy (duration)
	InfluxDbMetricsRetention Duration `protobuf:"varint,18,opt,name=influx_db_metrics_retention,json=influxDbMetricsRetention,proto3,casttype=Duration" json:"influx_db_metrics_retention,omitempty"`
	// Default Cloudlet Maintenance timeout (used twice for AutoProv and Cloudlet)
	CloudletMaintenanceTimeout Duration `protobuf:"varint,19,opt,name=cloudlet_maintenance_timeout,json=cloudletMaintenanceTimeout,proto3,casttype=Duration" json:"cloudlet_maintenance_timeout,omitempty"`
}

func (m *Settings) Reset()                    { *m = Settings{} }
func (m *Settings) String() string            { return proto.CompactTextString(m) }
func (*Settings) ProtoMessage()               {}
func (*Settings) Descriptor() ([]byte, []int) { return fileDescriptorSettings, []int{0} }

func init() {
	proto.RegisterType((*Settings)(nil), "edgeproto.Settings")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SettingsApi service

type SettingsApiClient interface {
	// Update settings
	UpdateSettings(ctx context.Context, in *Settings, opts ...grpc.CallOption) (*Result, error)
	// Reset all settings to their defaults
	ResetSettings(ctx context.Context, in *Settings, opts ...grpc.CallOption) (*Result, error)
	// Show settings
	ShowSettings(ctx context.Context, in *Settings, opts ...grpc.CallOption) (*Settings, error)
}

type settingsApiClient struct {
	cc *grpc.ClientConn
}

func NewSettingsApiClient(cc *grpc.ClientConn) SettingsApiClient {
	return &settingsApiClient{cc}
}

func (c *settingsApiClient) UpdateSettings(ctx context.Context, in *Settings, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.SettingsApi/UpdateSettings", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsApiClient) ResetSettings(ctx context.Context, in *Settings, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.SettingsApi/ResetSettings", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsApiClient) ShowSettings(ctx context.Context, in *Settings, opts ...grpc.CallOption) (*Settings, error) {
	out := new(Settings)
	err := grpc.Invoke(ctx, "/edgeproto.SettingsApi/ShowSettings", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SettingsApi service

type SettingsApiServer interface {
	// Update settings
	UpdateSettings(context.Context, *Settings) (*Result, error)
	// Reset all settings to their defaults
	ResetSettings(context.Context, *Settings) (*Result, error)
	// Show settings
	ShowSettings(context.Context, *Settings) (*Settings, error)
}

func RegisterSettingsApiServer(s *grpc.Server, srv SettingsApiServer) {
	s.RegisterService(&_SettingsApi_serviceDesc, srv)
}

func _SettingsApi_UpdateSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Settings)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsApiServer).UpdateSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.SettingsApi/UpdateSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsApiServer).UpdateSettings(ctx, req.(*Settings))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettingsApi_ResetSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Settings)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsApiServer).ResetSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.SettingsApi/ResetSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsApiServer).ResetSettings(ctx, req.(*Settings))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettingsApi_ShowSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Settings)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsApiServer).ShowSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.SettingsApi/ShowSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsApiServer).ShowSettings(ctx, req.(*Settings))
	}
	return interceptor(ctx, in, info, handler)
}

var _SettingsApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.SettingsApi",
	HandlerType: (*SettingsApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateSettings",
			Handler:    _SettingsApi_UpdateSettings_Handler,
		},
		{
			MethodName: "ResetSettings",
			Handler:    _SettingsApi_ResetSettings_Handler,
		},
		{
			MethodName: "ShowSettings",
			Handler:    _SettingsApi_ShowSettings_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "settings.proto",
}

func (m *Settings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Settings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.ShepherdMetricsCollectionInterval != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.ShepherdMetricsCollectionInterval))
	}
	if m.ShepherdHealthCheckRetries != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.ShepherdHealthCheckRetries))
	}
	if m.ShepherdHealthCheckInterval != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.ShepherdHealthCheckInterval))
	}
	if m.AutoDeployIntervalSec != 0 {
		dAtA[i] = 0x29
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AutoDeployIntervalSec))))
		i += 8
	}
	if m.AutoDeployOffsetSec != 0 {
		dAtA[i] = 0x31
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AutoDeployOffsetSec))))
		i += 8
	}
	if m.AutoDeployMaxIntervals != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.AutoDeployMaxIntervals))
	}
	if m.CreateAppInstTimeout != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.CreateAppInstTimeout))
	}
	if m.UpdateAppInstTimeout != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.UpdateAppInstTimeout))
	}
	if m.DeleteAppInstTimeout != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.DeleteAppInstTimeout))
	}
	if m.CreateClusterInstTimeout != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.CreateClusterInstTimeout))
	}
	if m.UpdateClusterInstTimeout != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.UpdateClusterInstTimeout))
	}
	if m.DeleteClusterInstTimeout != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.DeleteClusterInstTimeout))
	}
	if len(m.MasterNodeFlavor) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintSettings(dAtA, i, uint64(len(m.MasterNodeFlavor)))
		i += copy(dAtA[i:], m.MasterNodeFlavor)
	}
	if m.LoadBalancerMaxPortRange != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.LoadBalancerMaxPortRange))
	}
	if m.MaxTrackedDmeClients != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.MaxTrackedDmeClients))
	}
	if m.ChefClientInterval != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.ChefClientInterval))
	}
	if m.InfluxDbMetricsRetention != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.InfluxDbMetricsRetention))
	}
	if m.CloudletMaintenanceTimeout != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.CloudletMaintenanceTimeout))
	}
	return i, nil
}

func encodeVarintSettings(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Settings) Matches(o *Settings, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.ShepherdMetricsCollectionInterval != 0 {
		if o.ShepherdMetricsCollectionInterval != m.ShepherdMetricsCollectionInterval {
			return false
		}
	}
	if !opts.Filter || o.ShepherdHealthCheckRetries != 0 {
		if o.ShepherdHealthCheckRetries != m.ShepherdHealthCheckRetries {
			return false
		}
	}
	if !opts.Filter || o.ShepherdHealthCheckInterval != 0 {
		if o.ShepherdHealthCheckInterval != m.ShepherdHealthCheckInterval {
			return false
		}
	}
	if !opts.Filter || o.AutoDeployIntervalSec != 0 {
		if o.AutoDeployIntervalSec != m.AutoDeployIntervalSec {
			return false
		}
	}
	if !opts.Filter || o.AutoDeployOffsetSec != 0 {
		if o.AutoDeployOffsetSec != m.AutoDeployOffsetSec {
			return false
		}
	}
	if !opts.Filter || o.AutoDeployMaxIntervals != 0 {
		if o.AutoDeployMaxIntervals != m.AutoDeployMaxIntervals {
			return false
		}
	}
	if !opts.Filter || o.CreateAppInstTimeout != 0 {
		if o.CreateAppInstTimeout != m.CreateAppInstTimeout {
			return false
		}
	}
	if !opts.Filter || o.UpdateAppInstTimeout != 0 {
		if o.UpdateAppInstTimeout != m.UpdateAppInstTimeout {
			return false
		}
	}
	if !opts.Filter || o.DeleteAppInstTimeout != 0 {
		if o.DeleteAppInstTimeout != m.DeleteAppInstTimeout {
			return false
		}
	}
	if !opts.Filter || o.CreateClusterInstTimeout != 0 {
		if o.CreateClusterInstTimeout != m.CreateClusterInstTimeout {
			return false
		}
	}
	if !opts.Filter || o.UpdateClusterInstTimeout != 0 {
		if o.UpdateClusterInstTimeout != m.UpdateClusterInstTimeout {
			return false
		}
	}
	if !opts.Filter || o.DeleteClusterInstTimeout != 0 {
		if o.DeleteClusterInstTimeout != m.DeleteClusterInstTimeout {
			return false
		}
	}
	if !opts.Filter || o.MasterNodeFlavor != "" {
		if o.MasterNodeFlavor != m.MasterNodeFlavor {
			return false
		}
	}
	if !opts.Filter || o.LoadBalancerMaxPortRange != 0 {
		if o.LoadBalancerMaxPortRange != m.LoadBalancerMaxPortRange {
			return false
		}
	}
	if !opts.Filter || o.MaxTrackedDmeClients != 0 {
		if o.MaxTrackedDmeClients != m.MaxTrackedDmeClients {
			return false
		}
	}
	if !opts.Filter || o.ChefClientInterval != 0 {
		if o.ChefClientInterval != m.ChefClientInterval {
			return false
		}
	}
	if !opts.Filter || o.InfluxDbMetricsRetention != 0 {
		if o.InfluxDbMetricsRetention != m.InfluxDbMetricsRetention {
			return false
		}
	}
	if !opts.Filter || o.CloudletMaintenanceTimeout != 0 {
		if o.CloudletMaintenanceTimeout != m.CloudletMaintenanceTimeout {
			return false
		}
	}
	return true
}

const SettingsFieldShepherdMetricsCollectionInterval = "2"
const SettingsFieldShepherdHealthCheckRetries = "3"
const SettingsFieldShepherdHealthCheckInterval = "4"
const SettingsFieldAutoDeployIntervalSec = "5"
const SettingsFieldAutoDeployOffsetSec = "6"
const SettingsFieldAutoDeployMaxIntervals = "7"
const SettingsFieldCreateAppInstTimeout = "8"
const SettingsFieldUpdateAppInstTimeout = "9"
const SettingsFieldDeleteAppInstTimeout = "10"
const SettingsFieldCreateClusterInstTimeout = "11"
const SettingsFieldUpdateClusterInstTimeout = "12"
const SettingsFieldDeleteClusterInstTimeout = "13"
const SettingsFieldMasterNodeFlavor = "14"
const SettingsFieldLoadBalancerMaxPortRange = "15"
const SettingsFieldMaxTrackedDmeClients = "16"
const SettingsFieldChefClientInterval = "17"
const SettingsFieldInfluxDbMetricsRetention = "18"
const SettingsFieldCloudletMaintenanceTimeout = "19"

var SettingsAllFields = []string{
	SettingsFieldShepherdMetricsCollectionInterval,
	SettingsFieldShepherdHealthCheckRetries,
	SettingsFieldShepherdHealthCheckInterval,
	SettingsFieldAutoDeployIntervalSec,
	SettingsFieldAutoDeployOffsetSec,
	SettingsFieldAutoDeployMaxIntervals,
	SettingsFieldCreateAppInstTimeout,
	SettingsFieldUpdateAppInstTimeout,
	SettingsFieldDeleteAppInstTimeout,
	SettingsFieldCreateClusterInstTimeout,
	SettingsFieldUpdateClusterInstTimeout,
	SettingsFieldDeleteClusterInstTimeout,
	SettingsFieldMasterNodeFlavor,
	SettingsFieldLoadBalancerMaxPortRange,
	SettingsFieldMaxTrackedDmeClients,
	SettingsFieldChefClientInterval,
	SettingsFieldInfluxDbMetricsRetention,
	SettingsFieldCloudletMaintenanceTimeout,
}

var SettingsAllFieldsMap = map[string]struct{}{
	SettingsFieldShepherdMetricsCollectionInterval: struct{}{},
	SettingsFieldShepherdHealthCheckRetries:        struct{}{},
	SettingsFieldShepherdHealthCheckInterval:       struct{}{},
	SettingsFieldAutoDeployIntervalSec:             struct{}{},
	SettingsFieldAutoDeployOffsetSec:               struct{}{},
	SettingsFieldAutoDeployMaxIntervals:            struct{}{},
	SettingsFieldCreateAppInstTimeout:              struct{}{},
	SettingsFieldUpdateAppInstTimeout:              struct{}{},
	SettingsFieldDeleteAppInstTimeout:              struct{}{},
	SettingsFieldCreateClusterInstTimeout:          struct{}{},
	SettingsFieldUpdateClusterInstTimeout:          struct{}{},
	SettingsFieldDeleteClusterInstTimeout:          struct{}{},
	SettingsFieldMasterNodeFlavor:                  struct{}{},
	SettingsFieldLoadBalancerMaxPortRange:          struct{}{},
	SettingsFieldMaxTrackedDmeClients:              struct{}{},
	SettingsFieldChefClientInterval:                struct{}{},
	SettingsFieldInfluxDbMetricsRetention:          struct{}{},
	SettingsFieldCloudletMaintenanceTimeout:        struct{}{},
}

var SettingsAllFieldsStringMap = map[string]string{
	SettingsFieldShepherdMetricsCollectionInterval: "Shepherd Metrics Collection Interval",
	SettingsFieldShepherdHealthCheckRetries:        "Shepherd Health Check Retries",
	SettingsFieldShepherdHealthCheckInterval:       "Shepherd Health Check Interval",
	SettingsFieldAutoDeployIntervalSec:             "Auto Deploy Interval Sec",
	SettingsFieldAutoDeployOffsetSec:               "Auto Deploy Offset Sec",
	SettingsFieldAutoDeployMaxIntervals:            "Auto Deploy Max Intervals",
	SettingsFieldCreateAppInstTimeout:              "Create App Inst Timeout",
	SettingsFieldUpdateAppInstTimeout:              "Update App Inst Timeout",
	SettingsFieldDeleteAppInstTimeout:              "Delete App Inst Timeout",
	SettingsFieldCreateClusterInstTimeout:          "Create Cluster Inst Timeout",
	SettingsFieldUpdateClusterInstTimeout:          "Update Cluster Inst Timeout",
	SettingsFieldDeleteClusterInstTimeout:          "Delete Cluster Inst Timeout",
	SettingsFieldMasterNodeFlavor:                  "Master Node Flavor",
	SettingsFieldLoadBalancerMaxPortRange:          "Load Balancer Max Port Range",
	SettingsFieldMaxTrackedDmeClients:              "Max Tracked Dme Clients",
	SettingsFieldChefClientInterval:                "Chef Client Interval",
	SettingsFieldInfluxDbMetricsRetention:          "Influx Db Metrics Retention",
	SettingsFieldCloudletMaintenanceTimeout:        "Cloudlet Maintenance Timeout",
}

func (m *Settings) IsKeyField(s string) bool {
	return strings.HasPrefix(s, SettingsFieldShepherdMetricsCollectionInterval+".") || s == SettingsFieldShepherdMetricsCollectionInterval
}

func (m *Settings) DiffFields(o *Settings, fields map[string]struct{}) {
	if m.ShepherdMetricsCollectionInterval != o.ShepherdMetricsCollectionInterval {
		fields[SettingsFieldShepherdMetricsCollectionInterval] = struct{}{}
	}
	if m.ShepherdHealthCheckRetries != o.ShepherdHealthCheckRetries {
		fields[SettingsFieldShepherdHealthCheckRetries] = struct{}{}
	}
	if m.ShepherdHealthCheckInterval != o.ShepherdHealthCheckInterval {
		fields[SettingsFieldShepherdHealthCheckInterval] = struct{}{}
	}
	if m.AutoDeployIntervalSec != o.AutoDeployIntervalSec {
		fields[SettingsFieldAutoDeployIntervalSec] = struct{}{}
	}
	if m.AutoDeployOffsetSec != o.AutoDeployOffsetSec {
		fields[SettingsFieldAutoDeployOffsetSec] = struct{}{}
	}
	if m.AutoDeployMaxIntervals != o.AutoDeployMaxIntervals {
		fields[SettingsFieldAutoDeployMaxIntervals] = struct{}{}
	}
	if m.CreateAppInstTimeout != o.CreateAppInstTimeout {
		fields[SettingsFieldCreateAppInstTimeout] = struct{}{}
	}
	if m.UpdateAppInstTimeout != o.UpdateAppInstTimeout {
		fields[SettingsFieldUpdateAppInstTimeout] = struct{}{}
	}
	if m.DeleteAppInstTimeout != o.DeleteAppInstTimeout {
		fields[SettingsFieldDeleteAppInstTimeout] = struct{}{}
	}
	if m.CreateClusterInstTimeout != o.CreateClusterInstTimeout {
		fields[SettingsFieldCreateClusterInstTimeout] = struct{}{}
	}
	if m.UpdateClusterInstTimeout != o.UpdateClusterInstTimeout {
		fields[SettingsFieldUpdateClusterInstTimeout] = struct{}{}
	}
	if m.DeleteClusterInstTimeout != o.DeleteClusterInstTimeout {
		fields[SettingsFieldDeleteClusterInstTimeout] = struct{}{}
	}
	if m.MasterNodeFlavor != o.MasterNodeFlavor {
		fields[SettingsFieldMasterNodeFlavor] = struct{}{}
	}
	if m.LoadBalancerMaxPortRange != o.LoadBalancerMaxPortRange {
		fields[SettingsFieldLoadBalancerMaxPortRange] = struct{}{}
	}
	if m.MaxTrackedDmeClients != o.MaxTrackedDmeClients {
		fields[SettingsFieldMaxTrackedDmeClients] = struct{}{}
	}
	if m.ChefClientInterval != o.ChefClientInterval {
		fields[SettingsFieldChefClientInterval] = struct{}{}
	}
	if m.InfluxDbMetricsRetention != o.InfluxDbMetricsRetention {
		fields[SettingsFieldInfluxDbMetricsRetention] = struct{}{}
	}
	if m.CloudletMaintenanceTimeout != o.CloudletMaintenanceTimeout {
		fields[SettingsFieldCloudletMaintenanceTimeout] = struct{}{}
	}
}

var UpdateSettingsFieldsMap = map[string]struct{}{
	SettingsFieldShepherdMetricsCollectionInterval: struct{}{},
	SettingsFieldShepherdHealthCheckRetries:        struct{}{},
	SettingsFieldShepherdHealthCheckInterval:       struct{}{},
	SettingsFieldAutoDeployIntervalSec:             struct{}{},
	SettingsFieldAutoDeployOffsetSec:               struct{}{},
	SettingsFieldAutoDeployMaxIntervals:            struct{}{},
	SettingsFieldCreateAppInstTimeout:              struct{}{},
	SettingsFieldUpdateAppInstTimeout:              struct{}{},
	SettingsFieldDeleteAppInstTimeout:              struct{}{},
	SettingsFieldCreateClusterInstTimeout:          struct{}{},
	SettingsFieldUpdateClusterInstTimeout:          struct{}{},
	SettingsFieldDeleteClusterInstTimeout:          struct{}{},
	SettingsFieldMasterNodeFlavor:                  struct{}{},
	SettingsFieldLoadBalancerMaxPortRange:          struct{}{},
	SettingsFieldMaxTrackedDmeClients:              struct{}{},
	SettingsFieldChefClientInterval:                struct{}{},
	SettingsFieldInfluxDbMetricsRetention:          struct{}{},
	SettingsFieldCloudletMaintenanceTimeout:        struct{}{},
}

func (m *Settings) ValidateUpdateFields() error {
	if m.Fields == nil {
		return fmt.Errorf("nothing specified to update")
	}
	fmap := MakeFieldMap(m.Fields)
	badFieldStrs := []string{}
	for field, _ := range fmap {
		if m.IsKeyField(field) {
			continue
		}
		if _, ok := UpdateSettingsFieldsMap[field]; !ok {
			if _, ok := SettingsAllFieldsStringMap[field]; !ok {
				continue
			}
			badFieldStrs = append(badFieldStrs, SettingsAllFieldsStringMap[field])
		}
	}
	if len(badFieldStrs) > 0 {
		return fmt.Errorf("specified field(s) %s cannot be modified", strings.Join(badFieldStrs, ","))
	}
	return nil
}

func (m *Settings) CopyInFields(src *Settings) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if m.ShepherdMetricsCollectionInterval != src.ShepherdMetricsCollectionInterval {
			m.ShepherdMetricsCollectionInterval = src.ShepherdMetricsCollectionInterval
			changed++
		}
	}
	if _, set := fmap["3"]; set {
		if m.ShepherdHealthCheckRetries != src.ShepherdHealthCheckRetries {
			m.ShepherdHealthCheckRetries = src.ShepherdHealthCheckRetries
			changed++
		}
	}
	if _, set := fmap["4"]; set {
		if m.ShepherdHealthCheckInterval != src.ShepherdHealthCheckInterval {
			m.ShepherdHealthCheckInterval = src.ShepherdHealthCheckInterval
			changed++
		}
	}
	if _, set := fmap["5"]; set {
		if m.AutoDeployIntervalSec != src.AutoDeployIntervalSec {
			m.AutoDeployIntervalSec = src.AutoDeployIntervalSec
			changed++
		}
	}
	if _, set := fmap["6"]; set {
		if m.AutoDeployOffsetSec != src.AutoDeployOffsetSec {
			m.AutoDeployOffsetSec = src.AutoDeployOffsetSec
			changed++
		}
	}
	if _, set := fmap["7"]; set {
		if m.AutoDeployMaxIntervals != src.AutoDeployMaxIntervals {
			m.AutoDeployMaxIntervals = src.AutoDeployMaxIntervals
			changed++
		}
	}
	if _, set := fmap["8"]; set {
		if m.CreateAppInstTimeout != src.CreateAppInstTimeout {
			m.CreateAppInstTimeout = src.CreateAppInstTimeout
			changed++
		}
	}
	if _, set := fmap["9"]; set {
		if m.UpdateAppInstTimeout != src.UpdateAppInstTimeout {
			m.UpdateAppInstTimeout = src.UpdateAppInstTimeout
			changed++
		}
	}
	if _, set := fmap["10"]; set {
		if m.DeleteAppInstTimeout != src.DeleteAppInstTimeout {
			m.DeleteAppInstTimeout = src.DeleteAppInstTimeout
			changed++
		}
	}
	if _, set := fmap["11"]; set {
		if m.CreateClusterInstTimeout != src.CreateClusterInstTimeout {
			m.CreateClusterInstTimeout = src.CreateClusterInstTimeout
			changed++
		}
	}
	if _, set := fmap["12"]; set {
		if m.UpdateClusterInstTimeout != src.UpdateClusterInstTimeout {
			m.UpdateClusterInstTimeout = src.UpdateClusterInstTimeout
			changed++
		}
	}
	if _, set := fmap["13"]; set {
		if m.DeleteClusterInstTimeout != src.DeleteClusterInstTimeout {
			m.DeleteClusterInstTimeout = src.DeleteClusterInstTimeout
			changed++
		}
	}
	if _, set := fmap["14"]; set {
		if m.MasterNodeFlavor != src.MasterNodeFlavor {
			m.MasterNodeFlavor = src.MasterNodeFlavor
			changed++
		}
	}
	if _, set := fmap["15"]; set {
		if m.LoadBalancerMaxPortRange != src.LoadBalancerMaxPortRange {
			m.LoadBalancerMaxPortRange = src.LoadBalancerMaxPortRange
			changed++
		}
	}
	if _, set := fmap["16"]; set {
		if m.MaxTrackedDmeClients != src.MaxTrackedDmeClients {
			m.MaxTrackedDmeClients = src.MaxTrackedDmeClients
			changed++
		}
	}
	if _, set := fmap["17"]; set {
		if m.ChefClientInterval != src.ChefClientInterval {
			m.ChefClientInterval = src.ChefClientInterval
			changed++
		}
	}
	if _, set := fmap["18"]; set {
		if m.InfluxDbMetricsRetention != src.InfluxDbMetricsRetention {
			m.InfluxDbMetricsRetention = src.InfluxDbMetricsRetention
			changed++
		}
	}
	if _, set := fmap["19"]; set {
		if m.CloudletMaintenanceTimeout != src.CloudletMaintenanceTimeout {
			m.CloudletMaintenanceTimeout = src.CloudletMaintenanceTimeout
			changed++
		}
	}
	return changed
}

func (m *Settings) DeepCopyIn(src *Settings) {
	m.ShepherdMetricsCollectionInterval = src.ShepherdMetricsCollectionInterval
	m.ShepherdHealthCheckRetries = src.ShepherdHealthCheckRetries
	m.ShepherdHealthCheckInterval = src.ShepherdHealthCheckInterval
	m.AutoDeployIntervalSec = src.AutoDeployIntervalSec
	m.AutoDeployOffsetSec = src.AutoDeployOffsetSec
	m.AutoDeployMaxIntervals = src.AutoDeployMaxIntervals
	m.CreateAppInstTimeout = src.CreateAppInstTimeout
	m.UpdateAppInstTimeout = src.UpdateAppInstTimeout
	m.DeleteAppInstTimeout = src.DeleteAppInstTimeout
	m.CreateClusterInstTimeout = src.CreateClusterInstTimeout
	m.UpdateClusterInstTimeout = src.UpdateClusterInstTimeout
	m.DeleteClusterInstTimeout = src.DeleteClusterInstTimeout
	m.MasterNodeFlavor = src.MasterNodeFlavor
	m.LoadBalancerMaxPortRange = src.LoadBalancerMaxPortRange
	m.MaxTrackedDmeClients = src.MaxTrackedDmeClients
	m.ChefClientInterval = src.ChefClientInterval
	m.InfluxDbMetricsRetention = src.InfluxDbMetricsRetention
	m.CloudletMaintenanceTimeout = src.CloudletMaintenanceTimeout
}

func (s *Settings) HasFields() bool {
	return true
}

type SettingsStore struct {
	kvstore objstore.KVStore
}

func NewSettingsStore(kvstore objstore.KVStore) SettingsStore {
	return SettingsStore{kvstore: kvstore}
}

func (s *SettingsStore) Create(ctx context.Context, m *Settings, wait func(int64)) (*Result, error) {
	err := m.Validate(SettingsAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Settings", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *SettingsStore) Update(ctx context.Context, m *Settings, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Settings", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur Settings
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *SettingsStore) Put(ctx context.Context, m *Settings, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(SettingsAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Settings", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *SettingsStore) Delete(ctx context.Context, m *Settings, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Settings", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *SettingsStore) LoadOne(key string) (*Settings, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj Settings
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse Settings data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *SettingsStore) STMGet(stm concurrency.STM, key *SettingsKey, buf *Settings) bool {
	keystr := objstore.DbKeyString("Settings", key)
	valstr := stm.Get(keystr)
	if valstr == "" {
		return false
	}
	if buf != nil {
		err := json.Unmarshal([]byte(valstr), buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *SettingsStore) STMPut(stm concurrency.STM, obj *Settings, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("Settings", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("Settings json marsahal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *SettingsStore) STMDel(stm concurrency.STM, key *SettingsKey) {
	keystr := objstore.DbKeyString("Settings", key)
	stm.Del(keystr)
}

type SettingsKeyWatcher struct {
	cb func(ctx context.Context)
}

type SettingsCacheData struct {
	Obj    *Settings
	ModRev int64
}

// SettingsCache caches Settings objects in memory in a hash table
// and keeps them in sync with the database.
type SettingsCache struct {
	Objs          map[SettingsKey]*SettingsCacheData
	Mux           util.Mutex
	List          map[SettingsKey]struct{}
	FlushAll      bool
	NotifyCb      func(ctx context.Context, obj *SettingsKey, old *Settings, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *Settings, new *Settings)
	DeletedCbs    []func(ctx context.Context, old *Settings)
	KeyWatchers   map[SettingsKey][]*SettingsKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *SettingsKey)
	DeletedKeyCbs []func(ctx context.Context, key *SettingsKey)
}

func NewSettingsCache() *SettingsCache {
	cache := SettingsCache{}
	InitSettingsCache(&cache)
	return &cache
}

func InitSettingsCache(cache *SettingsCache) {
	cache.Objs = make(map[SettingsKey]*SettingsCacheData)
	cache.KeyWatchers = make(map[SettingsKey][]*SettingsKeyWatcher)
	cache.NotifyCb = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *SettingsCache) GetTypeString() string {
	return "Settings"
}

func (c *SettingsCache) Get(key *SettingsKey, valbuf *Settings) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *SettingsCache) GetWithRev(key *SettingsKey, valbuf *Settings, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *SettingsCache) HasKey(key *SettingsKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *SettingsCache) GetAllKeys(ctx context.Context, cb func(key *SettingsKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *SettingsCache) Update(ctx context.Context, in *Settings, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *Settings) (*Settings, bool) {
		return in, true
	})
}

func (c *SettingsCache) UpdateModFunc(ctx context.Context, key *SettingsKey, modRev int64, modFunc func(old *Settings) (new *Settings, changed bool)) {
	c.Mux.Lock()
	var old *Settings
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	for _, cb := range c.UpdatedCbs {
		newCopy := &Settings{}
		newCopy.DeepCopyIn(new)
		defer cb(ctx, old, newCopy)
	}
	if c.NotifyCb != nil {
		defer c.NotifyCb(ctx, new.GetKey(), old, modRev)
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &Settings{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &SettingsCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *SettingsCache) Delete(ctx context.Context, in *Settings, modRev int64) {
	c.Mux.Lock()
	var old *Settings
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	c.Mux.Unlock()
	if c.NotifyCb != nil {
		c.NotifyCb(ctx, in.GetKey(), old, modRev)
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *SettingsCache) Prune(ctx context.Context, validKeys map[SettingsKey]struct{}) {
	notify := make(map[SettingsKey]*SettingsCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if c.NotifyCb != nil || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		if c.NotifyCb != nil {
			c.NotifyCb(ctx, &key, old.Obj, old.ModRev)
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *SettingsCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *SettingsCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *SettingsCache) Show(filter *Settings, cb func(ret *Settings) error) error {
	log.DebugLog(log.DebugLevelApi, "Show Settings", "count", len(c.Objs))
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		log.DebugLog(log.DebugLevelApi, "Compare Settings", "filter", filter, "data", data)
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		log.DebugLog(log.DebugLevelApi, "Show Settings", "obj", data.Obj)
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func SettingsGenericNotifyCb(fn func(key *SettingsKey, old *Settings)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*SettingsKey), obj.(*Settings))
	}
}

func (c *SettingsCache) SetNotifyCb(fn func(ctx context.Context, obj *SettingsKey, old *Settings, modRev int64)) {
	c.NotifyCb = fn
}

func (c *SettingsCache) SetUpdatedCb(fn func(ctx context.Context, old *Settings, new *Settings)) {
	c.UpdatedCbs = []func(ctx context.Context, old *Settings, new *Settings){fn}
}

func (c *SettingsCache) SetDeletedCb(fn func(ctx context.Context, old *Settings)) {
	c.DeletedCbs = []func(ctx context.Context, old *Settings){fn}
}

func (c *SettingsCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *SettingsKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *SettingsKey){fn}
}

func (c *SettingsCache) SetDeletedKeyCb(fn func(ctx context.Context, key *SettingsKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *SettingsKey){fn}
}

func (c *SettingsCache) AddUpdatedCb(fn func(ctx context.Context, old *Settings, new *Settings)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *SettingsCache) AddDeletedCb(fn func(ctx context.Context, old *Settings)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *SettingsCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *SettingsKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *SettingsCache) AddDeletedKeyCb(fn func(ctx context.Context, key *SettingsKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *SettingsCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *SettingsCache) WatchKey(key *SettingsKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*SettingsKeyWatcher, 0)
	}
	watcher := SettingsKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching Settings", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *SettingsCache) TriggerKeyWatchers(ctx context.Context, key *SettingsKey) {
	watchers := make([]*SettingsKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *SettingsCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := Settings{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse Settings data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *SettingsCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := Settings{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	SettingsKeyStringParse(keystr, &obj)
	c.Delete(ctx, &obj, modRev)
}

func (c *SettingsCache) SyncListStart(ctx context.Context) {
	c.List = make(map[SettingsKey]struct{})
}

func (c *SettingsCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[SettingsKey]*SettingsCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		if c.NotifyCb != nil {
			c.NotifyCb(ctx, &key, val.Obj, val.ModRev)
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *SettingsCache) UsesOrg(org string) bool {
	return false
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *Settings) ValidateEnums() error {
	return nil
}

func (m *Settings) Size() (n int) {
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovSettings(uint64(l))
		}
	}
	if m.ShepherdMetricsCollectionInterval != 0 {
		n += 1 + sovSettings(uint64(m.ShepherdMetricsCollectionInterval))
	}
	if m.ShepherdHealthCheckRetries != 0 {
		n += 1 + sovSettings(uint64(m.ShepherdHealthCheckRetries))
	}
	if m.ShepherdHealthCheckInterval != 0 {
		n += 1 + sovSettings(uint64(m.ShepherdHealthCheckInterval))
	}
	if m.AutoDeployIntervalSec != 0 {
		n += 9
	}
	if m.AutoDeployOffsetSec != 0 {
		n += 9
	}
	if m.AutoDeployMaxIntervals != 0 {
		n += 1 + sovSettings(uint64(m.AutoDeployMaxIntervals))
	}
	if m.CreateAppInstTimeout != 0 {
		n += 1 + sovSettings(uint64(m.CreateAppInstTimeout))
	}
	if m.UpdateAppInstTimeout != 0 {
		n += 1 + sovSettings(uint64(m.UpdateAppInstTimeout))
	}
	if m.DeleteAppInstTimeout != 0 {
		n += 1 + sovSettings(uint64(m.DeleteAppInstTimeout))
	}
	if m.CreateClusterInstTimeout != 0 {
		n += 1 + sovSettings(uint64(m.CreateClusterInstTimeout))
	}
	if m.UpdateClusterInstTimeout != 0 {
		n += 1 + sovSettings(uint64(m.UpdateClusterInstTimeout))
	}
	if m.DeleteClusterInstTimeout != 0 {
		n += 1 + sovSettings(uint64(m.DeleteClusterInstTimeout))
	}
	l = len(m.MasterNodeFlavor)
	if l > 0 {
		n += 1 + l + sovSettings(uint64(l))
	}
	if m.LoadBalancerMaxPortRange != 0 {
		n += 1 + sovSettings(uint64(m.LoadBalancerMaxPortRange))
	}
	if m.MaxTrackedDmeClients != 0 {
		n += 2 + sovSettings(uint64(m.MaxTrackedDmeClients))
	}
	if m.ChefClientInterval != 0 {
		n += 2 + sovSettings(uint64(m.ChefClientInterval))
	}
	if m.InfluxDbMetricsRetention != 0 {
		n += 2 + sovSettings(uint64(m.InfluxDbMetricsRetention))
	}
	if m.CloudletMaintenanceTimeout != 0 {
		n += 2 + sovSettings(uint64(m.CloudletMaintenanceTimeout))
	}
	return n
}

func sovSettings(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSettings(x uint64) (n int) {
	return sovSettings(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Settings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSettings
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Settings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Settings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettings
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShepherdMetricsCollectionInterval", wireType)
			}
			m.ShepherdMetricsCollectionInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShepherdMetricsCollectionInterval |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShepherdHealthCheckRetries", wireType)
			}
			m.ShepherdHealthCheckRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShepherdHealthCheckRetries |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShepherdHealthCheckInterval", wireType)
			}
			m.ShepherdHealthCheckInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShepherdHealthCheckInterval |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeployIntervalSec", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AutoDeployIntervalSec = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeployOffsetSec", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AutoDeployOffsetSec = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeployMaxIntervals", wireType)
			}
			m.AutoDeployMaxIntervals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoDeployMaxIntervals |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAppInstTimeout", wireType)
			}
			m.CreateAppInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAppInstTimeout |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAppInstTimeout", wireType)
			}
			m.UpdateAppInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAppInstTimeout |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteAppInstTimeout", wireType)
			}
			m.DeleteAppInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteAppInstTimeout |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateClusterInstTimeout", wireType)
			}
			m.CreateClusterInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateClusterInstTimeout |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateClusterInstTimeout", wireType)
			}
			m.UpdateClusterInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateClusterInstTimeout |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteClusterInstTimeout", wireType)
			}
			m.DeleteClusterInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteClusterInstTimeout |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterNodeFlavor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettings
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MasterNodeFlavor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerMaxPortRange", wireType)
			}
			m.LoadBalancerMaxPortRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoadBalancerMaxPortRange |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTrackedDmeClients", wireType)
			}
			m.MaxTrackedDmeClients = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTrackedDmeClients |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChefClientInterval", wireType)
			}
			m.ChefClientInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChefClientInterval |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfluxDbMetricsRetention", wireType)
			}
			m.InfluxDbMetricsRetention = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InfluxDbMetricsRetention |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletMaintenanceTimeout", wireType)
			}
			m.CloudletMaintenanceTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloudletMaintenanceTimeout |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSettings(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSettings
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSettings(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSettings
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSettings
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSettings
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSettings(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSettings = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSettings   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("settings.proto", fileDescriptorSettings) }

var fileDescriptorSettings = []byte{
	// 853 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x95, 0xdf, 0x6e, 0xdc, 0x44,
	0x14, 0xc6, 0x71, 0xd2, 0x86, 0x64, 0x9a, 0xa4, 0xa9, 0xb3, 0x4d, 0x87, 0x4d, 0x58, 0x96, 0x15,
	0x17, 0x2b, 0x08, 0xb1, 0x44, 0x85, 0x0a, 0x41, 0xaa, 0x94, 0x6c, 0x84, 0xa8, 0xa2, 0x2d, 0xe0,
	0x14, 0xee, 0x90, 0x35, 0x6b, 0x9f, 0xb5, 0xad, 0x8e, 0x67, 0xcc, 0xcc, 0xb8, 0xd9, 0xde, 0x21,
	0x9e, 0x00, 0x89, 0x67, 0xe0, 0x05, 0x78, 0x8a, 0x5e, 0x22, 0x71, 0x8f, 0x20, 0xe2, 0x02, 0x55,
	0x5c, 0x20, 0x9a, 0x22, 0xc4, 0x15, 0x9a, 0x19, 0xdb, 0xf9, 0xc3, 0x08, 0xc1, 0xcd, 0x6a, 0xf6,
	0x9c, 0xef, 0xf7, 0x9d, 0x73, 0xbc, 0x9e, 0xb3, 0x68, 0x55, 0x82, 0x52, 0x39, 0x4b, 0xe5, 0x4e,
	0x29, 0xb8, 0xe2, 0xfe, 0x12, 0x24, 0x29, 0x98, 0x63, 0x77, 0x59, 0x80, 0xac, 0xa8, 0xb2, 0x89,
	0xee, 0x56, 0xca, 0x79, 0x4a, 0x21, 0x20, 0x65, 0x1e, 0x10, 0xc6, 0xb8, 0x22, 0x2a, 0xe7, 0xac,
	0xc6, 0xba, 0xef, 0xa4, 0xb9, 0xca, 0xaa, 0xc9, 0x4e, 0xcc, 0x8b, 0xa0, 0xe0, 0x93, 0x9c, 0x6a,
	0x9b, 0x59, 0xa0, 0x3f, 0xdf, 0x8c, 0x29, 0xaf, 0x92, 0xc0, 0xe8, 0x52, 0x60, 0xed, 0xa1, 0x26,
	0x3b, 0x29, 0x4f, 0xb9, 0x39, 0x06, 0xfa, 0x64, 0xa3, 0x83, 0x6f, 0x10, 0x5a, 0x3c, 0xaa, 0x3b,
	0xf3, 0x37, 0xd0, 0xc2, 0x34, 0x07, 0x9a, 0x48, 0xec, 0xf5, 0xe7, 0x87, 0x4b, 0x61, 0xfd, 0xcd,
	0xff, 0x0c, 0xbd, 0x26, 0x33, 0x28, 0x33, 0x10, 0x49, 0x54, 0x80, 0x12, 0x79, 0x2c, 0xa3, 0x98,
	0x53, 0x0a, 0xb1, 0x6e, 0x2d, 0xca, 0x99, 0x02, 0xf1, 0x88, 0x50, 0x3c, 0xd7, 0xf7, 0x86, 0xf3,
	0xfb, 0xcb, 0x7f, 0xfd, 0xf0, 0xca, 0xe2, 0x41, 0x25, 0x4c, 0xdf, 0xe1, 0xab, 0x0d, 0x39, 0xb6,
	0xe0, 0xa8, 0xe5, 0xee, 0xd5, 0x98, 0xbf, 0x87, 0x5e, 0x6e, 0xed, 0x33, 0x20, 0x54, 0x65, 0x51,
	0x9c, 0x41, 0xfc, 0x30, 0x12, 0x1a, 0x01, 0x89, 0xe7, 0xfb, 0xde, 0xf0, 0x6a, 0xd8, 0x6d, 0x44,
	0x1f, 0x18, 0xcd, 0x48, 0x4b, 0x42, 0xab, 0xf0, 0x3f, 0x46, 0x3d, 0xb7, 0x45, 0xdb, 0xdb, 0x15,
	0x47, 0x6f, 0x9b, 0x0e, 0xc7, 0xb6, 0xab, 0x3b, 0x08, 0x93, 0x4a, 0xf1, 0x28, 0x81, 0x92, 0xf2,
	0xc7, 0xad, 0x51, 0x24, 0x21, 0xc6, 0x57, 0xfb, 0xde, 0xd0, 0x0b, 0x6f, 0xea, 0xfc, 0x81, 0x49,
	0x37, 0xd4, 0x11, 0xc4, 0xfe, 0x6d, 0xb4, 0x71, 0x1e, 0xe4, 0xd3, 0xa9, 0x04, 0x65, 0xb0, 0x05,
	0x83, 0xad, 0x9f, 0x61, 0x1f, 0x9a, 0x9c, 0x86, 0xde, 0x45, 0x2f, 0x9d, 0x87, 0x0a, 0x32, 0x6b,
	0x2b, 0x4a, 0xfc, 0x62, 0xdf, 0x1b, 0xae, 0x84, 0x1b, 0x67, 0xdc, 0x98, 0xcc, 0x9a, 0x8a, 0xd2,
	0x1f, 0xa1, 0x5b, 0xb1, 0x00, 0xa2, 0x20, 0x22, 0x65, 0x19, 0xe5, 0x4c, 0xaa, 0x48, 0xe5, 0x05,
	0xf0, 0x4a, 0xe1, 0x45, 0xc7, 0xd0, 0x1d, 0x2b, 0xde, 0x2b, 0xcb, 0x7b, 0x4c, 0xaa, 0x07, 0x56,
	0xa9, 0x4d, 0xaa, 0x32, 0x71, 0x9a, 0x2c, 0xb9, 0x4c, 0xac, 0xf8, 0x9f, 0x26, 0x09, 0x50, 0x70,
	0x99, 0x20, 0x97, 0x89, 0x15, 0x5f, 0x32, 0x39, 0x44, 0x9b, 0xf5, 0x38, 0x31, 0xad, 0xa4, 0x02,
	0x71, 0xd1, 0xe8, 0x9a, 0xc3, 0x08, 0x5b, 0x60, 0x64, 0xf5, 0x97, 0xcc, 0xea, 0xb1, 0x9c, 0x66,
	0xcb, 0x2e, 0x33, 0x0b, 0xb8, 0xcd, 0xea, 0xf1, 0x9c, 0x66, 0x2b, 0x2e, 0x33, 0x0b, 0x38, 0xcc,
	0xb6, 0x91, 0x5f, 0x10, 0x63, 0xc2, 0x78, 0x02, 0xd1, 0x94, 0x92, 0x47, 0x5c, 0xe0, 0xd5, 0xbe,
	0x37, 0x5c, 0x0a, 0xd7, 0x6c, 0xe6, 0x3e, 0x4f, 0xe0, 0x7d, 0x13, 0xf7, 0xef, 0xa2, 0x2d, 0xca,
	0x49, 0x12, 0x4d, 0x08, 0x25, 0x2c, 0x06, 0x61, 0x5e, 0x90, 0x92, 0x0b, 0x15, 0x09, 0xc2, 0x52,
	0xc0, 0xd7, 0xcd, 0x0d, 0xc1, 0x5a, 0xb3, 0x5f, 0x4b, 0xc6, 0x64, 0xf6, 0x11, 0x17, 0x2a, 0xd4,
	0x79, 0xff, 0x6d, 0x74, 0x4b, 0x13, 0x4a, 0x90, 0xf8, 0x21, 0x24, 0x51, 0x52, 0xe8, 0x19, 0x72,
	0x60, 0x4a, 0xe2, 0x35, 0x83, 0x76, 0x0a, 0x32, 0x7b, 0x60, 0xb3, 0x07, 0x05, 0x8c, 0x6c, 0xce,
	0xbf, 0x8b, 0x3a, 0x71, 0x06, 0xd3, 0x5a, 0x7b, 0x76, 0x99, 0x6e, 0x68, 0xe6, 0xd2, 0xa8, 0xbe,
	0x56, 0x5a, 0xb0, 0xbd, 0x43, 0x87, 0x68, 0x33, 0x67, 0x53, 0x5a, 0xcd, 0xa2, 0x64, 0xd2, 0x6e,
	0x0e, 0x01, 0x0a, 0x98, 0x46, 0xb0, 0xef, 0x7a, 0x62, 0x16, 0x38, 0x98, 0xd4, 0xfb, 0x22, 0x6c,
	0xd4, 0xfe, 0x7d, 0xb4, 0x65, 0x36, 0x1c, 0x05, 0x15, 0x15, 0x44, 0xf7, 0xc2, 0xf4, 0xa0, 0xed,
	0xf3, 0x5f, 0x77, 0x34, 0xd5, 0x6d, 0x88, 0xf1, 0x19, 0x50, 0xff, 0x02, 0xbb, 0x6f, 0xfc, 0xf2,
	0x0c, 0x7b, 0xbf, 0x3d, 0xc3, 0xde, 0x17, 0xa7, 0xd8, 0xfb, 0xea, 0x14, 0x7b, 0xbf, 0x3f, 0xc7,
	0xd7, 0x9a, 0x5d, 0x78, 0x08, 0x8f, 0xff, 0x7c, 0x8e, 0xbd, 0x6f, 0xff, 0xc0, 0x57, 0x18, 0x67,
	0xf0, 0xd6, 0xaf, 0x73, 0xa8, 0xcd, 0xed, 0x95, 0xb9, 0x5f, 0xa1, 0xd5, 0x4f, 0xcc, 0x7b, 0xd2,
	0x2e, 0xcf, 0xf5, 0x9d, 0x76, 0xa3, 0xef, 0x34, 0xc1, 0xee, 0x8d, 0x73, 0xc1, 0xd0, 0x6c, 0xf9,
	0xc1, 0x7b, 0x4f, 0x4f, 0xf1, 0x56, 0x08, 0x92, 0x57, 0x22, 0x86, 0x11, 0x67, 0xd3, 0x3c, 0xdd,
	0xde, 0x33, 0x0b, 0x71, 0x4c, 0x18, 0x49, 0x61, 0xfb, 0xcb, 0xef, 0x7f, 0xfe, 0x7a, 0xee, 0xe6,
	0x60, 0x2d, 0xb0, 0x2f, 0x62, 0xd0, 0xfc, 0x71, 0xec, 0x7a, 0xaf, 0xfb, 0x12, 0xad, 0x84, 0x60,
	0x56, 0xc6, 0xff, 0xac, 0xba, 0xfb, 0x9f, 0xaa, 0x76, 0x06, 0xd7, 0x03, 0xa1, 0xfd, 0x2f, 0x14,
	0xfd, 0x1c, 0x2d, 0x1f, 0x65, 0xfc, 0xf8, 0xdf, 0x6b, 0xba, 0x82, 0x83, 0x3b, 0x4f, 0x4f, 0x71,
	0xd7, 0x59, 0xf5, 0xd3, 0x1c, 0x8e, 0x6d, 0xcd, 0xf5, 0xc1, 0x6a, 0x20, 0x33, 0x7e, 0x7c, 0xbe,
	0xe4, 0xfe, 0xda, 0x93, 0x9f, 0x7a, 0x2f, 0x3c, 0x39, 0xe9, 0x79, 0xdf, 0x9d, 0xf4, 0xbc, 0x1f,
	0x4f, 0x7a, 0xde, 0x64, 0xc1, 0x58, 0xdf, 0xfe, 0x3b, 0x00, 0x00, 0xff, 0xff, 0x7f, 0x90, 0x66,
	0xcd, 0x48, 0x07, 0x00, 0x00,
}
