// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: settings.proto

package edgeproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/mobiledgex/edge-cloud/protogen"
import _ "github.com/gogo/protobuf/gogoproto"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import binary "encoding/binary"

import "encoding/json"
import "github.com/mobiledgex/edge-cloud/objstore"
import "github.com/coreos/etcd/clientv3/concurrency"
import "github.com/mobiledgex/edge-cloud/util"
import "github.com/mobiledgex/edge-cloud/log"
import strings "strings"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Global settings
type Settings struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty"`
	// Shepherd metrics collection interval for k8s and docker appInstances (duration)
	ShepherdMetricsCollectionInterval Duration `protobuf:"varint,2,opt,name=shepherd_metrics_collection_interval,json=shepherdMetricsCollectionInterval,proto3,casttype=Duration" json:"shepherd_metrics_collection_interval,omitempty"`
	// Number of times Shepherd Health Check fails before we mark appInst down
	ShepherdHealthCheckRetries int32 `protobuf:"varint,3,opt,name=shepherd_health_check_retries,json=shepherdHealthCheckRetries,proto3" json:"shepherd_health_check_retries,omitempty"`
	// Health Checking probing frequency (duration)
	ShepherdHealthCheckInterval Duration `protobuf:"varint,4,opt,name=shepherd_health_check_interval,json=shepherdHealthCheckInterval,proto3,casttype=Duration" json:"shepherd_health_check_interval,omitempty"`
	// Auto Provisioning Stats push and analysis interval (seconds)
	AutoDeployIntervalSec float64 `protobuf:"fixed64,5,opt,name=auto_deploy_interval_sec,json=autoDeployIntervalSec,proto3" json:"auto_deploy_interval_sec,omitempty"`
	// Auto Provisioning analysis offset from interval (seconds)
	AutoDeployOffsetSec float64 `protobuf:"fixed64,6,opt,name=auto_deploy_offset_sec,json=autoDeployOffsetSec,proto3" json:"auto_deploy_offset_sec,omitempty"`
	// Auto Provisioning Policy max allowed intervals
	AutoDeployMaxIntervals uint32 `protobuf:"varint,7,opt,name=auto_deploy_max_intervals,json=autoDeployMaxIntervals,proto3" json:"auto_deploy_max_intervals,omitempty"`
	// Create AppInst timeout (duration)
	CreateAppInstTimeout Duration `protobuf:"varint,8,opt,name=create_app_inst_timeout,json=createAppInstTimeout,proto3,casttype=Duration" json:"create_app_inst_timeout,omitempty"`
	// Update AppInst timeout (duration)
	UpdateAppInstTimeout Duration `protobuf:"varint,9,opt,name=update_app_inst_timeout,json=updateAppInstTimeout,proto3,casttype=Duration" json:"update_app_inst_timeout,omitempty"`
	// Delete AppInst timeout (duration)
	DeleteAppInstTimeout Duration `protobuf:"varint,10,opt,name=delete_app_inst_timeout,json=deleteAppInstTimeout,proto3,casttype=Duration" json:"delete_app_inst_timeout,omitempty"`
	// Create ClusterInst timeout (duration)
	CreateClusterInstTimeout Duration `protobuf:"varint,11,opt,name=create_cluster_inst_timeout,json=createClusterInstTimeout,proto3,casttype=Duration" json:"create_cluster_inst_timeout,omitempty"`
	// Update ClusterInst timeout (duration)
	UpdateClusterInstTimeout Duration `protobuf:"varint,12,opt,name=update_cluster_inst_timeout,json=updateClusterInstTimeout,proto3,casttype=Duration" json:"update_cluster_inst_timeout,omitempty"`
	// Delete ClusterInst timeout (duration)
	DeleteClusterInstTimeout Duration `protobuf:"varint,13,opt,name=delete_cluster_inst_timeout,json=deleteClusterInstTimeout,proto3,casttype=Duration" json:"delete_cluster_inst_timeout,omitempty"`
	// Default flavor for k8s master VM and > 0  workers
	MasterNodeFlavor string `protobuf:"bytes,14,opt,name=master_node_flavor,json=masterNodeFlavor,proto3" json:"master_node_flavor,omitempty"`
	// Max IP Port range when using a load balancer
	LoadBalancerMaxPortRange int32 `protobuf:"varint,15,opt,name=load_balancer_max_port_range,json=loadBalancerMaxPortRange,proto3" json:"load_balancer_max_port_range,omitempty"`
	// Max DME clients to be tracked at the same time.
	MaxTrackedDmeClients int32 `protobuf:"varint,16,opt,name=max_tracked_dme_clients,json=maxTrackedDmeClients,proto3" json:"max_tracked_dme_clients,omitempty"`
}

func (m *Settings) Reset()                    { *m = Settings{} }
func (m *Settings) String() string            { return proto.CompactTextString(m) }
func (*Settings) ProtoMessage()               {}
func (*Settings) Descriptor() ([]byte, []int) { return fileDescriptorSettings, []int{0} }

func init() {
	proto.RegisterType((*Settings)(nil), "edgeproto.Settings")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SettingsApi service

type SettingsApiClient interface {
	// Update settings
	UpdateSettings(ctx context.Context, in *Settings, opts ...grpc.CallOption) (*Result, error)
	// Reset all settings to their defaults
	ResetSettings(ctx context.Context, in *Settings, opts ...grpc.CallOption) (*Result, error)
	// Show settings
	ShowSettings(ctx context.Context, in *Settings, opts ...grpc.CallOption) (*Settings, error)
}

type settingsApiClient struct {
	cc *grpc.ClientConn
}

func NewSettingsApiClient(cc *grpc.ClientConn) SettingsApiClient {
	return &settingsApiClient{cc}
}

func (c *settingsApiClient) UpdateSettings(ctx context.Context, in *Settings, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.SettingsApi/UpdateSettings", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsApiClient) ResetSettings(ctx context.Context, in *Settings, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.SettingsApi/ResetSettings", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsApiClient) ShowSettings(ctx context.Context, in *Settings, opts ...grpc.CallOption) (*Settings, error) {
	out := new(Settings)
	err := grpc.Invoke(ctx, "/edgeproto.SettingsApi/ShowSettings", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SettingsApi service

type SettingsApiServer interface {
	// Update settings
	UpdateSettings(context.Context, *Settings) (*Result, error)
	// Reset all settings to their defaults
	ResetSettings(context.Context, *Settings) (*Result, error)
	// Show settings
	ShowSettings(context.Context, *Settings) (*Settings, error)
}

func RegisterSettingsApiServer(s *grpc.Server, srv SettingsApiServer) {
	s.RegisterService(&_SettingsApi_serviceDesc, srv)
}

func _SettingsApi_UpdateSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Settings)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsApiServer).UpdateSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.SettingsApi/UpdateSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsApiServer).UpdateSettings(ctx, req.(*Settings))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettingsApi_ResetSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Settings)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsApiServer).ResetSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.SettingsApi/ResetSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsApiServer).ResetSettings(ctx, req.(*Settings))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettingsApi_ShowSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Settings)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsApiServer).ShowSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.SettingsApi/ShowSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsApiServer).ShowSettings(ctx, req.(*Settings))
	}
	return interceptor(ctx, in, info, handler)
}

var _SettingsApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.SettingsApi",
	HandlerType: (*SettingsApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateSettings",
			Handler:    _SettingsApi_UpdateSettings_Handler,
		},
		{
			MethodName: "ResetSettings",
			Handler:    _SettingsApi_ResetSettings_Handler,
		},
		{
			MethodName: "ShowSettings",
			Handler:    _SettingsApi_ShowSettings_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "settings.proto",
}

func (m *Settings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Settings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.ShepherdMetricsCollectionInterval != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.ShepherdMetricsCollectionInterval))
	}
	if m.ShepherdHealthCheckRetries != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.ShepherdHealthCheckRetries))
	}
	if m.ShepherdHealthCheckInterval != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.ShepherdHealthCheckInterval))
	}
	if m.AutoDeployIntervalSec != 0 {
		dAtA[i] = 0x29
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AutoDeployIntervalSec))))
		i += 8
	}
	if m.AutoDeployOffsetSec != 0 {
		dAtA[i] = 0x31
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AutoDeployOffsetSec))))
		i += 8
	}
	if m.AutoDeployMaxIntervals != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.AutoDeployMaxIntervals))
	}
	if m.CreateAppInstTimeout != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.CreateAppInstTimeout))
	}
	if m.UpdateAppInstTimeout != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.UpdateAppInstTimeout))
	}
	if m.DeleteAppInstTimeout != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.DeleteAppInstTimeout))
	}
	if m.CreateClusterInstTimeout != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.CreateClusterInstTimeout))
	}
	if m.UpdateClusterInstTimeout != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.UpdateClusterInstTimeout))
	}
	if m.DeleteClusterInstTimeout != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.DeleteClusterInstTimeout))
	}
	if len(m.MasterNodeFlavor) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintSettings(dAtA, i, uint64(len(m.MasterNodeFlavor)))
		i += copy(dAtA[i:], m.MasterNodeFlavor)
	}
	if m.LoadBalancerMaxPortRange != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.LoadBalancerMaxPortRange))
	}
	if m.MaxTrackedDmeClients != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSettings(dAtA, i, uint64(m.MaxTrackedDmeClients))
	}
	return i, nil
}

func encodeVarintSettings(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Settings) Matches(o *Settings, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.ShepherdMetricsCollectionInterval != 0 {
		if o.ShepherdMetricsCollectionInterval != m.ShepherdMetricsCollectionInterval {
			return false
		}
	}
	if !opts.Filter || o.ShepherdHealthCheckRetries != 0 {
		if o.ShepherdHealthCheckRetries != m.ShepherdHealthCheckRetries {
			return false
		}
	}
	if !opts.Filter || o.ShepherdHealthCheckInterval != 0 {
		if o.ShepherdHealthCheckInterval != m.ShepherdHealthCheckInterval {
			return false
		}
	}
	if !opts.Filter || o.AutoDeployIntervalSec != 0 {
		if o.AutoDeployIntervalSec != m.AutoDeployIntervalSec {
			return false
		}
	}
	if !opts.Filter || o.AutoDeployOffsetSec != 0 {
		if o.AutoDeployOffsetSec != m.AutoDeployOffsetSec {
			return false
		}
	}
	if !opts.Filter || o.AutoDeployMaxIntervals != 0 {
		if o.AutoDeployMaxIntervals != m.AutoDeployMaxIntervals {
			return false
		}
	}
	if !opts.Filter || o.CreateAppInstTimeout != 0 {
		if o.CreateAppInstTimeout != m.CreateAppInstTimeout {
			return false
		}
	}
	if !opts.Filter || o.UpdateAppInstTimeout != 0 {
		if o.UpdateAppInstTimeout != m.UpdateAppInstTimeout {
			return false
		}
	}
	if !opts.Filter || o.DeleteAppInstTimeout != 0 {
		if o.DeleteAppInstTimeout != m.DeleteAppInstTimeout {
			return false
		}
	}
	if !opts.Filter || o.CreateClusterInstTimeout != 0 {
		if o.CreateClusterInstTimeout != m.CreateClusterInstTimeout {
			return false
		}
	}
	if !opts.Filter || o.UpdateClusterInstTimeout != 0 {
		if o.UpdateClusterInstTimeout != m.UpdateClusterInstTimeout {
			return false
		}
	}
	if !opts.Filter || o.DeleteClusterInstTimeout != 0 {
		if o.DeleteClusterInstTimeout != m.DeleteClusterInstTimeout {
			return false
		}
	}
	if !opts.Filter || o.MasterNodeFlavor != "" {
		if o.MasterNodeFlavor != m.MasterNodeFlavor {
			return false
		}
	}
	if !opts.Filter || o.LoadBalancerMaxPortRange != 0 {
		if o.LoadBalancerMaxPortRange != m.LoadBalancerMaxPortRange {
			return false
		}
	}
	if !opts.Filter || o.MaxTrackedDmeClients != 0 {
		if o.MaxTrackedDmeClients != m.MaxTrackedDmeClients {
			return false
		}
	}
	return true
}

const SettingsFieldShepherdMetricsCollectionInterval = "2"
const SettingsFieldShepherdHealthCheckRetries = "3"
const SettingsFieldShepherdHealthCheckInterval = "4"
const SettingsFieldAutoDeployIntervalSec = "5"
const SettingsFieldAutoDeployOffsetSec = "6"
const SettingsFieldAutoDeployMaxIntervals = "7"
const SettingsFieldCreateAppInstTimeout = "8"
const SettingsFieldUpdateAppInstTimeout = "9"
const SettingsFieldDeleteAppInstTimeout = "10"
const SettingsFieldCreateClusterInstTimeout = "11"
const SettingsFieldUpdateClusterInstTimeout = "12"
const SettingsFieldDeleteClusterInstTimeout = "13"
const SettingsFieldMasterNodeFlavor = "14"
const SettingsFieldLoadBalancerMaxPortRange = "15"
const SettingsFieldMaxTrackedDmeClients = "16"

var SettingsAllFields = []string{
	SettingsFieldShepherdMetricsCollectionInterval,
	SettingsFieldShepherdHealthCheckRetries,
	SettingsFieldShepherdHealthCheckInterval,
	SettingsFieldAutoDeployIntervalSec,
	SettingsFieldAutoDeployOffsetSec,
	SettingsFieldAutoDeployMaxIntervals,
	SettingsFieldCreateAppInstTimeout,
	SettingsFieldUpdateAppInstTimeout,
	SettingsFieldDeleteAppInstTimeout,
	SettingsFieldCreateClusterInstTimeout,
	SettingsFieldUpdateClusterInstTimeout,
	SettingsFieldDeleteClusterInstTimeout,
	SettingsFieldMasterNodeFlavor,
	SettingsFieldLoadBalancerMaxPortRange,
	SettingsFieldMaxTrackedDmeClients,
}

var SettingsAllFieldsMap = map[string]struct{}{
	SettingsFieldShepherdMetricsCollectionInterval: struct{}{},
	SettingsFieldShepherdHealthCheckRetries:        struct{}{},
	SettingsFieldShepherdHealthCheckInterval:       struct{}{},
	SettingsFieldAutoDeployIntervalSec:             struct{}{},
	SettingsFieldAutoDeployOffsetSec:               struct{}{},
	SettingsFieldAutoDeployMaxIntervals:            struct{}{},
	SettingsFieldCreateAppInstTimeout:              struct{}{},
	SettingsFieldUpdateAppInstTimeout:              struct{}{},
	SettingsFieldDeleteAppInstTimeout:              struct{}{},
	SettingsFieldCreateClusterInstTimeout:          struct{}{},
	SettingsFieldUpdateClusterInstTimeout:          struct{}{},
	SettingsFieldDeleteClusterInstTimeout:          struct{}{},
	SettingsFieldMasterNodeFlavor:                  struct{}{},
	SettingsFieldLoadBalancerMaxPortRange:          struct{}{},
	SettingsFieldMaxTrackedDmeClients:              struct{}{},
}

var SettingsAllFieldsStringMap = map[string]string{
	SettingsFieldShepherdMetricsCollectionInterval: "Shepherd Metrics Collection Interval",
	SettingsFieldShepherdHealthCheckRetries:        "Shepherd Health Check Retries",
	SettingsFieldShepherdHealthCheckInterval:       "Shepherd Health Check Interval",
	SettingsFieldAutoDeployIntervalSec:             "Auto Deploy Interval Sec",
	SettingsFieldAutoDeployOffsetSec:               "Auto Deploy Offset Sec",
	SettingsFieldAutoDeployMaxIntervals:            "Auto Deploy Max Intervals",
	SettingsFieldCreateAppInstTimeout:              "Create App Inst Timeout",
	SettingsFieldUpdateAppInstTimeout:              "Update App Inst Timeout",
	SettingsFieldDeleteAppInstTimeout:              "Delete App Inst Timeout",
	SettingsFieldCreateClusterInstTimeout:          "Create Cluster Inst Timeout",
	SettingsFieldUpdateClusterInstTimeout:          "Update Cluster Inst Timeout",
	SettingsFieldDeleteClusterInstTimeout:          "Delete Cluster Inst Timeout",
	SettingsFieldMasterNodeFlavor:                  "Master Node Flavor",
	SettingsFieldLoadBalancerMaxPortRange:          "Load Balancer Max Port Range",
	SettingsFieldMaxTrackedDmeClients:              "Max Tracked Dme Clients",
}

func (m *Settings) IsKeyField(s string) bool {
	return strings.HasPrefix(s, SettingsFieldShepherdMetricsCollectionInterval+".")
}

func (m *Settings) DiffFields(o *Settings, fields map[string]struct{}) {
	if m.ShepherdMetricsCollectionInterval != o.ShepherdMetricsCollectionInterval {
		fields[SettingsFieldShepherdMetricsCollectionInterval] = struct{}{}
	}
	if m.ShepherdHealthCheckRetries != o.ShepherdHealthCheckRetries {
		fields[SettingsFieldShepherdHealthCheckRetries] = struct{}{}
	}
	if m.ShepherdHealthCheckInterval != o.ShepherdHealthCheckInterval {
		fields[SettingsFieldShepherdHealthCheckInterval] = struct{}{}
	}
	if m.AutoDeployIntervalSec != o.AutoDeployIntervalSec {
		fields[SettingsFieldAutoDeployIntervalSec] = struct{}{}
	}
	if m.AutoDeployOffsetSec != o.AutoDeployOffsetSec {
		fields[SettingsFieldAutoDeployOffsetSec] = struct{}{}
	}
	if m.AutoDeployMaxIntervals != o.AutoDeployMaxIntervals {
		fields[SettingsFieldAutoDeployMaxIntervals] = struct{}{}
	}
	if m.CreateAppInstTimeout != o.CreateAppInstTimeout {
		fields[SettingsFieldCreateAppInstTimeout] = struct{}{}
	}
	if m.UpdateAppInstTimeout != o.UpdateAppInstTimeout {
		fields[SettingsFieldUpdateAppInstTimeout] = struct{}{}
	}
	if m.DeleteAppInstTimeout != o.DeleteAppInstTimeout {
		fields[SettingsFieldDeleteAppInstTimeout] = struct{}{}
	}
	if m.CreateClusterInstTimeout != o.CreateClusterInstTimeout {
		fields[SettingsFieldCreateClusterInstTimeout] = struct{}{}
	}
	if m.UpdateClusterInstTimeout != o.UpdateClusterInstTimeout {
		fields[SettingsFieldUpdateClusterInstTimeout] = struct{}{}
	}
	if m.DeleteClusterInstTimeout != o.DeleteClusterInstTimeout {
		fields[SettingsFieldDeleteClusterInstTimeout] = struct{}{}
	}
	if m.MasterNodeFlavor != o.MasterNodeFlavor {
		fields[SettingsFieldMasterNodeFlavor] = struct{}{}
	}
	if m.LoadBalancerMaxPortRange != o.LoadBalancerMaxPortRange {
		fields[SettingsFieldLoadBalancerMaxPortRange] = struct{}{}
	}
	if m.MaxTrackedDmeClients != o.MaxTrackedDmeClients {
		fields[SettingsFieldMaxTrackedDmeClients] = struct{}{}
	}
}

func (m *Settings) CopyInFields(src *Settings) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if m.ShepherdMetricsCollectionInterval != src.ShepherdMetricsCollectionInterval {
			m.ShepherdMetricsCollectionInterval = src.ShepherdMetricsCollectionInterval
			changed++
		}
	}
	if _, set := fmap["3"]; set {
		if m.ShepherdHealthCheckRetries != src.ShepherdHealthCheckRetries {
			m.ShepherdHealthCheckRetries = src.ShepherdHealthCheckRetries
			changed++
		}
	}
	if _, set := fmap["4"]; set {
		if m.ShepherdHealthCheckInterval != src.ShepherdHealthCheckInterval {
			m.ShepherdHealthCheckInterval = src.ShepherdHealthCheckInterval
			changed++
		}
	}
	if _, set := fmap["5"]; set {
		if m.AutoDeployIntervalSec != src.AutoDeployIntervalSec {
			m.AutoDeployIntervalSec = src.AutoDeployIntervalSec
			changed++
		}
	}
	if _, set := fmap["6"]; set {
		if m.AutoDeployOffsetSec != src.AutoDeployOffsetSec {
			m.AutoDeployOffsetSec = src.AutoDeployOffsetSec
			changed++
		}
	}
	if _, set := fmap["7"]; set {
		if m.AutoDeployMaxIntervals != src.AutoDeployMaxIntervals {
			m.AutoDeployMaxIntervals = src.AutoDeployMaxIntervals
			changed++
		}
	}
	if _, set := fmap["8"]; set {
		if m.CreateAppInstTimeout != src.CreateAppInstTimeout {
			m.CreateAppInstTimeout = src.CreateAppInstTimeout
			changed++
		}
	}
	if _, set := fmap["9"]; set {
		if m.UpdateAppInstTimeout != src.UpdateAppInstTimeout {
			m.UpdateAppInstTimeout = src.UpdateAppInstTimeout
			changed++
		}
	}
	if _, set := fmap["10"]; set {
		if m.DeleteAppInstTimeout != src.DeleteAppInstTimeout {
			m.DeleteAppInstTimeout = src.DeleteAppInstTimeout
			changed++
		}
	}
	if _, set := fmap["11"]; set {
		if m.CreateClusterInstTimeout != src.CreateClusterInstTimeout {
			m.CreateClusterInstTimeout = src.CreateClusterInstTimeout
			changed++
		}
	}
	if _, set := fmap["12"]; set {
		if m.UpdateClusterInstTimeout != src.UpdateClusterInstTimeout {
			m.UpdateClusterInstTimeout = src.UpdateClusterInstTimeout
			changed++
		}
	}
	if _, set := fmap["13"]; set {
		if m.DeleteClusterInstTimeout != src.DeleteClusterInstTimeout {
			m.DeleteClusterInstTimeout = src.DeleteClusterInstTimeout
			changed++
		}
	}
	if _, set := fmap["14"]; set {
		if m.MasterNodeFlavor != src.MasterNodeFlavor {
			m.MasterNodeFlavor = src.MasterNodeFlavor
			changed++
		}
	}
	if _, set := fmap["15"]; set {
		if m.LoadBalancerMaxPortRange != src.LoadBalancerMaxPortRange {
			m.LoadBalancerMaxPortRange = src.LoadBalancerMaxPortRange
			changed++
		}
	}
	if _, set := fmap["16"]; set {
		if m.MaxTrackedDmeClients != src.MaxTrackedDmeClients {
			m.MaxTrackedDmeClients = src.MaxTrackedDmeClients
			changed++
		}
	}
	return changed
}

func (s *Settings) HasFields() bool {
	return true
}

type SettingsStore struct {
	kvstore objstore.KVStore
}

func NewSettingsStore(kvstore objstore.KVStore) SettingsStore {
	return SettingsStore{kvstore: kvstore}
}

func (s *SettingsStore) Create(ctx context.Context, m *Settings, wait func(int64)) (*Result, error) {
	err := m.Validate(SettingsAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Settings", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *SettingsStore) Update(ctx context.Context, m *Settings, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Settings", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur Settings
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *SettingsStore) Put(ctx context.Context, m *Settings, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(SettingsAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Settings", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *SettingsStore) Delete(ctx context.Context, m *Settings, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Settings", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *SettingsStore) LoadOne(key string) (*Settings, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj Settings
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse Settings data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *SettingsStore) STMGet(stm concurrency.STM, key *SettingsKey, buf *Settings) bool {
	keystr := objstore.DbKeyString("Settings", key)
	valstr := stm.Get(keystr)
	if valstr == "" {
		return false
	}
	if buf != nil {
		err := json.Unmarshal([]byte(valstr), buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *SettingsStore) STMPut(stm concurrency.STM, obj *Settings, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("Settings", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("Settings json marsahal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *SettingsStore) STMDel(stm concurrency.STM, key *SettingsKey) {
	keystr := objstore.DbKeyString("Settings", key)
	stm.Del(keystr)
}

type SettingsKeyWatcher struct {
	cb func(ctx context.Context)
}

// SettingsCache caches Settings objects in memory in a hash table
// and keeps them in sync with the database.
type SettingsCache struct {
	Objs        map[SettingsKey]*Settings
	Mux         util.Mutex
	List        map[SettingsKey]struct{}
	FlushAll    bool
	NotifyCb    func(ctx context.Context, obj *SettingsKey, old *Settings)
	UpdatedCb   func(ctx context.Context, old *Settings, new *Settings)
	KeyWatchers map[SettingsKey][]*SettingsKeyWatcher
}

func NewSettingsCache() *SettingsCache {
	cache := SettingsCache{}
	InitSettingsCache(&cache)
	return &cache
}

func InitSettingsCache(cache *SettingsCache) {
	cache.Objs = make(map[SettingsKey]*Settings)
	cache.KeyWatchers = make(map[SettingsKey][]*SettingsKeyWatcher)
}

func (c *SettingsCache) GetTypeString() string {
	return "Settings"
}

func (c *SettingsCache) Get(key *SettingsKey, valbuf *Settings) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		*valbuf = *inst
	}
	return found
}

func (c *SettingsCache) HasKey(key *SettingsKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *SettingsCache) GetAllKeys(ctx context.Context, keys map[SettingsKey]context.Context) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		keys[key] = ctx
	}
}

func (c *SettingsCache) Update(ctx context.Context, in *Settings, rev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), rev, func(old *Settings) (*Settings, bool) {
		return in, true
	})
}

func (c *SettingsCache) UpdateModFunc(ctx context.Context, key *SettingsKey, rev int64, modFunc func(old *Settings) (new *Settings, changed bool)) {
	c.Mux.Lock()
	old := c.Objs[*key]
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	if c.UpdatedCb != nil || c.NotifyCb != nil {
		if c.UpdatedCb != nil {
			newCopy := &Settings{}
			*newCopy = *new
			defer c.UpdatedCb(ctx, old, newCopy)
		}
		if c.NotifyCb != nil {
			defer c.NotifyCb(ctx, new.GetKey(), old)
		}
	}
	c.Objs[new.GetKeyVal()] = new
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", new)
	log.DebugLog(log.DebugLevelApi, "SyncUpdate Settings", "obj", new, "rev", rev)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *SettingsCache) Delete(ctx context.Context, in *Settings, rev int64) {
	c.Mux.Lock()
	old := c.Objs[in.GetKeyVal()]
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	log.DebugLog(log.DebugLevelApi, "SyncDelete Settings", "key", in.GetKey(), "rev", rev)
	c.Mux.Unlock()
	if c.NotifyCb != nil {
		c.NotifyCb(ctx, in.GetKey(), old)
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *SettingsCache) Prune(ctx context.Context, validKeys map[SettingsKey]struct{}) {
	notify := make(map[SettingsKey]*Settings)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if c.NotifyCb != nil {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		if c.NotifyCb != nil {
			c.NotifyCb(ctx, &key, old)
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *SettingsCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *SettingsCache) Flush(ctx context.Context, notifyId int64) {
	if c.FlushAll {
		log.SpanLog(ctx, log.DebugLevelApi, "CacheFlush Settings", "notifyId", notifyId)
		flushed := make(map[SettingsKey]*Settings)
		c.Mux.Lock()
		for key, _ := range c.Objs {
			flushed[key] = c.Objs[key]
			log.SpanLog(ctx, log.DebugLevelApi, "CacheFlush Settings delete", "key", key)
			delete(c.Objs, key)
		}
		c.Mux.Unlock()
		return
	}
}

func (c *SettingsCache) Show(filter *Settings, cb func(ret *Settings) error) error {
	log.DebugLog(log.DebugLevelApi, "Show Settings", "count", len(c.Objs))
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, obj := range c.Objs {
		log.DebugLog(log.DebugLevelApi, "Compare Settings", "filter", filter, "obj", obj)
		if !obj.Matches(filter, MatchFilter()) {
			continue
		}
		log.DebugLog(log.DebugLevelApi, "Show Settings", "obj", obj)
		err := cb(obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func SettingsGenericNotifyCb(fn func(key *SettingsKey, old *Settings)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*SettingsKey), obj.(*Settings))
	}
}

func (c *SettingsCache) SetNotifyCb(fn func(ctx context.Context, obj *SettingsKey, old *Settings)) {
	c.NotifyCb = fn
}

func (c *SettingsCache) SetUpdatedCb(fn func(ctx context.Context, old *Settings, new *Settings)) {
	c.UpdatedCb = fn
}

func (c *SettingsCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *SettingsCache) WatchKey(key *SettingsKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*SettingsKeyWatcher, 0)
	}
	watcher := SettingsKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching Settings", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *SettingsCache) TriggerKeyWatchers(ctx context.Context, key *SettingsKey) {
	watchers := make([]*SettingsKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}
func (c *SettingsCache) SyncUpdate(ctx context.Context, key, val []byte, rev int64) {
	obj := Settings{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse Settings data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, rev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *SettingsCache) SyncDelete(ctx context.Context, key []byte, rev int64) {
	obj := Settings{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	SettingsKeyStringParse(keystr, &obj)
	c.Delete(ctx, &obj, rev)
}

func (c *SettingsCache) SyncListStart(ctx context.Context) {
	c.List = make(map[SettingsKey]struct{})
}

func (c *SettingsCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[SettingsKey]*Settings)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	if c.NotifyCb != nil {
		for key, val := range deleted {
			c.NotifyCb(ctx, &key, val)
			c.TriggerKeyWatchers(ctx, &key)
		}
	}
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *Settings) ValidateEnums() error {
	return nil
}

func (m *Settings) Size() (n int) {
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovSettings(uint64(l))
		}
	}
	if m.ShepherdMetricsCollectionInterval != 0 {
		n += 1 + sovSettings(uint64(m.ShepherdMetricsCollectionInterval))
	}
	if m.ShepherdHealthCheckRetries != 0 {
		n += 1 + sovSettings(uint64(m.ShepherdHealthCheckRetries))
	}
	if m.ShepherdHealthCheckInterval != 0 {
		n += 1 + sovSettings(uint64(m.ShepherdHealthCheckInterval))
	}
	if m.AutoDeployIntervalSec != 0 {
		n += 9
	}
	if m.AutoDeployOffsetSec != 0 {
		n += 9
	}
	if m.AutoDeployMaxIntervals != 0 {
		n += 1 + sovSettings(uint64(m.AutoDeployMaxIntervals))
	}
	if m.CreateAppInstTimeout != 0 {
		n += 1 + sovSettings(uint64(m.CreateAppInstTimeout))
	}
	if m.UpdateAppInstTimeout != 0 {
		n += 1 + sovSettings(uint64(m.UpdateAppInstTimeout))
	}
	if m.DeleteAppInstTimeout != 0 {
		n += 1 + sovSettings(uint64(m.DeleteAppInstTimeout))
	}
	if m.CreateClusterInstTimeout != 0 {
		n += 1 + sovSettings(uint64(m.CreateClusterInstTimeout))
	}
	if m.UpdateClusterInstTimeout != 0 {
		n += 1 + sovSettings(uint64(m.UpdateClusterInstTimeout))
	}
	if m.DeleteClusterInstTimeout != 0 {
		n += 1 + sovSettings(uint64(m.DeleteClusterInstTimeout))
	}
	l = len(m.MasterNodeFlavor)
	if l > 0 {
		n += 1 + l + sovSettings(uint64(l))
	}
	if m.LoadBalancerMaxPortRange != 0 {
		n += 1 + sovSettings(uint64(m.LoadBalancerMaxPortRange))
	}
	if m.MaxTrackedDmeClients != 0 {
		n += 2 + sovSettings(uint64(m.MaxTrackedDmeClients))
	}
	return n
}

func sovSettings(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSettings(x uint64) (n int) {
	return sovSettings(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Settings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSettings
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Settings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Settings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettings
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShepherdMetricsCollectionInterval", wireType)
			}
			m.ShepherdMetricsCollectionInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShepherdMetricsCollectionInterval |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShepherdHealthCheckRetries", wireType)
			}
			m.ShepherdHealthCheckRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShepherdHealthCheckRetries |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShepherdHealthCheckInterval", wireType)
			}
			m.ShepherdHealthCheckInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShepherdHealthCheckInterval |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeployIntervalSec", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AutoDeployIntervalSec = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeployOffsetSec", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AutoDeployOffsetSec = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeployMaxIntervals", wireType)
			}
			m.AutoDeployMaxIntervals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoDeployMaxIntervals |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAppInstTimeout", wireType)
			}
			m.CreateAppInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAppInstTimeout |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAppInstTimeout", wireType)
			}
			m.UpdateAppInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAppInstTimeout |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteAppInstTimeout", wireType)
			}
			m.DeleteAppInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteAppInstTimeout |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateClusterInstTimeout", wireType)
			}
			m.CreateClusterInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateClusterInstTimeout |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateClusterInstTimeout", wireType)
			}
			m.UpdateClusterInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateClusterInstTimeout |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteClusterInstTimeout", wireType)
			}
			m.DeleteClusterInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteClusterInstTimeout |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterNodeFlavor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettings
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MasterNodeFlavor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerMaxPortRange", wireType)
			}
			m.LoadBalancerMaxPortRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoadBalancerMaxPortRange |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTrackedDmeClients", wireType)
			}
			m.MaxTrackedDmeClients = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTrackedDmeClients |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSettings(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSettings
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSettings(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSettings
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSettings
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSettings
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSettings(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSettings = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSettings   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("settings.proto", fileDescriptorSettings) }

var fileDescriptorSettings = []byte{
	// 765 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x94, 0xcf, 0x6f, 0xe3, 0x44,
	0x14, 0xc7, 0x99, 0x96, 0x2d, 0xc9, 0x6c, 0x9a, 0x0d, 0x6e, 0xb6, 0x3b, 0x64, 0x4b, 0x08, 0x81,
	0x43, 0x84, 0x4a, 0x2c, 0xb1, 0x42, 0x0b, 0x45, 0x42, 0x4a, 0x53, 0x21, 0x56, 0xab, 0xf0, 0xc3,
	0x5d, 0xb8, 0x21, 0x6b, 0x62, 0xbf, 0xd8, 0x56, 0x6d, 0x8f, 0x99, 0x19, 0xb7, 0xe9, 0x0d, 0xf1,
	0x17, 0x20, 0xf1, 0x0f, 0x71, 0xec, 0x11, 0x89, 0x3b, 0x82, 0x8a, 0x03, 0xaa, 0x38, 0x20, 0x9a,
	0x4a, 0x88, 0x13, 0xf2, 0x8c, 0xe3, 0xa6, 0x65, 0x84, 0xe0, 0x12, 0x4d, 0xde, 0xfb, 0x7e, 0x3f,
	0xdf, 0x37, 0x89, 0xfd, 0x70, 0x53, 0x80, 0x94, 0x51, 0x1a, 0x88, 0x61, 0xc6, 0x99, 0x64, 0x56,
	0x1d, 0xfc, 0x00, 0xd4, 0xb1, 0xd3, 0xe0, 0x20, 0xf2, 0x58, 0xea, 0x46, 0x67, 0x27, 0x60, 0x2c,
	0x88, 0xc1, 0xa6, 0x59, 0x64, 0xd3, 0x34, 0x65, 0x92, 0xca, 0x88, 0xa5, 0xa5, 0xad, 0xf3, 0x4e,
	0x10, 0xc9, 0x30, 0x9f, 0x0e, 0x3d, 0x96, 0xd8, 0x09, 0x9b, 0x46, 0x71, 0x81, 0x99, 0xdb, 0xc5,
	0xe7, 0x9b, 0x5e, 0xcc, 0x72, 0xdf, 0x56, 0xba, 0x00, 0xd2, 0xea, 0x50, 0x3a, 0xdb, 0x01, 0x0b,
	0x98, 0x3a, 0xda, 0xc5, 0x49, 0x57, 0xfb, 0xdf, 0xd5, 0x70, 0xed, 0xb0, 0x9c, 0xcc, 0xda, 0xc6,
	0x1b, 0xb3, 0x08, 0x62, 0x5f, 0x10, 0xd4, 0x5b, 0x1f, 0xd4, 0x9d, 0xf2, 0x9b, 0xf5, 0x05, 0x7e,
	0x5d, 0x84, 0x90, 0x85, 0xc0, 0x7d, 0x37, 0x01, 0xc9, 0x23, 0x4f, 0xb8, 0x1e, 0x8b, 0x63, 0xf0,
	0x8a, 0xd1, 0xdc, 0x28, 0x95, 0xc0, 0x8f, 0x69, 0x4c, 0xd6, 0x7a, 0x68, 0xb0, 0xbe, 0xdf, 0xf8,
	0xeb, 0xc7, 0x57, 0x6a, 0x07, 0x39, 0x57, 0x73, 0x3b, 0xaf, 0x2e, 0x9d, 0x13, 0x6d, 0x1c, 0x57,
	0xbe, 0x27, 0xa5, 0xcd, 0x1a, 0xe1, 0x97, 0x2b, 0x7c, 0x08, 0x34, 0x96, 0xa1, 0xeb, 0x85, 0xe0,
	0x1d, 0xb9, 0xbc, 0xb0, 0x80, 0x20, 0xeb, 0x3d, 0x34, 0xb8, 0xe3, 0x74, 0x96, 0xa2, 0x0f, 0x95,
	0x66, 0x5c, 0x48, 0x1c, 0xad, 0xb0, 0x3e, 0xc5, 0x5d, 0x33, 0xa2, 0x9a, 0xed, 0x79, 0xc3, 0x6c,
	0x0f, 0x0d, 0xc4, 0x6a, 0xaa, 0xc7, 0x98, 0xd0, 0x5c, 0x32, 0xd7, 0x87, 0x2c, 0x66, 0xa7, 0x15,
	0xc8, 0x15, 0xe0, 0x91, 0x3b, 0x3d, 0x34, 0x40, 0xce, 0xfd, 0xa2, 0x7f, 0xa0, 0xda, 0x4b, 0xd7,
	0x21, 0x78, 0xd6, 0x23, 0xbc, 0xbd, 0x6a, 0x64, 0xb3, 0x99, 0x00, 0xa9, 0x6c, 0x1b, 0xca, 0xb6,
	0x75, 0x6d, 0xfb, 0x58, 0xf5, 0x0a, 0xd3, 0xbb, 0xf8, 0xa5, 0x55, 0x53, 0x42, 0xe7, 0x55, 0xa2,
	0x20, 0x2f, 0xf4, 0xd0, 0x60, 0xd3, 0xd9, 0xbe, 0xf6, 0x4d, 0xe8, 0x7c, 0x99, 0x28, 0xac, 0x31,
	0x7e, 0xe0, 0x71, 0xa0, 0x12, 0x5c, 0x9a, 0x65, 0x6e, 0x94, 0x0a, 0xe9, 0xca, 0x28, 0x01, 0x96,
	0x4b, 0x52, 0x33, 0x5c, 0xba, 0xad, 0xc5, 0xa3, 0x2c, 0x7b, 0x92, 0x0a, 0xf9, 0x4c, 0x2b, 0x0b,
	0x48, 0x9e, 0xf9, 0x46, 0x48, 0xdd, 0x04, 0xd1, 0xe2, 0x7f, 0x42, 0x7c, 0x88, 0xc1, 0x04, 0xc1,
	0x26, 0x88, 0x16, 0xdf, 0x82, 0x3c, 0xc5, 0x0f, 0xcb, 0xeb, 0x78, 0x71, 0x2e, 0x24, 0xf0, 0x9b,
	0xa0, 0xbb, 0x06, 0x10, 0xd1, 0x86, 0xb1, 0xd6, 0xdf, 0x82, 0x95, 0xd7, 0x32, 0xc2, 0x1a, 0x26,
	0x98, 0x36, 0x98, 0x61, 0xe5, 0xf5, 0x8c, 0xb0, 0x4d, 0x13, 0x4c, 0x1b, 0x0c, 0xb0, 0x5d, 0x6c,
	0x25, 0x54, 0x41, 0x52, 0xe6, 0x83, 0x3b, 0x8b, 0xe9, 0x31, 0xe3, 0xa4, 0xd9, 0x43, 0x83, 0xba,
	0xd3, 0xd2, 0x9d, 0x8f, 0x98, 0x0f, 0x1f, 0xa8, 0xba, 0xf5, 0x3e, 0xde, 0x89, 0x19, 0xf5, 0xdd,
	0x29, 0x8d, 0x69, 0xea, 0x01, 0x57, 0x0f, 0x48, 0xc6, 0xb8, 0x74, 0x39, 0x4d, 0x03, 0x20, 0xf7,
	0xd4, 0x1b, 0x42, 0x0a, 0xcd, 0x7e, 0x29, 0x99, 0xd0, 0xf9, 0x27, 0x8c, 0x4b, 0xa7, 0xe8, 0x5b,
	0x6f, 0xe3, 0x07, 0x85, 0x43, 0x72, 0xea, 0x1d, 0x81, 0xef, 0xfa, 0x49, 0x71, 0x87, 0x08, 0x52,
	0x29, 0x48, 0x4b, 0x59, 0xdb, 0x09, 0x9d, 0x3f, 0xd3, 0xdd, 0x83, 0x04, 0xc6, 0xba, 0xb7, 0xf7,
	0xda, 0xaf, 0x97, 0x04, 0xfd, 0x7e, 0x49, 0xd0, 0x57, 0x0b, 0x82, 0xbe, 0x59, 0x10, 0xf4, 0xc7,
	0x15, 0xb9, 0xbb, 0x5c, 0x17, 0x4f, 0xe1, 0xf4, 0xcf, 0x2b, 0x82, 0xde, 0xfa, 0x6d, 0x0d, 0x57,
	0xb5, 0x51, 0x16, 0x59, 0x39, 0x6e, 0x7e, 0xa6, 0x7e, 0xc2, 0x6a, 0xaf, 0x6c, 0x0d, 0xab, 0x65,
	0x37, 0x5c, 0x16, 0x3b, 0x2f, 0xae, 0x14, 0x1d, 0xb5, 0x00, 0xfb, 0xef, 0x5d, 0x2c, 0xc8, 0x8e,
	0x03, 0x82, 0xe5, 0xdc, 0x83, 0x31, 0x4b, 0x67, 0x51, 0xb0, 0x3b, 0x52, 0xbb, 0x62, 0x42, 0x53,
	0x1a, 0xc0, 0xee, 0xd7, 0x3f, 0xfc, 0xf2, 0xed, 0xda, 0xfd, 0x7e, 0xcb, 0xd6, 0xff, 0x91, 0xbd,
	0xdc, 0xa9, 0x7b, 0xe8, 0x0d, 0x4b, 0xe0, 0x4d, 0x07, 0xd4, 0xdb, 0xf4, 0x3f, 0x53, 0xf7, 0xfe,
	0x53, 0x6a, 0xbb, 0x7f, 0xcf, 0xe6, 0x05, 0xff, 0x46, 0xe8, 0x97, 0xb8, 0x71, 0x18, 0xb2, 0x93,
	0x7f, 0xcf, 0x34, 0x15, 0xfb, 0x8f, 0x2f, 0x16, 0xa4, 0x63, 0x4c, 0xfd, 0x3c, 0x82, 0x13, 0x9d,
	0xb9, 0xd5, 0x6f, 0xda, 0x22, 0x64, 0x27, 0xab, 0x91, 0xfb, 0xad, 0xb3, 0x9f, 0xbb, 0xcf, 0x9d,
	0x9d, 0x77, 0xd1, 0xf7, 0xe7, 0x5d, 0xf4, 0xd3, 0x79, 0x17, 0x4d, 0x37, 0x14, 0xfa, 0xd1, 0xdf,
	0x01, 0x00, 0x00, 0xff, 0xff, 0x32, 0xb7, 0xe9, 0x52, 0x63, 0x06, 0x00, 0x00,
}
