// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cloudlet.proto

package edgeproto

import (
	context "context"
	"encoding/json"
	"errors"
	fmt "fmt"
	"github.com/coreos/etcd/clientv3/concurrency"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	distributed_match_engine "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto"
	dme_proto "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto"
	"github.com/mobiledgex/edge-cloud/log"
	"github.com/mobiledgex/edge-cloud/objstore"
	_ "github.com/mobiledgex/edge-cloud/protogen"
	"github.com/mobiledgex/edge-cloud/util"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	"strconv"
	strings "strings"
	"time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Platform Type
//
// PlatformType is the supported list of cloudlet types
//
// 0: `PLATFORM_TYPE_FAKE`
// 1: `PLATFORM_TYPE_DIND`
// 2: `PLATFORM_TYPE_OPENSTACK`
// 3: `PLATFORM_TYPE_AZURE`
// 4: `PLATFORM_TYPE_GCP`
// 5: `PLATFORM_TYPE_EDGEBOX`
// 6: `PLATFORM_TYPE_FAKEINFRA`
// 7: `PLATFORM_TYPE_VSPHERE`
// 8: `PLATFORM_TYPE_AWS_EKS`
// 9: `PLATFORM_TYPE_VM_POOL`
// 10: `PLATFORM_TYPE_AWS_EC2`
// 11: `PLATFORM_TYPE_VCD`
// 12: `PLATFORM_TYPE_K8S_BARE_METAL`
// 13: `PLATFORM_TYPE_KIND`
// 14: `PLATFORM_TYPE_KINDINFRA`
// 15: `PLATFORM_TYPE_FAKE_SINGLE_CLUSTER`
// 16: `PLATFORM_TYPE_FEDERATION`
// 17: `PLATFORM_TYPE_FAKE_VM_POOL`
type PlatformType int32

const (
	// Fake Cloudlet
	PlatformType_PLATFORM_TYPE_FAKE PlatformType = 0
	// DIND Cloudlet
	PlatformType_PLATFORM_TYPE_DIND PlatformType = 1
	// Openstack Cloudlet
	PlatformType_PLATFORM_TYPE_OPENSTACK PlatformType = 2
	// Azure Cloudlet
	PlatformType_PLATFORM_TYPE_AZURE PlatformType = 3
	// GCP Cloudlet
	PlatformType_PLATFORM_TYPE_GCP PlatformType = 4
	// Edgebox Cloudlet
	PlatformType_PLATFORM_TYPE_EDGEBOX PlatformType = 5
	// Fake Infra Cloudlet
	PlatformType_PLATFORM_TYPE_FAKEINFRA PlatformType = 6
	// VMWare VSphere (ESXi)
	PlatformType_PLATFORM_TYPE_VSPHERE PlatformType = 7
	// AWS EKS Cloudlet
	PlatformType_PLATFORM_TYPE_AWS_EKS PlatformType = 8
	// VM Pool Cloudlet
	PlatformType_PLATFORM_TYPE_VM_POOL PlatformType = 9
	// AWS EC2 VM Cloudlet
	PlatformType_PLATFORM_TYPE_AWS_EC2 PlatformType = 10
	// VMWare vCloud Director Cloudlet
	PlatformType_PLATFORM_TYPE_VCD PlatformType = 11
	// Kubebetes on bare metal
	PlatformType_PLATFORM_TYPE_K8S_BARE_METAL PlatformType = 12
	// KIND Cloudlet
	PlatformType_PLATFORM_TYPE_KIND PlatformType = 13
	// KIND Infra Cloudlet
	PlatformType_PLATFORM_TYPE_KINDINFRA PlatformType = 14
	// Fake Single Cluster Cloudlet
	PlatformType_PLATFORM_TYPE_FAKE_SINGLE_CLUSTER PlatformType = 15
	// Cloudlet shared as part of federation
	PlatformType_PLATFORM_TYPE_FEDERATION PlatformType = 16
	// Fake VM Pool Cloudlet
	PlatformType_PLATFORM_TYPE_FAKE_VM_POOL PlatformType = 17
)

var PlatformType_name = map[int32]string{
	0:  "PLATFORM_TYPE_FAKE",
	1:  "PLATFORM_TYPE_DIND",
	2:  "PLATFORM_TYPE_OPENSTACK",
	3:  "PLATFORM_TYPE_AZURE",
	4:  "PLATFORM_TYPE_GCP",
	5:  "PLATFORM_TYPE_EDGEBOX",
	6:  "PLATFORM_TYPE_FAKEINFRA",
	7:  "PLATFORM_TYPE_VSPHERE",
	8:  "PLATFORM_TYPE_AWS_EKS",
	9:  "PLATFORM_TYPE_VM_POOL",
	10: "PLATFORM_TYPE_AWS_EC2",
	11: "PLATFORM_TYPE_VCD",
	12: "PLATFORM_TYPE_K8S_BARE_METAL",
	13: "PLATFORM_TYPE_KIND",
	14: "PLATFORM_TYPE_KINDINFRA",
	15: "PLATFORM_TYPE_FAKE_SINGLE_CLUSTER",
	16: "PLATFORM_TYPE_FEDERATION",
	17: "PLATFORM_TYPE_FAKE_VM_POOL",
}

var PlatformType_value = map[string]int32{
	"PLATFORM_TYPE_FAKE":                0,
	"PLATFORM_TYPE_DIND":                1,
	"PLATFORM_TYPE_OPENSTACK":           2,
	"PLATFORM_TYPE_AZURE":               3,
	"PLATFORM_TYPE_GCP":                 4,
	"PLATFORM_TYPE_EDGEBOX":             5,
	"PLATFORM_TYPE_FAKEINFRA":           6,
	"PLATFORM_TYPE_VSPHERE":             7,
	"PLATFORM_TYPE_AWS_EKS":             8,
	"PLATFORM_TYPE_VM_POOL":             9,
	"PLATFORM_TYPE_AWS_EC2":             10,
	"PLATFORM_TYPE_VCD":                 11,
	"PLATFORM_TYPE_K8S_BARE_METAL":      12,
	"PLATFORM_TYPE_KIND":                13,
	"PLATFORM_TYPE_KINDINFRA":           14,
	"PLATFORM_TYPE_FAKE_SINGLE_CLUSTER": 15,
	"PLATFORM_TYPE_FEDERATION":          16,
	"PLATFORM_TYPE_FAKE_VM_POOL":        17,
}

func (x PlatformType) String() string {
	return proto.EnumName(PlatformType_name, int32(x))
}

func (PlatformType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{0}
}

// Infra API Access
//
// InfraApiAccess is the type of access available to Infra API endpoint
//
// 0: `DIRECT_ACCESS`
// 1: `RESTRICTED_ACCESS`
type InfraApiAccess int32

const (
	// Infra API endpoint is accessible from public network
	InfraApiAccess_DIRECT_ACCESS InfraApiAccess = 0
	// Infra API endpoint is not accessible from public network
	InfraApiAccess_RESTRICTED_ACCESS InfraApiAccess = 1
)

var InfraApiAccess_name = map[int32]string{
	0: "DIRECT_ACCESS",
	1: "RESTRICTED_ACCESS",
}

var InfraApiAccess_value = map[string]int32{
	"DIRECT_ACCESS":     0,
	"RESTRICTED_ACCESS": 1,
}

func (x InfraApiAccess) String() string {
	return proto.EnumName(InfraApiAccess_name, int32(x))
}

func (InfraApiAccess) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{1}
}

// Operating System Type
//
// OSType is the type of the Operator System
//
//  0: `Linux`
//  1: `Windows`
// 20: `Others`
type OSType int32

const (
	// Linux Operating System
	OSType_LINUX OSType = 0
	// Windows Operating System
	OSType_WINDOWS OSType = 1
	// Other Operating Systems
	OSType_OTHERS OSType = 20
)

var OSType_name = map[int32]string{
	0:  "LINUX",
	1:  "WINDOWS",
	20: "OTHERS",
}

var OSType_value = map[string]int32{
	"LINUX":   0,
	"WINDOWS": 1,
	"OTHERS":  20,
}

func (x OSType) String() string {
	return proto.EnumName(OSType_name, int32(x))
}

func (OSType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{2}
}

// Report Schedule
//
// ReportSchedule is the interval for which report is to be generated
//
// 0: `EveryWeek`
// 1: `Every15Days`
// 2: `Every30Days`
// 3: `EveryMonth`
type ReportSchedule int32

const (
	// Every Week
	ReportSchedule_EveryWeek ReportSchedule = 0
	// Every 15 Days
	ReportSchedule_Every15Days ReportSchedule = 1
	// Every 30 Days
	ReportSchedule_Every30Days ReportSchedule = 2
	// Every Month
	ReportSchedule_EveryMonth ReportSchedule = 3
)

var ReportSchedule_name = map[int32]string{
	0: "EveryWeek",
	1: "Every15Days",
	2: "Every30Days",
	3: "EveryMonth",
}

var ReportSchedule_value = map[string]int32{
	"EveryWeek":   0,
	"Every15Days": 1,
	"Every30Days": 2,
	"EveryMonth":  3,
}

func (x ReportSchedule) String() string {
	return proto.EnumName(ReportSchedule_name, int32(x))
}

func (ReportSchedule) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{3}
}

// Operation time limits
//
// Time limits for cloudlet create, update and delete operations
type OperationTimeLimits struct {
	// Override default max time to create a cluster instance (duration)
	CreateClusterInstTimeout Duration `protobuf:"varint,1,opt,name=create_cluster_inst_timeout,json=createClusterInstTimeout,proto3,casttype=Duration" json:"create_cluster_inst_timeout,omitempty"`
	// Override default max time to update a cluster instance (duration)
	UpdateClusterInstTimeout Duration `protobuf:"varint,2,opt,name=update_cluster_inst_timeout,json=updateClusterInstTimeout,proto3,casttype=Duration" json:"update_cluster_inst_timeout,omitempty"`
	// Override default max time to delete a cluster instance (duration)
	DeleteClusterInstTimeout Duration `protobuf:"varint,3,opt,name=delete_cluster_inst_timeout,json=deleteClusterInstTimeout,proto3,casttype=Duration" json:"delete_cluster_inst_timeout,omitempty"`
	// Override default max time to create an app instance (duration)
	CreateAppInstTimeout Duration `protobuf:"varint,4,opt,name=create_app_inst_timeout,json=createAppInstTimeout,proto3,casttype=Duration" json:"create_app_inst_timeout,omitempty"`
	// Override default max time to update an app instance (duration)
	UpdateAppInstTimeout Duration `protobuf:"varint,5,opt,name=update_app_inst_timeout,json=updateAppInstTimeout,proto3,casttype=Duration" json:"update_app_inst_timeout,omitempty"`
	// Override default max time to delete an app instance (duration)
	DeleteAppInstTimeout Duration `protobuf:"varint,6,opt,name=delete_app_inst_timeout,json=deleteAppInstTimeout,proto3,casttype=Duration" json:"delete_app_inst_timeout,omitempty"`
}

func (m *OperationTimeLimits) Reset()         { *m = OperationTimeLimits{} }
func (m *OperationTimeLimits) String() string { return proto.CompactTextString(m) }
func (*OperationTimeLimits) ProtoMessage()    {}
func (*OperationTimeLimits) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{0}
}
func (m *OperationTimeLimits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperationTimeLimits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperationTimeLimits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperationTimeLimits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperationTimeLimits.Merge(m, src)
}
func (m *OperationTimeLimits) XXX_Size() int {
	return m.Size()
}
func (m *OperationTimeLimits) XXX_DiscardUnknown() {
	xxx_messageInfo_OperationTimeLimits.DiscardUnknown(m)
}

var xxx_messageInfo_OperationTimeLimits proto.InternalMessageInfo

// CloudletInternal is for data exchanged only between CRM and Shepherd and never the controller
type CloudletInternal struct {
	// Fields are used for the Update API to specify which fields to apply.
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Resource cloudlet key
	Key CloudletKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// Map of key value pairs for data exchanged between components
	Props map[string]string `protobuf:"bytes,3,rep,name=props,proto3" json:"props,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CloudletInternal) Reset()         { *m = CloudletInternal{} }
func (m *CloudletInternal) String() string { return proto.CompactTextString(m) }
func (*CloudletInternal) ProtoMessage()    {}
func (*CloudletInternal) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{1}
}
func (m *CloudletInternal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletInternal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletInternal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletInternal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletInternal.Merge(m, src)
}
func (m *CloudletInternal) XXX_Size() int {
	return m.Size()
}
func (m *CloudletInternal) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletInternal.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletInternal proto.InternalMessageInfo

//
// Platform specific configuration required for Cloudlet management
type PlatformConfig struct {
	// Path to Docker registry holding edge-cloud image
	ContainerRegistryPath string `protobuf:"bytes,1,opt,name=container_registry_path,json=containerRegistryPath,proto3" json:"container_registry_path,omitempty"`
	// Path to platform base image
	CloudletVmImagePath string `protobuf:"bytes,2,opt,name=cloudlet_vm_image_path,json=cloudletVmImagePath,proto3" json:"cloudlet_vm_image_path,omitempty"`
	// Address of controller notify port (can be multiple of these)
	NotifyCtrlAddrs string `protobuf:"bytes,3,opt,name=notify_ctrl_addrs,json=notifyCtrlAddrs,proto3" json:"notify_ctrl_addrs,omitempty"`
	// TLS cert file
	TlsCertFile string `protobuf:"bytes,5,opt,name=tls_cert_file,json=tlsCertFile,proto3" json:"tls_cert_file,omitempty"`
	// TLS key file
	TlsKeyFile string `protobuf:"bytes,20,opt,name=tls_key_file,json=tlsKeyFile,proto3" json:"tls_key_file,omitempty"`
	// TLS ca file
	TlsCaFile string `protobuf:"bytes,21,opt,name=tls_ca_file,json=tlsCaFile,proto3" json:"tls_ca_file,omitempty"`
	// Environment variables
	EnvVar map[string]string `protobuf:"bytes,6,rep,name=env_var,json=envVar,proto3" json:"env_var,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Tag of edge-cloud image
	PlatformTag string `protobuf:"bytes,8,opt,name=platform_tag,json=platformTag,proto3" json:"platform_tag,omitempty"`
	// Internal Test flag
	TestMode bool `protobuf:"varint,9,opt,name=test_mode,json=testMode,proto3" json:"test_mode,omitempty"`
	// Span string
	Span string `protobuf:"bytes,10,opt,name=span,proto3" json:"span,omitempty"`
	// Internal cleanup flag
	CleanupMode bool `protobuf:"varint,11,opt,name=cleanup_mode,json=cleanupMode,proto3" json:"cleanup_mode,omitempty"`
	// Region
	Region string `protobuf:"bytes,12,opt,name=region,proto3" json:"region,omitempty"`
	// Get certs from vault or generate your own for the root load balancer
	CommercialCerts bool `protobuf:"varint,13,opt,name=commercial_certs,json=commercialCerts,proto3" json:"commercial_certs,omitempty"`
	// Use Vault certs and CAs for internal TLS communication
	UseVaultPki bool `protobuf:"varint,14,opt,name=use_vault_pki,json=useVaultPki,proto3" json:"use_vault_pki,omitempty"`
	// App domain name root
	AppDnsRoot string `protobuf:"bytes,16,opt,name=app_dns_root,json=appDnsRoot,proto3" json:"app_dns_root,omitempty"`
	// Path to Chef Server
	ChefServerPath string `protobuf:"bytes,17,opt,name=chef_server_path,json=chefServerPath,proto3" json:"chef_server_path,omitempty"`
	// Chef client interval
	ChefClientInterval Duration `protobuf:"varint,18,opt,name=chef_client_interval,json=chefClientInterval,proto3,casttype=Duration" json:"chef_client_interval,omitempty"`
	// Deployment Tag
	DeploymentTag string `protobuf:"bytes,19,opt,name=deployment_tag,json=deploymentTag,proto3" json:"deployment_tag,omitempty"`
	// crm access private key
	CrmAccessPrivateKey string `protobuf:"bytes,22,opt,name=crm_access_private_key,json=crmAccessPrivateKey,proto3" json:"crm_access_private_key,omitempty"`
	// controller access API address
	AccessApiAddr string `protobuf:"bytes,23,opt,name=access_api_addr,json=accessApiAddr,proto3" json:"access_api_addr,omitempty"`
	// cache dir
	CacheDir string `protobuf:"bytes,24,opt,name=cache_dir,json=cacheDir,proto3" json:"cache_dir,omitempty"`
	// secondary crm access private key
	SecondaryCrmAccessPrivateKey string `protobuf:"bytes,25,opt,name=secondary_crm_access_private_key,json=secondaryCrmAccessPrivateKey,proto3" json:"secondary_crm_access_private_key,omitempty"`
}

func (m *PlatformConfig) Reset()         { *m = PlatformConfig{} }
func (m *PlatformConfig) String() string { return proto.CompactTextString(m) }
func (*PlatformConfig) ProtoMessage()    {}
func (*PlatformConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{2}
}
func (m *PlatformConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlatformConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlatformConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlatformConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlatformConfig.Merge(m, src)
}
func (m *PlatformConfig) XXX_Size() int {
	return m.Size()
}
func (m *PlatformConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PlatformConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PlatformConfig proto.InternalMessageInfo

// optional resource input consists of a resource specifier and clouldkey name
type CloudletResMap struct {
	// Resource cloudlet key
	Key CloudletKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
	// Resource mapping info
	Mapping map[string]string `protobuf:"bytes,2,rep,name=mapping,proto3" json:"mapping,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CloudletResMap) Reset()         { *m = CloudletResMap{} }
func (m *CloudletResMap) String() string { return proto.CompactTextString(m) }
func (*CloudletResMap) ProtoMessage()    {}
func (*CloudletResMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{3}
}
func (m *CloudletResMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletResMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletResMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletResMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletResMap.Merge(m, src)
}
func (m *CloudletResMap) XXX_Size() int {
	return m.Size()
}
func (m *CloudletResMap) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletResMap.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletResMap proto.InternalMessageInfo

// Infra specific configuration used for Cloudlet deployments
type InfraConfig struct {
	// Infra specific external network name
	ExternalNetworkName string `protobuf:"bytes,1,opt,name=external_network_name,json=externalNetworkName,proto3" json:"external_network_name,omitempty"`
	// Infra specific flavor name
	FlavorName string `protobuf:"bytes,2,opt,name=flavor_name,json=flavorName,proto3" json:"flavor_name,omitempty"`
}

func (m *InfraConfig) Reset()         { *m = InfraConfig{} }
func (m *InfraConfig) String() string { return proto.CompactTextString(m) }
func (*InfraConfig) ProtoMessage()    {}
func (*InfraConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{4}
}
func (m *InfraConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InfraConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InfraConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InfraConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfraConfig.Merge(m, src)
}
func (m *InfraConfig) XXX_Size() int {
	return m.Size()
}
func (m *InfraConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_InfraConfig.DiscardUnknown(m)
}

var xxx_messageInfo_InfraConfig proto.InternalMessageInfo

// Resource Quota
type ResourceQuota struct {
	// Resource name on which to set quota
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Quota value of the resource
	Value uint64 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
	// Generate alert when more than threshold percentage of resource is used
	AlertThreshold int32 `protobuf:"varint,3,opt,name=alert_threshold,json=alertThreshold,proto3" json:"alert_threshold,omitempty"`
}

func (m *ResourceQuota) Reset()         { *m = ResourceQuota{} }
func (m *ResourceQuota) String() string { return proto.CompactTextString(m) }
func (*ResourceQuota) ProtoMessage()    {}
func (*ResourceQuota) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{5}
}
func (m *ResourceQuota) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceQuota) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceQuota.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceQuota) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceQuota.Merge(m, src)
}
func (m *ResourceQuota) XXX_Size() int {
	return m.Size()
}
func (m *ResourceQuota) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceQuota.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceQuota proto.InternalMessageInfo

// GPU Driver Key
//
// GPUDriverKey uniquely identifies a GPU driver
type GPUDriverKey struct {
	// Name of the driver
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Organization to which the driver belongs to
	Organization string `protobuf:"bytes,2,opt,name=organization,proto3" json:"organization,omitempty"`
}

func (m *GPUDriverKey) Reset()         { *m = GPUDriverKey{} }
func (m *GPUDriverKey) String() string { return proto.CompactTextString(m) }
func (*GPUDriverKey) ProtoMessage()    {}
func (*GPUDriverKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{6}
}
func (m *GPUDriverKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUDriverKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUDriverKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUDriverKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUDriverKey.Merge(m, src)
}
func (m *GPUDriverKey) XXX_Size() int {
	return m.Size()
}
func (m *GPUDriverKey) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUDriverKey.DiscardUnknown(m)
}

var xxx_messageInfo_GPUDriverKey proto.InternalMessageInfo

type GPUDriverBuild struct {
	// Unique identifier key
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Path where the driver package is located, if it is authenticated path,
	// then credentials must be passed as part of URL (one-time download path)
	DriverPath string `protobuf:"bytes,2,opt,name=driver_path,json=driverPath,proto3" json:"driver_path,omitempty"`
	// Optional credentials (username:password) to access driver path
	DriverPathCreds string `protobuf:"bytes,3,opt,name=driver_path_creds,json=driverPathCreds,proto3" json:"driver_path_creds,omitempty"`
	// Operator System supported by GPU driver build
	OperatingSystem OSType `protobuf:"varint,4,opt,name=operating_system,json=operatingSystem,proto3,enum=edgeproto.OSType" json:"operating_system,omitempty"`
	// Kernel Version supported by GPU driver build
	KernelVersion string `protobuf:"bytes,5,opt,name=kernel_version,json=kernelVersion,proto3" json:"kernel_version,omitempty"`
	// Info on hypervisor supported by vGPU driver
	HypervisorInfo string `protobuf:"bytes,6,opt,name=hypervisor_info,json=hypervisorInfo,proto3" json:"hypervisor_info,omitempty"`
	// Driver package md5sum to ensure package is not corrupted
	Md5Sum string `protobuf:"bytes,7,opt,name=md5sum,proto3" json:"md5sum,omitempty"`
}

func (m *GPUDriverBuild) Reset()         { *m = GPUDriverBuild{} }
func (m *GPUDriverBuild) String() string { return proto.CompactTextString(m) }
func (*GPUDriverBuild) ProtoMessage()    {}
func (*GPUDriverBuild) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{7}
}
func (m *GPUDriverBuild) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUDriverBuild) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUDriverBuild.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUDriverBuild) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUDriverBuild.Merge(m, src)
}
func (m *GPUDriverBuild) XXX_Size() int {
	return m.Size()
}
func (m *GPUDriverBuild) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUDriverBuild.DiscardUnknown(m)
}

var xxx_messageInfo_GPUDriverBuild proto.InternalMessageInfo

type GPUDriverBuildMember struct {
	// Unique identifier key
	Key GPUDriverKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
	// GPU driver build
	Build GPUDriverBuild `protobuf:"bytes,2,opt,name=build,proto3" json:"build"`
	// Ignore state will ignore any action in-progress on the GPU driver
	IgnoreState bool `protobuf:"varint,3,opt,name=ignore_state,json=ignoreState,proto3" json:"ignore_state,omitempty"`
}

func (m *GPUDriverBuildMember) Reset()         { *m = GPUDriverBuildMember{} }
func (m *GPUDriverBuildMember) String() string { return proto.CompactTextString(m) }
func (*GPUDriverBuildMember) ProtoMessage()    {}
func (*GPUDriverBuildMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{8}
}
func (m *GPUDriverBuildMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUDriverBuildMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUDriverBuildMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUDriverBuildMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUDriverBuildMember.Merge(m, src)
}
func (m *GPUDriverBuildMember) XXX_Size() int {
	return m.Size()
}
func (m *GPUDriverBuildMember) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUDriverBuildMember.DiscardUnknown(m)
}

var xxx_messageInfo_GPUDriverBuildMember proto.InternalMessageInfo

type GPUDriverBuildURL struct {
	// Build URL path
	BuildUrlPath string `protobuf:"bytes,1,opt,name=build_url_path,json=buildUrlPath,proto3" json:"build_url_path,omitempty"`
	// Build URL path validity
	Validity Duration `protobuf:"varint,2,opt,name=validity,proto3,casttype=Duration" json:"validity,omitempty"`
}

func (m *GPUDriverBuildURL) Reset()         { *m = GPUDriverBuildURL{} }
func (m *GPUDriverBuildURL) String() string { return proto.CompactTextString(m) }
func (*GPUDriverBuildURL) ProtoMessage()    {}
func (*GPUDriverBuildURL) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{9}
}
func (m *GPUDriverBuildURL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUDriverBuildURL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUDriverBuildURL.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUDriverBuildURL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUDriverBuildURL.Merge(m, src)
}
func (m *GPUDriverBuildURL) XXX_Size() int {
	return m.Size()
}
func (m *GPUDriverBuildURL) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUDriverBuildURL.DiscardUnknown(m)
}

var xxx_messageInfo_GPUDriverBuildURL proto.InternalMessageInfo

type GPUDriver struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique identifier key
	Key GPUDriverKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// List of GPU driver build
	Builds []GPUDriverBuild `protobuf:"bytes,3,rep,name=builds,proto3" json:"builds"`
	// License config to setup license (will be stored in secure storage)
	LicenseConfig string `protobuf:"bytes,4,opt,name=license_config,json=licenseConfig,proto3" json:"license_config,omitempty"`
	// License config md5sum, to ensure integrity of license config
	LicenseConfigMd5Sum string `protobuf:"bytes,5,opt,name=license_config_md5sum,json=licenseConfigMd5sum,proto3" json:"license_config_md5sum,omitempty"`
	// Additional properties associated with GPU driver build
	// For example: license server information, driver release date, etc
	Properties map[string]string `protobuf:"bytes,6,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// State to figure out if any action on the GPU driver is in-progress
	State string `protobuf:"bytes,7,opt,name=state,proto3" json:"state,omitempty"`
	// Ignore state will ignore any action in-progress on the GPU driver
	IgnoreState bool `protobuf:"varint,8,opt,name=ignore_state,json=ignoreState,proto3" json:"ignore_state,omitempty"`
	// Preparing to be deleted
	DeletePrepare bool `protobuf:"varint,9,opt,name=delete_prepare,json=deletePrepare,proto3" json:"delete_prepare,omitempty"`
}

func (m *GPUDriver) Reset()         { *m = GPUDriver{} }
func (m *GPUDriver) String() string { return proto.CompactTextString(m) }
func (*GPUDriver) ProtoMessage()    {}
func (*GPUDriver) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{10}
}
func (m *GPUDriver) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUDriver) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUDriver.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUDriver) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUDriver.Merge(m, src)
}
func (m *GPUDriver) XXX_Size() int {
	return m.Size()
}
func (m *GPUDriver) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUDriver.DiscardUnknown(m)
}

var xxx_messageInfo_GPUDriver proto.InternalMessageInfo

type GPUConfig struct {
	// GPU driver key
	Driver GPUDriverKey `protobuf:"bytes,1,opt,name=driver,proto3" json:"driver"`
	// Properties to identify specifics of GPU
	Properties map[string]string `protobuf:"bytes,2,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Cloudlet specific license config to setup license (will be stored in secure storage)
	LicenseConfig string `protobuf:"bytes,3,opt,name=license_config,json=licenseConfig,proto3" json:"license_config,omitempty"`
	// Cloudlet specific license config md5sum, to ensure integrity of license config
	LicenseConfigMd5Sum string `protobuf:"bytes,4,opt,name=license_config_md5sum,json=licenseConfigMd5sum,proto3" json:"license_config_md5sum,omitempty"`
}

func (m *GPUConfig) Reset()         { *m = GPUConfig{} }
func (m *GPUConfig) String() string { return proto.CompactTextString(m) }
func (*GPUConfig) ProtoMessage()    {}
func (*GPUConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{11}
}
func (m *GPUConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUConfig.Merge(m, src)
}
func (m *GPUConfig) XXX_Size() int {
	return m.Size()
}
func (m *GPUConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GPUConfig proto.InternalMessageInfo

// Cloudlet
//
// A Cloudlet is a set of compute resources at a particular location, provided by an Operator.
type Cloudlet struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// required: true
	// Unique identifier key
	Key CloudletKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// Location of the Cloudlet site
	Location dme_proto.Loc `protobuf:"bytes,5,opt,name=location,proto3" json:"location"`
	// Type of IP support provided by Cloudlet (see IpSupport)
	IpSupport IpSupport `protobuf:"varint,6,opt,name=ip_support,json=ipSupport,proto3,enum=edgeproto.IpSupport" json:"ip_support,omitempty"`
	// List of static IPs for static IP support
	StaticIps string `protobuf:"bytes,7,opt,name=static_ips,json=staticIps,proto3" json:"static_ips,omitempty"`
	// Number of dynamic IPs available for dynamic IP support
	NumDynamicIps int32 `protobuf:"varint,8,opt,name=num_dynamic_ips,json=numDynamicIps,proto3" json:"num_dynamic_ips,omitempty"`
	// time limits which override global settings if non-zero
	TimeLimits OperationTimeLimits `protobuf:"bytes,9,opt,name=time_limits,json=timeLimits,proto3" json:"time_limits"`
	// Any errors trying to create, update, or delete the Cloudlet.
	Errors []string `protobuf:"bytes,10,rep,name=errors,proto3" json:"errors,omitempty"`
	// status is used to reflect progress of creation or other events
	Status StatusInfo `protobuf:"bytes,11,opt,name=status,proto3" json:"status"`
	// Current state of the cloudlet
	State TrackedState `protobuf:"varint,12,opt,name=state,proto3,enum=edgeproto.TrackedState" json:"state,omitempty"`
	// Override actions to CRM
	CrmOverride CRMOverride `protobuf:"varint,13,opt,name=crm_override,json=crmOverride,proto3,enum=edgeproto.CRMOverride" json:"crm_override,omitempty"`
	// Deploy cloudlet services locally
	DeploymentLocal bool `protobuf:"varint,14,opt,name=deployment_local,json=deploymentLocal,proto3" json:"deployment_local,omitempty"`
	// Platform type
	PlatformType PlatformType `protobuf:"varint,15,opt,name=platform_type,json=platformType,proto3,enum=edgeproto.PlatformType" json:"platform_type,omitempty"`
	// Address for the CRM notify listener to run on
	NotifySrvAddr string `protobuf:"bytes,16,opt,name=notify_srv_addr,json=notifySrvAddr,proto3" json:"notify_srv_addr,omitempty"`
	// Min system resource requirements for platform
	Flavor FlavorKey `protobuf:"bytes,17,opt,name=flavor,proto3" json:"flavor"`
	// Physical infrastructure cloudlet name
	PhysicalName string `protobuf:"bytes,18,opt,name=physical_name,json=physicalName,proto3" json:"physical_name,omitempty"`
	// Single Key-Value pair of env var to be passed to CRM
	EnvVar map[string]string `protobuf:"bytes,19,rep,name=env_var,json=envVar,proto3" json:"env_var,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Cloudlet container version
	ContainerVersion string `protobuf:"bytes,20,opt,name=container_version,json=containerVersion,proto3" json:"container_version,omitempty"`
	// Platform Config Info
	Config PlatformConfig `protobuf:"bytes,21,opt,name=config,proto3" json:"config"`
	// Optional resource to restagtbl key map key values = [gpu, nas, nic]
	ResTagMap map[string]*ResTagTableKey `protobuf:"bytes,22,rep,name=res_tag_map,json=resTagMap,proto3" json:"res_tag_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Variables required to access cloudlet
	AccessVars map[string]string `protobuf:"bytes,23,rep,name=access_vars,json=accessVars,proto3" json:"access_vars,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// MobiledgeX baseimage version where CRM services reside
	VmImageVersion string `protobuf:"bytes,24,opt,name=vm_image_version,json=vmImageVersion,proto3" json:"vm_image_version,omitempty"`
	// Deployment type to bring up CRM services (docker, kubernetes)
	Deployment string `protobuf:"bytes,26,opt,name=deployment,proto3" json:"deployment,omitempty"`
	// Infra Access Type is the type of access available to Infra API Endpoint
	InfraApiAccess InfraApiAccess `protobuf:"varint,27,opt,name=infra_api_access,json=infraApiAccess,proto3,enum=edgeproto.InfraApiAccess" json:"infra_api_access,omitempty"`
	// Infra specific config
	InfraConfig InfraConfig `protobuf:"bytes,28,opt,name=infra_config,json=infraConfig,proto3" json:"infra_config"`
	// Chef client key
	ChefClientKey map[string]string `protobuf:"bytes,29,rep,name=chef_client_key,json=chefClientKey,proto3" json:"chef_client_key,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// State for maintenance
	MaintenanceState dme_proto.MaintenanceState `protobuf:"varint,30,opt,name=maintenance_state,json=maintenanceState,proto3,enum=distributed_match_engine.MaintenanceState" json:"maintenance_state,omitempty"`
	// Override container version from policy file
	OverridePolicyContainerVersion bool `protobuf:"varint,31,opt,name=override_policy_container_version,json=overridePolicyContainerVersion,proto3" json:"override_policy_container_version,omitempty"`
	// VM Pool
	VmPool string `protobuf:"bytes,32,opt,name=vm_pool,json=vmPool,proto3" json:"vm_pool,omitempty"`
	// CRM access public key
	CrmAccessPublicKey string `protobuf:"bytes,33,opt,name=crm_access_public_key,json=crmAccessPublicKey,proto3" json:"crm_access_public_key,omitempty"`
	// CRM access key upgrade required
	CrmAccessKeyUpgradeRequired bool `protobuf:"varint,34,opt,name=crm_access_key_upgrade_required,json=crmAccessKeyUpgradeRequired,proto3" json:"crm_access_key_upgrade_required,omitempty"`
	// Created at time
	CreatedAt dme_proto.Timestamp `protobuf:"bytes,35,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	// Updated at time
	UpdatedAt dme_proto.Timestamp `protobuf:"bytes,36,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	// Optional Trust Policy
	TrustPolicy string `protobuf:"bytes,37,opt,name=trust_policy,json=trustPolicy,proto3" json:"trust_policy,omitempty"`
	// State of trust policy
	TrustPolicyState TrackedState `protobuf:"varint,38,opt,name=trust_policy_state,json=trustPolicyState,proto3,enum=edgeproto.TrackedState" json:"trust_policy_state,omitempty"`
	// Resource quotas
	ResourceQuotas []ResourceQuota `protobuf:"bytes,39,rep,name=resource_quotas,json=resourceQuotas,proto3" json:"resource_quotas"`
	// Default resource alert threshold percentage
	DefaultResourceAlertThreshold int32 `protobuf:"varint,40,opt,name=default_resource_alert_threshold,json=defaultResourceAlertThreshold,proto3" json:"default_resource_alert_threshold,omitempty"`
	// Address of the controller hosting the cloudlet services if it is running locally
	HostController string `protobuf:"bytes,41,opt,name=HostController,proto3" json:"HostController,omitempty"`
	// Operator provided kafka cluster endpoint to push events to
	KafkaCluster string `protobuf:"bytes,42,opt,name=kafka_cluster,json=kafkaCluster,proto3" json:"kafka_cluster,omitempty"`
	// Username for kafka SASL/PLAIN authentification, stored securely in secret storage and never visible externally
	KafkaUser string `protobuf:"bytes,43,opt,name=kafka_user,json=kafkaUser,proto3" json:"kafka_user,omitempty"`
	// Password for kafka SASL/PLAIN authentification, stored securely in secret storage and never visible externally
	KafkaPassword string `protobuf:"bytes,44,opt,name=kafka_password,json=kafkaPassword,proto3" json:"kafka_password,omitempty"`
	// GPU Configuration associated with cloudlet
	GpuConfig GPUConfig `protobuf:"bytes,45,opt,name=gpu_config,json=gpuConfig,proto3" json:"gpu_config"`
	// Enable experimental default multitenant (serverless) cluster
	EnableDefaultServerlessCluster bool `protobuf:"varint,46,opt,name=enable_default_serverless_cluster,json=enableDefaultServerlessCluster,proto3" json:"enable_default_serverless_cluster,omitempty"`
	// This cloudlet will be treated as directly connected to these additional operator organizations for the purposes of FindCloudlet
	AllianceOrgs []string `protobuf:"bytes,47,rep,name=alliance_orgs,json=allianceOrgs,proto3" json:"alliance_orgs,omitempty"`
	// For single kubernetes cluster cloudlet platforms, cluster is owned by this organization instead of multi-tenant
	SingleKubernetesClusterOwner string `protobuf:"bytes,48,opt,name=single_kubernetes_cluster_owner,json=singleKubernetesClusterOwner,proto3" json:"single_kubernetes_cluster_owner,omitempty"`
	// Preparing to be deleted
	DeletePrepare bool `protobuf:"varint,49,opt,name=delete_prepare,json=deletePrepare,proto3" json:"delete_prepare,omitempty"`
	// Enable platform H/A
	PlatformHighAvailability bool `protobuf:"varint,50,opt,name=platform_high_availability,json=platformHighAvailability,proto3" json:"platform_high_availability,omitempty"`
	// CRM secondary access public key for H/A
	SecondaryCrmAccessPublicKey string `protobuf:"bytes,51,opt,name=secondary_crm_access_public_key,json=secondaryCrmAccessPublicKey,proto3" json:"secondary_crm_access_public_key,omitempty"`
	// CRM secondary access key upgrade required for H/A
	SecondaryCrmAccessKeyUpgradeRequired bool `protobuf:"varint,52,opt,name=secondary_crm_access_key_upgrade_required,json=secondaryCrmAccessKeyUpgradeRequired,proto3" json:"secondary_crm_access_key_upgrade_required,omitempty"`
	// Address for the secondary CRM notify listener to run on
	SecondaryNotifySrvAddr string `protobuf:"bytes,53,opt,name=secondary_notify_srv_addr,json=secondaryNotifySrvAddr,proto3" json:"secondary_notify_srv_addr,omitempty"`
	// DNS label that is unique within the region
	DnsLabel string `protobuf:"bytes,54,opt,name=dns_label,json=dnsLabel,proto3" json:"dns_label,omitempty"`
	// Root LB FQDN which is globally unique
	RootLbFqdn string `protobuf:"bytes,55,opt,name=root_lb_fqdn,json=rootLbFqdn,proto3" json:"root_lb_fqdn,omitempty"`
}

func (m *Cloudlet) Reset()         { *m = Cloudlet{} }
func (m *Cloudlet) String() string { return proto.CompactTextString(m) }
func (*Cloudlet) ProtoMessage()    {}
func (*Cloudlet) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{12}
}
func (m *Cloudlet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cloudlet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cloudlet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cloudlet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cloudlet.Merge(m, src)
}
func (m *Cloudlet) XXX_Size() int {
	return m.Size()
}
func (m *Cloudlet) XXX_DiscardUnknown() {
	xxx_messageInfo_Cloudlet.DiscardUnknown(m)
}

var xxx_messageInfo_Cloudlet proto.InternalMessageInfo

type FlavorMatch struct {
	// Cloudlet ctx
	Key CloudletKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
	// Flavor name to lookup
	FlavorName string `protobuf:"bytes,3,opt,name=flavor_name,json=flavorName,proto3" json:"flavor_name,omitempty"`
	// availability zone for optional resources if any
	AvailabilityZone string `protobuf:"bytes,4,opt,name=availability_zone,json=availabilityZone,proto3" json:"availability_zone,omitempty"`
}

func (m *FlavorMatch) Reset()         { *m = FlavorMatch{} }
func (m *FlavorMatch) String() string { return proto.CompactTextString(m) }
func (*FlavorMatch) ProtoMessage()    {}
func (*FlavorMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{13}
}
func (m *FlavorMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlavorMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlavorMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlavorMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlavorMatch.Merge(m, src)
}
func (m *FlavorMatch) XXX_Size() int {
	return m.Size()
}
func (m *FlavorMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_FlavorMatch.DiscardUnknown(m)
}

var xxx_messageInfo_FlavorMatch proto.InternalMessageInfo

type CloudletManifest struct {
	// Manifest to bringup cloudlet VM and services.
	Manifest string `protobuf:"bytes,2,opt,name=manifest,proto3" json:"manifest,omitempty"`
}

func (m *CloudletManifest) Reset()         { *m = CloudletManifest{} }
func (m *CloudletManifest) String() string { return proto.CompactTextString(m) }
func (*CloudletManifest) ProtoMessage()    {}
func (*CloudletManifest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{14}
}
func (m *CloudletManifest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletManifest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletManifest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletManifest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletManifest.Merge(m, src)
}
func (m *CloudletManifest) XXX_Size() int {
	return m.Size()
}
func (m *CloudletManifest) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletManifest.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletManifest proto.InternalMessageInfo

type PropertyInfo struct {
	// Name of the property
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Description of the property
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Default value of the property
	Value string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	// Is the property a secret value, will be hidden
	Secret bool `protobuf:"varint,4,opt,name=secret,proto3" json:"secret,omitempty"`
	// Is the property mandatory
	Mandatory bool `protobuf:"varint,5,opt,name=mandatory,proto3" json:"mandatory,omitempty"`
	// Is the property internal, not to be set by Operator
	Internal bool `protobuf:"varint,6,opt,name=internal,proto3" json:"internal,omitempty"`
}

func (m *PropertyInfo) Reset()         { *m = PropertyInfo{} }
func (m *PropertyInfo) String() string { return proto.CompactTextString(m) }
func (*PropertyInfo) ProtoMessage()    {}
func (*PropertyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{15}
}
func (m *PropertyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropertyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropertyInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropertyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropertyInfo.Merge(m, src)
}
func (m *PropertyInfo) XXX_Size() int {
	return m.Size()
}
func (m *PropertyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PropertyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PropertyInfo proto.InternalMessageInfo

type CloudletProps struct {
	// Platform type
	PlatformType PlatformType `protobuf:"varint,1,opt,name=platform_type,json=platformType,proto3,enum=edgeproto.PlatformType" json:"platform_type,omitempty"`
	// Single Key-Value pair of env var to be passed to CRM
	Properties map[string]*PropertyInfo `protobuf:"bytes,2,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Organization
	Organization string `protobuf:"bytes,3,opt,name=organization,proto3" json:"organization,omitempty"`
}

func (m *CloudletProps) Reset()         { *m = CloudletProps{} }
func (m *CloudletProps) String() string { return proto.CompactTextString(m) }
func (*CloudletProps) ProtoMessage()    {}
func (*CloudletProps) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{16}
}
func (m *CloudletProps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletProps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletProps.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletProps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletProps.Merge(m, src)
}
func (m *CloudletProps) XXX_Size() int {
	return m.Size()
}
func (m *CloudletProps) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletProps.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletProps proto.InternalMessageInfo

type CloudletResourceQuotaProps struct {
	// Platform type
	PlatformType PlatformType `protobuf:"varint,1,opt,name=platform_type,json=platformType,proto3,enum=edgeproto.PlatformType" json:"platform_type,omitempty"`
	// Cloudlet resource properties
	Properties []InfraResource `protobuf:"bytes,2,rep,name=properties,proto3" json:"properties"`
	// Organization
	Organization string `protobuf:"bytes,3,opt,name=organization,proto3" json:"organization,omitempty"`
}

func (m *CloudletResourceQuotaProps) Reset()         { *m = CloudletResourceQuotaProps{} }
func (m *CloudletResourceQuotaProps) String() string { return proto.CompactTextString(m) }
func (*CloudletResourceQuotaProps) ProtoMessage()    {}
func (*CloudletResourceQuotaProps) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{17}
}
func (m *CloudletResourceQuotaProps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletResourceQuotaProps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletResourceQuotaProps.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletResourceQuotaProps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletResourceQuotaProps.Merge(m, src)
}
func (m *CloudletResourceQuotaProps) XXX_Size() int {
	return m.Size()
}
func (m *CloudletResourceQuotaProps) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletResourceQuotaProps.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletResourceQuotaProps proto.InternalMessageInfo

type CloudletResourceUsage struct {
	// Cloudlet Key
	Key CloudletKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
	// Show Infra based usage
	InfraUsage bool `protobuf:"varint,2,opt,name=infra_usage,json=infraUsage,proto3" json:"infra_usage,omitempty"`
	// Infra Resource information
	Info []InfraResource `protobuf:"bytes,3,rep,name=info,proto3" json:"info"`
}

func (m *CloudletResourceUsage) Reset()         { *m = CloudletResourceUsage{} }
func (m *CloudletResourceUsage) String() string { return proto.CompactTextString(m) }
func (*CloudletResourceUsage) ProtoMessage()    {}
func (*CloudletResourceUsage) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{18}
}
func (m *CloudletResourceUsage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletResourceUsage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletResourceUsage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletResourceUsage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletResourceUsage.Merge(m, src)
}
func (m *CloudletResourceUsage) XXX_Size() int {
	return m.Size()
}
func (m *CloudletResourceUsage) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletResourceUsage.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletResourceUsage proto.InternalMessageInfo

type CloudletAllianceOrg struct {
	// Cloudlet Key
	Key CloudletKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
	// Alliance organization
	Organization string `protobuf:"bytes,2,opt,name=organization,proto3" json:"organization,omitempty"`
}

func (m *CloudletAllianceOrg) Reset()         { *m = CloudletAllianceOrg{} }
func (m *CloudletAllianceOrg) String() string { return proto.CompactTextString(m) }
func (*CloudletAllianceOrg) ProtoMessage()    {}
func (*CloudletAllianceOrg) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{19}
}
func (m *CloudletAllianceOrg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletAllianceOrg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletAllianceOrg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletAllianceOrg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletAllianceOrg.Merge(m, src)
}
func (m *CloudletAllianceOrg) XXX_Size() int {
	return m.Size()
}
func (m *CloudletAllianceOrg) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletAllianceOrg.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletAllianceOrg proto.InternalMessageInfo

// Flavor details from the Cloudlet
type FlavorInfo struct {
	// Name of the flavor on the Cloudlet
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Number of VCPU cores on the Cloudlet
	Vcpus uint64 `protobuf:"varint,2,opt,name=vcpus,proto3" json:"vcpus,omitempty"`
	// Ram in MB on the Cloudlet
	Ram uint64 `protobuf:"varint,3,opt,name=ram,proto3" json:"ram,omitempty"`
	// Amount of disk in GB on the Cloudlet
	Disk uint64 `protobuf:"varint,4,opt,name=disk,proto3" json:"disk,omitempty"`
	// OS Flavor Properties, if any
	PropMap map[string]string `protobuf:"bytes,5,rep,name=prop_map,json=propMap,proto3" json:"prop_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *FlavorInfo) Reset()         { *m = FlavorInfo{} }
func (m *FlavorInfo) String() string { return proto.CompactTextString(m) }
func (*FlavorInfo) ProtoMessage()    {}
func (*FlavorInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{20}
}
func (m *FlavorInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlavorInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlavorInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlavorInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlavorInfo.Merge(m, src)
}
func (m *FlavorInfo) XXX_Size() int {
	return m.Size()
}
func (m *FlavorInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FlavorInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FlavorInfo proto.InternalMessageInfo

type OSAZone struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *OSAZone) Reset()         { *m = OSAZone{} }
func (m *OSAZone) String() string { return proto.CompactTextString(m) }
func (*OSAZone) ProtoMessage()    {}
func (*OSAZone) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{21}
}
func (m *OSAZone) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OSAZone) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OSAZone.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OSAZone) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OSAZone.Merge(m, src)
}
func (m *OSAZone) XXX_Size() int {
	return m.Size()
}
func (m *OSAZone) XXX_DiscardUnknown() {
	xxx_messageInfo_OSAZone.DiscardUnknown(m)
}

var xxx_messageInfo_OSAZone proto.InternalMessageInfo

type OSImage struct {
	// image name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// optional tags present on image
	Tags string `protobuf:"bytes,2,opt,name=tags,proto3" json:"tags,omitempty"`
	// image properties/metadata
	Properties string `protobuf:"bytes,3,opt,name=properties,proto3" json:"properties,omitempty"`
	// format qcow2, img, etc
	DiskFormat string `protobuf:"bytes,4,opt,name=disk_format,json=diskFormat,proto3" json:"disk_format,omitempty"`
}

func (m *OSImage) Reset()         { *m = OSImage{} }
func (m *OSImage) String() string { return proto.CompactTextString(m) }
func (*OSImage) ProtoMessage()    {}
func (*OSImage) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{22}
}
func (m *OSImage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OSImage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OSImage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OSImage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OSImage.Merge(m, src)
}
func (m *OSImage) XXX_Size() int {
	return m.Size()
}
func (m *OSImage) XXX_DiscardUnknown() {
	xxx_messageInfo_OSImage.DiscardUnknown(m)
}

var xxx_messageInfo_OSImage proto.InternalMessageInfo

// CloudletInfo provides information from the Cloudlet Resource Manager about the state of the Cloudlet.
type CloudletInfo struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique identifier key
	Key CloudletKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// State of cloudlet
	State dme_proto.CloudletState `protobuf:"varint,3,opt,name=state,proto3,enum=distributed_match_engine.CloudletState" json:"state,omitempty"`
	// Id of client assigned by server (internal use only)
	NotifyId int64 `protobuf:"varint,4,opt,name=notify_id,json=notifyId,proto3" json:"notify_id,omitempty"`
	// Connected controller unique id
	Controller string `protobuf:"bytes,5,opt,name=controller,proto3" json:"controller,omitempty"`
	// Maximum Ram in MB on the Cloudlet
	OsMaxRam uint64 `protobuf:"varint,6,opt,name=os_max_ram,json=osMaxRam,proto3" json:"os_max_ram,omitempty"`
	// Maximum number of VCPU cores on the Cloudlet
	OsMaxVcores uint64 `protobuf:"varint,7,opt,name=os_max_vcores,json=osMaxVcores,proto3" json:"os_max_vcores,omitempty"`
	// Maximum amount of disk in GB on the Cloudlet
	OsMaxVolGb uint64 `protobuf:"varint,8,opt,name=os_max_vol_gb,json=osMaxVolGb,proto3" json:"os_max_vol_gb,omitempty"`
	// Any errors encountered while making changes to the Cloudlet
	Errors []string `protobuf:"bytes,9,rep,name=errors,proto3" json:"errors,omitempty"`
	// Supported flavors by the Cloudlet
	Flavors []*FlavorInfo `protobuf:"bytes,10,rep,name=flavors,proto3" json:"flavors,omitempty"`
	// status is used to reflect progress of creation or other events
	Status StatusInfo `protobuf:"bytes,11,opt,name=status,proto3" json:"status"`
	// Cloudlet container version
	ContainerVersion string `protobuf:"bytes,12,opt,name=container_version,json=containerVersion,proto3" json:"container_version,omitempty"`
	// Availability Zones if any
	AvailabilityZones []*OSAZone `protobuf:"bytes,13,rep,name=availability_zones,json=availabilityZones,proto3" json:"availability_zones,omitempty"`
	// Local Images availble to cloudlet
	OsImages []*OSImage `protobuf:"bytes,14,rep,name=os_images,json=osImages,proto3" json:"os_images,omitempty"`
	// Indicates all controller data has been sent to CRM
	ControllerCacheReceived bool `protobuf:"varint,15,opt,name=controller_cache_received,json=controllerCacheReceived,proto3" json:"controller_cache_received,omitempty"`
	// State for maintenance
	MaintenanceState dme_proto.MaintenanceState `protobuf:"varint,16,opt,name=maintenance_state,json=maintenanceState,proto3,enum=distributed_match_engine.MaintenanceState" json:"maintenance_state,omitempty"`
	// Snapshot of resources used by cloudlet
	ResourcesSnapshot InfraResourcesSnapshot `protobuf:"bytes,17,opt,name=resources_snapshot,json=resourcesSnapshot,proto3" json:"resources_snapshot"`
	// Trust Policy State
	TrustPolicyState TrackedState `protobuf:"varint,18,opt,name=trust_policy_state,json=trustPolicyState,proto3,enum=edgeproto.TrackedState" json:"trust_policy_state,omitempty"`
	// Version for compatibility tracking
	CompatibilityVersion uint32 `protobuf:"varint,19,opt,name=compatibility_version,json=compatibilityVersion,proto3" json:"compatibility_version,omitempty"`
	// Cloudlet properties
	Properties map[string]string `protobuf:"bytes,20,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Cluster node info for serverless platforms (k8s multi-tenant cluster)
	NodeInfos []*NodeInfo `protobuf:"bytes,21,rep,name=node_infos,json=nodeInfos,proto3" json:"node_infos,omitempty"`
	// Active HA instance
	ActiveCrmInstance string `protobuf:"bytes,22,opt,name=active_crm_instance,json=activeCrmInstance,proto3" json:"active_crm_instance,omitempty"`
	// Denotes if info was reported by inactive
	StandbyCrm bool `protobuf:"varint,23,opt,name=standby_crm,json=standbyCrm,proto3" json:"standby_crm,omitempty"`
}

func (m *CloudletInfo) Reset()         { *m = CloudletInfo{} }
func (m *CloudletInfo) String() string { return proto.CompactTextString(m) }
func (*CloudletInfo) ProtoMessage()    {}
func (*CloudletInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{23}
}
func (m *CloudletInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletInfo.Merge(m, src)
}
func (m *CloudletInfo) XXX_Size() int {
	return m.Size()
}
func (m *CloudletInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletInfo proto.InternalMessageInfo

// (TODO) CloudletMetrics provide metrics collected about the Cloudlet. They are sent to a metrics collector for analytics. They are not stored in the persistent distributed database, but are stored as a time series in some other database or files.
type CloudletMetrics struct {
	// what goes here?
	Foo uint64 `protobuf:"varint,5,opt,name=foo,proto3" json:"foo,omitempty"`
}

func (m *CloudletMetrics) Reset()         { *m = CloudletMetrics{} }
func (m *CloudletMetrics) String() string { return proto.CompactTextString(m) }
func (*CloudletMetrics) ProtoMessage()    {}
func (*CloudletMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{24}
}
func (m *CloudletMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletMetrics.Merge(m, src)
}
func (m *CloudletMetrics) XXX_Size() int {
	return m.Size()
}
func (m *CloudletMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletMetrics proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("edgeproto.PlatformType", PlatformType_name, PlatformType_value)
	proto.RegisterEnum("edgeproto.InfraApiAccess", InfraApiAccess_name, InfraApiAccess_value)
	proto.RegisterEnum("edgeproto.OSType", OSType_name, OSType_value)
	proto.RegisterEnum("edgeproto.ReportSchedule", ReportSchedule_name, ReportSchedule_value)
	proto.RegisterType((*OperationTimeLimits)(nil), "edgeproto.OperationTimeLimits")
	proto.RegisterType((*CloudletInternal)(nil), "edgeproto.CloudletInternal")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.CloudletInternal.PropsEntry")
	proto.RegisterType((*PlatformConfig)(nil), "edgeproto.PlatformConfig")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.PlatformConfig.EnvVarEntry")
	proto.RegisterType((*CloudletResMap)(nil), "edgeproto.CloudletResMap")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.CloudletResMap.MappingEntry")
	proto.RegisterType((*InfraConfig)(nil), "edgeproto.InfraConfig")
	proto.RegisterType((*ResourceQuota)(nil), "edgeproto.ResourceQuota")
	proto.RegisterType((*GPUDriverKey)(nil), "edgeproto.GPUDriverKey")
	proto.RegisterType((*GPUDriverBuild)(nil), "edgeproto.GPUDriverBuild")
	proto.RegisterType((*GPUDriverBuildMember)(nil), "edgeproto.GPUDriverBuildMember")
	proto.RegisterType((*GPUDriverBuildURL)(nil), "edgeproto.GPUDriverBuildURL")
	proto.RegisterType((*GPUDriver)(nil), "edgeproto.GPUDriver")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.GPUDriver.PropertiesEntry")
	proto.RegisterType((*GPUConfig)(nil), "edgeproto.GPUConfig")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.GPUConfig.PropertiesEntry")
	proto.RegisterType((*Cloudlet)(nil), "edgeproto.Cloudlet")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.Cloudlet.AccessVarsEntry")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.Cloudlet.ChefClientKeyEntry")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.Cloudlet.EnvVarEntry")
	proto.RegisterMapType((map[string]*ResTagTableKey)(nil), "edgeproto.Cloudlet.ResTagMapEntry")
	proto.RegisterType((*FlavorMatch)(nil), "edgeproto.FlavorMatch")
	proto.RegisterType((*CloudletManifest)(nil), "edgeproto.CloudletManifest")
	proto.RegisterType((*PropertyInfo)(nil), "edgeproto.PropertyInfo")
	proto.RegisterType((*CloudletProps)(nil), "edgeproto.CloudletProps")
	proto.RegisterMapType((map[string]*PropertyInfo)(nil), "edgeproto.CloudletProps.PropertiesEntry")
	proto.RegisterType((*CloudletResourceQuotaProps)(nil), "edgeproto.CloudletResourceQuotaProps")
	proto.RegisterType((*CloudletResourceUsage)(nil), "edgeproto.CloudletResourceUsage")
	proto.RegisterType((*CloudletAllianceOrg)(nil), "edgeproto.CloudletAllianceOrg")
	proto.RegisterType((*FlavorInfo)(nil), "edgeproto.FlavorInfo")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.FlavorInfo.PropMapEntry")
	proto.RegisterType((*OSAZone)(nil), "edgeproto.OSAZone")
	proto.RegisterType((*OSImage)(nil), "edgeproto.OSImage")
	proto.RegisterType((*CloudletInfo)(nil), "edgeproto.CloudletInfo")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.CloudletInfo.PropertiesEntry")
	proto.RegisterType((*CloudletMetrics)(nil), "edgeproto.CloudletMetrics")
}

func init() { proto.RegisterFile("cloudlet.proto", fileDescriptor_3aea31a648a25d86) }

var fileDescriptor_3aea31a648a25d86 = []byte{
	// 5566 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x3b, 0x5b, 0x6c, 0x1b, 0xd9,
	0x75, 0x1e, 0xbd, 0x2c, 0x1e, 0x52, 0x14, 0x75, 0xf5, 0x1a, 0xd3, 0xb6, 0x2c, 0x73, 0x5f, 0x5e,
	0x2f, 0x2d, 0xed, 0xca, 0x71, 0xb2, 0x51, 0x77, 0x37, 0xa1, 0x28, 0x5a, 0x56, 0x25, 0x59, 0xda,
	0xa1, 0x24, 0x27, 0x0b, 0xb4, 0xd3, 0xd1, 0xcc, 0x15, 0x35, 0xd5, 0x70, 0x66, 0x7c, 0x67, 0xc8,
	0x5d, 0xee, 0x57, 0x90, 0x7e, 0xa4, 0x40, 0x81, 0x20, 0xdd, 0xb4, 0x4d, 0xba, 0x2d, 0x92, 0x20,
	0x40, 0xd2, 0xb4, 0x48, 0x81, 0x60, 0xd1, 0x8f, 0x26, 0x28, 0x8a, 0x7e, 0x2e, 0xda, 0x9f, 0x05,
	0xfa, 0xd1, 0x62, 0x81, 0x06, 0x89, 0xb7, 0x1f, 0xad, 0xbf, 0x02, 0x44, 0x72, 0x83, 0x7e, 0x15,
	0xf7, 0x31, 0xc3, 0x19, 0x72, 0x68, 0x5b, 0xb2, 0xd3, 0xfc, 0xd8, 0x9c, 0x73, 0xcf, 0x3d, 0xf7,
	0x9c, 0x73, 0xcf, 0x3d, 0xaf, 0x7b, 0x05, 0x59, 0xdd, 0x72, 0x1a, 0x86, 0x85, 0xfd, 0x39, 0x97,
	0x38, 0xbe, 0x83, 0x52, 0xd8, 0xa8, 0x61, 0xf6, 0x33, 0x7f, 0xa1, 0xe6, 0x38, 0x35, 0x0b, 0xcf,
	0x6b, 0xae, 0x39, 0xaf, 0xd9, 0xb6, 0xe3, 0x6b, 0xbe, 0xe9, 0xd8, 0x1e, 0x47, 0xcc, 0xbf, 0x5a,
	0x33, 0xfd, 0x83, 0xc6, 0xde, 0x9c, 0xee, 0xd4, 0xe7, 0xeb, 0xce, 0x9e, 0x69, 0xd1, 0x89, 0xef,
	0xcc, 0xd3, 0x7f, 0xaf, 0x31, 0x9a, 0xf3, 0x0c, 0xaf, 0x86, 0xed, 0xf0, 0x87, 0x98, 0x39, 0x16,
	0x2c, 0x79, 0x88, 0x5b, 0x02, 0x94, 0xd9, 0xb7, 0xb4, 0xa6, 0x43, 0x82, 0x2f, 0x82, 0xbd, 0x86,
	0xe5, 0x07, 0xe8, 0x04, 0x7b, 0xbe, 0x56, 0xf3, 0xb5, 0x3d, 0x0b, 0x07, 0x08, 0xba, 0x53, 0xaf,
	0x3b, 0x01, 0xbd, 0x09, 0xd3, 0xde, 0x27, 0x1a, 0xc1, 0x9e, 0xd3, 0x20, 0x3a, 0x0e, 0xf8, 0x4b,
	0x39, 0xa4, 0x26, 0x7e, 0x96, 0x1f, 0xc9, 0xaa, 0x71, 0xad, 0xae, 0xf9, 0xfa, 0xc1, 0x35, 0x6c,
	0xd7, 0x4c, 0x1b, 0xcf, 0x1b, 0x75, 0x7c, 0x8d, 0x4d, 0x9d, 0xb7, 0x1c, 0x3d, 0x58, 0xa5, 0xe6,
	0xd4, 0x1c, 0x0e, 0xa4, 0xbf, 0x04, 0x74, 0xf5, 0xf4, 0xa4, 0x35, 0xd7, 0x8d, 0x8a, 0x51, 0xf8,
	0x97, 0x7e, 0x18, 0xdf, 0x74, 0x31, 0x61, 0x5a, 0xde, 0x36, 0xeb, 0x78, 0xdd, 0xac, 0x9b, 0xbe,
	0x87, 0xd6, 0xe0, 0xbc, 0x4e, 0xb0, 0xe6, 0x63, 0x55, 0xb7, 0x1a, 0x9e, 0x8f, 0x89, 0x6a, 0xda,
	0x9e, 0xaf, 0xfa, 0x66, 0x1d, 0x3b, 0x0d, 0x5f, 0x96, 0x66, 0xa5, 0x2b, 0xfd, 0x4b, 0x99, 0xff,
	0xfd, 0xe9, 0xa5, 0xe1, 0xe5, 0x06, 0x9f, 0xac, 0xc8, 0x7c, 0x42, 0x99, 0xe3, 0xaf, 0xda, 0x9e,
	0xbf, 0xcd, 0xb1, 0x29, 0xb1, 0x86, 0x6b, 0xf4, 0x24, 0xd6, 0x97, 0x44, 0x8c, 0x4f, 0x48, 0x26,
	0x66, 0x60, 0x0b, 0xf7, 0x22, 0xd6, 0x9f, 0x44, 0x8c, 0x4f, 0x48, 0x20, 0x56, 0x86, 0x69, 0x21,
	0xa6, 0xe6, 0xba, 0x71, 0x42, 0x03, 0x09, 0x84, 0x26, 0x38, 0x72, 0xc9, 0x75, 0x3b, 0x88, 0x08,
	0xf1, 0xba, 0x88, 0x0c, 0x26, 0x11, 0xe1, 0xc8, 0xdd, 0x44, 0x84, 0x58, 0x5d, 0x44, 0x86, 0x92,
	0x88, 0x70, 0xe4, 0x38, 0x91, 0xc2, 0xaf, 0x24, 0xc8, 0x95, 0x85, 0x9d, 0xaf, 0xda, 0x3e, 0x26,
	0xb6, 0x66, 0xa1, 0x29, 0x18, 0xda, 0x37, 0xb1, 0x65, 0x78, 0xb2, 0x34, 0xdb, 0x7f, 0x25, 0xa5,
	0x88, 0x2f, 0x34, 0x07, 0xfd, 0x87, 0xb8, 0xc5, 0xb4, 0x9f, 0x5e, 0x98, 0x9a, 0x0b, 0x8f, 0xe0,
	0x5c, 0x40, 0x61, 0x0d, 0xb7, 0x96, 0x06, 0x3e, 0xfc, 0xe9, 0xa5, 0x33, 0x0a, 0x45, 0x44, 0xaf,
	0xc1, 0xa0, 0x4b, 0x1c, 0xd7, 0x93, 0xfb, 0x67, 0xfb, 0xaf, 0xa4, 0x17, 0x9e, 0x4f, 0x98, 0x11,
	0xac, 0x39, 0xb7, 0x45, 0x11, 0x2b, 0xb6, 0x4f, 0x5a, 0x0a, 0x9f, 0x94, 0x7f, 0x15, 0xa0, 0x0d,
	0x44, 0x39, 0xbe, 0x36, 0x35, 0xa3, 0x14, 0xa7, 0x3e, 0x01, 0x83, 0x4d, 0xcd, 0x6a, 0x60, 0xc6,
	0x4f, 0x4a, 0xe1, 0x1f, 0x8b, 0x7d, 0xaf, 0x4a, 0x8b, 0xcf, 0xfe, 0xd7, 0x2f, 0x65, 0xe9, 0x17,
	0xbf, 0x94, 0xa5, 0x2f, 0x1d, 0xc9, 0xd2, 0xd7, 0x8e, 0x64, 0xe9, 0x83, 0x07, 0x72, 0xee, 0x10,
	0xb7, 0x5e, 0xdf, 0x24, 0x35, 0xcd, 0x36, 0xdf, 0x65, 0x0a, 0x29, 0x7c, 0x7b, 0x18, 0xb2, 0x5b,
	0x96, 0xe6, 0xef, 0x3b, 0xa4, 0x5e, 0x76, 0xec, 0x7d, 0xb3, 0x86, 0x3e, 0x0d, 0xd3, 0xba, 0x63,
	0xfb, 0x9a, 0x69, 0x63, 0xa2, 0x12, 0x5c, 0x33, 0x3d, 0x9f, 0xb4, 0x54, 0x57, 0xf3, 0x0f, 0xc4,
	0xc2, 0x93, 0xe1, 0xb0, 0x22, 0x46, 0xb7, 0x34, 0xff, 0x00, 0x5d, 0x87, 0xa9, 0xc0, 0x59, 0xa8,
	0xcd, 0xba, 0x6a, 0xd6, 0xb5, 0x1a, 0xe6, 0xd3, 0x38, 0x6f, 0xe3, 0xc1, 0xe8, 0x6e, 0x7d, 0x95,
	0x8e, 0xb1, 0x49, 0x37, 0x60, 0xcc, 0x76, 0x7c, 0x73, 0xbf, 0xa5, 0xea, 0x3e, 0xb1, 0x54, 0xcd,
	0x30, 0x88, 0xc7, 0x8c, 0x31, 0xb5, 0x94, 0x7a, 0xef, 0x83, 0x73, 0x83, 0xb6, 0xa3, 0xd7, 0x5d,
	0x65, 0x94, 0xe3, 0x94, 0x7d, 0x62, 0x95, 0x28, 0x06, 0x2a, 0xc0, 0x88, 0x6f, 0x79, 0xaa, 0x8e,
	0x89, 0xaf, 0xee, 0x9b, 0x16, 0x66, 0x16, 0x93, 0x52, 0xd2, 0xbe, 0xe5, 0x95, 0x31, 0xf1, 0x6f,
	0x9a, 0x16, 0x46, 0xb3, 0x90, 0xa1, 0x38, 0x87, 0xb8, 0xc5, 0x51, 0x26, 0x18, 0x0a, 0xf8, 0x96,
	0xb7, 0x86, 0x5b, 0x0c, 0x63, 0x06, 0xd2, 0x8c, 0x8a, 0xc6, 0x11, 0x26, 0x19, 0x42, 0x8a, 0xd2,
	0xd0, 0xd8, 0xf8, 0x1b, 0x70, 0x16, 0xdb, 0x4d, 0xb5, 0xa9, 0x11, 0x79, 0x88, 0x6d, 0xde, 0x73,
	0x91, 0xcd, 0x8b, 0x6b, 0x6d, 0xae, 0x62, 0x37, 0x77, 0x35, 0xc2, 0xf7, 0x6e, 0x08, 0xb3, 0x0f,
	0x54, 0x84, 0x8c, 0x2b, 0xb0, 0x54, 0x5f, 0xab, 0xc9, 0xc3, 0x9d, 0x72, 0xa5, 0x83, 0xe1, 0x6d,
	0xad, 0x86, 0xce, 0x43, 0xca, 0xc7, 0x9e, 0xaf, 0xd6, 0x1d, 0x03, 0xcb, 0xa9, 0x59, 0xe9, 0xca,
	0xb0, 0x32, 0x4c, 0x01, 0x1b, 0x8e, 0x81, 0xd1, 0x45, 0x18, 0xf0, 0x5c, 0xcd, 0x96, 0xa1, 0x93,
	0x04, 0x03, 0xa3, 0xcb, 0x90, 0xd1, 0x2d, 0xac, 0xd9, 0x0d, 0x97, 0x4f, 0x4f, 0xb3, 0xe9, 0x69,
	0x01, 0x63, 0x14, 0xa6, 0x60, 0x88, 0x6e, 0xa6, 0x63, 0xcb, 0x19, 0x26, 0xa7, 0xf8, 0x42, 0x2f,
	0x42, 0x8e, 0xba, 0x36, 0x4c, 0x74, 0x53, 0xb3, 0x98, 0x46, 0x3d, 0x79, 0x84, 0x4d, 0x1f, 0x6d,
	0xc3, 0xa9, 0x52, 0x99, 0xd6, 0x1b, 0x1e, 0x56, 0x9b, 0x5a, 0xc3, 0xf2, 0x55, 0xf7, 0xd0, 0x94,
	0xb3, 0x7c, 0x99, 0x86, 0x87, 0x77, 0x29, 0x6c, 0xeb, 0xd0, 0xa4, 0x5a, 0xa7, 0x27, 0xd1, 0xb0,
	0x3d, 0x95, 0x38, 0x8e, 0x2f, 0xe7, 0xb8, 0xd6, 0x35, 0xd7, 0x5d, 0xb6, 0x3d, 0xc5, 0x71, 0x7c,
	0x74, 0x05, 0x72, 0xfa, 0x01, 0xde, 0x57, 0x3d, 0x4c, 0x9a, 0x98, 0x70, 0x0b, 0x19, 0x63, 0x58,
	0x59, 0x0a, 0xaf, 0x32, 0x30, 0x33, 0x8e, 0x37, 0x60, 0x82, 0x61, 0xea, 0x96, 0x89, 0x6d, 0x5f,
	0x35, 0xe9, 0x31, 0x69, 0x6a, 0x96, 0x8c, 0x66, 0xa5, 0x2b, 0x83, 0x1d, 0x27, 0x1b, 0x51, 0xcc,
	0x32, 0x43, 0x5c, 0x15, 0x78, 0xe8, 0x39, 0xc8, 0x1a, 0xd8, 0xb5, 0x9c, 0x56, 0x9d, 0x4e, 0xa7,
	0x3b, 0x30, 0xce, 0xd6, 0x19, 0x69, 0x43, 0xa9, 0xe2, 0xdf, 0x80, 0x29, 0x9d, 0xd4, 0x55, 0x4d,
	0xd7, 0xb1, 0xe7, 0xa9, 0x2e, 0x31, 0x9b, 0xd4, 0x29, 0xd1, 0x83, 0x36, 0xd5, 0xa9, 0xed, 0x71,
	0x9d, 0xd4, 0x4b, 0x0c, 0x6f, 0x8b, 0xa3, 0xad, 0xe1, 0x16, 0x7a, 0x05, 0x46, 0xc5, 0x5c, 0xcd,
	0x35, 0x99, 0x09, 0xcb, 0xd3, 0x9d, 0x13, 0x47, 0x38, 0x46, 0xc9, 0x35, 0xa9, 0x01, 0xd3, 0xbd,
	0xd6, 0x35, 0xfd, 0x00, 0xab, 0x86, 0x49, 0x64, 0x99, 0x31, 0x35, 0xcc, 0x00, 0xcb, 0x26, 0x41,
	0x6f, 0xc2, 0xac, 0x87, 0x75, 0xc7, 0x36, 0x34, 0xd2, 0x52, 0x7b, 0x70, 0x76, 0xae, 0x73, 0x81,
	0x0b, 0xe1, 0x94, 0x72, 0x37, 0x8b, 0xf9, 0xcf, 0x42, 0x3a, 0x62, 0xa0, 0x27, 0xf1, 0x23, 0x85,
	0x9f, 0xf7, 0x41, 0x36, 0x70, 0x54, 0x0a, 0xf6, 0x36, 0x34, 0x17, 0x2d, 0xb6, 0xa7, 0xf7, 0x76,
	0x81, 0xb9, 0xfb, 0x0f, 0xe4, 0xe1, 0x00, 0xd0, 0x76, 0x87, 0x6f, 0xc2, 0xd9, 0xba, 0xe6, 0xba,
	0xa6, 0x5d, 0x93, 0xfb, 0x7a, 0x3a, 0x44, 0xbe, 0xce, 0xdc, 0x06, 0x47, 0x64, 0x3c, 0x2f, 0x8d,
	0xde, 0x7f, 0x20, 0xa7, 0x15, 0xec, 0x6d, 0x6b, 0xb5, 0x6d, 0x9a, 0x5e, 0x28, 0x01, 0x9d, 0xfc,
	0x22, 0x64, 0xa2, 0x98, 0x27, 0xf2, 0x92, 0x7f, 0x20, 0xbd, 0x7f, 0x2c, 0xdf, 0x09, 0x3c, 0xd3,
	0xeb, 0x6b, 0xb8, 0x35, 0x77, 0x5b, 0xab, 0xe3, 0x62, 0x00, 0xb9, 0xe6, 0x90, 0x1a, 0x83, 0x46,
	0xbd, 0x66, 0x71, 0x1f, 0x1b, 0x34, 0xf6, 0x63, 0x23, 0x1c, 0xbe, 0x19, 0x40, 0xa2, 0x78, 0xdf,
	0x3d, 0x96, 0xcf, 0xf5, 0x1c, 0xfc, 0xe7, 0x63, 0xf9, 0xac, 0x60, 0xbb, 0xb0, 0x07, 0xe9, 0x55,
	0x9a, 0x17, 0x09, 0x0f, 0xbc, 0x00, 0x93, 0xf8, 0x1d, 0x1e, 0x12, 0x54, 0x1b, 0xfb, 0x6f, 0x3b,
	0xe4, 0x50, 0xb5, 0xb5, 0x3a, 0x16, 0x22, 0x8d, 0x07, 0x83, 0xb7, 0xf9, 0x18, 0x65, 0x18, 0x5d,
	0x82, 0x34, 0xcf, 0xcb, 0x38, 0x26, 0x17, 0x14, 0x38, 0x88, 0x22, 0x14, 0xf6, 0x60, 0x44, 0x11,
	0x69, 0xd7, 0x9b, 0x0d, 0xc7, 0xd7, 0x10, 0x82, 0x81, 0x08, 0x51, 0xf6, 0x3b, 0xae, 0xa8, 0x01,
	0xa1, 0x28, 0xf4, 0x02, 0x8c, 0x6a, 0x16, 0x75, 0xb5, 0xfe, 0x01, 0xc1, 0xde, 0x81, 0x63, 0x19,
	0xcc, 0x45, 0x0f, 0x2a, 0x59, 0x06, 0xde, 0x0e, 0xa0, 0x85, 0x06, 0x64, 0x56, 0xb6, 0x76, 0x96,
	0x89, 0xd9, 0xc4, 0x84, 0x9e, 0x8c, 0xcb, 0xd1, 0x25, 0x96, 0x46, 0x7e, 0xf2, 0x40, 0x4e, 0xd5,
	0xdc, 0x86, 0xc1, 0xc6, 0xc5, 0x8a, 0x9f, 0x82, 0x8c, 0x13, 0xd1, 0x0a, 0x67, 0x7c, 0x29, 0xf7,
	0x93, 0x07, 0x72, 0x26, 0x44, 0x75, 0x48, 0x4d, 0x89, 0x61, 0x2d, 0x66, 0x68, 0x70, 0xfb, 0xd5,
	0x2f, 0x65, 0xe9, 0x47, 0xdf, 0xb9, 0x24, 0x15, 0xbe, 0xd1, 0x07, 0xd9, 0x70, 0xdd, 0xa5, 0x86,
	0x69, 0x19, 0x89, 0xc2, 0x5d, 0x82, 0x34, 0xa7, 0x17, 0x8d, 0x4a, 0xc0, 0x41, 0xcc, 0xdf, 0x5c,
	0x85, 0xb1, 0x08, 0x82, 0xaa, 0x13, 0x6c, 0x88, 0x60, 0xa4, 0x8c, 0xb6, 0xd1, 0xca, 0x14, 0x8c,
	0x5e, 0x83, 0x9c, 0xc3, 0x13, 0x40, 0xbb, 0xa6, 0x7a, 0x2d, 0xcf, 0xc7, 0x75, 0x96, 0xfb, 0x64,
	0x17, 0xc6, 0x22, 0x06, 0xbd, 0x59, 0xdd, 0x6e, 0xb9, 0x58, 0x19, 0x0d, 0x51, 0xab, 0x0c, 0x93,
	0x7a, 0xa6, 0x43, 0x4c, 0x6c, 0x6c, 0xa9, 0x4d, 0x4c, 0x3c, 0x2a, 0x37, 0x0f, 0x60, 0x23, 0x1c,
	0xba, 0xcb, 0x81, 0x54, 0xf1, 0x07, 0x2d, 0x17, 0x93, 0xa6, 0xe9, 0x39, 0x34, 0x61, 0xdb, 0x77,
	0x58, 0x56, 0x93, 0x52, 0xb2, 0x6d, 0xf0, 0xaa, 0xbd, 0xef, 0x50, 0xe7, 0x5e, 0x37, 0x6e, 0x78,
	0x8d, 0xba, 0x7c, 0x96, 0x3b, 0x77, 0xfe, 0x55, 0xf8, 0x85, 0x04, 0x13, 0x71, 0xcd, 0x6c, 0xe0,
	0xfa, 0x1e, 0x26, 0x68, 0x3e, 0x7a, 0x84, 0xa7, 0x23, 0x1c, 0x47, 0xf7, 0x2f, 0x9a, 0xc6, 0xdc,
	0x80, 0xc1, 0x3d, 0x3a, 0x5f, 0x24, 0x3e, 0xe7, 0x92, 0xa6, 0xb0, 0x05, 0xc4, 0x24, 0x8e, 0x4d,
	0x03, 0x93, 0x59, 0xb3, 0x1d, 0x82, 0x55, 0xcf, 0xd7, 0x7c, 0xcc, 0xb4, 0x39, 0xac, 0xa4, 0x39,
	0xac, 0x4a, 0x41, 0x8b, 0x1b, 0xef, 0x1f, 0xcb, 0x37, 0xc2, 0xbd, 0xa6, 0x3b, 0xd5, 0x3e, 0x86,
	0x21, 0x38, 0xf1, 0x1c, 0x26, 0x66, 0x34, 0x3a, 0x8c, 0xc5, 0x19, 0xda, 0x51, 0xd6, 0xd1, 0xb3,
	0x90, 0x65, 0xfc, 0xa8, 0x0d, 0x62, 0x45, 0x53, 0x99, 0x0c, 0x83, 0xee, 0x10, 0x8b, 0xed, 0xff,
	0x15, 0x18, 0x6e, 0x6a, 0x96, 0x69, 0x98, 0x7e, 0x2b, 0x31, 0xbb, 0x0e, 0x47, 0x0b, 0x5f, 0x1d,
	0x84, 0x54, 0xb8, 0x4a, 0xcf, 0x54, 0x71, 0x3e, 0x9a, 0x2a, 0x3e, 0x8e, 0x92, 0x3f, 0x03, 0x43,
	0x8c, 0xa1, 0x20, 0x59, 0x7c, 0xa4, 0x96, 0x05, 0x3a, 0xb5, 0x27, 0xcb, 0xd4, 0xb1, 0xed, 0x61,
	0x55, 0x67, 0x3e, 0x84, 0xd9, 0x62, 0x4a, 0x19, 0x11, 0xd0, 0xb6, 0x63, 0x89, 0xa3, 0xa9, 0xc2,
	0x6a, 0xb8, 0xf5, 0x8d, 0xc7, 0xb0, 0x37, 0xd8, 0x10, 0x5a, 0x06, 0xa0, 0xa9, 0x28, 0x26, 0xbe,
	0x89, 0x3d, 0x91, 0x07, 0x3d, 0x9b, 0xc4, 0x17, 0xcb, 0x5e, 0x39, 0x1a, 0x4f, 0x83, 0x22, 0xf3,
	0xa8, 0x63, 0xe1, 0x06, 0xc0, 0xed, 0x93, 0x7f, 0x74, 0x59, 0xc7, 0x70, 0x97, 0x75, 0xa0, 0x97,
	0x68, 0x0c, 0x67, 0x09, 0xbe, 0x4b, 0xb0, 0xab, 0x11, 0x91, 0x1a, 0x2d, 0x0d, 0xfc, 0xe0, 0x48,
	0x96, 0x68, 0x24, 0xa7, 0x63, 0x5b, 0x7c, 0x28, 0xff, 0x3a, 0x8c, 0x76, 0x30, 0x71, 0xa2, 0x60,
	0xf0, 0xf7, 0x52, 0x67, 0xce, 0xfc, 0xcd, 0x23, 0x59, 0xfa, 0xd1, 0x91, 0x2c, 0x7d, 0x78, 0x24,
	0x4b, 0xef, 0x1d, 0xcb, 0x2f, 0x30, 0x9e, 0x8a, 0xeb, 0x1d, 0x6a, 0xaa, 0x36, 0xea, 0xc5, 0xe5,
	0x28, 0x23, 0xa7, 0xb6, 0xe8, 0xef, 0x1e, 0xcb, 0xb9, 0xc7, 0xb1, 0xf2, 0x2f, 0xff, 0x0f, 0x73,
	0x8f, 0x5c, 0xf1, 0x25, 0xd7, 0x2c, 0x7c, 0xd8, 0xc7, 0x0c, 0x52, 0xec, 0xf3, 0x12, 0x0c, 0xf1,
	0x45, 0x1e, 0x75, 0xc0, 0xc7, 0xee, 0x3f, 0x90, 0xdb, 0x86, 0xcc, 0x4d, 0x8a, 0xcf, 0xec, 0xd8,
	0xf7, 0xbe, 0xa4, 0x7d, 0x17, 0xa9, 0xef, 0xc3, 0xf6, 0xbd, 0xdb, 0x30, 0xfb, 0x4f, 0x64, 0x98,
	0x03, 0x3d, 0x0d, 0xf3, 0x49, 0x37, 0x7b, 0xfa, 0xbd, 0x63, 0x79, 0x3c, 0x61, 0x27, 0x0b, 0x9f,
	0xcc, 0x40, 0x98, 0xb7, 0x3c, 0xb5, 0x2a, 0xf0, 0x73, 0x30, 0x6c, 0x39, 0x3a, 0x0f, 0x71, 0x83,
	0x6c, 0xd2, 0xc5, 0x39, 0x83, 0xd6, 0x4e, 0xe6, 0x5e, 0xc3, 0xc7, 0x86, 0xca, 0xfa, 0x0e, 0x2a,
	0xef, 0x3b, 0xcc, 0xad, 0x3b, 0xba, 0x98, 0x1b, 0x4e, 0x42, 0xd7, 0x01, 0x4c, 0x57, 0xf5, 0x1a,
	0xae, 0xeb, 0x10, 0x5e, 0xdb, 0x66, 0x17, 0x26, 0x22, 0xeb, 0xae, 0xba, 0x55, 0x3e, 0xa6, 0xa4,
	0xcc, 0xe0, 0x27, 0xba, 0x08, 0x40, 0x0f, 0x96, 0xa9, 0xab, 0xa6, 0xeb, 0x89, 0xa3, 0x97, 0xe2,
	0x90, 0x55, 0xd7, 0x43, 0xcf, 0xc3, 0xa8, 0xdd, 0xa8, 0xab, 0x46, 0xcb, 0xd6, 0xea, 0x02, 0x67,
	0x98, 0xc5, 0xf5, 0x11, 0xbb, 0x51, 0x5f, 0xe6, 0x50, 0x8a, 0x57, 0x81, 0x34, 0x2d, 0xaa, 0x55,
	0x8b, 0x35, 0x39, 0xd8, 0x01, 0x4c, 0x2f, 0xcc, 0x44, 0xc3, 0x5c, 0x77, 0x2b, 0x44, 0x08, 0x00,
	0x7e, 0xbb, 0x39, 0xf2, 0x1c, 0x0c, 0x61, 0x42, 0x1c, 0xe2, 0xc9, 0x40, 0x75, 0xb9, 0x34, 0x42,
	0x8f, 0x70, 0x3b, 0x83, 0x15, 0x83, 0xe8, 0xf3, 0x30, 0x44, 0x59, 0x6c, 0x78, 0xac, 0x8a, 0x49,
	0x2f, 0x4c, 0x46, 0x16, 0xaa, 0xb2, 0x01, 0x1a, 0xf2, 0x96, 0xc6, 0x62, 0xb3, 0xb9, 0xe9, 0xf2,
	0x79, 0xe8, 0x7a, 0xe0, 0x6c, 0x32, 0x4c, 0x4d, 0x51, 0xeb, 0xdf, 0x26, 0x9a, 0x7e, 0x88, 0x0d,
	0x76, 0x8e, 0x85, 0x0f, 0x11, 0xbe, 0xe8, 0x73, 0x90, 0xa1, 0xb9, 0xb6, 0xd3, 0xc4, 0x84, 0x98,
	0x06, 0x66, 0x35, 0x50, 0x36, 0xbe, 0xb5, 0xca, 0xc6, 0xa6, 0x18, 0x15, 0x53, 0xd3, 0x3a, 0xa9,
	0x07, 0x20, 0x34, 0x0f, 0xb9, 0x48, 0xb5, 0x41, 0x37, 0xce, 0xe2, 0x05, 0x92, 0x40, 0x1e, 0x6d,
	0x8f, 0xae, 0xd3, 0x41, 0xf4, 0x1a, 0x8c, 0xb4, 0xcb, 0xc3, 0x96, 0x8b, 0xe5, 0xd1, 0x2e, 0x76,
	0x83, 0x22, 0x93, 0x65, 0x11, 0x61, 0x31, 0x49, 0xbf, 0xd0, 0x0d, 0x10, 0x55, 0xb1, 0xea, 0x91,
	0x26, 0xaf, 0x3a, 0x72, 0x3c, 0xcd, 0x8a, 0xab, 0x75, 0x84, 0x63, 0x55, 0x49, 0x93, 0x55, 0x1e,
	0xaf, 0xc1, 0x10, 0x4f, 0x0a, 0x59, 0xcd, 0x95, 0x8e, 0xd9, 0xd0, 0x4d, 0x36, 0x40, 0x2d, 0x37,
	0x7b, 0xff, 0x81, 0x3c, 0xc4, 0x3f, 0xb9, 0x66, 0xf9, 0x1c, 0xf4, 0x0c, 0x8c, 0xb8, 0x07, 0x2d,
	0xcf, 0xd4, 0x69, 0x66, 0x4a, 0xf3, 0x2b, 0xc4, 0xc3, 0x68, 0x00, 0x64, 0xa9, 0xe8, 0xab, 0xed,
	0xb2, 0x79, 0x9c, 0xb9, 0x8d, 0x4b, 0x09, 0xe7, 0x23, 0xb1, 0x60, 0x7e, 0x09, 0xc6, 0xda, 0xad,
	0x87, 0x20, 0x33, 0xe2, 0x75, 0x7b, 0x2e, 0x1c, 0x08, 0x92, 0xa3, 0xdf, 0x82, 0x21, 0xe1, 0x52,
	0x26, 0xbb, 0x52, 0x92, 0x78, 0x71, 0xbe, 0x34, 0x4c, 0x55, 0xc2, 0x05, 0xe1, 0x53, 0xd0, 0x1d,
	0x48, 0x13, 0xec, 0xd1, 0x9a, 0x50, 0xad, 0x6b, 0xae, 0x3c, 0xc5, 0xf8, 0x2c, 0x24, 0xf1, 0xc9,
	0x4b, 0x8e, 0x0d, 0xcd, 0xe5, 0x65, 0xc8, 0x38, 0x25, 0xd5, 0x59, 0x8a, 0xa4, 0x48, 0x80, 0x84,
	0x96, 0x21, 0x2d, 0xca, 0xb5, 0xa6, 0x46, 0x3c, 0x79, 0x9a, 0x11, 0x7e, 0x26, 0x89, 0x30, 0x2f,
	0xd2, 0x76, 0x35, 0x12, 0xb8, 0x4d, 0x2d, 0x04, 0xd0, 0x1a, 0x39, 0x6c, 0xa1, 0x04, 0x7a, 0xe0,
	0x65, 0x62, 0xb6, 0xc9, 0xbb, 0x27, 0x81, 0x16, 0x66, 0x00, 0xda, 0x76, 0x25, 0xe7, 0x45, 0x4e,
	0x1b, 0x42, 0x50, 0x19, 0x72, 0xac, 0xe5, 0xca, 0x6b, 0x53, 0xb6, 0x82, 0x7c, 0x9e, 0xd9, 0x59,
	0x54, 0x5f, 0xac, 0xfa, 0xa0, 0xc5, 0x29, 0x43, 0x50, 0xb2, 0x66, 0xec, 0x9b, 0x9e, 0x0d, 0x4e,
	0x44, 0x28, 0xfc, 0x42, 0x97, 0xdb, 0x8b, 0x94, 0x2f, 0xe2, 0xe4, 0xa7, 0xcd, 0x48, 0x45, 0xb3,
	0x0d, 0xa3, 0xd1, 0x4a, 0x9e, 0xba, 0xce, 0x8b, 0x3d, 0xab, 0xbf, 0xb9, 0x72, 0x58, 0xca, 0xaf,
	0xe1, 0x16, 0x57, 0xbb, 0x08, 0xf7, 0x7a, 0x74, 0x04, 0xdd, 0x81, 0xb1, 0xba, 0x66, 0xda, 0x3e,
	0xb6, 0x35, 0x5b, 0x0f, 0x72, 0x88, 0x19, 0x26, 0xdc, 0xd5, 0xde, 0xde, 0x75, 0xa3, 0x3d, 0x85,
	0xb9, 0x01, 0x25, 0x57, 0xef, 0x80, 0xa0, 0x55, 0xb8, 0x1c, 0xf8, 0x01, 0xd5, 0x75, 0x2c, 0x53,
	0x6f, 0xa9, 0xdd, 0x76, 0x79, 0x89, 0x25, 0x2b, 0x33, 0x01, 0xe2, 0x16, 0xc3, 0x2b, 0x77, 0x5a,
	0xe9, 0x33, 0x70, 0xb6, 0x59, 0x57, 0x5d, 0xc7, 0xb1, 0xe4, 0x59, 0x76, 0x3c, 0x81, 0x1e, 0xad,
	0xdd, 0x8d, 0x2d, 0xc7, 0xb1, 0x94, 0xa1, 0x66, 0x9d, 0xfe, 0x8f, 0x3e, 0x0f, 0x93, 0xd1, 0x3a,
	0xbf, 0xb1, 0x67, 0x99, 0x3a, 0x53, 0xd2, 0xe5, 0xa4, 0x13, 0x8d, 0xda, 0x4d, 0x08, 0x86, 0x49,
	0x55, 0xf1, 0xdb, 0x70, 0x29, 0x42, 0xe1, 0x10, 0xb7, 0xd4, 0x86, 0x5b, 0x23, 0x9a, 0x81, 0x55,
	0x82, 0xef, 0x36, 0x4c, 0x82, 0x0d, 0xb9, 0x10, 0xf1, 0x45, 0xe7, 0x43, 0x12, 0x6b, 0xb8, 0xb5,
	0xc3, 0x31, 0x15, 0x81, 0x88, 0xbe, 0x08, 0xc0, 0x1b, 0xb6, 0x86, 0xaa, 0xf9, 0xf2, 0x33, 0x6c,
	0xaf, 0x9f, 0xe9, 0xad, 0x4f, 0xea, 0xf3, 0x3d, 0x5f, 0xab, 0xbb, 0x4b, 0x93, 0x82, 0xcf, 0x94,
	0x1f, 0x80, 0x98, 0x25, 0xa4, 0x04, 0xb5, 0x92, 0x4f, 0x49, 0xf3, 0x36, 0x2e, 0x23, 0xfd, 0xec,
	0x93, 0x93, 0x16, 0xd4, 0x4a, 0x3e, 0x5a, 0x80, 0x8c, 0x4f, 0x1a, 0x9e, 0x2f, 0x36, 0x4c, 0x7e,
	0x8e, 0xa9, 0x8e, 0x75, 0x0d, 0xb6, 0x29, 0x9c, 0xef, 0x8f, 0x92, 0xf6, 0xdb, 0x1f, 0x68, 0x0d,
	0x50, 0x74, 0x8e, 0xb0, 0xa0, 0xe7, 0x1f, 0x27, 0x6a, 0xe4, 0x22, 0x74, 0xb8, 0xd1, 0xac, 0xc0,
	0x68, 0x70, 0xaf, 0xa1, 0xde, 0xa5, 0x15, 0xb6, 0x27, 0xbf, 0xc0, 0x6c, 0x5c, 0x8e, 0x50, 0x8a,
	0x95, 0xe0, 0xe2, 0xa4, 0x64, 0x49, 0x14, 0xe8, 0xa1, 0x15, 0x98, 0x35, 0xf0, 0x3e, 0x6b, 0xb2,
	0x85, 0x04, 0x3b, 0xeb, 0xef, 0x2b, 0x2c, 0x4e, 0x5f, 0x14, 0x78, 0x01, 0xd5, 0x52, 0xac, 0x1c,
	0x47, 0x37, 0x20, 0x7b, 0xcb, 0xf1, 0x7c, 0x6a, 0x93, 0xc4, 0xb1, 0x2c, 0x4c, 0xe4, 0x17, 0x93,
	0xec, 0xa9, 0x03, 0x89, 0x3a, 0xf9, 0x43, 0x6d, 0xff, 0x50, 0x0b, 0x6e, 0x0a, 0xe4, 0xab, 0xdc,
	0xc9, 0x33, 0xa0, 0xb8, 0x0d, 0xa0, 0xa9, 0x05, 0x47, 0x6a, 0x78, 0x98, 0xc8, 0x2f, 0xf1, 0xd4,
	0x82, 0x41, 0x76, 0x3c, 0x4c, 0x58, 0x81, 0xcb, 0x86, 0x5d, 0xcd, 0xf3, 0xde, 0x76, 0x88, 0x21,
	0x17, 0x45, 0x81, 0x4b, 0xa1, 0x5b, 0x02, 0x88, 0x3e, 0x0b, 0x50, 0x73, 0x1b, 0x81, 0x5b, 0xb9,
	0xd6, 0x15, 0x91, 0xc2, 0x24, 0x53, 0xa8, 0x2a, 0x55, 0x73, 0x1b, 0xc2, 0xa5, 0xac, 0xc2, 0x65,
	0x6c, 0x53, 0xef, 0xab, 0x06, 0xca, 0xe2, 0x0d, 0x45, 0x8b, 0x1e, 0x80, 0x80, 0xf3, 0x39, 0x7e,
	0x46, 0x39, 0xe2, 0x32, 0xc7, 0xab, 0x86, 0x68, 0x81, 0x2c, 0xcf, 0xc0, 0x88, 0x66, 0x59, 0x26,
	0x73, 0x22, 0x0e, 0xa9, 0x79, 0xf2, 0x3c, 0xcb, 0xf5, 0x32, 0x01, 0x70, 0x93, 0xd4, 0x68, 0x12,
	0x74, 0xc9, 0x33, 0xed, 0x9a, 0x85, 0xd5, 0xc3, 0xc6, 0x1e, 0xad, 0xd2, 0x7d, 0x1c, 0xae, 0xa3,
	0x3a, 0x6f, 0xdb, 0x98, 0xc8, 0x2f, 0x33, 0x11, 0x2f, 0x70, 0xb4, 0xb5, 0x10, 0x4b, 0x2c, 0xb3,
	0x49, 0x71, 0x12, 0xea, 0x99, 0x57, 0x7a, 0xd6, 0x33, 0xe8, 0x35, 0xc8, 0x87, 0x19, 0xc2, 0x81,
	0x59, 0x3b, 0x50, 0xb5, 0xa6, 0x66, 0x5a, 0xda, 0x9e, 0x69, 0xd1, 0x12, 0x75, 0x81, 0x09, 0x27,
	0x07, 0x18, 0xb7, 0xcc, 0xda, 0x41, 0x29, 0x32, 0x8e, 0xaa, 0x70, 0x29, 0xb9, 0x8f, 0xd8, 0xf6,
	0x2f, 0xd7, 0x93, 0xec, 0xe1, 0x7c, 0x42, 0x2b, 0x31, 0x74, 0x34, 0xbf, 0x03, 0x2f, 0x26, 0x12,
	0x4d, 0x74, 0x39, 0x9f, 0x8a, 0x88, 0xf6, 0x6c, 0x37, 0xd5, 0x04, 0xdf, 0x73, 0x0b, 0xce, 0xb5,
	0xc9, 0x77, 0xe6, 0x37, 0x37, 0x92, 0xb8, 0x9d, 0x0a, 0xf1, 0x6f, 0xc7, 0x12, 0x9d, 0xcb, 0x90,
	0x32, 0x6c, 0x4f, 0xb5, 0xb4, 0x3d, 0x6c, 0xc9, 0x9f, 0x66, 0x33, 0x39, 0x23, 0xc3, 0x86, 0xed,
	0xad, 0x53, 0x28, 0x7a, 0x1e, 0x32, 0xc4, 0x71, 0x7c, 0xd5, 0xda, 0x53, 0xf7, 0xef, 0x1a, 0xb6,
	0xfc, 0x99, 0x08, 0x16, 0xd0, 0x91, 0xf5, 0xbd, 0x9b, 0x77, 0x0d, 0xfb, 0x09, 0xba, 0xa7, 0xf9,
	0x3b, 0x90, 0x8d, 0x27, 0x10, 0x09, 0xb3, 0xe7, 0xa3, 0xb3, 0xe3, 0x79, 0x4c, 0x24, 0xc9, 0x58,
	0xc3, 0xad, 0x28, 0xe1, 0xd7, 0x61, 0xb4, 0x23, 0x81, 0x38, 0x11, 0x5f, 0x9f, 0x07, 0xd4, 0x1d,
	0x65, 0x4f, 0x54, 0x3f, 0xfd, 0xc3, 0x40, 0xaf, 0x62, 0xf9, 0x27, 0x47, 0x72, 0x26, 0xea, 0x31,
	0x69, 0xf1, 0xfc, 0x11, 0x2f, 0xa0, 0x8f, 0xfa, 0xd6, 0x45, 0x41, 0x33, 0x77, 0xcb, 0x21, 0xe6,
	0xbb, 0x34, 0x5a, 0x5a, 0x25, 0x5d, 0x6f, 0x10, 0x4d, 0x6f, 0x15, 0xc3, 0xb1, 0x5d, 0x5a, 0xd4,
	0xe9, 0x49, 0x23, 0x65, 0xa7, 0x41, 0x3c, 0xdc, 0xfe, 0xae, 0xba, 0x18, 0x1b, 0xed, 0xcf, 0x30,
	0x60, 0x14, 0x79, 0xa5, 0x50, 0xe4, 0xce, 0xa2, 0x18, 0x93, 0xb5, 0xc8, 0xab, 0xf8, 0x0a, 0x2b,
	0x37, 0x8a, 0xdd, 0x36, 0x5e, 0x7c, 0x88, 0x81, 0x16, 0xab, 0xbd, 0xcf, 0x46, 0xc2, 0x58, 0x02,
	0x81, 0x72, 0x10, 0x0c, 0x8b, 0x3b, 0x41, 0xec, 0x2a, 0x6e, 0x77, 0xc4, 0x92, 0x62, 0xdc, 0x23,
	0xc7, 0x9b, 0x0b, 0xc5, 0x95, 0xc0, 0x07, 0xce, 0x25, 0x36, 0x22, 0x84, 0x75, 0x17, 0x95, 0xd0,
	0x80, 0x7f, 0x53, 0x2d, 0xee, 0x8f, 0x8f, 0xe5, 0xfe, 0x35, 0xdc, 0x4a, 0x6c, 0xd3, 0x7d, 0xbf,
	0x0f, 0xd2, 0xbc, 0xc0, 0xd8, 0xa0, 0x11, 0x3f, 0x28, 0xa8, 0xa5, 0xc7, 0x2d, 0xa8, 0x3b, 0xfa,
	0xdd, 0xfd, 0x9d, 0xfd, 0x6e, 0x5a, 0x4b, 0x44, 0xbd, 0xa5, 0xfa, 0xae, 0x63, 0x63, 0xd1, 0x4e,
	0xc8, 0x45, 0x07, 0xde, 0x72, 0x6c, 0xbc, 0xf8, 0x4d, 0xe9, 0xfd, 0x63, 0xd9, 0x3c, 0xb1, 0x8e,
	0xd8, 0x6a, 0xaf, 0xdf, 0x0c, 0x17, 0x7d, 0x5a, 0x17, 0x03, 0xd0, 0x26, 0x59, 0x98, 0x6b, 0xdf,
	0x4d, 0x6f, 0x68, 0xb6, 0xb9, 0x8f, 0x3d, 0x1f, 0xe5, 0x61, 0xb8, 0x2e, 0x7e, 0x8b, 0x83, 0x19,
	0x7e, 0x17, 0x7e, 0x28, 0x41, 0x46, 0xf4, 0x45, 0x5a, 0xac, 0x37, 0x9c, 0xd4, 0x0a, 0x9f, 0x85,
	0xb4, 0x81, 0x3d, 0x9d, 0x98, 0x6e, 0xbb, 0xe9, 0xae, 0x44, 0x41, 0xed, 0x83, 0xdf, 0x1f, 0x39,
	0xf8, 0x68, 0x0a, 0x86, 0x3c, 0xac, 0x13, 0xcc, 0xef, 0xf9, 0x87, 0x15, 0xf1, 0x85, 0x2e, 0x40,
	0xaa, 0xae, 0xd9, 0x86, 0xe6, 0x3b, 0xa4, 0xc5, 0xfa, 0x1b, 0xc3, 0x4a, 0x1b, 0x40, 0xd9, 0x35,
	0xc5, 0x15, 0x37, 0xeb, 0x5c, 0x0c, 0x2b, 0xe1, 0x77, 0xe1, 0xeb, 0x7d, 0x30, 0x12, 0xc8, 0xc7,
	0x6e, 0xba, 0xbb, 0xcb, 0x62, 0xe9, 0x24, 0x65, 0xf1, 0xad, 0x84, 0xb6, 0xd5, 0x95, 0x04, 0x73,
	0x62, 0x6b, 0x3d, 0xb4, 0x75, 0x55, 0xe8, 0xb8, 0x99, 0xe0, 0x8a, 0x88, 0xc1, 0xf2, 0xbb, 0x8f,
	0xd3, 0x83, 0xba, 0x16, 0xf7, 0xef, 0x31, 0x41, 0x22, 0x1b, 0x15, 0xbd, 0x74, 0xfb, 0x47, 0x09,
	0xf2, 0x91, 0xcb, 0xb0, 0x76, 0x76, 0xf8, 0x34, 0x54, 0xf4, 0x46, 0x82, 0x8a, 0xe4, 0xce, 0x5a,
	0x2e, 0x58, 0x35, 0xe8, 0xe3, 0x9c, 0x4c, 0x31, 0x85, 0x3f, 0xeb, 0x83, 0xc9, 0x4e, 0x01, 0x76,
	0x3c, 0xad, 0x86, 0x4f, 0x73, 0xd0, 0x79, 0xed, 0xd9, 0xa0, 0xd3, 0x99, 0x0e, 0x87, 0x15, 0x60,
	0x20, 0x4e, 0x70, 0x01, 0x06, 0xd8, 0xcd, 0x48, 0xff, 0x63, 0x09, 0xc2, 0x70, 0x17, 0xdf, 0xf9,
	0x4d, 0xb9, 0xc4, 0xc2, 0x57, 0xfb, 0x60, 0x3c, 0x90, 0xb4, 0xd4, 0xce, 0x2f, 0x4f, 0xac, 0x96,
	0x42, 0xd2, 0xbd, 0x59, 0xc7, 0x2d, 0xd9, 0x77, 0xa9, 0x57, 0xbb, 0x7b, 0x52, 0x31, 0x83, 0xac,
	0x97, 0x8d, 0x3a, 0xbf, 0x86, 0x6b, 0xcf, 0x4c, 0x4c, 0x21, 0xff, 0x21, 0x81, 0x70, 0x77, 0x3d,
	0xbd, 0x15, 0xf5, 0x45, 0xba, 0xdb, 0xf0, 0xc2, 0x5b, 0x49, 0xfa, 0x41, 0x0f, 0x1a, 0xd1, 0xea,
	0xcc, 0xfa, 0x06, 0x14, 0xfa, 0x93, 0xce, 0x35, 0x4c, 0xef, 0x90, 0xf9, 0xa6, 0x01, 0x85, 0xfd,
	0x46, 0x65, 0x18, 0xa6, 0xa6, 0xcb, 0xba, 0x3c, 0x83, 0x5d, 0x5d, 0x9e, 0xf6, 0xc2, 0xec, 0x28,
	0x86, 0x5d, 0x1e, 0x9e, 0x03, 0x9e, 0x75, 0x39, 0x2c, 0xbf, 0xc8, 0x5d, 0xea, 0x43, 0x72, 0xb8,
	0xde, 0xf7, 0xe7, 0x37, 0xe0, 0xec, 0x66, 0xb5, 0x44, 0xa3, 0x4c, 0xa2, 0x6c, 0x53, 0x61, 0xb7,
	0x93, 0xcf, 0x14, 0x5f, 0x05, 0x42, 0xa7, 0xb1, 0x4e, 0x4f, 0xe2, 0x34, 0x04, 0x03, 0xbe, 0x56,
	0x0b, 0x26, 0xb1, 0xdf, 0x68, 0x26, 0x76, 0xae, 0x45, 0x44, 0x8c, 0x9c, 0xdb, 0x4b, 0x90, 0xa6,
	0x2a, 0x51, 0xa9, 0x23, 0xd0, 0x7c, 0x11, 0x0b, 0x81, 0x82, 0x6e, 0x32, 0x48, 0xe1, 0xfb, 0x69,
	0xc8, 0xb4, 0xdf, 0x24, 0xf1, 0x6b, 0xc5, 0xa7, 0xd2, 0xfd, 0x7e, 0x3d, 0x68, 0xc8, 0xf6, 0x33,
	0x3f, 0xf5, 0x42, 0xef, 0x8a, 0x3f, 0x20, 0xc0, 0x3b, 0x33, 0xa2, 0x35, 0xfb, 0x3c, 0xa4, 0x44,
	0x29, 0x60, 0x1a, 0xe2, 0x81, 0x59, 0xe4, 0xe5, 0xc3, 0x30, 0x1f, 0x5b, 0x35, 0xd0, 0x8b, 0x00,
	0x7a, 0xbb, 0xd6, 0x1d, 0xec, 0x7c, 0x22, 0x11, 0x19, 0x44, 0x17, 0x00, 0x1c, 0x4f, 0xad, 0x6b,
	0xef, 0xa8, 0xd4, 0x86, 0x86, 0x98, 0xc1, 0x0c, 0x3b, 0xde, 0x86, 0xf6, 0x8e, 0xa2, 0xd5, 0x51,
	0x01, 0x46, 0xc4, 0x68, 0x53, 0x77, 0x08, 0xe6, 0xad, 0xf3, 0x01, 0x25, 0xcd, 0x10, 0x76, 0x19,
	0x08, 0x5d, 0x6e, 0xe3, 0x38, 0x96, 0x5a, 0xdb, 0x63, 0xad, 0xf3, 0x01, 0x05, 0x38, 0x8e, 0x63,
	0xad, 0xec, 0x51, 0xf5, 0x89, 0x86, 0x77, 0x8a, 0xab, 0x4f, 0x74, 0xb8, 0xe7, 0xe1, 0x2c, 0x4f,
	0x1d, 0x78, 0x27, 0x3c, 0xde, 0xe2, 0x6e, 0x9b, 0xa4, 0x12, 0x60, 0xa1, 0xd7, 0x1e, 0xaf, 0x25,
	0x3e, 0x92, 0xdc, 0x0e, 0x4f, 0xec, 0xaa, 0x66, 0x7a, 0x74, 0x55, 0x4b, 0x80, 0xba, 0xd2, 0x26,
	0x4f, 0x1e, 0x61, 0x6c, 0xa2, 0xd8, 0xcd, 0x36, 0xb3, 0x69, 0x65, 0xac, 0x33, 0x97, 0xa2, 0xe2,
	0xa5, 0x1c, 0x8f, 0x37, 0x2f, 0x3d, 0x39, 0x9b, 0x30, 0x93, 0x99, 0x35, 0x55, 0x37, 0xfb, 0xe1,
	0xa1, 0x45, 0x38, 0xd7, 0xde, 0x1a, 0x95, 0x3f, 0x8c, 0x21, 0x58, 0xc7, 0x66, 0x13, 0x1b, 0xac,
	0x29, 0x3e, 0xac, 0x4c, 0xb7, 0x11, 0xca, 0x74, 0x5c, 0x11, 0xc3, 0xc9, 0x3d, 0xc0, 0xdc, 0x53,
	0xe8, 0x01, 0xbe, 0x05, 0x28, 0x7c, 0xa6, 0xaa, 0x7a, 0xb6, 0xe6, 0x7a, 0x07, 0x8e, 0x2f, 0x9a,
	0xe6, 0x97, 0x7b, 0x05, 0x19, 0xaf, 0x2a, 0x10, 0x23, 0x2d, 0xe7, 0x31, 0xd2, 0x39, 0x88, 0x2a,
	0x89, 0x7d, 0x27, 0xf4, 0xd0, 0xbe, 0x53, 0x42, 0xc7, 0xe9, 0x0d, 0x98, 0xd4, 0x9d, 0xba, 0xab,
	0xf9, 0xa6, 0xd8, 0xac, 0x60, 0x73, 0xc7, 0x67, 0xa5, 0x2b, 0x23, 0x51, 0xd3, 0x9f, 0x88, 0xe1,
	0x05, 0x7b, 0xbd, 0x12, 0x73, 0x18, 0x13, 0x6c, 0xa7, 0x5e, 0x48, 0x7c, 0x9f, 0xb8, 0xef, 0x3c,
	0x34, 0x55, 0x5a, 0x00, 0xb0, 0x1d, 0x03, 0xb3, 0x17, 0x0a, 0x9e, 0x3c, 0xc9, 0x08, 0x8d, 0x47,
	0x08, 0xdd, 0x76, 0x0c, 0xcc, 0x2c, 0x3a, 0x65, 0x8b, 0x5f, 0xd4, 0x87, 0x8c, 0x6b, 0xba, 0x6f,
	0x36, 0x31, 0xeb, 0x22, 0x98, 0xb6, 0xe7, 0x53, 0xdd, 0xf3, 0x27, 0x57, 0xca, 0x18, 0x1f, 0x2a,
	0x93, 0xfa, 0xaa, 0x18, 0xa0, 0xde, 0x8b, 0xfe, 0x32, 0xf6, 0x58, 0xdb, 0x81, 0xbd, 0xb0, 0x1a,
	0x56, 0x40, 0x80, 0xca, 0xe4, 0x89, 0xef, 0x03, 0xff, 0xba, 0xeb, 0xf2, 0xf7, 0x3b, 0xa2, 0x6e,
	0xfd, 0x19, 0xaf, 0x5d, 0x53, 0xe1, 0x26, 0xff, 0xa6, 0x92, 0x87, 0x0f, 0x1e, 0xc8, 0x03, 0xb6,
	0x63, 0xe3, 0xc2, 0x33, 0x30, 0x1a, 0xd6, 0x04, 0xd8, 0x27, 0xa6, 0xce, 0xa2, 0xe1, 0xbe, 0xe3,
	0x30, 0xa7, 0x37, 0xa0, 0xd0, 0x9f, 0x57, 0xbf, 0x3c, 0x00, 0x99, 0x68, 0x16, 0x88, 0xa6, 0x00,
	0x6d, 0xad, 0x97, 0xb6, 0x6f, 0x6e, 0x2a, 0x1b, 0xea, 0xf6, 0x17, 0xb7, 0x2a, 0xea, 0xcd, 0xd2,
	0x5a, 0x25, 0x77, 0xa6, 0x1b, 0xbe, 0xbc, 0x7a, 0x7b, 0x39, 0x27, 0xa1, 0xf3, 0x30, 0x1d, 0x87,
	0x6f, 0x6e, 0x55, 0x6e, 0x57, 0xb7, 0x4b, 0xe5, 0xb5, 0x5c, 0x1f, 0x9a, 0x86, 0xf1, 0xf8, 0x60,
	0xe9, 0xad, 0x1d, 0xa5, 0x92, 0xeb, 0x47, 0x93, 0x30, 0x16, 0x1f, 0x58, 0x29, 0x6f, 0xe5, 0x06,
	0xd0, 0x39, 0x98, 0x8c, 0x83, 0x2b, 0xcb, 0x2b, 0x95, 0xa5, 0xcd, 0x2f, 0xe4, 0x06, 0xbb, 0xd7,
	0xa1, 0x7c, 0xad, 0xde, 0xbe, 0xa9, 0x94, 0x72, 0x43, 0xdd, 0xf3, 0x76, 0xab, 0x5b, 0xb7, 0x2a,
	0x4a, 0x25, 0x77, 0xb6, 0x7b, 0xa8, 0x74, 0xa7, 0xaa, 0x56, 0xd6, 0xaa, 0xb9, 0xe1, 0x84, 0x59,
	0x1b, 0xea, 0xd6, 0xe6, 0xe6, 0x7a, 0x2e, 0xd5, 0x63, 0x56, 0x79, 0x21, 0x07, 0xdd, 0xac, 0xef,
	0x96, 0x97, 0x73, 0x69, 0x34, 0x0b, 0x17, 0xe2, 0xe0, 0xb5, 0x57, 0xab, 0xea, 0x52, 0x49, 0xa9,
	0xa8, 0x1b, 0x95, 0xed, 0xd2, 0x7a, 0x2e, 0xd3, 0xad, 0xc1, 0x35, 0xaa, 0xc1, 0x91, 0x6e, 0xc9,
	0x28, 0x9c, 0x4b, 0x96, 0x45, 0xcf, 0xc1, 0xe5, 0x6e, 0xb1, 0xd5, 0xea, 0xea, 0xed, 0x95, 0xf5,
	0x8a, 0x5a, 0x5e, 0xdf, 0xa9, 0x6e, 0x57, 0x94, 0xdc, 0x28, 0xba, 0x00, 0x72, 0x07, 0x5a, 0x65,
	0xb9, 0xa2, 0x94, 0xb6, 0x57, 0x37, 0x6f, 0xe7, 0x72, 0x68, 0x06, 0xf2, 0x09, 0x44, 0x02, 0x69,
	0xc7, 0xae, 0x2e, 0x42, 0x36, 0x7e, 0xb7, 0x83, 0xc6, 0x60, 0x64, 0x79, 0x55, 0xa9, 0x94, 0xb7,
	0xd5, 0x52, 0xb9, 0x5c, 0xa9, 0x56, 0x73, 0x67, 0xa8, 0xdc, 0x4a, 0xa5, 0xba, 0xad, 0xac, 0x96,
	0xb7, 0x2b, 0xcb, 0x01, 0x58, 0xba, 0x5a, 0x84, 0x21, 0xfe, 0x7e, 0x09, 0xa5, 0x60, 0x70, 0x7d,
	0xf5, 0xf6, 0xce, 0x17, 0x72, 0x67, 0x50, 0x1a, 0xce, 0xde, 0x59, 0xbd, 0xbd, 0xbc, 0x79, 0xa7,
	0x9a, 0x93, 0x10, 0xc0, 0xd0, 0xe6, 0xf6, 0xad, 0x8a, 0x52, 0xcd, 0x4d, 0x5c, 0x65, 0x9d, 0x2e,
	0xd7, 0x21, 0x7e, 0x55, 0x3f, 0xc0, 0x46, 0xc3, 0xc2, 0x68, 0x04, 0x52, 0x95, 0x26, 0x26, 0xad,
	0x3b, 0x18, 0x1f, 0xe6, 0xce, 0xa0, 0x51, 0x48, 0xb3, 0xcf, 0x57, 0x6e, 0x2c, 0x6b, 0x2d, 0x2f,
	0x27, 0x85, 0x80, 0xeb, 0x2f, 0x33, 0x40, 0x1f, 0xca, 0x02, 0x30, 0xc0, 0x86, 0x63, 0xfb, 0x07,
	0xb9, 0xfe, 0xfc, 0xc0, 0xc7, 0x0f, 0xe4, 0x33, 0x0b, 0x7f, 0x97, 0x8e, 0xbc, 0x2a, 0x2b, 0xb9,
	0x26, 0xfa, 0x9e, 0x04, 0xa3, 0xbc, 0x8b, 0xd2, 0x7e, 0x82, 0x33, 0x91, 0xf4, 0xc2, 0x21, 0x3f,
	0x16, 0x6f, 0xa5, 0x35, 0x2c, 0xbf, 0x50, 0xbb, 0x7f, 0x24, 0xcf, 0x07, 0x27, 0x39, 0x38, 0x44,
	0x5e, 0xb1, 0xa4, 0xd3, 0x03, 0xb6, 0xa1, 0xd9, 0x5a, 0x0d, 0x17, 0x3b, 0x0f, 0xef, 0x0f, 0x8e,
	0x65, 0xe9, 0x6f, 0x1e, 0x74, 0xbf, 0xcc, 0xf8, 0xf2, 0xbf, 0xfe, 0xe7, 0xd7, 0xfb, 0xa6, 0x0a,
	0x63, 0xf3, 0xfc, 0x82, 0x63, 0x3e, 0x7c, 0xdb, 0xb1, 0x28, 0x5d, 0x7d, 0x59, 0x42, 0x7f, 0x2c,
	0xc1, 0x28, 0xef, 0xdc, 0x9c, 0x82, 0xcf, 0xea, 0x29, 0xf9, 0x0c, 0x79, 0xe2, 0x9d, 0xe4, 0x4e,
	0x9e, 0x7e, 0x28, 0xc1, 0x28, 0xef, 0x3b, 0x9d, 0x82, 0x27, 0xfb, 0x94, 0x3c, 0x7d, 0x7c, 0x2c,
	0x4f, 0xb3, 0x57, 0x4b, 0x5e, 0x91, 0x9a, 0x53, 0x71, 0xb5, 0xfd, 0xbe, 0x27, 0x64, 0x97, 0x5f,
	0xe4, 0x74, 0xb2, 0xfb, 0x9e, 0x04, 0x23, 0xd5, 0x03, 0xe7, 0xed, 0x47, 0x31, 0x9b, 0x08, 0x65,
	0x3a, 0xbc, 0xd6, 0x8b, 0xdf, 0x5d, 0x13, 0xbf, 0x9d, 0xc8, 0xed, 0x47, 0x81, 0x16, 0x27, 0x0a,
	0xa3, 0xf3, 0xde, 0x81, 0xf3, 0x76, 0x27, 0x53, 0x9f, 0x48, 0x30, 0x56, 0x32, 0x8c, 0x8e, 0x17,
	0x87, 0x97, 0x7a, 0xbe, 0xd5, 0xe2, 0x4f, 0xee, 0x92, 0x14, 0xfa, 0x0d, 0xe9, 0x94, 0x1a, 0xbd,
	0x77, 0x2c, 0xbf, 0xc1, 0x68, 0xf3, 0xd0, 0xc3, 0x7f, 0x2e, 0x87, 0x4f, 0x14, 0x05, 0x40, 0x74,
	0x04, 0xf9, 0xc7, 0x66, 0xfc, 0x09, 0x22, 0x93, 0x50, 0x2e, 0x8c, 0xcf, 0x6b, 0x86, 0xd1, 0x16,
	0x90, 0x3d, 0x27, 0xe3, 0x52, 0xfe, 0x61, 0x1f, 0x4c, 0x28, 0xb8, 0xee, 0x34, 0xf1, 0x53, 0x10,
	0xf4, 0xc7, 0xd2, 0xe9, 0x4d, 0x67, 0xb3, 0x87, 0x74, 0x1d, 0x02, 0x09, 0xe8, 0x5a, 0xf4, 0x01,
	0xa5, 0x80, 0xdd, 0x8a, 0x3d, 0x96, 0xbc, 0x77, 0x2c, 0x43, 0x5b, 0x77, 0x4c, 0x0f, 0xe7, 0x0b,
	0x53, 0xf3, 0x84, 0xc9, 0x9a, 0xa8, 0x8a, 0x0f, 0xfa, 0x60, 0x62, 0x05, 0xfb, 0xdd, 0xcf, 0x0a,
	0x1f, 0xa9, 0x8a, 0x0b, 0x3d, 0x11, 0x76, 0x94, 0xf5, 0xc2, 0xc7, 0xd2, 0x89, 0x0d, 0xf4, 0x23,
	0xae, 0x13, 0xf2, 0x94, 0x75, 0xd2, 0x65, 0x41, 0xec, 0x91, 0x6b, 0xcc, 0x8c, 0x7a, 0xa8, 0xad,
	0x86, 0xfd, 0x0e, 0x9d, 0x35, 0x88, 0xb5, 0x28, 0x5d, 0x5d, 0xf8, 0x37, 0x19, 0xd2, 0x61, 0xa3,
	0xc3, 0x35, 0xd1, 0x7d, 0x09, 0xb2, 0x65, 0xf1, 0xa7, 0x4e, 0xe2, 0x71, 0xd5, 0x78, 0x42, 0xae,
	0x99, 0x64, 0x3d, 0x7f, 0x7b, 0x5a, 0xeb, 0x11, 0xda, 0x4a, 0x85, 0x57, 0x30, 0xf7, 0x8e, 0xe5,
	0x85, 0xdb, 0xd1, 0xb7, 0x4d, 0xed, 0xab, 0x83, 0x75, 0xcd, 0x37, 0xfd, 0x86, 0x11, 0xb9, 0x5b,
	0x58, 0x77, 0xec, 0x1a, 0x03, 0xf5, 0xf4, 0xfd, 0x93, 0x85, 0x5c, 0xe0, 0xfb, 0x83, 0xec, 0x8f,
	0x5b, 0xcc, 0xfb, 0x12, 0x64, 0x97, 0xc5, 0x5f, 0x4f, 0x9d, 0x50, 0xd8, 0xdf, 0x3d, 0xfd, 0x49,
	0x69, 0xcb, 0x19, 0xfa, 0x2f, 0x11, 0x05, 0x18, 0x77, 0x01, 0x73, 0x1f, 0xf6, 0x41, 0x76, 0x47,
	0xfc, 0x9d, 0xd8, 0x09, 0x99, 0xfb, 0xa3, 0xbe, 0x27, 0xdb, 0x89, 0x1f, 0x49, 0xd1, 0x8c, 0xb4,
	0xb8, 0x1c, 0x7f, 0x11, 0x55, 0xe4, 0xb5, 0x6f, 0x71, 0x2b, 0xf2, 0x9a, 0xa8, 0xd8, 0xf9, 0xa2,
	0xa2, 0x18, 0x0a, 0x59, 0xdc, 0x8d, 0x3d, 0x85, 0x89, 0x50, 0x2b, 0xc6, 0x73, 0x9e, 0x62, 0xe4,
	0x75, 0x4a, 0x71, 0xf3, 0xa1, 0xef, 0x35, 0x8a, 0xbb, 0xec, 0x45, 0x46, 0x31, 0xae, 0x49, 0xba,
	0xcf, 0x22, 0x40, 0xc5, 0xf7, 0xf9, 0x2b, 0x12, 0x64, 0x68, 0x7c, 0x7a, 0xb8, 0x22, 0x93, 0x80,
	0x85, 0xb5, 0xfb, 0x47, 0xf2, 0xc5, 0x87, 0x9e, 0xfd, 0x8f, 0x12, 0x77, 0x75, 0xbc, 0x90, 0xe5,
	0x51, 0x29, 0xce, 0xc9, 0x5f, 0x4a, 0x30, 0xbe, 0x82, 0xfd, 0xae, 0xab, 0x82, 0x1e, 0xdd, 0x99,
	0xfc, 0xf9, 0x04, 0x78, 0x30, 0xa9, 0xb0, 0x75, 0xff, 0x48, 0x7e, 0xe9, 0x11, 0xbb, 0xdc, 0x75,
	0x18, 0x02, 0x6f, 0x10, 0xf0, 0x35, 0x1f, 0x5c, 0x49, 0x2c, 0x4a, 0x57, 0xd1, 0x8f, 0x25, 0xc8,
	0x45, 0xd8, 0xe3, 0x6d, 0x6c, 0xb9, 0x57, 0x5f, 0x3e, 0xdf, 0x73, 0xa4, 0x70, 0xf7, 0xfe, 0x91,
	0xfc, 0x4a, 0x27, 0x6b, 0x25, 0x5b, 0xb3, 0x5a, 0xbe, 0xa9, 0xc7, 0xd4, 0xd7, 0x71, 0x13, 0x05,
	0xed, 0xe2, 0xf0, 0xde, 0xb1, 0x1c, 0xab, 0x8c, 0xc2, 0x58, 0x18, 0x63, 0x9f, 0xfd, 0x01, 0x1e,
	0xe5, 0xfd, 0xbf, 0x25, 0xb8, 0x18, 0xe1, 0x3d, 0xa1, 0x1f, 0xff, 0x5c, 0xf2, 0xdf, 0xb0, 0x74,
	0xa0, 0xe5, 0x1f, 0x0f, 0xad, 0xf0, 0xee, 0xaf, 0x4b, 0xc4, 0xcb, 0x85, 0x0b, 0x71, 0x11, 0x83,
	0xce, 0x44, 0x5b, 0xd6, 0x7f, 0x92, 0x40, 0x4e, 0x90, 0x95, 0x77, 0xda, 0x67, 0x1f, 0xc2, 0x3f,
	0xc3, 0xc8, 0x3f, 0x12, 0xa3, 0xf0, 0x7b, 0x27, 0x0e, 0x79, 0x1f, 0x1f, 0xcb, 0x03, 0x34, 0x46,
	0x3d, 0x42, 0x04, 0x76, 0x3d, 0x40, 0x45, 0xf8, 0x73, 0x09, 0x26, 0x4b, 0x86, 0x11, 0xff, 0x5b,
	0x22, 0xd7, 0xb4, 0x6b, 0xe8, 0x5c, 0xcf, 0x3f, 0x35, 0x4a, 0xf2, 0x75, 0xca, 0x29, 0x5c, 0x1d,
	0xe3, 0xf1, 0x5c, 0x61, 0x82, 0x66, 0x55, 0xe2, 0xcf, 0x93, 0xa2, 0xe7, 0x14, 0xfd, 0x85, 0x04,
	0x32, 0x4f, 0xaa, 0x9e, 0x98, 0xbd, 0x37, 0x4f, 0xcb, 0x1e, 0x35, 0x74, 0x52, 0x4f, 0xe2, 0xee,
	0xaf, 0x24, 0x98, 0x8a, 0x68, 0x2e, 0x7a, 0x3d, 0x31, 0x93, 0xc0, 0x5b, 0x64, 0x3c, 0x89, 0xc1,
	0xb7, 0x4e, 0xc1, 0x60, 0x98, 0x7b, 0x5f, 0x2c, 0xc8, 0x54, 0x87, 0xc1, 0x5d, 0x84, 0x43, 0xe2,
	0x9c, 0x7e, 0x4f, 0x82, 0x73, 0x71, 0x3d, 0x3e, 0x21, 0xb3, 0x3b, 0xa7, 0xd5, 0xe6, 0x85, 0xc2,
	0xf4, 0x3c, 0xa9, 0xf7, 0xe2, 0xf3, 0x4f, 0x24, 0x18, 0xbd, 0x69, 0xda, 0x46, 0xf4, 0xa6, 0x7b,
	0xaa, 0xab, 0xd9, 0xcb, 0xe0, 0xf9, 0x1e, 0x70, 0xb6, 0xd1, 0x27, 0x3b, 0x31, 0x8c, 0xb1, 0x7c,
	0x61, 0x72, 0x7e, 0xdf, 0xb4, 0x13, 0xcd, 0xf0, 0x5b, 0x12, 0x4c, 0xd1, 0xb0, 0xc5, 0x97, 0xf1,
	0x6e, 0x3a, 0xa4, 0xfd, 0xe0, 0xbd, 0x47, 0xbc, 0x48, 0x7c, 0x27, 0x5c, 0xd8, 0x7e, 0x64, 0x10,
	0x0b, 0x82, 0xff, 0x97, 0x1e, 0x88, 0x9d, 0xa5, 0x27, 0x98, 0xc6, 0xaf, 0x4e, 0xbe, 0x44, 0xaf,
	0x9b, 0x47, 0xb3, 0x1f, 0x48, 0x90, 0x5f, 0xc1, 0x7e, 0x54, 0x28, 0x6f, 0xd3, 0x7e, 0x24, 0x93,
	0xd1, 0xde, 0x69, 0xec, 0x92, 0xe9, 0xce, 0xfd, 0x23, 0xf9, 0xc5, 0x87, 0xf2, 0x99, 0x58, 0x47,
	0xcf, 0x16, 0xce, 0xc7, 0xbd, 0x4d, 0xf4, 0x3a, 0xcc, 0x6b, 0x57, 0xf9, 0x0a, 0x6e, 0x3a, 0x87,
	0x38, 0x7c, 0xf2, 0xd1, 0x93, 0xbf, 0x1e, 0x75, 0xfe, 0x89, 0x43, 0xed, 0x4c, 0xe1, 0xdc, 0x3c,
	0x61, 0x6b, 0x86, 0xac, 0xf1, 0x67, 0x58, 0x87, 0xb8, 0x45, 0xf7, 0xf7, 0x4f, 0x25, 0x18, 0x5b,
	0xc1, 0x36, 0xeb, 0x20, 0x9e, 0x8a, 0xab, 0x9d, 0xd3, 0x70, 0xc5, 0xb5, 0xc5, 0x57, 0x4d, 0xe6,
	0x6b, 0x19, 0xa6, 0x82, 0xa0, 0x74, 0xca, 0xec, 0xf8, 0xcc, 0xcb, 0xd2, 0xc2, 0xb7, 0xfb, 0xdb,
	0xed, 0x4f, 0x1a, 0x18, 0x68, 0x75, 0xf1, 0x2d, 0x09, 0x72, 0xd1, 0x44, 0x8c, 0x5d, 0x5f, 0x4d,
	0xf7, 0xe8, 0x65, 0xe7, 0x7b, 0x0d, 0x14, 0x76, 0xef, 0x1f, 0xc9, 0x37, 0x1e, 0x2b, 0xf4, 0x26,
	0x9e, 0xb9, 0xe9, 0x02, 0x8a, 0xe7, 0x66, 0xec, 0xb2, 0x99, 0x99, 0x49, 0x03, 0xd0, 0xaa, 0xfd,
	0xfb, 0x58, 0xf7, 0x1f, 0x8f, 0xc3, 0x04, 0xd1, 0xaf, 0x9f, 0xc2, 0x45, 0x21, 0x1f, 0xc6, 0x2a,
	0x4d, 0xf3, 0xff, 0x79, 0xd5, 0x85, 0xaf, 0x48, 0x80, 0x3a, 0x1a, 0xd4, 0x74, 0x93, 0xee, 0xc2,
	0x78, 0x74, 0x8f, 0x82, 0xd6, 0x75, 0x3e, 0x29, 0x15, 0xe5, 0x63, 0xf9, 0x87, 0x8c, 0x15, 0x66,
	0x43, 0x3f, 0x17, 0xd3, 0x79, 0x9d, 0x0f, 0x33, 0xb5, 0x2f, 0x5d, 0xf8, 0xf0, 0xe7, 0x33, 0x67,
	0x3e, 0xbc, 0x37, 0x23, 0x7d, 0x74, 0x6f, 0x46, 0xfa, 0xd9, 0xbd, 0x19, 0xe9, 0x6b, 0x9f, 0xcc,
	0x9c, 0xf9, 0xe8, 0x93, 0x99, 0x33, 0xff, 0xfe, 0xc9, 0xcc, 0x99, 0xbd, 0x21, 0x46, 0xf8, 0xfa,
	0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x04, 0x5a, 0x37, 0x89, 0x59, 0x45, 0x00, 0x00,
}

func (this *GPUDriverKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&edgeproto.GPUDriverKey{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Organization: "+fmt.Sprintf("%#v", this.Organization)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCloudlet(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GPUDriverApiClient is the client API for GPUDriverApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GPUDriverApiClient interface {
	// Create GPU Driver. Creates GPU driver with all the config
	// required to install it.
	CreateGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_CreateGPUDriverClient, error)
	// Delete GPU Driver. Deletes GPU driver given that it is not
	// used by any cloudlet.
	DeleteGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_DeleteGPUDriverClient, error)
	// Update GPU Driver. Updates GPU driver config.
	UpdateGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_UpdateGPUDriverClient, error)
	// Show GPU Drivers. Lists all the MobiledgeX created GPU drivers and operator
	// created GPU drivers.
	ShowGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_ShowGPUDriverClient, error)
	// Add GPU Driver Build. Adds new build to GPU driver.
	AddGPUDriverBuild(ctx context.Context, in *GPUDriverBuildMember, opts ...grpc.CallOption) (GPUDriverApi_AddGPUDriverBuildClient, error)
	// Remove GPU Driver Build. Removes build from GPU driver.
	RemoveGPUDriverBuild(ctx context.Context, in *GPUDriverBuildMember, opts ...grpc.CallOption) (GPUDriverApi_RemoveGPUDriverBuildClient, error)
	// Get GPU Driver Build URL. Returns a time-limited signed URL to download GPU driver.
	GetGPUDriverBuildURL(ctx context.Context, in *GPUDriverBuildMember, opts ...grpc.CallOption) (*GPUDriverBuildURL, error)
}

type gPUDriverApiClient struct {
	cc *grpc.ClientConn
}

func NewGPUDriverApiClient(cc *grpc.ClientConn) GPUDriverApiClient {
	return &gPUDriverApiClient{cc}
}

func (c *gPUDriverApiClient) CreateGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_CreateGPUDriverClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GPUDriverApi_serviceDesc.Streams[0], "/edgeproto.GPUDriverApi/CreateGPUDriver", opts...)
	if err != nil {
		return nil, err
	}
	x := &gPUDriverApiCreateGPUDriverClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GPUDriverApi_CreateGPUDriverClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type gPUDriverApiCreateGPUDriverClient struct {
	grpc.ClientStream
}

func (x *gPUDriverApiCreateGPUDriverClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gPUDriverApiClient) DeleteGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_DeleteGPUDriverClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GPUDriverApi_serviceDesc.Streams[1], "/edgeproto.GPUDriverApi/DeleteGPUDriver", opts...)
	if err != nil {
		return nil, err
	}
	x := &gPUDriverApiDeleteGPUDriverClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GPUDriverApi_DeleteGPUDriverClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type gPUDriverApiDeleteGPUDriverClient struct {
	grpc.ClientStream
}

func (x *gPUDriverApiDeleteGPUDriverClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gPUDriverApiClient) UpdateGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_UpdateGPUDriverClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GPUDriverApi_serviceDesc.Streams[2], "/edgeproto.GPUDriverApi/UpdateGPUDriver", opts...)
	if err != nil {
		return nil, err
	}
	x := &gPUDriverApiUpdateGPUDriverClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GPUDriverApi_UpdateGPUDriverClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type gPUDriverApiUpdateGPUDriverClient struct {
	grpc.ClientStream
}

func (x *gPUDriverApiUpdateGPUDriverClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gPUDriverApiClient) ShowGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_ShowGPUDriverClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GPUDriverApi_serviceDesc.Streams[3], "/edgeproto.GPUDriverApi/ShowGPUDriver", opts...)
	if err != nil {
		return nil, err
	}
	x := &gPUDriverApiShowGPUDriverClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GPUDriverApi_ShowGPUDriverClient interface {
	Recv() (*GPUDriver, error)
	grpc.ClientStream
}

type gPUDriverApiShowGPUDriverClient struct {
	grpc.ClientStream
}

func (x *gPUDriverApiShowGPUDriverClient) Recv() (*GPUDriver, error) {
	m := new(GPUDriver)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gPUDriverApiClient) AddGPUDriverBuild(ctx context.Context, in *GPUDriverBuildMember, opts ...grpc.CallOption) (GPUDriverApi_AddGPUDriverBuildClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GPUDriverApi_serviceDesc.Streams[4], "/edgeproto.GPUDriverApi/AddGPUDriverBuild", opts...)
	if err != nil {
		return nil, err
	}
	x := &gPUDriverApiAddGPUDriverBuildClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GPUDriverApi_AddGPUDriverBuildClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type gPUDriverApiAddGPUDriverBuildClient struct {
	grpc.ClientStream
}

func (x *gPUDriverApiAddGPUDriverBuildClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gPUDriverApiClient) RemoveGPUDriverBuild(ctx context.Context, in *GPUDriverBuildMember, opts ...grpc.CallOption) (GPUDriverApi_RemoveGPUDriverBuildClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GPUDriverApi_serviceDesc.Streams[5], "/edgeproto.GPUDriverApi/RemoveGPUDriverBuild", opts...)
	if err != nil {
		return nil, err
	}
	x := &gPUDriverApiRemoveGPUDriverBuildClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GPUDriverApi_RemoveGPUDriverBuildClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type gPUDriverApiRemoveGPUDriverBuildClient struct {
	grpc.ClientStream
}

func (x *gPUDriverApiRemoveGPUDriverBuildClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gPUDriverApiClient) GetGPUDriverBuildURL(ctx context.Context, in *GPUDriverBuildMember, opts ...grpc.CallOption) (*GPUDriverBuildURL, error) {
	out := new(GPUDriverBuildURL)
	err := c.cc.Invoke(ctx, "/edgeproto.GPUDriverApi/GetGPUDriverBuildURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GPUDriverApiServer is the server API for GPUDriverApi service.
type GPUDriverApiServer interface {
	// Create GPU Driver. Creates GPU driver with all the config
	// required to install it.
	CreateGPUDriver(*GPUDriver, GPUDriverApi_CreateGPUDriverServer) error
	// Delete GPU Driver. Deletes GPU driver given that it is not
	// used by any cloudlet.
	DeleteGPUDriver(*GPUDriver, GPUDriverApi_DeleteGPUDriverServer) error
	// Update GPU Driver. Updates GPU driver config.
	UpdateGPUDriver(*GPUDriver, GPUDriverApi_UpdateGPUDriverServer) error
	// Show GPU Drivers. Lists all the MobiledgeX created GPU drivers and operator
	// created GPU drivers.
	ShowGPUDriver(*GPUDriver, GPUDriverApi_ShowGPUDriverServer) error
	// Add GPU Driver Build. Adds new build to GPU driver.
	AddGPUDriverBuild(*GPUDriverBuildMember, GPUDriverApi_AddGPUDriverBuildServer) error
	// Remove GPU Driver Build. Removes build from GPU driver.
	RemoveGPUDriverBuild(*GPUDriverBuildMember, GPUDriverApi_RemoveGPUDriverBuildServer) error
	// Get GPU Driver Build URL. Returns a time-limited signed URL to download GPU driver.
	GetGPUDriverBuildURL(context.Context, *GPUDriverBuildMember) (*GPUDriverBuildURL, error)
}

// UnimplementedGPUDriverApiServer can be embedded to have forward compatible implementations.
type UnimplementedGPUDriverApiServer struct {
}

func (*UnimplementedGPUDriverApiServer) CreateGPUDriver(req *GPUDriver, srv GPUDriverApi_CreateGPUDriverServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateGPUDriver not implemented")
}
func (*UnimplementedGPUDriverApiServer) DeleteGPUDriver(req *GPUDriver, srv GPUDriverApi_DeleteGPUDriverServer) error {
	return status.Errorf(codes.Unimplemented, "method DeleteGPUDriver not implemented")
}
func (*UnimplementedGPUDriverApiServer) UpdateGPUDriver(req *GPUDriver, srv GPUDriverApi_UpdateGPUDriverServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateGPUDriver not implemented")
}
func (*UnimplementedGPUDriverApiServer) ShowGPUDriver(req *GPUDriver, srv GPUDriverApi_ShowGPUDriverServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowGPUDriver not implemented")
}
func (*UnimplementedGPUDriverApiServer) AddGPUDriverBuild(req *GPUDriverBuildMember, srv GPUDriverApi_AddGPUDriverBuildServer) error {
	return status.Errorf(codes.Unimplemented, "method AddGPUDriverBuild not implemented")
}
func (*UnimplementedGPUDriverApiServer) RemoveGPUDriverBuild(req *GPUDriverBuildMember, srv GPUDriverApi_RemoveGPUDriverBuildServer) error {
	return status.Errorf(codes.Unimplemented, "method RemoveGPUDriverBuild not implemented")
}
func (*UnimplementedGPUDriverApiServer) GetGPUDriverBuildURL(ctx context.Context, req *GPUDriverBuildMember) (*GPUDriverBuildURL, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGPUDriverBuildURL not implemented")
}

func RegisterGPUDriverApiServer(s *grpc.Server, srv GPUDriverApiServer) {
	s.RegisterService(&_GPUDriverApi_serviceDesc, srv)
}

func _GPUDriverApi_CreateGPUDriver_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GPUDriver)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GPUDriverApiServer).CreateGPUDriver(m, &gPUDriverApiCreateGPUDriverServer{stream})
}

type GPUDriverApi_CreateGPUDriverServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type gPUDriverApiCreateGPUDriverServer struct {
	grpc.ServerStream
}

func (x *gPUDriverApiCreateGPUDriverServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _GPUDriverApi_DeleteGPUDriver_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GPUDriver)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GPUDriverApiServer).DeleteGPUDriver(m, &gPUDriverApiDeleteGPUDriverServer{stream})
}

type GPUDriverApi_DeleteGPUDriverServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type gPUDriverApiDeleteGPUDriverServer struct {
	grpc.ServerStream
}

func (x *gPUDriverApiDeleteGPUDriverServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _GPUDriverApi_UpdateGPUDriver_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GPUDriver)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GPUDriverApiServer).UpdateGPUDriver(m, &gPUDriverApiUpdateGPUDriverServer{stream})
}

type GPUDriverApi_UpdateGPUDriverServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type gPUDriverApiUpdateGPUDriverServer struct {
	grpc.ServerStream
}

func (x *gPUDriverApiUpdateGPUDriverServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _GPUDriverApi_ShowGPUDriver_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GPUDriver)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GPUDriverApiServer).ShowGPUDriver(m, &gPUDriverApiShowGPUDriverServer{stream})
}

type GPUDriverApi_ShowGPUDriverServer interface {
	Send(*GPUDriver) error
	grpc.ServerStream
}

type gPUDriverApiShowGPUDriverServer struct {
	grpc.ServerStream
}

func (x *gPUDriverApiShowGPUDriverServer) Send(m *GPUDriver) error {
	return x.ServerStream.SendMsg(m)
}

func _GPUDriverApi_AddGPUDriverBuild_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GPUDriverBuildMember)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GPUDriverApiServer).AddGPUDriverBuild(m, &gPUDriverApiAddGPUDriverBuildServer{stream})
}

type GPUDriverApi_AddGPUDriverBuildServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type gPUDriverApiAddGPUDriverBuildServer struct {
	grpc.ServerStream
}

func (x *gPUDriverApiAddGPUDriverBuildServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _GPUDriverApi_RemoveGPUDriverBuild_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GPUDriverBuildMember)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GPUDriverApiServer).RemoveGPUDriverBuild(m, &gPUDriverApiRemoveGPUDriverBuildServer{stream})
}

type GPUDriverApi_RemoveGPUDriverBuildServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type gPUDriverApiRemoveGPUDriverBuildServer struct {
	grpc.ServerStream
}

func (x *gPUDriverApiRemoveGPUDriverBuildServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _GPUDriverApi_GetGPUDriverBuildURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GPUDriverBuildMember)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GPUDriverApiServer).GetGPUDriverBuildURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.GPUDriverApi/GetGPUDriverBuildURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GPUDriverApiServer).GetGPUDriverBuildURL(ctx, req.(*GPUDriverBuildMember))
	}
	return interceptor(ctx, in, info, handler)
}

var _GPUDriverApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.GPUDriverApi",
	HandlerType: (*GPUDriverApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetGPUDriverBuildURL",
			Handler:    _GPUDriverApi_GetGPUDriverBuildURL_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreateGPUDriver",
			Handler:       _GPUDriverApi_CreateGPUDriver_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DeleteGPUDriver",
			Handler:       _GPUDriverApi_DeleteGPUDriver_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdateGPUDriver",
			Handler:       _GPUDriverApi_UpdateGPUDriver_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowGPUDriver",
			Handler:       _GPUDriverApi_ShowGPUDriver_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AddGPUDriverBuild",
			Handler:       _GPUDriverApi_AddGPUDriverBuild_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RemoveGPUDriverBuild",
			Handler:       _GPUDriverApi_RemoveGPUDriverBuild_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cloudlet.proto",
}

// CloudletApiClient is the client API for CloudletApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CloudletApiClient interface {
	// Create Cloudlet. Sets up Cloudlet services on the Operator's compute resources,
	// and integrated as part of MobiledgeX edge resource portfolio.
	// These resources are managed from the Edge Controller.
	CreateCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_CreateCloudletClient, error)
	// Delete Cloudlet. Removes the Cloudlet services where they are no longer managed
	// from the Edge Controller.
	DeleteCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_DeleteCloudletClient, error)
	// Update Cloudlet. Updates the Cloudlet configuration and manages the upgrade of Cloudlet services.
	UpdateCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_UpdateCloudletClient, error)
	// Show Cloudlets. Lists all the cloudlets managed from Edge Controller.
	ShowCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_ShowCloudletClient, error)
	// Get Cloudlet Manifest. Shows deployment manifest required to setup cloudlet
	GetCloudletManifest(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (*CloudletManifest, error)
	// Get Cloudlet Properties. Shows all the infra properties used to setup cloudlet
	GetCloudletProps(ctx context.Context, in *CloudletProps, opts ...grpc.CallOption) (*CloudletProps, error)
	// Get Cloudlet Resource Quota Properties. Shows all the resource quota properties of the cloudlet
	GetCloudletResourceQuotaProps(ctx context.Context, in *CloudletResourceQuotaProps, opts ...grpc.CallOption) (*CloudletResourceQuotaProps, error)
	// Get Cloudlet resource information. Shows cloudlet resources used and their limits
	GetCloudletResourceUsage(ctx context.Context, in *CloudletResourceUsage, opts ...grpc.CallOption) (*CloudletResourceUsage, error)
	// Add Optional Resource tag table
	AddCloudletResMapping(ctx context.Context, in *CloudletResMap, opts ...grpc.CallOption) (*Result, error)
	// Remove Optional Resource tag table
	RemoveCloudletResMapping(ctx context.Context, in *CloudletResMap, opts ...grpc.CallOption) (*Result, error)
	// Add alliance organization to the cloudlet
	AddCloudletAllianceOrg(ctx context.Context, in *CloudletAllianceOrg, opts ...grpc.CallOption) (*Result, error)
	// Remove alliance organization from the cloudlet
	RemoveCloudletAllianceOrg(ctx context.Context, in *CloudletAllianceOrg, opts ...grpc.CallOption) (*Result, error)
	// Discover if flavor produces a matching platform flavor
	FindFlavorMatch(ctx context.Context, in *FlavorMatch, opts ...grpc.CallOption) (*FlavorMatch, error)
	// Find all meta flavors viable on cloudlet
	ShowFlavorsForCloudlet(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (CloudletApi_ShowFlavorsForCloudletClient, error)
	// Get organizations of ClusterInsts and AppInsts on cloudlet
	GetOrganizationsOnCloudlet(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (CloudletApi_GetOrganizationsOnCloudletClient, error)
	// Revoke crm access key
	RevokeAccessKey(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (*Result, error)
	// Generate new crm access key
	GenerateAccessKey(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (*Result, error)
	// This is used internally to forward requests to other Controllers
	PlatformDeleteCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_PlatformDeleteCloudletClient, error)
}

type cloudletApiClient struct {
	cc *grpc.ClientConn
}

func NewCloudletApiClient(cc *grpc.ClientConn) CloudletApiClient {
	return &cloudletApiClient{cc}
}

func (c *cloudletApiClient) CreateCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_CreateCloudletClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CloudletApi_serviceDesc.Streams[0], "/edgeproto.CloudletApi/CreateCloudlet", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletApiCreateCloudletClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletApi_CreateCloudletClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type cloudletApiCreateCloudletClient struct {
	grpc.ClientStream
}

func (x *cloudletApiCreateCloudletClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cloudletApiClient) DeleteCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_DeleteCloudletClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CloudletApi_serviceDesc.Streams[1], "/edgeproto.CloudletApi/DeleteCloudlet", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletApiDeleteCloudletClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletApi_DeleteCloudletClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type cloudletApiDeleteCloudletClient struct {
	grpc.ClientStream
}

func (x *cloudletApiDeleteCloudletClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cloudletApiClient) UpdateCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_UpdateCloudletClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CloudletApi_serviceDesc.Streams[2], "/edgeproto.CloudletApi/UpdateCloudlet", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletApiUpdateCloudletClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletApi_UpdateCloudletClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type cloudletApiUpdateCloudletClient struct {
	grpc.ClientStream
}

func (x *cloudletApiUpdateCloudletClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cloudletApiClient) ShowCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_ShowCloudletClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CloudletApi_serviceDesc.Streams[3], "/edgeproto.CloudletApi/ShowCloudlet", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletApiShowCloudletClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletApi_ShowCloudletClient interface {
	Recv() (*Cloudlet, error)
	grpc.ClientStream
}

type cloudletApiShowCloudletClient struct {
	grpc.ClientStream
}

func (x *cloudletApiShowCloudletClient) Recv() (*Cloudlet, error) {
	m := new(Cloudlet)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cloudletApiClient) GetCloudletManifest(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (*CloudletManifest, error) {
	out := new(CloudletManifest)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/GetCloudletManifest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) GetCloudletProps(ctx context.Context, in *CloudletProps, opts ...grpc.CallOption) (*CloudletProps, error) {
	out := new(CloudletProps)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/GetCloudletProps", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) GetCloudletResourceQuotaProps(ctx context.Context, in *CloudletResourceQuotaProps, opts ...grpc.CallOption) (*CloudletResourceQuotaProps, error) {
	out := new(CloudletResourceQuotaProps)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/GetCloudletResourceQuotaProps", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) GetCloudletResourceUsage(ctx context.Context, in *CloudletResourceUsage, opts ...grpc.CallOption) (*CloudletResourceUsage, error) {
	out := new(CloudletResourceUsage)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/GetCloudletResourceUsage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) AddCloudletResMapping(ctx context.Context, in *CloudletResMap, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/AddCloudletResMapping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) RemoveCloudletResMapping(ctx context.Context, in *CloudletResMap, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/RemoveCloudletResMapping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) AddCloudletAllianceOrg(ctx context.Context, in *CloudletAllianceOrg, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/AddCloudletAllianceOrg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) RemoveCloudletAllianceOrg(ctx context.Context, in *CloudletAllianceOrg, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/RemoveCloudletAllianceOrg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) FindFlavorMatch(ctx context.Context, in *FlavorMatch, opts ...grpc.CallOption) (*FlavorMatch, error) {
	out := new(FlavorMatch)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/FindFlavorMatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) ShowFlavorsForCloudlet(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (CloudletApi_ShowFlavorsForCloudletClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CloudletApi_serviceDesc.Streams[4], "/edgeproto.CloudletApi/ShowFlavorsForCloudlet", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletApiShowFlavorsForCloudletClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletApi_ShowFlavorsForCloudletClient interface {
	Recv() (*FlavorKey, error)
	grpc.ClientStream
}

type cloudletApiShowFlavorsForCloudletClient struct {
	grpc.ClientStream
}

func (x *cloudletApiShowFlavorsForCloudletClient) Recv() (*FlavorKey, error) {
	m := new(FlavorKey)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cloudletApiClient) GetOrganizationsOnCloudlet(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (CloudletApi_GetOrganizationsOnCloudletClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CloudletApi_serviceDesc.Streams[5], "/edgeproto.CloudletApi/GetOrganizationsOnCloudlet", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletApiGetOrganizationsOnCloudletClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletApi_GetOrganizationsOnCloudletClient interface {
	Recv() (*Organization, error)
	grpc.ClientStream
}

type cloudletApiGetOrganizationsOnCloudletClient struct {
	grpc.ClientStream
}

func (x *cloudletApiGetOrganizationsOnCloudletClient) Recv() (*Organization, error) {
	m := new(Organization)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cloudletApiClient) RevokeAccessKey(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/RevokeAccessKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) GenerateAccessKey(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/GenerateAccessKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) PlatformDeleteCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_PlatformDeleteCloudletClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CloudletApi_serviceDesc.Streams[6], "/edgeproto.CloudletApi/PlatformDeleteCloudlet", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletApiPlatformDeleteCloudletClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletApi_PlatformDeleteCloudletClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type cloudletApiPlatformDeleteCloudletClient struct {
	grpc.ClientStream
}

func (x *cloudletApiPlatformDeleteCloudletClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CloudletApiServer is the server API for CloudletApi service.
type CloudletApiServer interface {
	// Create Cloudlet. Sets up Cloudlet services on the Operator's compute resources,
	// and integrated as part of MobiledgeX edge resource portfolio.
	// These resources are managed from the Edge Controller.
	CreateCloudlet(*Cloudlet, CloudletApi_CreateCloudletServer) error
	// Delete Cloudlet. Removes the Cloudlet services where they are no longer managed
	// from the Edge Controller.
	DeleteCloudlet(*Cloudlet, CloudletApi_DeleteCloudletServer) error
	// Update Cloudlet. Updates the Cloudlet configuration and manages the upgrade of Cloudlet services.
	UpdateCloudlet(*Cloudlet, CloudletApi_UpdateCloudletServer) error
	// Show Cloudlets. Lists all the cloudlets managed from Edge Controller.
	ShowCloudlet(*Cloudlet, CloudletApi_ShowCloudletServer) error
	// Get Cloudlet Manifest. Shows deployment manifest required to setup cloudlet
	GetCloudletManifest(context.Context, *CloudletKey) (*CloudletManifest, error)
	// Get Cloudlet Properties. Shows all the infra properties used to setup cloudlet
	GetCloudletProps(context.Context, *CloudletProps) (*CloudletProps, error)
	// Get Cloudlet Resource Quota Properties. Shows all the resource quota properties of the cloudlet
	GetCloudletResourceQuotaProps(context.Context, *CloudletResourceQuotaProps) (*CloudletResourceQuotaProps, error)
	// Get Cloudlet resource information. Shows cloudlet resources used and their limits
	GetCloudletResourceUsage(context.Context, *CloudletResourceUsage) (*CloudletResourceUsage, error)
	// Add Optional Resource tag table
	AddCloudletResMapping(context.Context, *CloudletResMap) (*Result, error)
	// Remove Optional Resource tag table
	RemoveCloudletResMapping(context.Context, *CloudletResMap) (*Result, error)
	// Add alliance organization to the cloudlet
	AddCloudletAllianceOrg(context.Context, *CloudletAllianceOrg) (*Result, error)
	// Remove alliance organization from the cloudlet
	RemoveCloudletAllianceOrg(context.Context, *CloudletAllianceOrg) (*Result, error)
	// Discover if flavor produces a matching platform flavor
	FindFlavorMatch(context.Context, *FlavorMatch) (*FlavorMatch, error)
	// Find all meta flavors viable on cloudlet
	ShowFlavorsForCloudlet(*CloudletKey, CloudletApi_ShowFlavorsForCloudletServer) error
	// Get organizations of ClusterInsts and AppInsts on cloudlet
	GetOrganizationsOnCloudlet(*CloudletKey, CloudletApi_GetOrganizationsOnCloudletServer) error
	// Revoke crm access key
	RevokeAccessKey(context.Context, *CloudletKey) (*Result, error)
	// Generate new crm access key
	GenerateAccessKey(context.Context, *CloudletKey) (*Result, error)
	// This is used internally to forward requests to other Controllers
	PlatformDeleteCloudlet(*Cloudlet, CloudletApi_PlatformDeleteCloudletServer) error
}

// UnimplementedCloudletApiServer can be embedded to have forward compatible implementations.
type UnimplementedCloudletApiServer struct {
}

func (*UnimplementedCloudletApiServer) CreateCloudlet(req *Cloudlet, srv CloudletApi_CreateCloudletServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateCloudlet not implemented")
}
func (*UnimplementedCloudletApiServer) DeleteCloudlet(req *Cloudlet, srv CloudletApi_DeleteCloudletServer) error {
	return status.Errorf(codes.Unimplemented, "method DeleteCloudlet not implemented")
}
func (*UnimplementedCloudletApiServer) UpdateCloudlet(req *Cloudlet, srv CloudletApi_UpdateCloudletServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateCloudlet not implemented")
}
func (*UnimplementedCloudletApiServer) ShowCloudlet(req *Cloudlet, srv CloudletApi_ShowCloudletServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowCloudlet not implemented")
}
func (*UnimplementedCloudletApiServer) GetCloudletManifest(ctx context.Context, req *CloudletKey) (*CloudletManifest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCloudletManifest not implemented")
}
func (*UnimplementedCloudletApiServer) GetCloudletProps(ctx context.Context, req *CloudletProps) (*CloudletProps, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCloudletProps not implemented")
}
func (*UnimplementedCloudletApiServer) GetCloudletResourceQuotaProps(ctx context.Context, req *CloudletResourceQuotaProps) (*CloudletResourceQuotaProps, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCloudletResourceQuotaProps not implemented")
}
func (*UnimplementedCloudletApiServer) GetCloudletResourceUsage(ctx context.Context, req *CloudletResourceUsage) (*CloudletResourceUsage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCloudletResourceUsage not implemented")
}
func (*UnimplementedCloudletApiServer) AddCloudletResMapping(ctx context.Context, req *CloudletResMap) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCloudletResMapping not implemented")
}
func (*UnimplementedCloudletApiServer) RemoveCloudletResMapping(ctx context.Context, req *CloudletResMap) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveCloudletResMapping not implemented")
}
func (*UnimplementedCloudletApiServer) AddCloudletAllianceOrg(ctx context.Context, req *CloudletAllianceOrg) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCloudletAllianceOrg not implemented")
}
func (*UnimplementedCloudletApiServer) RemoveCloudletAllianceOrg(ctx context.Context, req *CloudletAllianceOrg) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveCloudletAllianceOrg not implemented")
}
func (*UnimplementedCloudletApiServer) FindFlavorMatch(ctx context.Context, req *FlavorMatch) (*FlavorMatch, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindFlavorMatch not implemented")
}
func (*UnimplementedCloudletApiServer) ShowFlavorsForCloudlet(req *CloudletKey, srv CloudletApi_ShowFlavorsForCloudletServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowFlavorsForCloudlet not implemented")
}
func (*UnimplementedCloudletApiServer) GetOrganizationsOnCloudlet(req *CloudletKey, srv CloudletApi_GetOrganizationsOnCloudletServer) error {
	return status.Errorf(codes.Unimplemented, "method GetOrganizationsOnCloudlet not implemented")
}
func (*UnimplementedCloudletApiServer) RevokeAccessKey(ctx context.Context, req *CloudletKey) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeAccessKey not implemented")
}
func (*UnimplementedCloudletApiServer) GenerateAccessKey(ctx context.Context, req *CloudletKey) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateAccessKey not implemented")
}
func (*UnimplementedCloudletApiServer) PlatformDeleteCloudlet(req *Cloudlet, srv CloudletApi_PlatformDeleteCloudletServer) error {
	return status.Errorf(codes.Unimplemented, "method PlatformDeleteCloudlet not implemented")
}

func RegisterCloudletApiServer(s *grpc.Server, srv CloudletApiServer) {
	s.RegisterService(&_CloudletApi_serviceDesc, srv)
}

func _CloudletApi_CreateCloudlet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Cloudlet)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletApiServer).CreateCloudlet(m, &cloudletApiCreateCloudletServer{stream})
}

type CloudletApi_CreateCloudletServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type cloudletApiCreateCloudletServer struct {
	grpc.ServerStream
}

func (x *cloudletApiCreateCloudletServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _CloudletApi_DeleteCloudlet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Cloudlet)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletApiServer).DeleteCloudlet(m, &cloudletApiDeleteCloudletServer{stream})
}

type CloudletApi_DeleteCloudletServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type cloudletApiDeleteCloudletServer struct {
	grpc.ServerStream
}

func (x *cloudletApiDeleteCloudletServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _CloudletApi_UpdateCloudlet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Cloudlet)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletApiServer).UpdateCloudlet(m, &cloudletApiUpdateCloudletServer{stream})
}

type CloudletApi_UpdateCloudletServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type cloudletApiUpdateCloudletServer struct {
	grpc.ServerStream
}

func (x *cloudletApiUpdateCloudletServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _CloudletApi_ShowCloudlet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Cloudlet)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletApiServer).ShowCloudlet(m, &cloudletApiShowCloudletServer{stream})
}

type CloudletApi_ShowCloudletServer interface {
	Send(*Cloudlet) error
	grpc.ServerStream
}

type cloudletApiShowCloudletServer struct {
	grpc.ServerStream
}

func (x *cloudletApiShowCloudletServer) Send(m *Cloudlet) error {
	return x.ServerStream.SendMsg(m)
}

func _CloudletApi_GetCloudletManifest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).GetCloudletManifest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/GetCloudletManifest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).GetCloudletManifest(ctx, req.(*CloudletKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_GetCloudletProps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletProps)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).GetCloudletProps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/GetCloudletProps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).GetCloudletProps(ctx, req.(*CloudletProps))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_GetCloudletResourceQuotaProps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletResourceQuotaProps)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).GetCloudletResourceQuotaProps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/GetCloudletResourceQuotaProps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).GetCloudletResourceQuotaProps(ctx, req.(*CloudletResourceQuotaProps))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_GetCloudletResourceUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletResourceUsage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).GetCloudletResourceUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/GetCloudletResourceUsage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).GetCloudletResourceUsage(ctx, req.(*CloudletResourceUsage))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_AddCloudletResMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletResMap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).AddCloudletResMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/AddCloudletResMapping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).AddCloudletResMapping(ctx, req.(*CloudletResMap))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_RemoveCloudletResMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletResMap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).RemoveCloudletResMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/RemoveCloudletResMapping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).RemoveCloudletResMapping(ctx, req.(*CloudletResMap))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_AddCloudletAllianceOrg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletAllianceOrg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).AddCloudletAllianceOrg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/AddCloudletAllianceOrg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).AddCloudletAllianceOrg(ctx, req.(*CloudletAllianceOrg))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_RemoveCloudletAllianceOrg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletAllianceOrg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).RemoveCloudletAllianceOrg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/RemoveCloudletAllianceOrg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).RemoveCloudletAllianceOrg(ctx, req.(*CloudletAllianceOrg))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_FindFlavorMatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlavorMatch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).FindFlavorMatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/FindFlavorMatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).FindFlavorMatch(ctx, req.(*FlavorMatch))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_ShowFlavorsForCloudlet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CloudletKey)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletApiServer).ShowFlavorsForCloudlet(m, &cloudletApiShowFlavorsForCloudletServer{stream})
}

type CloudletApi_ShowFlavorsForCloudletServer interface {
	Send(*FlavorKey) error
	grpc.ServerStream
}

type cloudletApiShowFlavorsForCloudletServer struct {
	grpc.ServerStream
}

func (x *cloudletApiShowFlavorsForCloudletServer) Send(m *FlavorKey) error {
	return x.ServerStream.SendMsg(m)
}

func _CloudletApi_GetOrganizationsOnCloudlet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CloudletKey)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletApiServer).GetOrganizationsOnCloudlet(m, &cloudletApiGetOrganizationsOnCloudletServer{stream})
}

type CloudletApi_GetOrganizationsOnCloudletServer interface {
	Send(*Organization) error
	grpc.ServerStream
}

type cloudletApiGetOrganizationsOnCloudletServer struct {
	grpc.ServerStream
}

func (x *cloudletApiGetOrganizationsOnCloudletServer) Send(m *Organization) error {
	return x.ServerStream.SendMsg(m)
}

func _CloudletApi_RevokeAccessKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).RevokeAccessKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/RevokeAccessKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).RevokeAccessKey(ctx, req.(*CloudletKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_GenerateAccessKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).GenerateAccessKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/GenerateAccessKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).GenerateAccessKey(ctx, req.(*CloudletKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_PlatformDeleteCloudlet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Cloudlet)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletApiServer).PlatformDeleteCloudlet(m, &cloudletApiPlatformDeleteCloudletServer{stream})
}

type CloudletApi_PlatformDeleteCloudletServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type cloudletApiPlatformDeleteCloudletServer struct {
	grpc.ServerStream
}

func (x *cloudletApiPlatformDeleteCloudletServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

var _CloudletApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.CloudletApi",
	HandlerType: (*CloudletApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCloudletManifest",
			Handler:    _CloudletApi_GetCloudletManifest_Handler,
		},
		{
			MethodName: "GetCloudletProps",
			Handler:    _CloudletApi_GetCloudletProps_Handler,
		},
		{
			MethodName: "GetCloudletResourceQuotaProps",
			Handler:    _CloudletApi_GetCloudletResourceQuotaProps_Handler,
		},
		{
			MethodName: "GetCloudletResourceUsage",
			Handler:    _CloudletApi_GetCloudletResourceUsage_Handler,
		},
		{
			MethodName: "AddCloudletResMapping",
			Handler:    _CloudletApi_AddCloudletResMapping_Handler,
		},
		{
			MethodName: "RemoveCloudletResMapping",
			Handler:    _CloudletApi_RemoveCloudletResMapping_Handler,
		},
		{
			MethodName: "AddCloudletAllianceOrg",
			Handler:    _CloudletApi_AddCloudletAllianceOrg_Handler,
		},
		{
			MethodName: "RemoveCloudletAllianceOrg",
			Handler:    _CloudletApi_RemoveCloudletAllianceOrg_Handler,
		},
		{
			MethodName: "FindFlavorMatch",
			Handler:    _CloudletApi_FindFlavorMatch_Handler,
		},
		{
			MethodName: "RevokeAccessKey",
			Handler:    _CloudletApi_RevokeAccessKey_Handler,
		},
		{
			MethodName: "GenerateAccessKey",
			Handler:    _CloudletApi_GenerateAccessKey_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreateCloudlet",
			Handler:       _CloudletApi_CreateCloudlet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DeleteCloudlet",
			Handler:       _CloudletApi_DeleteCloudlet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdateCloudlet",
			Handler:       _CloudletApi_UpdateCloudlet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowCloudlet",
			Handler:       _CloudletApi_ShowCloudlet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowFlavorsForCloudlet",
			Handler:       _CloudletApi_ShowFlavorsForCloudlet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetOrganizationsOnCloudlet",
			Handler:       _CloudletApi_GetOrganizationsOnCloudlet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PlatformDeleteCloudlet",
			Handler:       _CloudletApi_PlatformDeleteCloudlet_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cloudlet.proto",
}

// CloudletInfoApiClient is the client API for CloudletInfoApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CloudletInfoApiClient interface {
	// Show CloudletInfos
	ShowCloudletInfo(ctx context.Context, in *CloudletInfo, opts ...grpc.CallOption) (CloudletInfoApi_ShowCloudletInfoClient, error)
	// Inject (create) a CloudletInfo for regression testing
	InjectCloudletInfo(ctx context.Context, in *CloudletInfo, opts ...grpc.CallOption) (*Result, error)
	// Evict (delete) a CloudletInfo for regression testing
	EvictCloudletInfo(ctx context.Context, in *CloudletInfo, opts ...grpc.CallOption) (*Result, error)
}

type cloudletInfoApiClient struct {
	cc *grpc.ClientConn
}

func NewCloudletInfoApiClient(cc *grpc.ClientConn) CloudletInfoApiClient {
	return &cloudletInfoApiClient{cc}
}

func (c *cloudletInfoApiClient) ShowCloudletInfo(ctx context.Context, in *CloudletInfo, opts ...grpc.CallOption) (CloudletInfoApi_ShowCloudletInfoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CloudletInfoApi_serviceDesc.Streams[0], "/edgeproto.CloudletInfoApi/ShowCloudletInfo", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletInfoApiShowCloudletInfoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletInfoApi_ShowCloudletInfoClient interface {
	Recv() (*CloudletInfo, error)
	grpc.ClientStream
}

type cloudletInfoApiShowCloudletInfoClient struct {
	grpc.ClientStream
}

func (x *cloudletInfoApiShowCloudletInfoClient) Recv() (*CloudletInfo, error) {
	m := new(CloudletInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cloudletInfoApiClient) InjectCloudletInfo(ctx context.Context, in *CloudletInfo, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletInfoApi/InjectCloudletInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletInfoApiClient) EvictCloudletInfo(ctx context.Context, in *CloudletInfo, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletInfoApi/EvictCloudletInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CloudletInfoApiServer is the server API for CloudletInfoApi service.
type CloudletInfoApiServer interface {
	// Show CloudletInfos
	ShowCloudletInfo(*CloudletInfo, CloudletInfoApi_ShowCloudletInfoServer) error
	// Inject (create) a CloudletInfo for regression testing
	InjectCloudletInfo(context.Context, *CloudletInfo) (*Result, error)
	// Evict (delete) a CloudletInfo for regression testing
	EvictCloudletInfo(context.Context, *CloudletInfo) (*Result, error)
}

// UnimplementedCloudletInfoApiServer can be embedded to have forward compatible implementations.
type UnimplementedCloudletInfoApiServer struct {
}

func (*UnimplementedCloudletInfoApiServer) ShowCloudletInfo(req *CloudletInfo, srv CloudletInfoApi_ShowCloudletInfoServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowCloudletInfo not implemented")
}
func (*UnimplementedCloudletInfoApiServer) InjectCloudletInfo(ctx context.Context, req *CloudletInfo) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InjectCloudletInfo not implemented")
}
func (*UnimplementedCloudletInfoApiServer) EvictCloudletInfo(ctx context.Context, req *CloudletInfo) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvictCloudletInfo not implemented")
}

func RegisterCloudletInfoApiServer(s *grpc.Server, srv CloudletInfoApiServer) {
	s.RegisterService(&_CloudletInfoApi_serviceDesc, srv)
}

func _CloudletInfoApi_ShowCloudletInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CloudletInfo)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletInfoApiServer).ShowCloudletInfo(m, &cloudletInfoApiShowCloudletInfoServer{stream})
}

type CloudletInfoApi_ShowCloudletInfoServer interface {
	Send(*CloudletInfo) error
	grpc.ServerStream
}

type cloudletInfoApiShowCloudletInfoServer struct {
	grpc.ServerStream
}

func (x *cloudletInfoApiShowCloudletInfoServer) Send(m *CloudletInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _CloudletInfoApi_InjectCloudletInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletInfoApiServer).InjectCloudletInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletInfoApi/InjectCloudletInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletInfoApiServer).InjectCloudletInfo(ctx, req.(*CloudletInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletInfoApi_EvictCloudletInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletInfoApiServer).EvictCloudletInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletInfoApi/EvictCloudletInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletInfoApiServer).EvictCloudletInfo(ctx, req.(*CloudletInfo))
	}
	return interceptor(ctx, in, info, handler)
}

var _CloudletInfoApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.CloudletInfoApi",
	HandlerType: (*CloudletInfoApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InjectCloudletInfo",
			Handler:    _CloudletInfoApi_InjectCloudletInfo_Handler,
		},
		{
			MethodName: "EvictCloudletInfo",
			Handler:    _CloudletInfoApi_EvictCloudletInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowCloudletInfo",
			Handler:       _CloudletInfoApi_ShowCloudletInfo_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cloudlet.proto",
}

// CloudletMetricsApiClient is the client API for CloudletMetricsApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CloudletMetricsApiClient interface {
	// Show Cloudlet metrics
	ShowCloudletMetrics(ctx context.Context, in *CloudletMetrics, opts ...grpc.CallOption) (CloudletMetricsApi_ShowCloudletMetricsClient, error)
}

type cloudletMetricsApiClient struct {
	cc *grpc.ClientConn
}

func NewCloudletMetricsApiClient(cc *grpc.ClientConn) CloudletMetricsApiClient {
	return &cloudletMetricsApiClient{cc}
}

func (c *cloudletMetricsApiClient) ShowCloudletMetrics(ctx context.Context, in *CloudletMetrics, opts ...grpc.CallOption) (CloudletMetricsApi_ShowCloudletMetricsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CloudletMetricsApi_serviceDesc.Streams[0], "/edgeproto.CloudletMetricsApi/ShowCloudletMetrics", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletMetricsApiShowCloudletMetricsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletMetricsApi_ShowCloudletMetricsClient interface {
	Recv() (*CloudletMetrics, error)
	grpc.ClientStream
}

type cloudletMetricsApiShowCloudletMetricsClient struct {
	grpc.ClientStream
}

func (x *cloudletMetricsApiShowCloudletMetricsClient) Recv() (*CloudletMetrics, error) {
	m := new(CloudletMetrics)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CloudletMetricsApiServer is the server API for CloudletMetricsApi service.
type CloudletMetricsApiServer interface {
	// Show Cloudlet metrics
	ShowCloudletMetrics(*CloudletMetrics, CloudletMetricsApi_ShowCloudletMetricsServer) error
}

// UnimplementedCloudletMetricsApiServer can be embedded to have forward compatible implementations.
type UnimplementedCloudletMetricsApiServer struct {
}

func (*UnimplementedCloudletMetricsApiServer) ShowCloudletMetrics(req *CloudletMetrics, srv CloudletMetricsApi_ShowCloudletMetricsServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowCloudletMetrics not implemented")
}

func RegisterCloudletMetricsApiServer(s *grpc.Server, srv CloudletMetricsApiServer) {
	s.RegisterService(&_CloudletMetricsApi_serviceDesc, srv)
}

func _CloudletMetricsApi_ShowCloudletMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CloudletMetrics)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletMetricsApiServer).ShowCloudletMetrics(m, &cloudletMetricsApiShowCloudletMetricsServer{stream})
}

type CloudletMetricsApi_ShowCloudletMetricsServer interface {
	Send(*CloudletMetrics) error
	grpc.ServerStream
}

type cloudletMetricsApiShowCloudletMetricsServer struct {
	grpc.ServerStream
}

func (x *cloudletMetricsApiShowCloudletMetricsServer) Send(m *CloudletMetrics) error {
	return x.ServerStream.SendMsg(m)
}

var _CloudletMetricsApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.CloudletMetricsApi",
	HandlerType: (*CloudletMetricsApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowCloudletMetrics",
			Handler:       _CloudletMetricsApi_ShowCloudletMetrics_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cloudlet.proto",
}

func (m *OperationTimeLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperationTimeLimits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperationTimeLimits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeleteAppInstTimeout != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.DeleteAppInstTimeout))
		i--
		dAtA[i] = 0x30
	}
	if m.UpdateAppInstTimeout != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.UpdateAppInstTimeout))
		i--
		dAtA[i] = 0x28
	}
	if m.CreateAppInstTimeout != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.CreateAppInstTimeout))
		i--
		dAtA[i] = 0x20
	}
	if m.DeleteClusterInstTimeout != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.DeleteClusterInstTimeout))
		i--
		dAtA[i] = 0x18
	}
	if m.UpdateClusterInstTimeout != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.UpdateClusterInstTimeout))
		i--
		dAtA[i] = 0x10
	}
	if m.CreateClusterInstTimeout != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.CreateClusterInstTimeout))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CloudletInternal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletInternal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletInternal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Props) > 0 {
		for k := range m.Props {
			v := m.Props[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PlatformConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlatformConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlatformConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SecondaryCrmAccessPrivateKey) > 0 {
		i -= len(m.SecondaryCrmAccessPrivateKey)
		copy(dAtA[i:], m.SecondaryCrmAccessPrivateKey)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.SecondaryCrmAccessPrivateKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.CacheDir) > 0 {
		i -= len(m.CacheDir)
		copy(dAtA[i:], m.CacheDir)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.CacheDir)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.AccessApiAddr) > 0 {
		i -= len(m.AccessApiAddr)
		copy(dAtA[i:], m.AccessApiAddr)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.AccessApiAddr)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.CrmAccessPrivateKey) > 0 {
		i -= len(m.CrmAccessPrivateKey)
		copy(dAtA[i:], m.CrmAccessPrivateKey)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.CrmAccessPrivateKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.TlsCaFile) > 0 {
		i -= len(m.TlsCaFile)
		copy(dAtA[i:], m.TlsCaFile)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.TlsCaFile)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.TlsKeyFile) > 0 {
		i -= len(m.TlsKeyFile)
		copy(dAtA[i:], m.TlsKeyFile)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.TlsKeyFile)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.DeploymentTag) > 0 {
		i -= len(m.DeploymentTag)
		copy(dAtA[i:], m.DeploymentTag)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.DeploymentTag)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.ChefClientInterval != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.ChefClientInterval))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.ChefServerPath) > 0 {
		i -= len(m.ChefServerPath)
		copy(dAtA[i:], m.ChefServerPath)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.ChefServerPath)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.AppDnsRoot) > 0 {
		i -= len(m.AppDnsRoot)
		copy(dAtA[i:], m.AppDnsRoot)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.AppDnsRoot)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.UseVaultPki {
		i--
		if m.UseVaultPki {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.CommercialCerts {
		i--
		if m.CommercialCerts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x62
	}
	if m.CleanupMode {
		i--
		if m.CleanupMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.Span) > 0 {
		i -= len(m.Span)
		copy(dAtA[i:], m.Span)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Span)))
		i--
		dAtA[i] = 0x52
	}
	if m.TestMode {
		i--
		if m.TestMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.PlatformTag) > 0 {
		i -= len(m.PlatformTag)
		copy(dAtA[i:], m.PlatformTag)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.PlatformTag)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.EnvVar) > 0 {
		for k := range m.EnvVar {
			v := m.EnvVar[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.TlsCertFile) > 0 {
		i -= len(m.TlsCertFile)
		copy(dAtA[i:], m.TlsCertFile)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.TlsCertFile)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NotifyCtrlAddrs) > 0 {
		i -= len(m.NotifyCtrlAddrs)
		copy(dAtA[i:], m.NotifyCtrlAddrs)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.NotifyCtrlAddrs)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CloudletVmImagePath) > 0 {
		i -= len(m.CloudletVmImagePath)
		copy(dAtA[i:], m.CloudletVmImagePath)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.CloudletVmImagePath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContainerRegistryPath) > 0 {
		i -= len(m.ContainerRegistryPath)
		copy(dAtA[i:], m.ContainerRegistryPath)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.ContainerRegistryPath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudletResMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletResMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletResMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Mapping) > 0 {
		for k := range m.Mapping {
			v := m.Mapping[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *InfraConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfraConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InfraConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FlavorName) > 0 {
		i -= len(m.FlavorName)
		copy(dAtA[i:], m.FlavorName)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.FlavorName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ExternalNetworkName) > 0 {
		i -= len(m.ExternalNetworkName)
		copy(dAtA[i:], m.ExternalNetworkName)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.ExternalNetworkName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourceQuota) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceQuota) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceQuota) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AlertThreshold != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.AlertThreshold))
		i--
		dAtA[i] = 0x18
	}
	if m.Value != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GPUDriverKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUDriverKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPUDriverKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GPUDriverBuild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUDriverBuild) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPUDriverBuild) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Md5Sum) > 0 {
		i -= len(m.Md5Sum)
		copy(dAtA[i:], m.Md5Sum)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Md5Sum)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.HypervisorInfo) > 0 {
		i -= len(m.HypervisorInfo)
		copy(dAtA[i:], m.HypervisorInfo)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.HypervisorInfo)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.KernelVersion) > 0 {
		i -= len(m.KernelVersion)
		copy(dAtA[i:], m.KernelVersion)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.KernelVersion)))
		i--
		dAtA[i] = 0x2a
	}
	if m.OperatingSystem != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.OperatingSystem))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DriverPathCreds) > 0 {
		i -= len(m.DriverPathCreds)
		copy(dAtA[i:], m.DriverPathCreds)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.DriverPathCreds)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DriverPath) > 0 {
		i -= len(m.DriverPath)
		copy(dAtA[i:], m.DriverPath)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.DriverPath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GPUDriverBuildMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUDriverBuildMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPUDriverBuildMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IgnoreState {
		i--
		if m.IgnoreState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Build.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GPUDriverBuildURL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUDriverBuildURL) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPUDriverBuildURL) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Validity != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.Validity))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BuildUrlPath) > 0 {
		i -= len(m.BuildUrlPath)
		copy(dAtA[i:], m.BuildUrlPath)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.BuildUrlPath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GPUDriver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUDriver) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPUDriver) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeletePrepare {
		i--
		if m.DeletePrepare {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.IgnoreState {
		i--
		if m.IgnoreState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Properties) > 0 {
		for k := range m.Properties {
			v := m.Properties[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.LicenseConfigMd5Sum) > 0 {
		i -= len(m.LicenseConfigMd5Sum)
		copy(dAtA[i:], m.LicenseConfigMd5Sum)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.LicenseConfigMd5Sum)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.LicenseConfig) > 0 {
		i -= len(m.LicenseConfig)
		copy(dAtA[i:], m.LicenseConfig)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.LicenseConfig)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Builds) > 0 {
		for iNdEx := len(m.Builds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Builds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudlet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GPUConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPUConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LicenseConfigMd5Sum) > 0 {
		i -= len(m.LicenseConfigMd5Sum)
		copy(dAtA[i:], m.LicenseConfigMd5Sum)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.LicenseConfigMd5Sum)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.LicenseConfig) > 0 {
		i -= len(m.LicenseConfig)
		copy(dAtA[i:], m.LicenseConfig)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.LicenseConfig)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Properties) > 0 {
		for k := range m.Properties {
			v := m.Properties[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Driver.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Cloudlet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cloudlet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cloudlet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RootLbFqdn) > 0 {
		i -= len(m.RootLbFqdn)
		copy(dAtA[i:], m.RootLbFqdn)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.RootLbFqdn)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xba
	}
	if len(m.DnsLabel) > 0 {
		i -= len(m.DnsLabel)
		copy(dAtA[i:], m.DnsLabel)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.DnsLabel)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb2
	}
	if len(m.SecondaryNotifySrvAddr) > 0 {
		i -= len(m.SecondaryNotifySrvAddr)
		copy(dAtA[i:], m.SecondaryNotifySrvAddr)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.SecondaryNotifySrvAddr)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xaa
	}
	if m.SecondaryCrmAccessKeyUpgradeRequired {
		i--
		if m.SecondaryCrmAccessKeyUpgradeRequired {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if len(m.SecondaryCrmAccessPublicKey) > 0 {
		i -= len(m.SecondaryCrmAccessPublicKey)
		copy(dAtA[i:], m.SecondaryCrmAccessPublicKey)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.SecondaryCrmAccessPublicKey)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	if m.PlatformHighAvailability {
		i--
		if m.PlatformHighAvailability {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.DeletePrepare {
		i--
		if m.DeletePrepare {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x88
	}
	if len(m.SingleKubernetesClusterOwner) > 0 {
		i -= len(m.SingleKubernetesClusterOwner)
		copy(dAtA[i:], m.SingleKubernetesClusterOwner)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.SingleKubernetesClusterOwner)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x82
	}
	if len(m.AllianceOrgs) > 0 {
		for iNdEx := len(m.AllianceOrgs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllianceOrgs[iNdEx])
			copy(dAtA[i:], m.AllianceOrgs[iNdEx])
			i = encodeVarintCloudlet(dAtA, i, uint64(len(m.AllianceOrgs[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xfa
		}
	}
	if m.EnableDefaultServerlessCluster {
		i--
		if m.EnableDefaultServerlessCluster {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	{
		size, err := m.GpuConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xea
	if len(m.KafkaPassword) > 0 {
		i -= len(m.KafkaPassword)
		copy(dAtA[i:], m.KafkaPassword)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.KafkaPassword)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	if len(m.KafkaUser) > 0 {
		i -= len(m.KafkaUser)
		copy(dAtA[i:], m.KafkaUser)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.KafkaUser)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	if len(m.KafkaCluster) > 0 {
		i -= len(m.KafkaCluster)
		copy(dAtA[i:], m.KafkaCluster)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.KafkaCluster)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	if len(m.HostController) > 0 {
		i -= len(m.HostController)
		copy(dAtA[i:], m.HostController)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.HostController)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if m.DefaultResourceAlertThreshold != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.DefaultResourceAlertThreshold))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if len(m.ResourceQuotas) > 0 {
		for iNdEx := len(m.ResourceQuotas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResourceQuotas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudlet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xba
		}
	}
	if m.TrustPolicyState != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.TrustPolicyState))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if len(m.TrustPolicy) > 0 {
		i -= len(m.TrustPolicy)
		copy(dAtA[i:], m.TrustPolicy)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.TrustPolicy)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	{
		size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xa2
	{
		size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x9a
	if m.CrmAccessKeyUpgradeRequired {
		i--
		if m.CrmAccessKeyUpgradeRequired {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if len(m.CrmAccessPublicKey) > 0 {
		i -= len(m.CrmAccessPublicKey)
		copy(dAtA[i:], m.CrmAccessPublicKey)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.CrmAccessPublicKey)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if len(m.VmPool) > 0 {
		i -= len(m.VmPool)
		copy(dAtA[i:], m.VmPool)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.VmPool)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.OverridePolicyContainerVersion {
		i--
		if m.OverridePolicyContainerVersion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.MaintenanceState != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.MaintenanceState))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if len(m.ChefClientKey) > 0 {
		for k := range m.ChefClientKey {
			v := m.ChefClientKey[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xea
		}
	}
	{
		size, err := m.InfraConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xe2
	if m.InfraApiAccess != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.InfraApiAccess))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if len(m.Deployment) > 0 {
		i -= len(m.Deployment)
		copy(dAtA[i:], m.Deployment)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Deployment)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.VmImageVersion) > 0 {
		i -= len(m.VmImageVersion)
		copy(dAtA[i:], m.VmImageVersion)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.VmImageVersion)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.AccessVars) > 0 {
		for k := range m.AccessVars {
			v := m.AccessVars[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.ResTagMap) > 0 {
		for k := range m.ResTagMap {
			v := m.ResTagMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCloudlet(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	{
		size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xaa
	if len(m.ContainerVersion) > 0 {
		i -= len(m.ContainerVersion)
		copy(dAtA[i:], m.ContainerVersion)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.ContainerVersion)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.EnvVar) > 0 {
		for k := range m.EnvVar {
			v := m.EnvVar[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.PhysicalName) > 0 {
		i -= len(m.PhysicalName)
		copy(dAtA[i:], m.PhysicalName)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.PhysicalName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	{
		size, err := m.Flavor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if len(m.NotifySrvAddr) > 0 {
		i -= len(m.NotifySrvAddr)
		copy(dAtA[i:], m.NotifySrvAddr)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.NotifySrvAddr)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.PlatformType != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.PlatformType))
		i--
		dAtA[i] = 0x78
	}
	if m.DeploymentLocal {
		i--
		if m.DeploymentLocal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.CrmOverride != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.CrmOverride))
		i--
		dAtA[i] = 0x68
	}
	if m.State != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x60
	}
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Errors[iNdEx])
			copy(dAtA[i:], m.Errors[iNdEx])
			i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Errors[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	{
		size, err := m.TimeLimits.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.NumDynamicIps != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.NumDynamicIps))
		i--
		dAtA[i] = 0x40
	}
	if len(m.StaticIps) > 0 {
		i -= len(m.StaticIps)
		copy(dAtA[i:], m.StaticIps)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.StaticIps)))
		i--
		dAtA[i] = 0x3a
	}
	if m.IpSupport != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.IpSupport))
		i--
		dAtA[i] = 0x30
	}
	{
		size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FlavorMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlavorMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlavorMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AvailabilityZone) > 0 {
		i -= len(m.AvailabilityZone)
		copy(dAtA[i:], m.AvailabilityZone)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.AvailabilityZone)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FlavorName) > 0 {
		i -= len(m.FlavorName)
		copy(dAtA[i:], m.FlavorName)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.FlavorName)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CloudletManifest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletManifest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletManifest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Manifest) > 0 {
		i -= len(m.Manifest)
		copy(dAtA[i:], m.Manifest)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Manifest)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *PropertyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropertyInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropertyInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Internal {
		i--
		if m.Internal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Mandatory {
		i--
		if m.Mandatory {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Secret {
		i--
		if m.Secret {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudletProps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletProps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletProps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Properties) > 0 {
		for k := range m.Properties {
			v := m.Properties[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCloudlet(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.PlatformType != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.PlatformType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CloudletResourceQuotaProps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletResourceQuotaProps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletResourceQuotaProps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Properties) > 0 {
		for iNdEx := len(m.Properties) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Properties[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudlet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.PlatformType != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.PlatformType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CloudletResourceUsage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletResourceUsage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletResourceUsage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Info) > 0 {
		for iNdEx := len(m.Info) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Info[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudlet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.InfraUsage {
		i--
		if m.InfraUsage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CloudletAllianceOrg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletAllianceOrg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletAllianceOrg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FlavorInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlavorInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlavorInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PropMap) > 0 {
		for k := range m.PropMap {
			v := m.PropMap[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Disk != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.Disk))
		i--
		dAtA[i] = 0x20
	}
	if m.Ram != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.Ram))
		i--
		dAtA[i] = 0x18
	}
	if m.Vcpus != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.Vcpus))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OSAZone) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OSAZone) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OSAZone) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OSImage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OSImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OSImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DiskFormat) > 0 {
		i -= len(m.DiskFormat)
		copy(dAtA[i:], m.DiskFormat)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.DiskFormat)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Properties) > 0 {
		i -= len(m.Properties)
		copy(dAtA[i:], m.Properties)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Properties)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Tags) > 0 {
		i -= len(m.Tags)
		copy(dAtA[i:], m.Tags)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Tags)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudletInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StandbyCrm {
		i--
		if m.StandbyCrm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.ActiveCrmInstance) > 0 {
		i -= len(m.ActiveCrmInstance)
		copy(dAtA[i:], m.ActiveCrmInstance)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.ActiveCrmInstance)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.NodeInfos) > 0 {
		for iNdEx := len(m.NodeInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudlet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.Properties) > 0 {
		for k := range m.Properties {
			v := m.Properties[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.CompatibilityVersion != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.CompatibilityVersion))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.TrustPolicyState != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.TrustPolicyState))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	{
		size, err := m.ResourcesSnapshot.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if m.MaintenanceState != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.MaintenanceState))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.ControllerCacheReceived {
		i--
		if m.ControllerCacheReceived {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if len(m.OsImages) > 0 {
		for iNdEx := len(m.OsImages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OsImages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudlet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.AvailabilityZones) > 0 {
		for iNdEx := len(m.AvailabilityZones) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AvailabilityZones[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudlet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.ContainerVersion) > 0 {
		i -= len(m.ContainerVersion)
		copy(dAtA[i:], m.ContainerVersion)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.ContainerVersion)))
		i--
		dAtA[i] = 0x62
	}
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	if len(m.Flavors) > 0 {
		for iNdEx := len(m.Flavors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Flavors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudlet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Errors[iNdEx])
			copy(dAtA[i:], m.Errors[iNdEx])
			i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Errors[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.OsMaxVolGb != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.OsMaxVolGb))
		i--
		dAtA[i] = 0x40
	}
	if m.OsMaxVcores != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.OsMaxVcores))
		i--
		dAtA[i] = 0x38
	}
	if m.OsMaxRam != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.OsMaxRam))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Controller) > 0 {
		i -= len(m.Controller)
		copy(dAtA[i:], m.Controller)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Controller)))
		i--
		dAtA[i] = 0x2a
	}
	if m.NotifyId != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.NotifyId))
		i--
		dAtA[i] = 0x20
	}
	if m.State != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CloudletMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Foo != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.Foo))
		i--
		dAtA[i] = 0x28
	}
	return len(dAtA) - i, nil
}

func encodeVarintCloudlet(dAtA []byte, offset int, v uint64) int {
	offset -= sovCloudlet(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *OperationTimeLimits) CopyInFields(src *OperationTimeLimits) int {
	changed := 0
	if m.CreateClusterInstTimeout != src.CreateClusterInstTimeout {
		m.CreateClusterInstTimeout = src.CreateClusterInstTimeout
		changed++
	}
	if m.UpdateClusterInstTimeout != src.UpdateClusterInstTimeout {
		m.UpdateClusterInstTimeout = src.UpdateClusterInstTimeout
		changed++
	}
	if m.DeleteClusterInstTimeout != src.DeleteClusterInstTimeout {
		m.DeleteClusterInstTimeout = src.DeleteClusterInstTimeout
		changed++
	}
	if m.CreateAppInstTimeout != src.CreateAppInstTimeout {
		m.CreateAppInstTimeout = src.CreateAppInstTimeout
		changed++
	}
	if m.UpdateAppInstTimeout != src.UpdateAppInstTimeout {
		m.UpdateAppInstTimeout = src.UpdateAppInstTimeout
		changed++
	}
	if m.DeleteAppInstTimeout != src.DeleteAppInstTimeout {
		m.DeleteAppInstTimeout = src.DeleteAppInstTimeout
		changed++
	}
	return changed
}

func (m *OperationTimeLimits) DeepCopyIn(src *OperationTimeLimits) {
	m.CreateClusterInstTimeout = src.CreateClusterInstTimeout
	m.UpdateClusterInstTimeout = src.UpdateClusterInstTimeout
	m.DeleteClusterInstTimeout = src.DeleteClusterInstTimeout
	m.CreateAppInstTimeout = src.CreateAppInstTimeout
	m.UpdateAppInstTimeout = src.UpdateAppInstTimeout
	m.DeleteAppInstTimeout = src.DeleteAppInstTimeout
}

// Helper method to check that enums have valid values
func (m *OperationTimeLimits) ValidateEnums() error {
	return nil
}

func (s *OperationTimeLimits) ClearTagged(tags map[string]struct{}) {
}

func (m *CloudletInternal) Matches(o *CloudletInternal, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.Props != nil {
		if len(m.Props) == 0 && len(o.Props) > 0 || len(m.Props) > 0 && len(o.Props) == 0 {
			return false
		} else if m.Props != nil && o.Props != nil {
			if !opts.Filter && len(m.Props) != len(o.Props) {
				return false
			}
			for k, _ := range o.Props {
				_, ok := m.Props[k]
				if !ok {
					return false
				}
				if o.Props[k] != m.Props[k] {
					return false
				}
			}
		}
	}
	return true
}

const CloudletInternalFieldKey = "2"
const CloudletInternalFieldKeyOrganization = "2.1"
const CloudletInternalFieldKeyName = "2.2"
const CloudletInternalFieldKeyFederatedOrganization = "2.3"
const CloudletInternalFieldProps = "3"
const CloudletInternalFieldPropsKey = "3.1"
const CloudletInternalFieldPropsValue = "3.2"

var CloudletInternalAllFields = []string{
	CloudletInternalFieldKeyOrganization,
	CloudletInternalFieldKeyName,
	CloudletInternalFieldKeyFederatedOrganization,
	CloudletInternalFieldPropsKey,
	CloudletInternalFieldPropsValue,
}

var CloudletInternalAllFieldsMap = map[string]struct{}{
	CloudletInternalFieldKeyOrganization:          struct{}{},
	CloudletInternalFieldKeyName:                  struct{}{},
	CloudletInternalFieldKeyFederatedOrganization: struct{}{},
	CloudletInternalFieldPropsKey:                 struct{}{},
	CloudletInternalFieldPropsValue:               struct{}{},
}

var CloudletInternalAllFieldsStringMap = map[string]string{
	CloudletInternalFieldKeyOrganization:          "Key Organization",
	CloudletInternalFieldKeyName:                  "Key Name",
	CloudletInternalFieldKeyFederatedOrganization: "Key Federated Organization",
	CloudletInternalFieldPropsKey:                 "Props Key",
	CloudletInternalFieldPropsValue:               "Props Value",
}

func (m *CloudletInternal) IsKeyField(s string) bool {
	return strings.HasPrefix(s, CloudletInternalFieldKey+".") || s == CloudletInternalFieldKey
}

func (m *CloudletInternal) DiffFields(o *CloudletInternal, fields map[string]struct{}) {
	if m.Key.Organization != o.Key.Organization {
		fields[CloudletInternalFieldKeyOrganization] = struct{}{}
		fields[CloudletInternalFieldKey] = struct{}{}
	}
	if m.Key.Name != o.Key.Name {
		fields[CloudletInternalFieldKeyName] = struct{}{}
		fields[CloudletInternalFieldKey] = struct{}{}
	}
	if m.Key.FederatedOrganization != o.Key.FederatedOrganization {
		fields[CloudletInternalFieldKeyFederatedOrganization] = struct{}{}
		fields[CloudletInternalFieldKey] = struct{}{}
	}
	if m.Props != nil && o.Props != nil {
		if len(m.Props) != len(o.Props) {
			fields[CloudletInternalFieldProps] = struct{}{}
		} else {
			for k0, _ := range m.Props {
				_, vok0 := o.Props[k0]
				if !vok0 {
					fields[CloudletInternalFieldProps] = struct{}{}
				} else {
					if m.Props[k0] != o.Props[k0] {
						fields[CloudletInternalFieldProps] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.Props != nil && o.Props == nil) || (m.Props == nil && o.Props != nil) {
		fields[CloudletInternalFieldProps] = struct{}{}
	}
}

func (m *CloudletInternal) CopyInFields(src *CloudletInternal) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
		if _, set := fmap["2.2"]; set {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
		if _, set := fmap["2.3"]; set {
			if m.Key.FederatedOrganization != src.Key.FederatedOrganization {
				m.Key.FederatedOrganization = src.Key.FederatedOrganization
				changed++
			}
		}
	}
	if _, set := fmap["3"]; set {
		if src.Props != nil {
			m.Props = make(map[string]string)
			for k0, _ := range src.Props {
				m.Props[k0] = src.Props[k0]
				changed++
			}
		} else if m.Props != nil {
			m.Props = nil
			changed++
		}
	}
	return changed
}

func (m *CloudletInternal) DeepCopyIn(src *CloudletInternal) {
	m.Key.DeepCopyIn(&src.Key)
	if src.Props != nil {
		m.Props = make(map[string]string)
		for k, v := range src.Props {
			m.Props[k] = v
		}
	} else {
		m.Props = nil
	}
}

func (s *CloudletInternal) HasFields() bool {
	return true
}

type CloudletInternalStore interface {
	Create(ctx context.Context, m *CloudletInternal, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *CloudletInternal, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *CloudletInternal, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *CloudletInternal, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*CloudletInternal, int64, error)
	Get(ctx context.Context, key *CloudletKey, buf *CloudletInternal) bool
	STMGet(stm concurrency.STM, key *CloudletKey, buf *CloudletInternal) bool
	STMPut(stm concurrency.STM, obj *CloudletInternal, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *CloudletKey)
}

type CloudletInternalStoreImpl struct {
	kvstore objstore.KVStore
}

func NewCloudletInternalStore(kvstore objstore.KVStore) *CloudletInternalStoreImpl {
	return &CloudletInternalStoreImpl{kvstore: kvstore}
}

func (s *CloudletInternalStoreImpl) Create(ctx context.Context, m *CloudletInternal, wait func(int64)) (*Result, error) {
	err := m.Validate(CloudletInternalAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("CloudletInternal", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletInternalStoreImpl) Update(ctx context.Context, m *CloudletInternal, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("CloudletInternal", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur CloudletInternal
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletInternalStoreImpl) Put(ctx context.Context, m *CloudletInternal, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(CloudletInternalAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("CloudletInternal", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletInternalStoreImpl) Delete(ctx context.Context, m *CloudletInternal, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("CloudletInternal", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletInternalStoreImpl) LoadOne(key string) (*CloudletInternal, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj CloudletInternal
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse CloudletInternal data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *CloudletInternalStoreImpl) Get(ctx context.Context, key *CloudletKey, buf *CloudletInternal) bool {
	keystr := objstore.DbKeyString("CloudletInternal", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *CloudletInternalStoreImpl) STMGet(stm concurrency.STM, key *CloudletKey, buf *CloudletInternal) bool {
	keystr := objstore.DbKeyString("CloudletInternal", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *CloudletInternalStoreImpl) parseGetData(val []byte, buf *CloudletInternal) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = CloudletInternal{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *CloudletInternalStoreImpl) STMPut(stm concurrency.STM, obj *CloudletInternal, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("CloudletInternal", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("CloudletInternal json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *CloudletInternalStoreImpl) STMDel(stm concurrency.STM, key *CloudletKey) {
	keystr := objstore.DbKeyString("CloudletInternal", key)
	stm.Del(keystr)
}

type CloudletInternalKeyWatcher struct {
	cb func(ctx context.Context)
}

type CloudletInternalCacheData struct {
	Obj    *CloudletInternal
	ModRev int64
}

// CloudletInternalCache caches CloudletInternal objects in memory in a hash table
// and keeps them in sync with the database.
type CloudletInternalCache struct {
	Objs          map[CloudletKey]*CloudletInternalCacheData
	Mux           util.Mutex
	List          map[CloudletKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *CloudletKey, old *CloudletInternal, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *CloudletInternal, new *CloudletInternal)
	DeletedCbs    []func(ctx context.Context, old *CloudletInternal)
	KeyWatchers   map[CloudletKey][]*CloudletInternalKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *CloudletKey)
	DeletedKeyCbs []func(ctx context.Context, key *CloudletKey)
}

func NewCloudletInternalCache() *CloudletInternalCache {
	cache := CloudletInternalCache{}
	InitCloudletInternalCache(&cache)
	return &cache
}

func InitCloudletInternalCache(cache *CloudletInternalCache) {
	cache.Objs = make(map[CloudletKey]*CloudletInternalCacheData)
	cache.KeyWatchers = make(map[CloudletKey][]*CloudletInternalKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *CloudletInternalCache) GetTypeString() string {
	return "CloudletInternal"
}

func (c *CloudletInternalCache) Get(key *CloudletKey, valbuf *CloudletInternal) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *CloudletInternalCache) GetWithRev(key *CloudletKey, valbuf *CloudletInternal, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *CloudletInternalCache) HasKey(key *CloudletKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *CloudletInternalCache) GetAllKeys(ctx context.Context, cb func(key *CloudletKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *CloudletInternalCache) Update(ctx context.Context, in *CloudletInternal, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *CloudletInternal) (*CloudletInternal, bool) {
		return in, true
	})
}

func (c *CloudletInternalCache) UpdateModFunc(ctx context.Context, key *CloudletKey, modRev int64, modFunc func(old *CloudletInternal) (new *CloudletInternal, changed bool)) {
	c.Mux.Lock()
	var old *CloudletInternal
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	for _, cb := range c.UpdatedCbs {
		newCopy := &CloudletInternal{}
		newCopy.DeepCopyIn(new)
		defer cb(ctx, old, newCopy)
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			defer cb(ctx, new.GetKey(), old, modRev)
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &CloudletInternal{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &CloudletInternalCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *CloudletInternalCache) Delete(ctx context.Context, in *CloudletInternal, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *CloudletInternal) bool {
		return true
	})
}

func (c *CloudletInternalCache) DeleteCondFunc(ctx context.Context, in *CloudletInternal, modRev int64, condFunc func(old *CloudletInternal) bool) {
	c.Mux.Lock()
	var old *CloudletInternal
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	c.Mux.Unlock()
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, in.GetKey(), old, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *CloudletInternalCache) Prune(ctx context.Context, validKeys map[CloudletKey]struct{}) {
	notify := make(map[CloudletKey]*CloudletInternalCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, old.Obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *CloudletInternalCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *CloudletInternalCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *CloudletInternalCache) Show(filter *CloudletInternal, cb func(ret *CloudletInternal) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func CloudletInternalGenericNotifyCb(fn func(key *CloudletKey, old *CloudletInternal)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*CloudletKey), obj.(*CloudletInternal))
	}
}

func (c *CloudletInternalCache) SetNotifyCb(fn func(ctx context.Context, obj *CloudletKey, old *CloudletInternal, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *CloudletKey, old *CloudletInternal, modRev int64){fn}
}

func (c *CloudletInternalCache) SetUpdatedCb(fn func(ctx context.Context, old *CloudletInternal, new *CloudletInternal)) {
	c.UpdatedCbs = []func(ctx context.Context, old *CloudletInternal, new *CloudletInternal){fn}
}

func (c *CloudletInternalCache) SetDeletedCb(fn func(ctx context.Context, old *CloudletInternal)) {
	c.DeletedCbs = []func(ctx context.Context, old *CloudletInternal){fn}
}

func (c *CloudletInternalCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *CloudletKey){fn}
}

func (c *CloudletInternalCache) SetDeletedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *CloudletKey){fn}
}

func (c *CloudletInternalCache) AddUpdatedCb(fn func(ctx context.Context, old *CloudletInternal, new *CloudletInternal)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *CloudletInternalCache) AddDeletedCb(fn func(ctx context.Context, old *CloudletInternal)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *CloudletInternalCache) AddNotifyCb(fn func(ctx context.Context, obj *CloudletKey, old *CloudletInternal, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *CloudletInternalCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *CloudletInternalCache) AddDeletedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *CloudletInternalCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *CloudletInternalCache) WatchKey(key *CloudletKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*CloudletInternalKeyWatcher, 0)
	}
	watcher := CloudletInternalKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching CloudletInternal", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *CloudletInternalCache) TriggerKeyWatchers(ctx context.Context, key *CloudletKey) {
	watchers := make([]*CloudletInternalKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *CloudletInternalCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := CloudletInternal{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse CloudletInternal data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *CloudletInternalCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := CloudletInternal{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	CloudletKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *CloudletInternalCache) SyncListStart(ctx context.Context) {
	c.List = make(map[CloudletKey]struct{})
}

func (c *CloudletInternalCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[CloudletKey]*CloudletInternalCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, val.Obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *CloudletInternalCache) UsesOrg(org string) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		if key.Organization == org {
			return true
		}
	}
	return false
}

func (m *CloudletInternal) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *CloudletInternal) GetKey() *CloudletKey {
	return &m.Key
}

func (m *CloudletInternal) GetKeyVal() CloudletKey {
	return m.Key
}

func (m *CloudletInternal) SetKey(key *CloudletKey) {
	m.Key = *key
}

func CmpSortCloudletInternal(a CloudletInternal, b CloudletInternal) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *CloudletInternal) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *CloudletInternal) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
}

func (m *PlatformConfig) CopyInFields(src *PlatformConfig) int {
	changed := 0
	if m.ContainerRegistryPath != src.ContainerRegistryPath {
		m.ContainerRegistryPath = src.ContainerRegistryPath
		changed++
	}
	if m.CloudletVmImagePath != src.CloudletVmImagePath {
		m.CloudletVmImagePath = src.CloudletVmImagePath
		changed++
	}
	if m.NotifyCtrlAddrs != src.NotifyCtrlAddrs {
		m.NotifyCtrlAddrs = src.NotifyCtrlAddrs
		changed++
	}
	if m.TlsCertFile != src.TlsCertFile {
		m.TlsCertFile = src.TlsCertFile
		changed++
	}
	if src.EnvVar != nil {
		m.EnvVar = make(map[string]string)
		for k0, _ := range src.EnvVar {
			m.EnvVar[k0] = src.EnvVar[k0]
			changed++
		}
	} else if m.EnvVar != nil {
		m.EnvVar = nil
		changed++
	}
	if m.PlatformTag != src.PlatformTag {
		m.PlatformTag = src.PlatformTag
		changed++
	}
	if m.TestMode != src.TestMode {
		m.TestMode = src.TestMode
		changed++
	}
	if m.Span != src.Span {
		m.Span = src.Span
		changed++
	}
	if m.CleanupMode != src.CleanupMode {
		m.CleanupMode = src.CleanupMode
		changed++
	}
	if m.Region != src.Region {
		m.Region = src.Region
		changed++
	}
	if m.CommercialCerts != src.CommercialCerts {
		m.CommercialCerts = src.CommercialCerts
		changed++
	}
	if m.UseVaultPki != src.UseVaultPki {
		m.UseVaultPki = src.UseVaultPki
		changed++
	}
	if m.AppDnsRoot != src.AppDnsRoot {
		m.AppDnsRoot = src.AppDnsRoot
		changed++
	}
	if m.ChefServerPath != src.ChefServerPath {
		m.ChefServerPath = src.ChefServerPath
		changed++
	}
	if m.ChefClientInterval != src.ChefClientInterval {
		m.ChefClientInterval = src.ChefClientInterval
		changed++
	}
	if m.DeploymentTag != src.DeploymentTag {
		m.DeploymentTag = src.DeploymentTag
		changed++
	}
	if m.TlsKeyFile != src.TlsKeyFile {
		m.TlsKeyFile = src.TlsKeyFile
		changed++
	}
	if m.TlsCaFile != src.TlsCaFile {
		m.TlsCaFile = src.TlsCaFile
		changed++
	}
	if m.CrmAccessPrivateKey != src.CrmAccessPrivateKey {
		m.CrmAccessPrivateKey = src.CrmAccessPrivateKey
		changed++
	}
	if m.AccessApiAddr != src.AccessApiAddr {
		m.AccessApiAddr = src.AccessApiAddr
		changed++
	}
	if m.CacheDir != src.CacheDir {
		m.CacheDir = src.CacheDir
		changed++
	}
	if m.SecondaryCrmAccessPrivateKey != src.SecondaryCrmAccessPrivateKey {
		m.SecondaryCrmAccessPrivateKey = src.SecondaryCrmAccessPrivateKey
		changed++
	}
	return changed
}

func (m *PlatformConfig) DeepCopyIn(src *PlatformConfig) {
	m.ContainerRegistryPath = src.ContainerRegistryPath
	m.CloudletVmImagePath = src.CloudletVmImagePath
	m.NotifyCtrlAddrs = src.NotifyCtrlAddrs
	m.TlsCertFile = src.TlsCertFile
	if src.EnvVar != nil {
		m.EnvVar = make(map[string]string)
		for k, v := range src.EnvVar {
			m.EnvVar[k] = v
		}
	} else {
		m.EnvVar = nil
	}
	m.PlatformTag = src.PlatformTag
	m.TestMode = src.TestMode
	m.Span = src.Span
	m.CleanupMode = src.CleanupMode
	m.Region = src.Region
	m.CommercialCerts = src.CommercialCerts
	m.UseVaultPki = src.UseVaultPki
	m.AppDnsRoot = src.AppDnsRoot
	m.ChefServerPath = src.ChefServerPath
	m.ChefClientInterval = src.ChefClientInterval
	m.DeploymentTag = src.DeploymentTag
	m.TlsKeyFile = src.TlsKeyFile
	m.TlsCaFile = src.TlsCaFile
	m.CrmAccessPrivateKey = src.CrmAccessPrivateKey
	m.AccessApiAddr = src.AccessApiAddr
	m.CacheDir = src.CacheDir
	m.SecondaryCrmAccessPrivateKey = src.SecondaryCrmAccessPrivateKey
}

// Helper method to check that enums have valid values
func (m *PlatformConfig) ValidateEnums() error {
	return nil
}

func (s *PlatformConfig) ClearTagged(tags map[string]struct{}) {
	if _, found := tags["nocmp"]; found {
		s.NotifyCtrlAddrs = ""
	}
	if _, found := tags["nocmp"]; found {
		s.PlatformTag = ""
	}
	if _, found := tags["nocmp"]; found {
		s.Span = ""
	}
	if _, found := tags["nocmp"]; found {
		s.CrmAccessPrivateKey = ""
	}
	if _, found := tags["nocmp"]; found {
		s.AccessApiAddr = ""
	}
	if _, found := tags["nocmp"]; found {
		s.SecondaryCrmAccessPrivateKey = ""
	}
}

func IgnorePlatformConfigFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "NotifyCtrlAddrs")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "PlatformTag")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Span")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "CrmAccessPrivateKey")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "AccessApiAddr")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "SecondaryCrmAccessPrivateKey")
	}
	return cmpopts.IgnoreFields(PlatformConfig{}, names...)
}

func (m *CloudletResMap) CopyInFields(src *CloudletResMap) int {
	changed := 0
	if m.Key.Organization != src.Key.Organization {
		m.Key.Organization = src.Key.Organization
		changed++
	}
	if m.Key.Name != src.Key.Name {
		m.Key.Name = src.Key.Name
		changed++
	}
	if m.Key.FederatedOrganization != src.Key.FederatedOrganization {
		m.Key.FederatedOrganization = src.Key.FederatedOrganization
		changed++
	}
	if src.Mapping != nil {
		m.Mapping = make(map[string]string)
		for k0, _ := range src.Mapping {
			m.Mapping[k0] = src.Mapping[k0]
			changed++
		}
	} else if m.Mapping != nil {
		m.Mapping = nil
		changed++
	}
	return changed
}

func (m *CloudletResMap) DeepCopyIn(src *CloudletResMap) {
	m.Key.DeepCopyIn(&src.Key)
	if src.Mapping != nil {
		m.Mapping = make(map[string]string)
		for k, v := range src.Mapping {
			m.Mapping[k] = v
		}
	} else {
		m.Mapping = nil
	}
}

func (m *CloudletResMap) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *CloudletResMap) GetKey() *CloudletKey {
	return &m.Key
}

func (m *CloudletResMap) GetKeyVal() CloudletKey {
	return m.Key
}

func (m *CloudletResMap) SetKey(key *CloudletKey) {
	m.Key = *key
}

func CmpSortCloudletResMap(a CloudletResMap, b CloudletResMap) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *CloudletResMap) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *CloudletResMap) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
}

func (m *InfraConfig) CopyInFields(src *InfraConfig) int {
	changed := 0
	if m.ExternalNetworkName != src.ExternalNetworkName {
		m.ExternalNetworkName = src.ExternalNetworkName
		changed++
	}
	if m.FlavorName != src.FlavorName {
		m.FlavorName = src.FlavorName
		changed++
	}
	return changed
}

func (m *InfraConfig) DeepCopyIn(src *InfraConfig) {
	m.ExternalNetworkName = src.ExternalNetworkName
	m.FlavorName = src.FlavorName
}

// Helper method to check that enums have valid values
func (m *InfraConfig) ValidateEnums() error {
	return nil
}

func (s *InfraConfig) ClearTagged(tags map[string]struct{}) {
}

func (m *ResourceQuota) CopyInFields(src *ResourceQuota) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.Value != src.Value {
		m.Value = src.Value
		changed++
	}
	if m.AlertThreshold != src.AlertThreshold {
		m.AlertThreshold = src.AlertThreshold
		changed++
	}
	return changed
}

func (m *ResourceQuota) DeepCopyIn(src *ResourceQuota) {
	m.Name = src.Name
	m.Value = src.Value
	m.AlertThreshold = src.AlertThreshold
}

// Helper method to check that enums have valid values
func (m *ResourceQuota) ValidateEnums() error {
	return nil
}

func (s *ResourceQuota) ClearTagged(tags map[string]struct{}) {
}

func (m *GPUDriverKey) Matches(o *GPUDriverKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.Name != "" {
		if o.Name != m.Name {
			return false
		}
	}
	if !opts.Filter || o.Organization != "" {
		if o.Organization != m.Organization {
			return false
		}
	}
	return true
}

func (m *GPUDriverKey) CopyInFields(src *GPUDriverKey) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.Organization != src.Organization {
		m.Organization = src.Organization
		changed++
	}
	return changed
}

func (m *GPUDriverKey) DeepCopyIn(src *GPUDriverKey) {
	m.Name = src.Name
	m.Organization = src.Organization
}

func (m *GPUDriverKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal GPUDriverKey key string", "obj", m)
	}
	return string(key)
}

func GPUDriverKeyStringParse(str string, key *GPUDriverKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal GPUDriverKey key string", "str", str)
	}
}

func (m *GPUDriverKey) NotFoundError() error {
	return fmt.Errorf("GPUDriver key %s not found", m.GetKeyString())
}

func (m *GPUDriverKey) ExistsError() error {
	return fmt.Errorf("GPUDriver key %s already exists", m.GetKeyString())
}

func (m *GPUDriverKey) BeingDeletedError() error {
	return fmt.Errorf("GPUDriver %s is being deleted", m.GetKeyString())
}

var GPUDriverKeyTagName = "gpudriver"
var GPUDriverKeyTagOrganization = "gpudriverorg"

func (m *GPUDriverKey) GetTags() map[string]string {
	tags := make(map[string]string)
	tags["gpudriver"] = m.Name
	tags["gpudriverorg"] = m.Organization
	return tags
}

// Helper method to check that enums have valid values
func (m *GPUDriverKey) ValidateEnums() error {
	return nil
}

func (s *GPUDriverKey) ClearTagged(tags map[string]struct{}) {
}

func (m *GPUDriverBuild) CopyInFields(src *GPUDriverBuild) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.DriverPath != src.DriverPath {
		m.DriverPath = src.DriverPath
		changed++
	}
	if m.DriverPathCreds != src.DriverPathCreds {
		m.DriverPathCreds = src.DriverPathCreds
		changed++
	}
	if m.OperatingSystem != src.OperatingSystem {
		m.OperatingSystem = src.OperatingSystem
		changed++
	}
	if m.KernelVersion != src.KernelVersion {
		m.KernelVersion = src.KernelVersion
		changed++
	}
	if m.HypervisorInfo != src.HypervisorInfo {
		m.HypervisorInfo = src.HypervisorInfo
		changed++
	}
	if m.Md5Sum != src.Md5Sum {
		m.Md5Sum = src.Md5Sum
		changed++
	}
	return changed
}

func (m *GPUDriverBuild) DeepCopyIn(src *GPUDriverBuild) {
	m.Name = src.Name
	m.DriverPath = src.DriverPath
	m.DriverPathCreds = src.DriverPathCreds
	m.OperatingSystem = src.OperatingSystem
	m.KernelVersion = src.KernelVersion
	m.HypervisorInfo = src.HypervisorInfo
	m.Md5Sum = src.Md5Sum
}

// Helper method to check that enums have valid values
func (m *GPUDriverBuild) ValidateEnums() error {
	if _, ok := OSType_name[int32(m.OperatingSystem)]; !ok {
		return errors.New("invalid OperatingSystem")
	}
	return nil
}

func (s *GPUDriverBuild) ClearTagged(tags map[string]struct{}) {
}

func (m *GPUDriverBuildMember) CopyInFields(src *GPUDriverBuildMember) int {
	changed := 0
	if m.Key.Name != src.Key.Name {
		m.Key.Name = src.Key.Name
		changed++
	}
	if m.Key.Organization != src.Key.Organization {
		m.Key.Organization = src.Key.Organization
		changed++
	}
	if m.Build.Name != src.Build.Name {
		m.Build.Name = src.Build.Name
		changed++
	}
	if m.Build.DriverPath != src.Build.DriverPath {
		m.Build.DriverPath = src.Build.DriverPath
		changed++
	}
	if m.Build.DriverPathCreds != src.Build.DriverPathCreds {
		m.Build.DriverPathCreds = src.Build.DriverPathCreds
		changed++
	}
	if m.Build.OperatingSystem != src.Build.OperatingSystem {
		m.Build.OperatingSystem = src.Build.OperatingSystem
		changed++
	}
	if m.Build.KernelVersion != src.Build.KernelVersion {
		m.Build.KernelVersion = src.Build.KernelVersion
		changed++
	}
	if m.Build.HypervisorInfo != src.Build.HypervisorInfo {
		m.Build.HypervisorInfo = src.Build.HypervisorInfo
		changed++
	}
	if m.Build.Md5Sum != src.Build.Md5Sum {
		m.Build.Md5Sum = src.Build.Md5Sum
		changed++
	}
	if m.IgnoreState != src.IgnoreState {
		m.IgnoreState = src.IgnoreState
		changed++
	}
	return changed
}

func (m *GPUDriverBuildMember) DeepCopyIn(src *GPUDriverBuildMember) {
	m.Key.DeepCopyIn(&src.Key)
	m.Build.DeepCopyIn(&src.Build)
	m.IgnoreState = src.IgnoreState
}

func (m *GPUDriverBuildMember) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *GPUDriverBuildMember) GetKey() *GPUDriverKey {
	return &m.Key
}

func (m *GPUDriverBuildMember) GetKeyVal() GPUDriverKey {
	return m.Key
}

func (m *GPUDriverBuildMember) SetKey(key *GPUDriverKey) {
	m.Key = *key
}

func CmpSortGPUDriverBuildMember(a GPUDriverBuildMember, b GPUDriverBuildMember) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *GPUDriverBuildMember) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if err := m.Build.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *GPUDriverBuildMember) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	s.Build.ClearTagged(tags)
}

func (m *GPUDriverBuildURL) CopyInFields(src *GPUDriverBuildURL) int {
	changed := 0
	if m.BuildUrlPath != src.BuildUrlPath {
		m.BuildUrlPath = src.BuildUrlPath
		changed++
	}
	if m.Validity != src.Validity {
		m.Validity = src.Validity
		changed++
	}
	return changed
}

func (m *GPUDriverBuildURL) DeepCopyIn(src *GPUDriverBuildURL) {
	m.BuildUrlPath = src.BuildUrlPath
	m.Validity = src.Validity
}

// Helper method to check that enums have valid values
func (m *GPUDriverBuildURL) ValidateEnums() error {
	return nil
}

func (s *GPUDriverBuildURL) ClearTagged(tags map[string]struct{}) {
}

func (m *GPUDriver) Matches(o *GPUDriver, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.Builds != nil {
		if len(m.Builds) == 0 && len(o.Builds) > 0 || len(m.Builds) > 0 && len(o.Builds) == 0 {
			return false
		} else if m.Builds != nil && o.Builds != nil {
			if !opts.Filter && len(m.Builds) != len(o.Builds) {
				return false
			}
		}
	}
	if !opts.Filter || o.LicenseConfig != "" {
		if o.LicenseConfig != m.LicenseConfig {
			return false
		}
	}
	if !opts.Filter || o.LicenseConfigMd5Sum != "" {
		if o.LicenseConfigMd5Sum != m.LicenseConfigMd5Sum {
			return false
		}
	}
	if !opts.Filter || o.Properties != nil {
		if len(m.Properties) == 0 && len(o.Properties) > 0 || len(m.Properties) > 0 && len(o.Properties) == 0 {
			return false
		} else if m.Properties != nil && o.Properties != nil {
			if !opts.Filter && len(m.Properties) != len(o.Properties) {
				return false
			}
			for k, _ := range o.Properties {
				_, ok := m.Properties[k]
				if !ok {
					return false
				}
				if o.Properties[k] != m.Properties[k] {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.State != "" {
		if o.State != m.State {
			return false
		}
	}
	if !opts.Filter || o.IgnoreState != false {
		if o.IgnoreState != m.IgnoreState {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DeletePrepare != false {
			if o.DeletePrepare != m.DeletePrepare {
				return false
			}
		}
	}
	return true
}

const GPUDriverFieldKey = "2"
const GPUDriverFieldKeyName = "2.1"
const GPUDriverFieldKeyOrganization = "2.2"
const GPUDriverFieldBuilds = "3"
const GPUDriverFieldBuildsName = "3.1"
const GPUDriverFieldBuildsDriverPath = "3.2"
const GPUDriverFieldBuildsDriverPathCreds = "3.3"
const GPUDriverFieldBuildsOperatingSystem = "3.4"
const GPUDriverFieldBuildsKernelVersion = "3.5"
const GPUDriverFieldBuildsHypervisorInfo = "3.6"
const GPUDriverFieldBuildsMd5Sum = "3.7"
const GPUDriverFieldLicenseConfig = "4"
const GPUDriverFieldLicenseConfigMd5Sum = "5"
const GPUDriverFieldProperties = "6"
const GPUDriverFieldPropertiesKey = "6.1"
const GPUDriverFieldPropertiesValue = "6.2"
const GPUDriverFieldState = "7"
const GPUDriverFieldIgnoreState = "8"
const GPUDriverFieldDeletePrepare = "9"

var GPUDriverAllFields = []string{
	GPUDriverFieldKeyName,
	GPUDriverFieldKeyOrganization,
	GPUDriverFieldBuildsName,
	GPUDriverFieldBuildsDriverPath,
	GPUDriverFieldBuildsDriverPathCreds,
	GPUDriverFieldBuildsOperatingSystem,
	GPUDriverFieldBuildsKernelVersion,
	GPUDriverFieldBuildsHypervisorInfo,
	GPUDriverFieldBuildsMd5Sum,
	GPUDriverFieldLicenseConfig,
	GPUDriverFieldLicenseConfigMd5Sum,
	GPUDriverFieldPropertiesKey,
	GPUDriverFieldPropertiesValue,
	GPUDriverFieldState,
	GPUDriverFieldIgnoreState,
	GPUDriverFieldDeletePrepare,
}

var GPUDriverAllFieldsMap = map[string]struct{}{
	GPUDriverFieldKeyName:               struct{}{},
	GPUDriverFieldKeyOrganization:       struct{}{},
	GPUDriverFieldBuildsName:            struct{}{},
	GPUDriverFieldBuildsDriverPath:      struct{}{},
	GPUDriverFieldBuildsDriverPathCreds: struct{}{},
	GPUDriverFieldBuildsOperatingSystem: struct{}{},
	GPUDriverFieldBuildsKernelVersion:   struct{}{},
	GPUDriverFieldBuildsHypervisorInfo:  struct{}{},
	GPUDriverFieldBuildsMd5Sum:          struct{}{},
	GPUDriverFieldLicenseConfig:         struct{}{},
	GPUDriverFieldLicenseConfigMd5Sum:   struct{}{},
	GPUDriverFieldPropertiesKey:         struct{}{},
	GPUDriverFieldPropertiesValue:       struct{}{},
	GPUDriverFieldState:                 struct{}{},
	GPUDriverFieldIgnoreState:           struct{}{},
	GPUDriverFieldDeletePrepare:         struct{}{},
}

var GPUDriverAllFieldsStringMap = map[string]string{
	GPUDriverFieldKeyName:               "Key Name",
	GPUDriverFieldKeyOrganization:       "Key Organization",
	GPUDriverFieldBuildsName:            "Builds Name",
	GPUDriverFieldBuildsDriverPath:      "Builds Driver Path",
	GPUDriverFieldBuildsDriverPathCreds: "Builds Driver Path Creds",
	GPUDriverFieldBuildsOperatingSystem: "Builds Operating System",
	GPUDriverFieldBuildsKernelVersion:   "Builds Kernel Version",
	GPUDriverFieldBuildsHypervisorInfo:  "Builds Hypervisor Info",
	GPUDriverFieldBuildsMd5Sum:          "Builds Md5 Sum",
	GPUDriverFieldLicenseConfig:         "License Config",
	GPUDriverFieldLicenseConfigMd5Sum:   "License Config Md5 Sum",
	GPUDriverFieldPropertiesKey:         "Properties Key",
	GPUDriverFieldPropertiesValue:       "Properties Value",
	GPUDriverFieldState:                 "State",
	GPUDriverFieldIgnoreState:           "Ignore State",
	GPUDriverFieldDeletePrepare:         "Delete Prepare",
}

func (m *GPUDriver) IsKeyField(s string) bool {
	return strings.HasPrefix(s, GPUDriverFieldKey+".") || s == GPUDriverFieldKey
}

func (m *GPUDriver) DiffFields(o *GPUDriver, fields map[string]struct{}) {
	if m.Key.Name != o.Key.Name {
		fields[GPUDriverFieldKeyName] = struct{}{}
		fields[GPUDriverFieldKey] = struct{}{}
	}
	if m.Key.Organization != o.Key.Organization {
		fields[GPUDriverFieldKeyOrganization] = struct{}{}
		fields[GPUDriverFieldKey] = struct{}{}
	}
	if len(m.Builds) != len(o.Builds) {
		fields[GPUDriverFieldBuilds] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.Builds); i0++ {
			if m.Builds[i0].Name != o.Builds[i0].Name {
				fields[GPUDriverFieldBuildsName] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
			if m.Builds[i0].DriverPath != o.Builds[i0].DriverPath {
				fields[GPUDriverFieldBuildsDriverPath] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
			if m.Builds[i0].DriverPathCreds != o.Builds[i0].DriverPathCreds {
				fields[GPUDriverFieldBuildsDriverPathCreds] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
			if m.Builds[i0].OperatingSystem != o.Builds[i0].OperatingSystem {
				fields[GPUDriverFieldBuildsOperatingSystem] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
			if m.Builds[i0].KernelVersion != o.Builds[i0].KernelVersion {
				fields[GPUDriverFieldBuildsKernelVersion] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
			if m.Builds[i0].HypervisorInfo != o.Builds[i0].HypervisorInfo {
				fields[GPUDriverFieldBuildsHypervisorInfo] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
			if m.Builds[i0].Md5Sum != o.Builds[i0].Md5Sum {
				fields[GPUDriverFieldBuildsMd5Sum] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
		}
	}
	if m.LicenseConfig != o.LicenseConfig {
		fields[GPUDriverFieldLicenseConfig] = struct{}{}
	}
	if m.LicenseConfigMd5Sum != o.LicenseConfigMd5Sum {
		fields[GPUDriverFieldLicenseConfigMd5Sum] = struct{}{}
	}
	if m.Properties != nil && o.Properties != nil {
		if len(m.Properties) != len(o.Properties) {
			fields[GPUDriverFieldProperties] = struct{}{}
		} else {
			for k0, _ := range m.Properties {
				_, vok0 := o.Properties[k0]
				if !vok0 {
					fields[GPUDriverFieldProperties] = struct{}{}
				} else {
					if m.Properties[k0] != o.Properties[k0] {
						fields[GPUDriverFieldProperties] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.Properties != nil && o.Properties == nil) || (m.Properties == nil && o.Properties != nil) {
		fields[GPUDriverFieldProperties] = struct{}{}
	}
	if m.State != o.State {
		fields[GPUDriverFieldState] = struct{}{}
	}
	if m.IgnoreState != o.IgnoreState {
		fields[GPUDriverFieldIgnoreState] = struct{}{}
	}
	if m.DeletePrepare != o.DeletePrepare {
		fields[GPUDriverFieldDeletePrepare] = struct{}{}
	}
}

var UpdateGPUDriverFieldsMap = map[string]struct{}{
	GPUDriverFieldLicenseConfig:   struct{}{},
	GPUDriverFieldProperties:      struct{}{},
	GPUDriverFieldPropertiesValue: struct{}{},
}

func (m *GPUDriver) ValidateUpdateFields() error {
	if m.Fields == nil {
		return fmt.Errorf("nothing specified to update")
	}
	fmap := MakeFieldMap(m.Fields)
	badFieldStrs := []string{}
	for field, _ := range fmap {
		if m.IsKeyField(field) {
			continue
		}
		if _, ok := UpdateGPUDriverFieldsMap[field]; !ok {
			if _, ok := GPUDriverAllFieldsStringMap[field]; !ok {
				continue
			}
			badFieldStrs = append(badFieldStrs, GPUDriverAllFieldsStringMap[field])
		}
	}
	if len(badFieldStrs) > 0 {
		return fmt.Errorf("specified field(s) %s cannot be modified", strings.Join(badFieldStrs, ","))
	}
	return nil
}

func (m *GPUDriver) CopyInFields(src *GPUDriver) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
		if _, set := fmap["2.2"]; set {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
	}
	if _, set := fmap["3"]; set {
		if src.Builds != nil {
			m.Builds = src.Builds
			changed++
		} else if m.Builds != nil {
			m.Builds = nil
			changed++
		}
	}
	if _, set := fmap["4"]; set {
		if m.LicenseConfig != src.LicenseConfig {
			m.LicenseConfig = src.LicenseConfig
			changed++
		}
	}
	if _, set := fmap["5"]; set {
		if m.LicenseConfigMd5Sum != src.LicenseConfigMd5Sum {
			m.LicenseConfigMd5Sum = src.LicenseConfigMd5Sum
			changed++
		}
	}
	if _, set := fmap["6"]; set {
		if src.Properties != nil {
			m.Properties = make(map[string]string)
			for k0, _ := range src.Properties {
				m.Properties[k0] = src.Properties[k0]
				changed++
			}
		} else if m.Properties != nil {
			m.Properties = nil
			changed++
		}
	}
	if _, set := fmap["7"]; set {
		if m.State != src.State {
			m.State = src.State
			changed++
		}
	}
	if _, set := fmap["8"]; set {
		if m.IgnoreState != src.IgnoreState {
			m.IgnoreState = src.IgnoreState
			changed++
		}
	}
	if _, set := fmap["9"]; set {
		if m.DeletePrepare != src.DeletePrepare {
			m.DeletePrepare = src.DeletePrepare
			changed++
		}
	}
	return changed
}

func (m *GPUDriver) DeepCopyIn(src *GPUDriver) {
	m.Key.DeepCopyIn(&src.Key)
	if src.Builds != nil {
		m.Builds = make([]GPUDriverBuild, len(src.Builds), len(src.Builds))
		for ii, s := range src.Builds {
			m.Builds[ii].DeepCopyIn(&s)
		}
	} else {
		m.Builds = nil
	}
	m.LicenseConfig = src.LicenseConfig
	m.LicenseConfigMd5Sum = src.LicenseConfigMd5Sum
	if src.Properties != nil {
		m.Properties = make(map[string]string)
		for k, v := range src.Properties {
			m.Properties[k] = v
		}
	} else {
		m.Properties = nil
	}
	m.State = src.State
	m.IgnoreState = src.IgnoreState
	m.DeletePrepare = src.DeletePrepare
}

func (s *GPUDriver) HasFields() bool {
	return true
}

type GPUDriverStore interface {
	Create(ctx context.Context, m *GPUDriver, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *GPUDriver, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *GPUDriver, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *GPUDriver, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*GPUDriver, int64, error)
	Get(ctx context.Context, key *GPUDriverKey, buf *GPUDriver) bool
	STMGet(stm concurrency.STM, key *GPUDriverKey, buf *GPUDriver) bool
	STMPut(stm concurrency.STM, obj *GPUDriver, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *GPUDriverKey)
}

type GPUDriverStoreImpl struct {
	kvstore objstore.KVStore
}

func NewGPUDriverStore(kvstore objstore.KVStore) *GPUDriverStoreImpl {
	return &GPUDriverStoreImpl{kvstore: kvstore}
}

func (s *GPUDriverStoreImpl) Create(ctx context.Context, m *GPUDriver, wait func(int64)) (*Result, error) {
	err := m.Validate(GPUDriverAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("GPUDriver", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *GPUDriverStoreImpl) Update(ctx context.Context, m *GPUDriver, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("GPUDriver", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur GPUDriver
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *GPUDriverStoreImpl) Put(ctx context.Context, m *GPUDriver, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(GPUDriverAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("GPUDriver", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *GPUDriverStoreImpl) Delete(ctx context.Context, m *GPUDriver, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("GPUDriver", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *GPUDriverStoreImpl) LoadOne(key string) (*GPUDriver, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj GPUDriver
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse GPUDriver data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *GPUDriverStoreImpl) Get(ctx context.Context, key *GPUDriverKey, buf *GPUDriver) bool {
	keystr := objstore.DbKeyString("GPUDriver", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *GPUDriverStoreImpl) STMGet(stm concurrency.STM, key *GPUDriverKey, buf *GPUDriver) bool {
	keystr := objstore.DbKeyString("GPUDriver", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *GPUDriverStoreImpl) parseGetData(val []byte, buf *GPUDriver) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = GPUDriver{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *GPUDriverStoreImpl) STMPut(stm concurrency.STM, obj *GPUDriver, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("GPUDriver", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("GPUDriver json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *GPUDriverStoreImpl) STMDel(stm concurrency.STM, key *GPUDriverKey) {
	keystr := objstore.DbKeyString("GPUDriver", key)
	stm.Del(keystr)
}

type GPUDriverKeyWatcher struct {
	cb func(ctx context.Context)
}

type GPUDriverCacheData struct {
	Obj    *GPUDriver
	ModRev int64
}

// GPUDriverCache caches GPUDriver objects in memory in a hash table
// and keeps them in sync with the database.
type GPUDriverCache struct {
	Objs          map[GPUDriverKey]*GPUDriverCacheData
	Mux           util.Mutex
	List          map[GPUDriverKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *GPUDriverKey, old *GPUDriver, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *GPUDriver, new *GPUDriver)
	DeletedCbs    []func(ctx context.Context, old *GPUDriver)
	KeyWatchers   map[GPUDriverKey][]*GPUDriverKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *GPUDriverKey)
	DeletedKeyCbs []func(ctx context.Context, key *GPUDriverKey)
}

func NewGPUDriverCache() *GPUDriverCache {
	cache := GPUDriverCache{}
	InitGPUDriverCache(&cache)
	return &cache
}

func InitGPUDriverCache(cache *GPUDriverCache) {
	cache.Objs = make(map[GPUDriverKey]*GPUDriverCacheData)
	cache.KeyWatchers = make(map[GPUDriverKey][]*GPUDriverKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *GPUDriverCache) GetTypeString() string {
	return "GPUDriver"
}

func (c *GPUDriverCache) Get(key *GPUDriverKey, valbuf *GPUDriver) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *GPUDriverCache) GetWithRev(key *GPUDriverKey, valbuf *GPUDriver, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *GPUDriverCache) HasKey(key *GPUDriverKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *GPUDriverCache) GetAllKeys(ctx context.Context, cb func(key *GPUDriverKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *GPUDriverCache) Update(ctx context.Context, in *GPUDriver, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *GPUDriver) (*GPUDriver, bool) {
		return in, true
	})
}

func (c *GPUDriverCache) UpdateModFunc(ctx context.Context, key *GPUDriverKey, modRev int64, modFunc func(old *GPUDriver) (new *GPUDriver, changed bool)) {
	c.Mux.Lock()
	var old *GPUDriver
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	for _, cb := range c.UpdatedCbs {
		newCopy := &GPUDriver{}
		newCopy.DeepCopyIn(new)
		defer cb(ctx, old, newCopy)
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			defer cb(ctx, new.GetKey(), old, modRev)
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &GPUDriver{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &GPUDriverCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *GPUDriverCache) Delete(ctx context.Context, in *GPUDriver, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *GPUDriver) bool {
		return true
	})
}

func (c *GPUDriverCache) DeleteCondFunc(ctx context.Context, in *GPUDriver, modRev int64, condFunc func(old *GPUDriver) bool) {
	c.Mux.Lock()
	var old *GPUDriver
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	c.Mux.Unlock()
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, in.GetKey(), old, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *GPUDriverCache) Prune(ctx context.Context, validKeys map[GPUDriverKey]struct{}) {
	notify := make(map[GPUDriverKey]*GPUDriverCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, old.Obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *GPUDriverCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *GPUDriverCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *GPUDriverCache) Show(filter *GPUDriver, cb func(ret *GPUDriver) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func GPUDriverGenericNotifyCb(fn func(key *GPUDriverKey, old *GPUDriver)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*GPUDriverKey), obj.(*GPUDriver))
	}
}

func (c *GPUDriverCache) SetNotifyCb(fn func(ctx context.Context, obj *GPUDriverKey, old *GPUDriver, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *GPUDriverKey, old *GPUDriver, modRev int64){fn}
}

func (c *GPUDriverCache) SetUpdatedCb(fn func(ctx context.Context, old *GPUDriver, new *GPUDriver)) {
	c.UpdatedCbs = []func(ctx context.Context, old *GPUDriver, new *GPUDriver){fn}
}

func (c *GPUDriverCache) SetDeletedCb(fn func(ctx context.Context, old *GPUDriver)) {
	c.DeletedCbs = []func(ctx context.Context, old *GPUDriver){fn}
}

func (c *GPUDriverCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *GPUDriverKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *GPUDriverKey){fn}
}

func (c *GPUDriverCache) SetDeletedKeyCb(fn func(ctx context.Context, key *GPUDriverKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *GPUDriverKey){fn}
}

func (c *GPUDriverCache) AddUpdatedCb(fn func(ctx context.Context, old *GPUDriver, new *GPUDriver)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *GPUDriverCache) AddDeletedCb(fn func(ctx context.Context, old *GPUDriver)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *GPUDriverCache) AddNotifyCb(fn func(ctx context.Context, obj *GPUDriverKey, old *GPUDriver, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *GPUDriverCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *GPUDriverKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *GPUDriverCache) AddDeletedKeyCb(fn func(ctx context.Context, key *GPUDriverKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *GPUDriverCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *GPUDriverCache) WatchKey(key *GPUDriverKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*GPUDriverKeyWatcher, 0)
	}
	watcher := GPUDriverKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching GPUDriver", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *GPUDriverCache) TriggerKeyWatchers(ctx context.Context, key *GPUDriverKey) {
	watchers := make([]*GPUDriverKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *GPUDriverCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := GPUDriver{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse GPUDriver data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *GPUDriverCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := GPUDriver{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	GPUDriverKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *GPUDriverCache) SyncListStart(ctx context.Context) {
	c.List = make(map[GPUDriverKey]struct{})
}

func (c *GPUDriverCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[GPUDriverKey]*GPUDriverCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, val.Obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *GPUDriverCache) UsesOrg(org string) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		if key.Organization == org {
			return true
		}
	}
	return false
}

func (m *GPUDriver) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *GPUDriver) GetKey() *GPUDriverKey {
	return &m.Key
}

func (m *GPUDriver) GetKeyVal() GPUDriverKey {
	return m.Key
}

func (m *GPUDriver) SetKey(key *GPUDriverKey) {
	m.Key = *key
}

func CmpSortGPUDriver(a GPUDriver, b GPUDriver) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *GPUDriver) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.Builds {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *GPUDriver) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	if s.Builds != nil {
		for ii := 0; ii < len(s.Builds); ii++ {
			s.Builds[ii].ClearTagged(tags)
		}
	}
}

func (m *GPUConfig) CopyInFields(src *GPUConfig) int {
	changed := 0
	if m.Driver.Name != src.Driver.Name {
		m.Driver.Name = src.Driver.Name
		changed++
	}
	if m.Driver.Organization != src.Driver.Organization {
		m.Driver.Organization = src.Driver.Organization
		changed++
	}
	if src.Properties != nil {
		m.Properties = make(map[string]string)
		for k0, _ := range src.Properties {
			m.Properties[k0] = src.Properties[k0]
			changed++
		}
	} else if m.Properties != nil {
		m.Properties = nil
		changed++
	}
	if m.LicenseConfig != src.LicenseConfig {
		m.LicenseConfig = src.LicenseConfig
		changed++
	}
	if m.LicenseConfigMd5Sum != src.LicenseConfigMd5Sum {
		m.LicenseConfigMd5Sum = src.LicenseConfigMd5Sum
		changed++
	}
	return changed
}

func (m *GPUConfig) DeepCopyIn(src *GPUConfig) {
	m.Driver.DeepCopyIn(&src.Driver)
	if src.Properties != nil {
		m.Properties = make(map[string]string)
		for k, v := range src.Properties {
			m.Properties[k] = v
		}
	} else {
		m.Properties = nil
	}
	m.LicenseConfig = src.LicenseConfig
	m.LicenseConfigMd5Sum = src.LicenseConfigMd5Sum
}

// Helper method to check that enums have valid values
func (m *GPUConfig) ValidateEnums() error {
	if err := m.Driver.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *GPUConfig) ClearTagged(tags map[string]struct{}) {
	s.Driver.ClearTagged(tags)
}

func (m *Cloudlet) Matches(o *Cloudlet, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.IpSupport != 0 {
		if o.IpSupport != m.IpSupport {
			return false
		}
	}
	if !opts.Filter || o.StaticIps != "" {
		if o.StaticIps != m.StaticIps {
			return false
		}
	}
	if !opts.Filter || o.NumDynamicIps != 0 {
		if o.NumDynamicIps != m.NumDynamicIps {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Errors != nil {
			if len(m.Errors) == 0 && len(o.Errors) > 0 || len(m.Errors) > 0 && len(o.Errors) == 0 {
				return false
			} else if m.Errors != nil && o.Errors != nil {
				if !opts.Filter && len(m.Errors) != len(o.Errors) {
					return false
				}
				found := 0
				for oIndex, _ := range o.Errors {
					for mIndex, _ := range m.Errors {
						if o.Errors[oIndex] == m.Errors[mIndex] {
							found++
							break
						}
					}
				}
				if found != len(o.Errors) {
					return false
				}
			}
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.State != 0 {
			if o.State != m.State {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.CrmOverride != 0 {
			if o.CrmOverride != m.CrmOverride {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DeploymentLocal != false {
			if o.DeploymentLocal != m.DeploymentLocal {
				return false
			}
		}
	}
	if !opts.Filter || o.PlatformType != 0 {
		if o.PlatformType != m.PlatformType {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.NotifySrvAddr != "" {
			if o.NotifySrvAddr != m.NotifySrvAddr {
				return false
			}
		}
	}
	if !m.Flavor.Matches(&o.Flavor, fopts...) {
		return false
	}
	if !opts.Filter || o.PhysicalName != "" {
		if o.PhysicalName != m.PhysicalName {
			return false
		}
	}
	if !opts.Filter || o.EnvVar != nil {
		if len(m.EnvVar) == 0 && len(o.EnvVar) > 0 || len(m.EnvVar) > 0 && len(o.EnvVar) == 0 {
			return false
		} else if m.EnvVar != nil && o.EnvVar != nil {
			if !opts.Filter && len(m.EnvVar) != len(o.EnvVar) {
				return false
			}
			for k, _ := range o.EnvVar {
				_, ok := m.EnvVar[k]
				if !ok {
					return false
				}
				if o.EnvVar[k] != m.EnvVar[k] {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.ContainerVersion != "" {
		if o.ContainerVersion != m.ContainerVersion {
			return false
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.ResTagMap != nil {
			if len(m.ResTagMap) == 0 && len(o.ResTagMap) > 0 || len(m.ResTagMap) > 0 && len(o.ResTagMap) == 0 {
				return false
			} else if m.ResTagMap != nil && o.ResTagMap != nil {
				if !opts.Filter && len(m.ResTagMap) != len(o.ResTagMap) {
					return false
				}
				for k, _ := range o.ResTagMap {
					_, ok := m.ResTagMap[k]
					if !ok {
						return false
					}
					if !m.ResTagMap[k].Matches(o.ResTagMap[k], fopts...) {
						return false
					}
				}
			}
		}
	}
	if !opts.Filter || o.AccessVars != nil {
		if len(m.AccessVars) == 0 && len(o.AccessVars) > 0 || len(m.AccessVars) > 0 && len(o.AccessVars) == 0 {
			return false
		} else if m.AccessVars != nil && o.AccessVars != nil {
			if !opts.Filter && len(m.AccessVars) != len(o.AccessVars) {
				return false
			}
			for k, _ := range o.AccessVars {
				_, ok := m.AccessVars[k]
				if !ok {
					return false
				}
				if o.AccessVars[k] != m.AccessVars[k] {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.VmImageVersion != "" {
		if o.VmImageVersion != m.VmImageVersion {
			return false
		}
	}
	if !opts.Filter || o.Deployment != "" {
		if o.Deployment != m.Deployment {
			return false
		}
	}
	if !opts.Filter || o.InfraApiAccess != 0 {
		if o.InfraApiAccess != m.InfraApiAccess {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.ChefClientKey != nil {
			if len(m.ChefClientKey) == 0 && len(o.ChefClientKey) > 0 || len(m.ChefClientKey) > 0 && len(o.ChefClientKey) == 0 {
				return false
			} else if m.ChefClientKey != nil && o.ChefClientKey != nil {
				if !opts.Filter && len(m.ChefClientKey) != len(o.ChefClientKey) {
					return false
				}
				for k, _ := range o.ChefClientKey {
					_, ok := m.ChefClientKey[k]
					if !ok {
						return false
					}
					if o.ChefClientKey[k] != m.ChefClientKey[k] {
						return false
					}
				}
			}
		}
	}
	if !opts.Filter || o.MaintenanceState != 0 {
		if o.MaintenanceState != m.MaintenanceState {
			return false
		}
	}
	if !opts.Filter || o.OverridePolicyContainerVersion != false {
		if o.OverridePolicyContainerVersion != m.OverridePolicyContainerVersion {
			return false
		}
	}
	if !opts.Filter || o.VmPool != "" {
		if o.VmPool != m.VmPool {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.CrmAccessPublicKey != "" {
			if o.CrmAccessPublicKey != m.CrmAccessPublicKey {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.CrmAccessKeyUpgradeRequired != false {
			if o.CrmAccessKeyUpgradeRequired != m.CrmAccessKeyUpgradeRequired {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
	}
	if !opts.Filter || o.TrustPolicy != "" {
		if o.TrustPolicy != m.TrustPolicy {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.TrustPolicyState != 0 {
			if o.TrustPolicyState != m.TrustPolicyState {
				return false
			}
		}
	}
	if !opts.Filter || o.ResourceQuotas != nil {
		if len(m.ResourceQuotas) == 0 && len(o.ResourceQuotas) > 0 || len(m.ResourceQuotas) > 0 && len(o.ResourceQuotas) == 0 {
			return false
		} else if m.ResourceQuotas != nil && o.ResourceQuotas != nil {
			if !opts.Filter && len(m.ResourceQuotas) != len(o.ResourceQuotas) {
				return false
			}
		}
	}
	if !opts.Filter || o.DefaultResourceAlertThreshold != 0 {
		if o.DefaultResourceAlertThreshold != m.DefaultResourceAlertThreshold {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.HostController != "" {
			if o.HostController != m.HostController {
				return false
			}
		}
	}
	if !opts.Filter || o.KafkaCluster != "" {
		if o.KafkaCluster != m.KafkaCluster {
			return false
		}
	}
	if !opts.Filter || o.KafkaUser != "" {
		if o.KafkaUser != m.KafkaUser {
			return false
		}
	}
	if !opts.Filter || o.KafkaPassword != "" {
		if o.KafkaPassword != m.KafkaPassword {
			return false
		}
	}
	if !opts.Filter || o.EnableDefaultServerlessCluster != false {
		if o.EnableDefaultServerlessCluster != m.EnableDefaultServerlessCluster {
			return false
		}
	}
	if !opts.Filter || o.AllianceOrgs != nil {
		if len(m.AllianceOrgs) == 0 && len(o.AllianceOrgs) > 0 || len(m.AllianceOrgs) > 0 && len(o.AllianceOrgs) == 0 {
			return false
		} else if m.AllianceOrgs != nil && o.AllianceOrgs != nil {
			if !opts.Filter && len(m.AllianceOrgs) != len(o.AllianceOrgs) {
				return false
			}
			found := 0
			for oIndex, _ := range o.AllianceOrgs {
				for mIndex, _ := range m.AllianceOrgs {
					if o.AllianceOrgs[oIndex] == m.AllianceOrgs[mIndex] {
						found++
						break
					}
				}
			}
			if found != len(o.AllianceOrgs) {
				return false
			}
		}
	}
	if !opts.Filter || o.SingleKubernetesClusterOwner != "" {
		if o.SingleKubernetesClusterOwner != m.SingleKubernetesClusterOwner {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DeletePrepare != false {
			if o.DeletePrepare != m.DeletePrepare {
				return false
			}
		}
	}
	if !opts.Filter || o.PlatformHighAvailability != false {
		if o.PlatformHighAvailability != m.PlatformHighAvailability {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.SecondaryCrmAccessPublicKey != "" {
			if o.SecondaryCrmAccessPublicKey != m.SecondaryCrmAccessPublicKey {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.SecondaryCrmAccessKeyUpgradeRequired != false {
			if o.SecondaryCrmAccessKeyUpgradeRequired != m.SecondaryCrmAccessKeyUpgradeRequired {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.SecondaryNotifySrvAddr != "" {
			if o.SecondaryNotifySrvAddr != m.SecondaryNotifySrvAddr {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DnsLabel != "" {
			if o.DnsLabel != m.DnsLabel {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.RootLbFqdn != "" {
			if o.RootLbFqdn != m.RootLbFqdn {
				return false
			}
		}
	}
	return true
}

const CloudletFieldKey = "2"
const CloudletFieldKeyOrganization = "2.1"
const CloudletFieldKeyName = "2.2"
const CloudletFieldKeyFederatedOrganization = "2.3"
const CloudletFieldLocation = "5"
const CloudletFieldLocationLatitude = "5.1"
const CloudletFieldLocationLongitude = "5.2"
const CloudletFieldLocationHorizontalAccuracy = "5.3"
const CloudletFieldLocationVerticalAccuracy = "5.4"
const CloudletFieldLocationAltitude = "5.5"
const CloudletFieldLocationCourse = "5.6"
const CloudletFieldLocationSpeed = "5.7"
const CloudletFieldLocationTimestamp = "5.8"
const CloudletFieldLocationTimestampSeconds = "5.8.1"
const CloudletFieldLocationTimestampNanos = "5.8.2"
const CloudletFieldIpSupport = "6"
const CloudletFieldStaticIps = "7"
const CloudletFieldNumDynamicIps = "8"
const CloudletFieldTimeLimits = "9"
const CloudletFieldTimeLimitsCreateClusterInstTimeout = "9.1"
const CloudletFieldTimeLimitsUpdateClusterInstTimeout = "9.2"
const CloudletFieldTimeLimitsDeleteClusterInstTimeout = "9.3"
const CloudletFieldTimeLimitsCreateAppInstTimeout = "9.4"
const CloudletFieldTimeLimitsUpdateAppInstTimeout = "9.5"
const CloudletFieldTimeLimitsDeleteAppInstTimeout = "9.6"
const CloudletFieldErrors = "10"
const CloudletFieldStatus = "11"
const CloudletFieldStatusTaskNumber = "11.1"
const CloudletFieldStatusMaxTasks = "11.2"
const CloudletFieldStatusTaskName = "11.3"
const CloudletFieldStatusStepName = "11.4"
const CloudletFieldStatusMsgCount = "11.5"
const CloudletFieldStatusMsgs = "11.6"
const CloudletFieldState = "12"
const CloudletFieldCrmOverride = "13"
const CloudletFieldDeploymentLocal = "14"
const CloudletFieldPlatformType = "15"
const CloudletFieldNotifySrvAddr = "16"
const CloudletFieldFlavor = "17"
const CloudletFieldFlavorName = "17.1"
const CloudletFieldPhysicalName = "18"
const CloudletFieldEnvVar = "19"
const CloudletFieldEnvVarKey = "19.1"
const CloudletFieldEnvVarValue = "19.2"
const CloudletFieldContainerVersion = "20"
const CloudletFieldConfig = "21"
const CloudletFieldConfigContainerRegistryPath = "21.1"
const CloudletFieldConfigCloudletVmImagePath = "21.2"
const CloudletFieldConfigNotifyCtrlAddrs = "21.3"
const CloudletFieldConfigTlsCertFile = "21.5"
const CloudletFieldConfigEnvVar = "21.6"
const CloudletFieldConfigEnvVarKey = "21.6.1"
const CloudletFieldConfigEnvVarValue = "21.6.2"
const CloudletFieldConfigPlatformTag = "21.8"
const CloudletFieldConfigTestMode = "21.9"
const CloudletFieldConfigSpan = "21.10"
const CloudletFieldConfigCleanupMode = "21.11"
const CloudletFieldConfigRegion = "21.12"
const CloudletFieldConfigCommercialCerts = "21.13"
const CloudletFieldConfigUseVaultPki = "21.14"
const CloudletFieldConfigAppDnsRoot = "21.16"
const CloudletFieldConfigChefServerPath = "21.17"
const CloudletFieldConfigChefClientInterval = "21.18"
const CloudletFieldConfigDeploymentTag = "21.19"
const CloudletFieldConfigTlsKeyFile = "21.20"
const CloudletFieldConfigTlsCaFile = "21.21"
const CloudletFieldConfigCrmAccessPrivateKey = "21.22"
const CloudletFieldConfigAccessApiAddr = "21.23"
const CloudletFieldConfigCacheDir = "21.24"
const CloudletFieldConfigSecondaryCrmAccessPrivateKey = "21.25"
const CloudletFieldResTagMap = "22"
const CloudletFieldResTagMapKey = "22.1"
const CloudletFieldResTagMapValue = "22.2"
const CloudletFieldResTagMapValueName = "22.2.1"
const CloudletFieldResTagMapValueOrganization = "22.2.2"
const CloudletFieldAccessVars = "23"
const CloudletFieldAccessVarsKey = "23.1"
const CloudletFieldAccessVarsValue = "23.2"
const CloudletFieldVmImageVersion = "24"
const CloudletFieldDeployment = "26"
const CloudletFieldInfraApiAccess = "27"
const CloudletFieldInfraConfig = "28"
const CloudletFieldInfraConfigExternalNetworkName = "28.1"
const CloudletFieldInfraConfigFlavorName = "28.2"
const CloudletFieldChefClientKey = "29"
const CloudletFieldChefClientKeyKey = "29.1"
const CloudletFieldChefClientKeyValue = "29.2"
const CloudletFieldMaintenanceState = "30"
const CloudletFieldOverridePolicyContainerVersion = "31"
const CloudletFieldVmPool = "32"
const CloudletFieldCrmAccessPublicKey = "33"
const CloudletFieldCrmAccessKeyUpgradeRequired = "34"
const CloudletFieldCreatedAt = "35"
const CloudletFieldCreatedAtSeconds = "35.1"
const CloudletFieldCreatedAtNanos = "35.2"
const CloudletFieldUpdatedAt = "36"
const CloudletFieldUpdatedAtSeconds = "36.1"
const CloudletFieldUpdatedAtNanos = "36.2"
const CloudletFieldTrustPolicy = "37"
const CloudletFieldTrustPolicyState = "38"
const CloudletFieldResourceQuotas = "39"
const CloudletFieldResourceQuotasName = "39.1"
const CloudletFieldResourceQuotasValue = "39.2"
const CloudletFieldResourceQuotasAlertThreshold = "39.3"
const CloudletFieldDefaultResourceAlertThreshold = "40"
const CloudletFieldHostController = "41"
const CloudletFieldKafkaCluster = "42"
const CloudletFieldKafkaUser = "43"
const CloudletFieldKafkaPassword = "44"
const CloudletFieldGpuConfig = "45"
const CloudletFieldGpuConfigDriver = "45.1"
const CloudletFieldGpuConfigDriverName = "45.1.1"
const CloudletFieldGpuConfigDriverOrganization = "45.1.2"
const CloudletFieldGpuConfigProperties = "45.2"
const CloudletFieldGpuConfigPropertiesKey = "45.2.1"
const CloudletFieldGpuConfigPropertiesValue = "45.2.2"
const CloudletFieldGpuConfigLicenseConfig = "45.3"
const CloudletFieldGpuConfigLicenseConfigMd5Sum = "45.4"
const CloudletFieldEnableDefaultServerlessCluster = "46"
const CloudletFieldAllianceOrgs = "47"
const CloudletFieldSingleKubernetesClusterOwner = "48"
const CloudletFieldDeletePrepare = "49"
const CloudletFieldPlatformHighAvailability = "50"
const CloudletFieldSecondaryCrmAccessPublicKey = "51"
const CloudletFieldSecondaryCrmAccessKeyUpgradeRequired = "52"
const CloudletFieldSecondaryNotifySrvAddr = "53"
const CloudletFieldDnsLabel = "54"
const CloudletFieldRootLbFqdn = "55"

var CloudletAllFields = []string{
	CloudletFieldKeyOrganization,
	CloudletFieldKeyName,
	CloudletFieldKeyFederatedOrganization,
	CloudletFieldLocationLatitude,
	CloudletFieldLocationLongitude,
	CloudletFieldLocationHorizontalAccuracy,
	CloudletFieldLocationVerticalAccuracy,
	CloudletFieldLocationAltitude,
	CloudletFieldLocationCourse,
	CloudletFieldLocationSpeed,
	CloudletFieldLocationTimestampSeconds,
	CloudletFieldLocationTimestampNanos,
	CloudletFieldIpSupport,
	CloudletFieldStaticIps,
	CloudletFieldNumDynamicIps,
	CloudletFieldTimeLimitsCreateClusterInstTimeout,
	CloudletFieldTimeLimitsUpdateClusterInstTimeout,
	CloudletFieldTimeLimitsDeleteClusterInstTimeout,
	CloudletFieldTimeLimitsCreateAppInstTimeout,
	CloudletFieldTimeLimitsUpdateAppInstTimeout,
	CloudletFieldTimeLimitsDeleteAppInstTimeout,
	CloudletFieldErrors,
	CloudletFieldStatusTaskNumber,
	CloudletFieldStatusMaxTasks,
	CloudletFieldStatusTaskName,
	CloudletFieldStatusStepName,
	CloudletFieldStatusMsgCount,
	CloudletFieldStatusMsgs,
	CloudletFieldState,
	CloudletFieldCrmOverride,
	CloudletFieldDeploymentLocal,
	CloudletFieldPlatformType,
	CloudletFieldNotifySrvAddr,
	CloudletFieldFlavorName,
	CloudletFieldPhysicalName,
	CloudletFieldEnvVarKey,
	CloudletFieldEnvVarValue,
	CloudletFieldContainerVersion,
	CloudletFieldConfigContainerRegistryPath,
	CloudletFieldConfigCloudletVmImagePath,
	CloudletFieldConfigNotifyCtrlAddrs,
	CloudletFieldConfigTlsCertFile,
	CloudletFieldConfigEnvVarKey,
	CloudletFieldConfigEnvVarValue,
	CloudletFieldConfigPlatformTag,
	CloudletFieldConfigTestMode,
	CloudletFieldConfigSpan,
	CloudletFieldConfigCleanupMode,
	CloudletFieldConfigRegion,
	CloudletFieldConfigCommercialCerts,
	CloudletFieldConfigUseVaultPki,
	CloudletFieldConfigAppDnsRoot,
	CloudletFieldConfigChefServerPath,
	CloudletFieldConfigChefClientInterval,
	CloudletFieldConfigDeploymentTag,
	CloudletFieldConfigTlsKeyFile,
	CloudletFieldConfigTlsCaFile,
	CloudletFieldConfigCrmAccessPrivateKey,
	CloudletFieldConfigAccessApiAddr,
	CloudletFieldConfigCacheDir,
	CloudletFieldConfigSecondaryCrmAccessPrivateKey,
	CloudletFieldResTagMapKey,
	CloudletFieldResTagMapValueName,
	CloudletFieldResTagMapValueOrganization,
	CloudletFieldAccessVarsKey,
	CloudletFieldAccessVarsValue,
	CloudletFieldVmImageVersion,
	CloudletFieldDeployment,
	CloudletFieldInfraApiAccess,
	CloudletFieldInfraConfigExternalNetworkName,
	CloudletFieldInfraConfigFlavorName,
	CloudletFieldChefClientKeyKey,
	CloudletFieldChefClientKeyValue,
	CloudletFieldMaintenanceState,
	CloudletFieldOverridePolicyContainerVersion,
	CloudletFieldVmPool,
	CloudletFieldCrmAccessPublicKey,
	CloudletFieldCrmAccessKeyUpgradeRequired,
	CloudletFieldCreatedAtSeconds,
	CloudletFieldCreatedAtNanos,
	CloudletFieldUpdatedAtSeconds,
	CloudletFieldUpdatedAtNanos,
	CloudletFieldTrustPolicy,
	CloudletFieldTrustPolicyState,
	CloudletFieldResourceQuotasName,
	CloudletFieldResourceQuotasValue,
	CloudletFieldResourceQuotasAlertThreshold,
	CloudletFieldDefaultResourceAlertThreshold,
	CloudletFieldHostController,
	CloudletFieldKafkaCluster,
	CloudletFieldKafkaUser,
	CloudletFieldKafkaPassword,
	CloudletFieldGpuConfigDriverName,
	CloudletFieldGpuConfigDriverOrganization,
	CloudletFieldGpuConfigPropertiesKey,
	CloudletFieldGpuConfigPropertiesValue,
	CloudletFieldGpuConfigLicenseConfig,
	CloudletFieldGpuConfigLicenseConfigMd5Sum,
	CloudletFieldEnableDefaultServerlessCluster,
	CloudletFieldAllianceOrgs,
	CloudletFieldSingleKubernetesClusterOwner,
	CloudletFieldDeletePrepare,
	CloudletFieldPlatformHighAvailability,
	CloudletFieldSecondaryCrmAccessPublicKey,
	CloudletFieldSecondaryCrmAccessKeyUpgradeRequired,
	CloudletFieldSecondaryNotifySrvAddr,
	CloudletFieldDnsLabel,
	CloudletFieldRootLbFqdn,
}

var CloudletAllFieldsMap = map[string]struct{}{
	CloudletFieldKeyOrganization:                      struct{}{},
	CloudletFieldKeyName:                              struct{}{},
	CloudletFieldKeyFederatedOrganization:             struct{}{},
	CloudletFieldLocationLatitude:                     struct{}{},
	CloudletFieldLocationLongitude:                    struct{}{},
	CloudletFieldLocationHorizontalAccuracy:           struct{}{},
	CloudletFieldLocationVerticalAccuracy:             struct{}{},
	CloudletFieldLocationAltitude:                     struct{}{},
	CloudletFieldLocationCourse:                       struct{}{},
	CloudletFieldLocationSpeed:                        struct{}{},
	CloudletFieldLocationTimestampSeconds:             struct{}{},
	CloudletFieldLocationTimestampNanos:               struct{}{},
	CloudletFieldIpSupport:                            struct{}{},
	CloudletFieldStaticIps:                            struct{}{},
	CloudletFieldNumDynamicIps:                        struct{}{},
	CloudletFieldTimeLimitsCreateClusterInstTimeout:   struct{}{},
	CloudletFieldTimeLimitsUpdateClusterInstTimeout:   struct{}{},
	CloudletFieldTimeLimitsDeleteClusterInstTimeout:   struct{}{},
	CloudletFieldTimeLimitsCreateAppInstTimeout:       struct{}{},
	CloudletFieldTimeLimitsUpdateAppInstTimeout:       struct{}{},
	CloudletFieldTimeLimitsDeleteAppInstTimeout:       struct{}{},
	CloudletFieldErrors:                               struct{}{},
	CloudletFieldStatusTaskNumber:                     struct{}{},
	CloudletFieldStatusMaxTasks:                       struct{}{},
	CloudletFieldStatusTaskName:                       struct{}{},
	CloudletFieldStatusStepName:                       struct{}{},
	CloudletFieldStatusMsgCount:                       struct{}{},
	CloudletFieldStatusMsgs:                           struct{}{},
	CloudletFieldState:                                struct{}{},
	CloudletFieldCrmOverride:                          struct{}{},
	CloudletFieldDeploymentLocal:                      struct{}{},
	CloudletFieldPlatformType:                         struct{}{},
	CloudletFieldNotifySrvAddr:                        struct{}{},
	CloudletFieldFlavorName:                           struct{}{},
	CloudletFieldPhysicalName:                         struct{}{},
	CloudletFieldEnvVarKey:                            struct{}{},
	CloudletFieldEnvVarValue:                          struct{}{},
	CloudletFieldContainerVersion:                     struct{}{},
	CloudletFieldConfigContainerRegistryPath:          struct{}{},
	CloudletFieldConfigCloudletVmImagePath:            struct{}{},
	CloudletFieldConfigNotifyCtrlAddrs:                struct{}{},
	CloudletFieldConfigTlsCertFile:                    struct{}{},
	CloudletFieldConfigEnvVarKey:                      struct{}{},
	CloudletFieldConfigEnvVarValue:                    struct{}{},
	CloudletFieldConfigPlatformTag:                    struct{}{},
	CloudletFieldConfigTestMode:                       struct{}{},
	CloudletFieldConfigSpan:                           struct{}{},
	CloudletFieldConfigCleanupMode:                    struct{}{},
	CloudletFieldConfigRegion:                         struct{}{},
	CloudletFieldConfigCommercialCerts:                struct{}{},
	CloudletFieldConfigUseVaultPki:                    struct{}{},
	CloudletFieldConfigAppDnsRoot:                     struct{}{},
	CloudletFieldConfigChefServerPath:                 struct{}{},
	CloudletFieldConfigChefClientInterval:             struct{}{},
	CloudletFieldConfigDeploymentTag:                  struct{}{},
	CloudletFieldConfigTlsKeyFile:                     struct{}{},
	CloudletFieldConfigTlsCaFile:                      struct{}{},
	CloudletFieldConfigCrmAccessPrivateKey:            struct{}{},
	CloudletFieldConfigAccessApiAddr:                  struct{}{},
	CloudletFieldConfigCacheDir:                       struct{}{},
	CloudletFieldConfigSecondaryCrmAccessPrivateKey:   struct{}{},
	CloudletFieldResTagMapKey:                         struct{}{},
	CloudletFieldResTagMapValueName:                   struct{}{},
	CloudletFieldResTagMapValueOrganization:           struct{}{},
	CloudletFieldAccessVarsKey:                        struct{}{},
	CloudletFieldAccessVarsValue:                      struct{}{},
	CloudletFieldVmImageVersion:                       struct{}{},
	CloudletFieldDeployment:                           struct{}{},
	CloudletFieldInfraApiAccess:                       struct{}{},
	CloudletFieldInfraConfigExternalNetworkName:       struct{}{},
	CloudletFieldInfraConfigFlavorName:                struct{}{},
	CloudletFieldChefClientKeyKey:                     struct{}{},
	CloudletFieldChefClientKeyValue:                   struct{}{},
	CloudletFieldMaintenanceState:                     struct{}{},
	CloudletFieldOverridePolicyContainerVersion:       struct{}{},
	CloudletFieldVmPool:                               struct{}{},
	CloudletFieldCrmAccessPublicKey:                   struct{}{},
	CloudletFieldCrmAccessKeyUpgradeRequired:          struct{}{},
	CloudletFieldCreatedAtSeconds:                     struct{}{},
	CloudletFieldCreatedAtNanos:                       struct{}{},
	CloudletFieldUpdatedAtSeconds:                     struct{}{},
	CloudletFieldUpdatedAtNanos:                       struct{}{},
	CloudletFieldTrustPolicy:                          struct{}{},
	CloudletFieldTrustPolicyState:                     struct{}{},
	CloudletFieldResourceQuotasName:                   struct{}{},
	CloudletFieldResourceQuotasValue:                  struct{}{},
	CloudletFieldResourceQuotasAlertThreshold:         struct{}{},
	CloudletFieldDefaultResourceAlertThreshold:        struct{}{},
	CloudletFieldHostController:                       struct{}{},
	CloudletFieldKafkaCluster:                         struct{}{},
	CloudletFieldKafkaUser:                            struct{}{},
	CloudletFieldKafkaPassword:                        struct{}{},
	CloudletFieldGpuConfigDriverName:                  struct{}{},
	CloudletFieldGpuConfigDriverOrganization:          struct{}{},
	CloudletFieldGpuConfigPropertiesKey:               struct{}{},
	CloudletFieldGpuConfigPropertiesValue:             struct{}{},
	CloudletFieldGpuConfigLicenseConfig:               struct{}{},
	CloudletFieldGpuConfigLicenseConfigMd5Sum:         struct{}{},
	CloudletFieldEnableDefaultServerlessCluster:       struct{}{},
	CloudletFieldAllianceOrgs:                         struct{}{},
	CloudletFieldSingleKubernetesClusterOwner:         struct{}{},
	CloudletFieldDeletePrepare:                        struct{}{},
	CloudletFieldPlatformHighAvailability:             struct{}{},
	CloudletFieldSecondaryCrmAccessPublicKey:          struct{}{},
	CloudletFieldSecondaryCrmAccessKeyUpgradeRequired: struct{}{},
	CloudletFieldSecondaryNotifySrvAddr:               struct{}{},
	CloudletFieldDnsLabel:                             struct{}{},
	CloudletFieldRootLbFqdn:                           struct{}{},
}

var CloudletAllFieldsStringMap = map[string]string{
	CloudletFieldKeyOrganization:                      "Key Organization",
	CloudletFieldKeyName:                              "Key Name",
	CloudletFieldKeyFederatedOrganization:             "Key Federated Organization",
	CloudletFieldLocationLatitude:                     "Location Latitude",
	CloudletFieldLocationLongitude:                    "Location Longitude",
	CloudletFieldLocationHorizontalAccuracy:           "Location Horizontal Accuracy",
	CloudletFieldLocationVerticalAccuracy:             "Location Vertical Accuracy",
	CloudletFieldLocationAltitude:                     "Location Altitude",
	CloudletFieldLocationCourse:                       "Location Course",
	CloudletFieldLocationSpeed:                        "Location Speed",
	CloudletFieldLocationTimestampSeconds:             "Location Timestamp Seconds",
	CloudletFieldLocationTimestampNanos:               "Location Timestamp Nanos",
	CloudletFieldIpSupport:                            "Ip Support",
	CloudletFieldStaticIps:                            "Static Ips",
	CloudletFieldNumDynamicIps:                        "Num Dynamic Ips",
	CloudletFieldTimeLimitsCreateClusterInstTimeout:   "Time Limits Create Cluster Inst Timeout",
	CloudletFieldTimeLimitsUpdateClusterInstTimeout:   "Time Limits Update Cluster Inst Timeout",
	CloudletFieldTimeLimitsDeleteClusterInstTimeout:   "Time Limits Delete Cluster Inst Timeout",
	CloudletFieldTimeLimitsCreateAppInstTimeout:       "Time Limits Create App Inst Timeout",
	CloudletFieldTimeLimitsUpdateAppInstTimeout:       "Time Limits Update App Inst Timeout",
	CloudletFieldTimeLimitsDeleteAppInstTimeout:       "Time Limits Delete App Inst Timeout",
	CloudletFieldErrors:                               "Errors",
	CloudletFieldStatusTaskNumber:                     "Status Task Number",
	CloudletFieldStatusMaxTasks:                       "Status Max Tasks",
	CloudletFieldStatusTaskName:                       "Status Task Name",
	CloudletFieldStatusStepName:                       "Status Step Name",
	CloudletFieldStatusMsgCount:                       "Status Msg Count",
	CloudletFieldStatusMsgs:                           "Status Msgs",
	CloudletFieldState:                                "State",
	CloudletFieldCrmOverride:                          "Crm Override",
	CloudletFieldDeploymentLocal:                      "Deployment Local",
	CloudletFieldPlatformType:                         "Platform Type",
	CloudletFieldNotifySrvAddr:                        "Notify Srv Addr",
	CloudletFieldFlavorName:                           "Flavor Name",
	CloudletFieldPhysicalName:                         "Physical Name",
	CloudletFieldEnvVarKey:                            "Env Var Key",
	CloudletFieldEnvVarValue:                          "Env Var Value",
	CloudletFieldContainerVersion:                     "Container Version",
	CloudletFieldConfigContainerRegistryPath:          "Config Container Registry Path",
	CloudletFieldConfigCloudletVmImagePath:            "Config Cloudlet Vm Image Path",
	CloudletFieldConfigNotifyCtrlAddrs:                "Config Notify Ctrl Addrs",
	CloudletFieldConfigTlsCertFile:                    "Config Tls Cert File",
	CloudletFieldConfigEnvVarKey:                      "Config Env Var Key",
	CloudletFieldConfigEnvVarValue:                    "Config Env Var Value",
	CloudletFieldConfigPlatformTag:                    "Config Platform Tag",
	CloudletFieldConfigTestMode:                       "Config Test Mode",
	CloudletFieldConfigSpan:                           "Config Span",
	CloudletFieldConfigCleanupMode:                    "Config Cleanup Mode",
	CloudletFieldConfigRegion:                         "Config Region",
	CloudletFieldConfigCommercialCerts:                "Config Commercial Certs",
	CloudletFieldConfigUseVaultPki:                    "Config Use Vault Pki",
	CloudletFieldConfigAppDnsRoot:                     "Config App Dns Root",
	CloudletFieldConfigChefServerPath:                 "Config Chef Server Path",
	CloudletFieldConfigChefClientInterval:             "Config Chef Client Interval",
	CloudletFieldConfigDeploymentTag:                  "Config Deployment Tag",
	CloudletFieldConfigTlsKeyFile:                     "Config Tls Key File",
	CloudletFieldConfigTlsCaFile:                      "Config Tls Ca File",
	CloudletFieldConfigCrmAccessPrivateKey:            "Config Crm Access Private Key",
	CloudletFieldConfigAccessApiAddr:                  "Config Access Api Addr",
	CloudletFieldConfigCacheDir:                       "Config Cache Dir",
	CloudletFieldConfigSecondaryCrmAccessPrivateKey:   "Config Secondary Crm Access Private Key",
	CloudletFieldResTagMapKey:                         "Res Tag Map Key",
	CloudletFieldResTagMapValueName:                   "Res Tag Map Value Name",
	CloudletFieldResTagMapValueOrganization:           "Res Tag Map Value Organization",
	CloudletFieldAccessVarsKey:                        "Access Vars Key",
	CloudletFieldAccessVarsValue:                      "Access Vars Value",
	CloudletFieldVmImageVersion:                       "Vm Image Version",
	CloudletFieldDeployment:                           "Deployment",
	CloudletFieldInfraApiAccess:                       "Infra Api Access",
	CloudletFieldInfraConfigExternalNetworkName:       "Infra Config External Network Name",
	CloudletFieldInfraConfigFlavorName:                "Infra Config Flavor Name",
	CloudletFieldChefClientKeyKey:                     "Chef Client Key Key",
	CloudletFieldChefClientKeyValue:                   "Chef Client Key Value",
	CloudletFieldMaintenanceState:                     "Maintenance State",
	CloudletFieldOverridePolicyContainerVersion:       "Override Policy Container Version",
	CloudletFieldVmPool:                               "Vm Pool",
	CloudletFieldCrmAccessPublicKey:                   "Crm Access Public Key",
	CloudletFieldCrmAccessKeyUpgradeRequired:          "Crm Access Key Upgrade Required",
	CloudletFieldCreatedAtSeconds:                     "Created At Seconds",
	CloudletFieldCreatedAtNanos:                       "Created At Nanos",
	CloudletFieldUpdatedAtSeconds:                     "Updated At Seconds",
	CloudletFieldUpdatedAtNanos:                       "Updated At Nanos",
	CloudletFieldTrustPolicy:                          "Trust Policy",
	CloudletFieldTrustPolicyState:                     "Trust Policy State",
	CloudletFieldResourceQuotasName:                   "Resource Quotas Name",
	CloudletFieldResourceQuotasValue:                  "Resource Quotas Value",
	CloudletFieldResourceQuotasAlertThreshold:         "Resource Quotas Alert Threshold",
	CloudletFieldDefaultResourceAlertThreshold:        "Default Resource Alert Threshold",
	CloudletFieldHostController:                       "Host Controller",
	CloudletFieldKafkaCluster:                         "Kafka Cluster",
	CloudletFieldKafkaUser:                            "Kafka User",
	CloudletFieldKafkaPassword:                        "Kafka Password",
	CloudletFieldGpuConfigDriverName:                  "Gpu Config Driver Name",
	CloudletFieldGpuConfigDriverOrganization:          "Gpu Config Driver Organization",
	CloudletFieldGpuConfigPropertiesKey:               "Gpu Config Properties Key",
	CloudletFieldGpuConfigPropertiesValue:             "Gpu Config Properties Value",
	CloudletFieldGpuConfigLicenseConfig:               "Gpu Config License Config",
	CloudletFieldGpuConfigLicenseConfigMd5Sum:         "Gpu Config License Config Md5 Sum",
	CloudletFieldEnableDefaultServerlessCluster:       "Enable Default Serverless Cluster",
	CloudletFieldAllianceOrgs:                         "Alliance Orgs",
	CloudletFieldSingleKubernetesClusterOwner:         "Single Kubernetes Cluster Owner",
	CloudletFieldDeletePrepare:                        "Delete Prepare",
	CloudletFieldPlatformHighAvailability:             "Platform High Availability",
	CloudletFieldSecondaryCrmAccessPublicKey:          "Secondary Crm Access Public Key",
	CloudletFieldSecondaryCrmAccessKeyUpgradeRequired: "Secondary Crm Access Key Upgrade Required",
	CloudletFieldSecondaryNotifySrvAddr:               "Secondary Notify Srv Addr",
	CloudletFieldDnsLabel:                             "Dns Label",
	CloudletFieldRootLbFqdn:                           "Root Lb Fqdn",
}

func (m *Cloudlet) IsKeyField(s string) bool {
	return strings.HasPrefix(s, CloudletFieldKey+".") || s == CloudletFieldKey
}

func (m *Cloudlet) DiffFields(o *Cloudlet, fields map[string]struct{}) {
	if m.Key.Organization != o.Key.Organization {
		fields[CloudletFieldKeyOrganization] = struct{}{}
		fields[CloudletFieldKey] = struct{}{}
	}
	if m.Key.Name != o.Key.Name {
		fields[CloudletFieldKeyName] = struct{}{}
		fields[CloudletFieldKey] = struct{}{}
	}
	if m.Key.FederatedOrganization != o.Key.FederatedOrganization {
		fields[CloudletFieldKeyFederatedOrganization] = struct{}{}
		fields[CloudletFieldKey] = struct{}{}
	}
	if m.Location.Latitude != o.Location.Latitude {
		fields[CloudletFieldLocationLatitude] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.Location.Longitude != o.Location.Longitude {
		fields[CloudletFieldLocationLongitude] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.Location.HorizontalAccuracy != o.Location.HorizontalAccuracy {
		fields[CloudletFieldLocationHorizontalAccuracy] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.Location.VerticalAccuracy != o.Location.VerticalAccuracy {
		fields[CloudletFieldLocationVerticalAccuracy] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.Location.Altitude != o.Location.Altitude {
		fields[CloudletFieldLocationAltitude] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.Location.Course != o.Location.Course {
		fields[CloudletFieldLocationCourse] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.Location.Speed != o.Location.Speed {
		fields[CloudletFieldLocationSpeed] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.Location.Timestamp != nil && o.Location.Timestamp != nil {
		if m.Location.Timestamp.Seconds != o.Location.Timestamp.Seconds {
			fields[CloudletFieldLocationTimestampSeconds] = struct{}{}
			fields[CloudletFieldLocationTimestamp] = struct{}{}
			fields[CloudletFieldLocation] = struct{}{}
		}
		if m.Location.Timestamp.Nanos != o.Location.Timestamp.Nanos {
			fields[CloudletFieldLocationTimestampNanos] = struct{}{}
			fields[CloudletFieldLocationTimestamp] = struct{}{}
			fields[CloudletFieldLocation] = struct{}{}
		}
	} else if (m.Location.Timestamp != nil && o.Location.Timestamp == nil) || (m.Location.Timestamp == nil && o.Location.Timestamp != nil) {
		fields[CloudletFieldLocationTimestamp] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.IpSupport != o.IpSupport {
		fields[CloudletFieldIpSupport] = struct{}{}
	}
	if m.StaticIps != o.StaticIps {
		fields[CloudletFieldStaticIps] = struct{}{}
	}
	if m.NumDynamicIps != o.NumDynamicIps {
		fields[CloudletFieldNumDynamicIps] = struct{}{}
	}
	if m.TimeLimits.CreateClusterInstTimeout != o.TimeLimits.CreateClusterInstTimeout {
		fields[CloudletFieldTimeLimitsCreateClusterInstTimeout] = struct{}{}
		fields[CloudletFieldTimeLimits] = struct{}{}
	}
	if m.TimeLimits.UpdateClusterInstTimeout != o.TimeLimits.UpdateClusterInstTimeout {
		fields[CloudletFieldTimeLimitsUpdateClusterInstTimeout] = struct{}{}
		fields[CloudletFieldTimeLimits] = struct{}{}
	}
	if m.TimeLimits.DeleteClusterInstTimeout != o.TimeLimits.DeleteClusterInstTimeout {
		fields[CloudletFieldTimeLimitsDeleteClusterInstTimeout] = struct{}{}
		fields[CloudletFieldTimeLimits] = struct{}{}
	}
	if m.TimeLimits.CreateAppInstTimeout != o.TimeLimits.CreateAppInstTimeout {
		fields[CloudletFieldTimeLimitsCreateAppInstTimeout] = struct{}{}
		fields[CloudletFieldTimeLimits] = struct{}{}
	}
	if m.TimeLimits.UpdateAppInstTimeout != o.TimeLimits.UpdateAppInstTimeout {
		fields[CloudletFieldTimeLimitsUpdateAppInstTimeout] = struct{}{}
		fields[CloudletFieldTimeLimits] = struct{}{}
	}
	if m.TimeLimits.DeleteAppInstTimeout != o.TimeLimits.DeleteAppInstTimeout {
		fields[CloudletFieldTimeLimitsDeleteAppInstTimeout] = struct{}{}
		fields[CloudletFieldTimeLimits] = struct{}{}
	}
	if len(m.Errors) != len(o.Errors) {
		fields[CloudletFieldErrors] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.Errors); i0++ {
			if m.Errors[i0] != o.Errors[i0] {
				fields[CloudletFieldErrors] = struct{}{}
				break
			}
		}
	}
	if m.Status.TaskNumber != o.Status.TaskNumber {
		fields[CloudletFieldStatusTaskNumber] = struct{}{}
		fields[CloudletFieldStatus] = struct{}{}
	}
	if m.Status.MaxTasks != o.Status.MaxTasks {
		fields[CloudletFieldStatusMaxTasks] = struct{}{}
		fields[CloudletFieldStatus] = struct{}{}
	}
	if m.Status.TaskName != o.Status.TaskName {
		fields[CloudletFieldStatusTaskName] = struct{}{}
		fields[CloudletFieldStatus] = struct{}{}
	}
	if m.Status.StepName != o.Status.StepName {
		fields[CloudletFieldStatusStepName] = struct{}{}
		fields[CloudletFieldStatus] = struct{}{}
	}
	if m.Status.MsgCount != o.Status.MsgCount {
		fields[CloudletFieldStatusMsgCount] = struct{}{}
		fields[CloudletFieldStatus] = struct{}{}
	}
	if len(m.Status.Msgs) != len(o.Status.Msgs) {
		fields[CloudletFieldStatusMsgs] = struct{}{}
		fields[CloudletFieldStatus] = struct{}{}
	} else {
		for i1 := 0; i1 < len(m.Status.Msgs); i1++ {
			if m.Status.Msgs[i1] != o.Status.Msgs[i1] {
				fields[CloudletFieldStatusMsgs] = struct{}{}
				fields[CloudletFieldStatus] = struct{}{}
				break
			}
		}
	}
	if m.State != o.State {
		fields[CloudletFieldState] = struct{}{}
	}
	if m.CrmOverride != o.CrmOverride {
		fields[CloudletFieldCrmOverride] = struct{}{}
	}
	if m.DeploymentLocal != o.DeploymentLocal {
		fields[CloudletFieldDeploymentLocal] = struct{}{}
	}
	if m.PlatformType != o.PlatformType {
		fields[CloudletFieldPlatformType] = struct{}{}
	}
	if m.NotifySrvAddr != o.NotifySrvAddr {
		fields[CloudletFieldNotifySrvAddr] = struct{}{}
	}
	if m.Flavor.Name != o.Flavor.Name {
		fields[CloudletFieldFlavorName] = struct{}{}
		fields[CloudletFieldFlavor] = struct{}{}
	}
	if m.PhysicalName != o.PhysicalName {
		fields[CloudletFieldPhysicalName] = struct{}{}
	}
	if m.EnvVar != nil && o.EnvVar != nil {
		if len(m.EnvVar) != len(o.EnvVar) {
			fields[CloudletFieldEnvVar] = struct{}{}
		} else {
			for k0, _ := range m.EnvVar {
				_, vok0 := o.EnvVar[k0]
				if !vok0 {
					fields[CloudletFieldEnvVar] = struct{}{}
				} else {
					if m.EnvVar[k0] != o.EnvVar[k0] {
						fields[CloudletFieldEnvVar] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.EnvVar != nil && o.EnvVar == nil) || (m.EnvVar == nil && o.EnvVar != nil) {
		fields[CloudletFieldEnvVar] = struct{}{}
	}
	if m.ContainerVersion != o.ContainerVersion {
		fields[CloudletFieldContainerVersion] = struct{}{}
	}
	if m.Config.ContainerRegistryPath != o.Config.ContainerRegistryPath {
		fields[CloudletFieldConfigContainerRegistryPath] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.CloudletVmImagePath != o.Config.CloudletVmImagePath {
		fields[CloudletFieldConfigCloudletVmImagePath] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.NotifyCtrlAddrs != o.Config.NotifyCtrlAddrs {
		fields[CloudletFieldConfigNotifyCtrlAddrs] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.TlsCertFile != o.Config.TlsCertFile {
		fields[CloudletFieldConfigTlsCertFile] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.EnvVar != nil && o.Config.EnvVar != nil {
		if len(m.Config.EnvVar) != len(o.Config.EnvVar) {
			fields[CloudletFieldConfigEnvVar] = struct{}{}
			fields[CloudletFieldConfig] = struct{}{}
		} else {
			for k1, _ := range m.Config.EnvVar {
				_, vok1 := o.Config.EnvVar[k1]
				if !vok1 {
					fields[CloudletFieldConfigEnvVar] = struct{}{}
					fields[CloudletFieldConfig] = struct{}{}
				} else {
					if m.Config.EnvVar[k1] != o.Config.EnvVar[k1] {
						fields[CloudletFieldConfigEnvVar] = struct{}{}
						fields[CloudletFieldConfig] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.Config.EnvVar != nil && o.Config.EnvVar == nil) || (m.Config.EnvVar == nil && o.Config.EnvVar != nil) {
		fields[CloudletFieldConfigEnvVar] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.PlatformTag != o.Config.PlatformTag {
		fields[CloudletFieldConfigPlatformTag] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.TestMode != o.Config.TestMode {
		fields[CloudletFieldConfigTestMode] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.Span != o.Config.Span {
		fields[CloudletFieldConfigSpan] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.CleanupMode != o.Config.CleanupMode {
		fields[CloudletFieldConfigCleanupMode] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.Region != o.Config.Region {
		fields[CloudletFieldConfigRegion] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.CommercialCerts != o.Config.CommercialCerts {
		fields[CloudletFieldConfigCommercialCerts] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.UseVaultPki != o.Config.UseVaultPki {
		fields[CloudletFieldConfigUseVaultPki] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.AppDnsRoot != o.Config.AppDnsRoot {
		fields[CloudletFieldConfigAppDnsRoot] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.ChefServerPath != o.Config.ChefServerPath {
		fields[CloudletFieldConfigChefServerPath] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.ChefClientInterval != o.Config.ChefClientInterval {
		fields[CloudletFieldConfigChefClientInterval] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.DeploymentTag != o.Config.DeploymentTag {
		fields[CloudletFieldConfigDeploymentTag] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.TlsKeyFile != o.Config.TlsKeyFile {
		fields[CloudletFieldConfigTlsKeyFile] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.TlsCaFile != o.Config.TlsCaFile {
		fields[CloudletFieldConfigTlsCaFile] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.CrmAccessPrivateKey != o.Config.CrmAccessPrivateKey {
		fields[CloudletFieldConfigCrmAccessPrivateKey] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.AccessApiAddr != o.Config.AccessApiAddr {
		fields[CloudletFieldConfigAccessApiAddr] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.CacheDir != o.Config.CacheDir {
		fields[CloudletFieldConfigCacheDir] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.SecondaryCrmAccessPrivateKey != o.Config.SecondaryCrmAccessPrivateKey {
		fields[CloudletFieldConfigSecondaryCrmAccessPrivateKey] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.ResTagMap != nil && o.ResTagMap != nil {
		if len(m.ResTagMap) != len(o.ResTagMap) {
			fields[CloudletFieldResTagMap] = struct{}{}
		} else {
			for k0, _ := range m.ResTagMap {
				_, vok0 := o.ResTagMap[k0]
				if !vok0 {
					fields[CloudletFieldResTagMap] = struct{}{}
				} else {
					if m.ResTagMap[k0].Name != o.ResTagMap[k0].Name {
						fields[CloudletFieldResTagMapValueName] = struct{}{}
						fields[CloudletFieldResTagMapValue] = struct{}{}
						fields[CloudletFieldResTagMap] = struct{}{}
					}
					if m.ResTagMap[k0].Organization != o.ResTagMap[k0].Organization {
						fields[CloudletFieldResTagMapValueOrganization] = struct{}{}
						fields[CloudletFieldResTagMapValue] = struct{}{}
						fields[CloudletFieldResTagMap] = struct{}{}
					}
				}
			}
		}
	} else if (m.ResTagMap != nil && o.ResTagMap == nil) || (m.ResTagMap == nil && o.ResTagMap != nil) {
		fields[CloudletFieldResTagMap] = struct{}{}
	}
	if m.AccessVars != nil && o.AccessVars != nil {
		if len(m.AccessVars) != len(o.AccessVars) {
			fields[CloudletFieldAccessVars] = struct{}{}
		} else {
			for k0, _ := range m.AccessVars {
				_, vok0 := o.AccessVars[k0]
				if !vok0 {
					fields[CloudletFieldAccessVars] = struct{}{}
				} else {
					if m.AccessVars[k0] != o.AccessVars[k0] {
						fields[CloudletFieldAccessVars] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.AccessVars != nil && o.AccessVars == nil) || (m.AccessVars == nil && o.AccessVars != nil) {
		fields[CloudletFieldAccessVars] = struct{}{}
	}
	if m.VmImageVersion != o.VmImageVersion {
		fields[CloudletFieldVmImageVersion] = struct{}{}
	}
	if m.Deployment != o.Deployment {
		fields[CloudletFieldDeployment] = struct{}{}
	}
	if m.InfraApiAccess != o.InfraApiAccess {
		fields[CloudletFieldInfraApiAccess] = struct{}{}
	}
	if m.InfraConfig.ExternalNetworkName != o.InfraConfig.ExternalNetworkName {
		fields[CloudletFieldInfraConfigExternalNetworkName] = struct{}{}
		fields[CloudletFieldInfraConfig] = struct{}{}
	}
	if m.InfraConfig.FlavorName != o.InfraConfig.FlavorName {
		fields[CloudletFieldInfraConfigFlavorName] = struct{}{}
		fields[CloudletFieldInfraConfig] = struct{}{}
	}
	if m.ChefClientKey != nil && o.ChefClientKey != nil {
		if len(m.ChefClientKey) != len(o.ChefClientKey) {
			fields[CloudletFieldChefClientKey] = struct{}{}
		} else {
			for k0, _ := range m.ChefClientKey {
				_, vok0 := o.ChefClientKey[k0]
				if !vok0 {
					fields[CloudletFieldChefClientKey] = struct{}{}
				} else {
					if m.ChefClientKey[k0] != o.ChefClientKey[k0] {
						fields[CloudletFieldChefClientKey] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.ChefClientKey != nil && o.ChefClientKey == nil) || (m.ChefClientKey == nil && o.ChefClientKey != nil) {
		fields[CloudletFieldChefClientKey] = struct{}{}
	}
	if m.MaintenanceState != o.MaintenanceState {
		fields[CloudletFieldMaintenanceState] = struct{}{}
	}
	if m.OverridePolicyContainerVersion != o.OverridePolicyContainerVersion {
		fields[CloudletFieldOverridePolicyContainerVersion] = struct{}{}
	}
	if m.VmPool != o.VmPool {
		fields[CloudletFieldVmPool] = struct{}{}
	}
	if m.CrmAccessPublicKey != o.CrmAccessPublicKey {
		fields[CloudletFieldCrmAccessPublicKey] = struct{}{}
	}
	if m.CrmAccessKeyUpgradeRequired != o.CrmAccessKeyUpgradeRequired {
		fields[CloudletFieldCrmAccessKeyUpgradeRequired] = struct{}{}
	}
	if m.CreatedAt.Seconds != o.CreatedAt.Seconds {
		fields[CloudletFieldCreatedAtSeconds] = struct{}{}
		fields[CloudletFieldCreatedAt] = struct{}{}
	}
	if m.CreatedAt.Nanos != o.CreatedAt.Nanos {
		fields[CloudletFieldCreatedAtNanos] = struct{}{}
		fields[CloudletFieldCreatedAt] = struct{}{}
	}
	if m.UpdatedAt.Seconds != o.UpdatedAt.Seconds {
		fields[CloudletFieldUpdatedAtSeconds] = struct{}{}
		fields[CloudletFieldUpdatedAt] = struct{}{}
	}
	if m.UpdatedAt.Nanos != o.UpdatedAt.Nanos {
		fields[CloudletFieldUpdatedAtNanos] = struct{}{}
		fields[CloudletFieldUpdatedAt] = struct{}{}
	}
	if m.TrustPolicy != o.TrustPolicy {
		fields[CloudletFieldTrustPolicy] = struct{}{}
	}
	if m.TrustPolicyState != o.TrustPolicyState {
		fields[CloudletFieldTrustPolicyState] = struct{}{}
	}
	if len(m.ResourceQuotas) != len(o.ResourceQuotas) {
		fields[CloudletFieldResourceQuotas] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.ResourceQuotas); i0++ {
			if m.ResourceQuotas[i0].Name != o.ResourceQuotas[i0].Name {
				fields[CloudletFieldResourceQuotasName] = struct{}{}
				fields[CloudletFieldResourceQuotas] = struct{}{}
			}
			if m.ResourceQuotas[i0].Value != o.ResourceQuotas[i0].Value {
				fields[CloudletFieldResourceQuotasValue] = struct{}{}
				fields[CloudletFieldResourceQuotas] = struct{}{}
			}
			if m.ResourceQuotas[i0].AlertThreshold != o.ResourceQuotas[i0].AlertThreshold {
				fields[CloudletFieldResourceQuotasAlertThreshold] = struct{}{}
				fields[CloudletFieldResourceQuotas] = struct{}{}
			}
		}
	}
	if m.DefaultResourceAlertThreshold != o.DefaultResourceAlertThreshold {
		fields[CloudletFieldDefaultResourceAlertThreshold] = struct{}{}
	}
	if m.HostController != o.HostController {
		fields[CloudletFieldHostController] = struct{}{}
	}
	if m.KafkaCluster != o.KafkaCluster {
		fields[CloudletFieldKafkaCluster] = struct{}{}
	}
	if m.KafkaUser != o.KafkaUser {
		fields[CloudletFieldKafkaUser] = struct{}{}
	}
	if m.KafkaPassword != o.KafkaPassword {
		fields[CloudletFieldKafkaPassword] = struct{}{}
	}
	if m.GpuConfig.Driver.Name != o.GpuConfig.Driver.Name {
		fields[CloudletFieldGpuConfigDriverName] = struct{}{}
		fields[CloudletFieldGpuConfigDriver] = struct{}{}
		fields[CloudletFieldGpuConfig] = struct{}{}
	}
	if m.GpuConfig.Driver.Organization != o.GpuConfig.Driver.Organization {
		fields[CloudletFieldGpuConfigDriverOrganization] = struct{}{}
		fields[CloudletFieldGpuConfigDriver] = struct{}{}
		fields[CloudletFieldGpuConfig] = struct{}{}
	}
	if m.GpuConfig.Properties != nil && o.GpuConfig.Properties != nil {
		if len(m.GpuConfig.Properties) != len(o.GpuConfig.Properties) {
			fields[CloudletFieldGpuConfigProperties] = struct{}{}
			fields[CloudletFieldGpuConfig] = struct{}{}
		} else {
			for k1, _ := range m.GpuConfig.Properties {
				_, vok1 := o.GpuConfig.Properties[k1]
				if !vok1 {
					fields[CloudletFieldGpuConfigProperties] = struct{}{}
					fields[CloudletFieldGpuConfig] = struct{}{}
				} else {
					if m.GpuConfig.Properties[k1] != o.GpuConfig.Properties[k1] {
						fields[CloudletFieldGpuConfigProperties] = struct{}{}
						fields[CloudletFieldGpuConfig] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.GpuConfig.Properties != nil && o.GpuConfig.Properties == nil) || (m.GpuConfig.Properties == nil && o.GpuConfig.Properties != nil) {
		fields[CloudletFieldGpuConfigProperties] = struct{}{}
		fields[CloudletFieldGpuConfig] = struct{}{}
	}
	if m.GpuConfig.LicenseConfig != o.GpuConfig.LicenseConfig {
		fields[CloudletFieldGpuConfigLicenseConfig] = struct{}{}
		fields[CloudletFieldGpuConfig] = struct{}{}
	}
	if m.GpuConfig.LicenseConfigMd5Sum != o.GpuConfig.LicenseConfigMd5Sum {
		fields[CloudletFieldGpuConfigLicenseConfigMd5Sum] = struct{}{}
		fields[CloudletFieldGpuConfig] = struct{}{}
	}
	if m.EnableDefaultServerlessCluster != o.EnableDefaultServerlessCluster {
		fields[CloudletFieldEnableDefaultServerlessCluster] = struct{}{}
	}
	if len(m.AllianceOrgs) != len(o.AllianceOrgs) {
		fields[CloudletFieldAllianceOrgs] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.AllianceOrgs); i0++ {
			if m.AllianceOrgs[i0] != o.AllianceOrgs[i0] {
				fields[CloudletFieldAllianceOrgs] = struct{}{}
				break
			}
		}
	}
	if m.SingleKubernetesClusterOwner != o.SingleKubernetesClusterOwner {
		fields[CloudletFieldSingleKubernetesClusterOwner] = struct{}{}
	}
	if m.DeletePrepare != o.DeletePrepare {
		fields[CloudletFieldDeletePrepare] = struct{}{}
	}
	if m.PlatformHighAvailability != o.PlatformHighAvailability {
		fields[CloudletFieldPlatformHighAvailability] = struct{}{}
	}
	if m.SecondaryCrmAccessPublicKey != o.SecondaryCrmAccessPublicKey {
		fields[CloudletFieldSecondaryCrmAccessPublicKey] = struct{}{}
	}
	if m.SecondaryCrmAccessKeyUpgradeRequired != o.SecondaryCrmAccessKeyUpgradeRequired {
		fields[CloudletFieldSecondaryCrmAccessKeyUpgradeRequired] = struct{}{}
	}
	if m.SecondaryNotifySrvAddr != o.SecondaryNotifySrvAddr {
		fields[CloudletFieldSecondaryNotifySrvAddr] = struct{}{}
	}
	if m.DnsLabel != o.DnsLabel {
		fields[CloudletFieldDnsLabel] = struct{}{}
	}
	if m.RootLbFqdn != o.RootLbFqdn {
		fields[CloudletFieldRootLbFqdn] = struct{}{}
	}
}

var UpdateCloudletFieldsMap = map[string]struct{}{
	CloudletFieldLocation:                           struct{}{},
	CloudletFieldLocationLatitude:                   struct{}{},
	CloudletFieldLocationLongitude:                  struct{}{},
	CloudletFieldLocationAltitude:                   struct{}{},
	CloudletFieldIpSupport:                          struct{}{},
	CloudletFieldStaticIps:                          struct{}{},
	CloudletFieldNumDynamicIps:                      struct{}{},
	CloudletFieldTimeLimits:                         struct{}{},
	CloudletFieldTimeLimitsCreateClusterInstTimeout: struct{}{},
	CloudletFieldTimeLimitsUpdateClusterInstTimeout: struct{}{},
	CloudletFieldTimeLimitsDeleteClusterInstTimeout: struct{}{},
	CloudletFieldTimeLimitsCreateAppInstTimeout:     struct{}{},
	CloudletFieldTimeLimitsUpdateAppInstTimeout:     struct{}{},
	CloudletFieldTimeLimitsDeleteAppInstTimeout:     struct{}{},
	CloudletFieldCrmOverride:                        struct{}{},
	CloudletFieldNotifySrvAddr:                      struct{}{},
	CloudletFieldEnvVar:                             struct{}{},
	CloudletFieldEnvVarValue:                        struct{}{},
	CloudletFieldAccessVars:                         struct{}{},
	CloudletFieldAccessVarsValue:                    struct{}{},
	CloudletFieldMaintenanceState:                   struct{}{},
	CloudletFieldTrustPolicy:                        struct{}{},
	CloudletFieldResourceQuotas:                     struct{}{},
	CloudletFieldResourceQuotasName:                 struct{}{},
	CloudletFieldResourceQuotasValue:                struct{}{},
	CloudletFieldResourceQuotasAlertThreshold:       struct{}{},
	CloudletFieldDefaultResourceAlertThreshold:      struct{}{},
	CloudletFieldKafkaCluster:                       struct{}{},
	CloudletFieldKafkaUser:                          struct{}{},
	CloudletFieldKafkaPassword:                      struct{}{},
	CloudletFieldGpuConfig:                          struct{}{},
	CloudletFieldGpuConfigDriver:                    struct{}{},
	CloudletFieldGpuConfigDriverName:                struct{}{},
	CloudletFieldGpuConfigDriverOrganization:        struct{}{},
	CloudletFieldGpuConfigProperties:                struct{}{},
	CloudletFieldGpuConfigPropertiesValue:           struct{}{},
	CloudletFieldGpuConfigLicenseConfig:             struct{}{},
	CloudletFieldEnableDefaultServerlessCluster:     struct{}{},
	CloudletFieldAllianceOrgs:                       struct{}{},
	CloudletFieldSingleKubernetesClusterOwner:       struct{}{},
	CloudletFieldPlatformHighAvailability:           struct{}{},
	CloudletFieldSecondaryNotifySrvAddr:             struct{}{},
}

func (m *Cloudlet) ValidateUpdateFields() error {
	if m.Fields == nil {
		return fmt.Errorf("nothing specified to update")
	}
	fmap := MakeFieldMap(m.Fields)
	badFieldStrs := []string{}
	for field, _ := range fmap {
		if m.IsKeyField(field) {
			continue
		}
		if _, ok := UpdateCloudletFieldsMap[field]; !ok {
			if _, ok := CloudletAllFieldsStringMap[field]; !ok {
				continue
			}
			badFieldStrs = append(badFieldStrs, CloudletAllFieldsStringMap[field])
		}
	}
	if len(badFieldStrs) > 0 {
		return fmt.Errorf("specified field(s) %s cannot be modified", strings.Join(badFieldStrs, ","))
	}
	return nil
}

func (m *Cloudlet) CopyInFields(src *Cloudlet) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
		if _, set := fmap["2.2"]; set {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
		if _, set := fmap["2.3"]; set {
			if m.Key.FederatedOrganization != src.Key.FederatedOrganization {
				m.Key.FederatedOrganization = src.Key.FederatedOrganization
				changed++
			}
		}
	}
	if _, set := fmap["5"]; set {
		if _, set := fmap["5.1"]; set {
			if m.Location.Latitude != src.Location.Latitude {
				m.Location.Latitude = src.Location.Latitude
				changed++
			}
		}
		if _, set := fmap["5.2"]; set {
			if m.Location.Longitude != src.Location.Longitude {
				m.Location.Longitude = src.Location.Longitude
				changed++
			}
		}
		if _, set := fmap["5.3"]; set {
			if m.Location.HorizontalAccuracy != src.Location.HorizontalAccuracy {
				m.Location.HorizontalAccuracy = src.Location.HorizontalAccuracy
				changed++
			}
		}
		if _, set := fmap["5.4"]; set {
			if m.Location.VerticalAccuracy != src.Location.VerticalAccuracy {
				m.Location.VerticalAccuracy = src.Location.VerticalAccuracy
				changed++
			}
		}
		if _, set := fmap["5.5"]; set {
			if m.Location.Altitude != src.Location.Altitude {
				m.Location.Altitude = src.Location.Altitude
				changed++
			}
		}
		if _, set := fmap["5.6"]; set {
			if m.Location.Course != src.Location.Course {
				m.Location.Course = src.Location.Course
				changed++
			}
		}
		if _, set := fmap["5.7"]; set {
			if m.Location.Speed != src.Location.Speed {
				m.Location.Speed = src.Location.Speed
				changed++
			}
		}
		if _, set := fmap["5.8"]; set {
			if src.Location.Timestamp != nil {
				m.Location.Timestamp = &distributed_match_engine.Timestamp{}
				if _, set := fmap["5.8.1"]; set {
					if m.Location.Timestamp.Seconds != src.Location.Timestamp.Seconds {
						m.Location.Timestamp.Seconds = src.Location.Timestamp.Seconds
						changed++
					}
				}
				if _, set := fmap["5.8.2"]; set {
					if m.Location.Timestamp.Nanos != src.Location.Timestamp.Nanos {
						m.Location.Timestamp.Nanos = src.Location.Timestamp.Nanos
						changed++
					}
				}
			} else if m.Location.Timestamp != nil {
				m.Location.Timestamp = nil
				changed++
			}
		}
	}
	if _, set := fmap["6"]; set {
		if m.IpSupport != src.IpSupport {
			m.IpSupport = src.IpSupport
			changed++
		}
	}
	if _, set := fmap["7"]; set {
		if m.StaticIps != src.StaticIps {
			m.StaticIps = src.StaticIps
			changed++
		}
	}
	if _, set := fmap["8"]; set {
		if m.NumDynamicIps != src.NumDynamicIps {
			m.NumDynamicIps = src.NumDynamicIps
			changed++
		}
	}
	if _, set := fmap["9"]; set {
		if _, set := fmap["9.1"]; set {
			if m.TimeLimits.CreateClusterInstTimeout != src.TimeLimits.CreateClusterInstTimeout {
				m.TimeLimits.CreateClusterInstTimeout = src.TimeLimits.CreateClusterInstTimeout
				changed++
			}
		}
		if _, set := fmap["9.2"]; set {
			if m.TimeLimits.UpdateClusterInstTimeout != src.TimeLimits.UpdateClusterInstTimeout {
				m.TimeLimits.UpdateClusterInstTimeout = src.TimeLimits.UpdateClusterInstTimeout
				changed++
			}
		}
		if _, set := fmap["9.3"]; set {
			if m.TimeLimits.DeleteClusterInstTimeout != src.TimeLimits.DeleteClusterInstTimeout {
				m.TimeLimits.DeleteClusterInstTimeout = src.TimeLimits.DeleteClusterInstTimeout
				changed++
			}
		}
		if _, set := fmap["9.4"]; set {
			if m.TimeLimits.CreateAppInstTimeout != src.TimeLimits.CreateAppInstTimeout {
				m.TimeLimits.CreateAppInstTimeout = src.TimeLimits.CreateAppInstTimeout
				changed++
			}
		}
		if _, set := fmap["9.5"]; set {
			if m.TimeLimits.UpdateAppInstTimeout != src.TimeLimits.UpdateAppInstTimeout {
				m.TimeLimits.UpdateAppInstTimeout = src.TimeLimits.UpdateAppInstTimeout
				changed++
			}
		}
		if _, set := fmap["9.6"]; set {
			if m.TimeLimits.DeleteAppInstTimeout != src.TimeLimits.DeleteAppInstTimeout {
				m.TimeLimits.DeleteAppInstTimeout = src.TimeLimits.DeleteAppInstTimeout
				changed++
			}
		}
	}
	if _, set := fmap["10"]; set {
		if src.Errors != nil {
			m.Errors = src.Errors
			changed++
		} else if m.Errors != nil {
			m.Errors = nil
			changed++
		}
	}
	if _, set := fmap["11"]; set {
		if _, set := fmap["11.1"]; set {
			if m.Status.TaskNumber != src.Status.TaskNumber {
				m.Status.TaskNumber = src.Status.TaskNumber
				changed++
			}
		}
		if _, set := fmap["11.2"]; set {
			if m.Status.MaxTasks != src.Status.MaxTasks {
				m.Status.MaxTasks = src.Status.MaxTasks
				changed++
			}
		}
		if _, set := fmap["11.3"]; set {
			if m.Status.TaskName != src.Status.TaskName {
				m.Status.TaskName = src.Status.TaskName
				changed++
			}
		}
		if _, set := fmap["11.4"]; set {
			if m.Status.StepName != src.Status.StepName {
				m.Status.StepName = src.Status.StepName
				changed++
			}
		}
		if _, set := fmap["11.5"]; set {
			if m.Status.MsgCount != src.Status.MsgCount {
				m.Status.MsgCount = src.Status.MsgCount
				changed++
			}
		}
		if _, set := fmap["11.6"]; set {
			if src.Status.Msgs != nil {
				m.Status.Msgs = src.Status.Msgs
				changed++
			} else if m.Status.Msgs != nil {
				m.Status.Msgs = nil
				changed++
			}
		}
	}
	if _, set := fmap["12"]; set {
		if m.State != src.State {
			m.State = src.State
			changed++
		}
	}
	if _, set := fmap["13"]; set {
		if m.CrmOverride != src.CrmOverride {
			m.CrmOverride = src.CrmOverride
			changed++
		}
	}
	if _, set := fmap["14"]; set {
		if m.DeploymentLocal != src.DeploymentLocal {
			m.DeploymentLocal = src.DeploymentLocal
			changed++
		}
	}
	if _, set := fmap["15"]; set {
		if m.PlatformType != src.PlatformType {
			m.PlatformType = src.PlatformType
			changed++
		}
	}
	if _, set := fmap["16"]; set {
		if m.NotifySrvAddr != src.NotifySrvAddr {
			m.NotifySrvAddr = src.NotifySrvAddr
			changed++
		}
	}
	if _, set := fmap["17"]; set {
		if _, set := fmap["17.1"]; set {
			if m.Flavor.Name != src.Flavor.Name {
				m.Flavor.Name = src.Flavor.Name
				changed++
			}
		}
	}
	if _, set := fmap["18"]; set {
		if m.PhysicalName != src.PhysicalName {
			m.PhysicalName = src.PhysicalName
			changed++
		}
	}
	if _, set := fmap["19"]; set {
		if src.EnvVar != nil {
			m.EnvVar = make(map[string]string)
			for k0, _ := range src.EnvVar {
				m.EnvVar[k0] = src.EnvVar[k0]
				changed++
			}
		} else if m.EnvVar != nil {
			m.EnvVar = nil
			changed++
		}
	}
	if _, set := fmap["20"]; set {
		if m.ContainerVersion != src.ContainerVersion {
			m.ContainerVersion = src.ContainerVersion
			changed++
		}
	}
	if _, set := fmap["21"]; set {
		if _, set := fmap["21.1"]; set {
			if m.Config.ContainerRegistryPath != src.Config.ContainerRegistryPath {
				m.Config.ContainerRegistryPath = src.Config.ContainerRegistryPath
				changed++
			}
		}
		if _, set := fmap["21.2"]; set {
			if m.Config.CloudletVmImagePath != src.Config.CloudletVmImagePath {
				m.Config.CloudletVmImagePath = src.Config.CloudletVmImagePath
				changed++
			}
		}
		if _, set := fmap["21.3"]; set {
			if m.Config.NotifyCtrlAddrs != src.Config.NotifyCtrlAddrs {
				m.Config.NotifyCtrlAddrs = src.Config.NotifyCtrlAddrs
				changed++
			}
		}
		if _, set := fmap["21.5"]; set {
			if m.Config.TlsCertFile != src.Config.TlsCertFile {
				m.Config.TlsCertFile = src.Config.TlsCertFile
				changed++
			}
		}
		if _, set := fmap["21.6"]; set {
			if src.Config.EnvVar != nil {
				m.Config.EnvVar = make(map[string]string)
				for k1, _ := range src.Config.EnvVar {
					m.Config.EnvVar[k1] = src.Config.EnvVar[k1]
					changed++
				}
			} else if m.Config.EnvVar != nil {
				m.Config.EnvVar = nil
				changed++
			}
		}
		if _, set := fmap["21.8"]; set {
			if m.Config.PlatformTag != src.Config.PlatformTag {
				m.Config.PlatformTag = src.Config.PlatformTag
				changed++
			}
		}
		if _, set := fmap["21.9"]; set {
			if m.Config.TestMode != src.Config.TestMode {
				m.Config.TestMode = src.Config.TestMode
				changed++
			}
		}
		if _, set := fmap["21.10"]; set {
			if m.Config.Span != src.Config.Span {
				m.Config.Span = src.Config.Span
				changed++
			}
		}
		if _, set := fmap["21.11"]; set {
			if m.Config.CleanupMode != src.Config.CleanupMode {
				m.Config.CleanupMode = src.Config.CleanupMode
				changed++
			}
		}
		if _, set := fmap["21.12"]; set {
			if m.Config.Region != src.Config.Region {
				m.Config.Region = src.Config.Region
				changed++
			}
		}
		if _, set := fmap["21.13"]; set {
			if m.Config.CommercialCerts != src.Config.CommercialCerts {
				m.Config.CommercialCerts = src.Config.CommercialCerts
				changed++
			}
		}
		if _, set := fmap["21.14"]; set {
			if m.Config.UseVaultPki != src.Config.UseVaultPki {
				m.Config.UseVaultPki = src.Config.UseVaultPki
				changed++
			}
		}
		if _, set := fmap["21.16"]; set {
			if m.Config.AppDnsRoot != src.Config.AppDnsRoot {
				m.Config.AppDnsRoot = src.Config.AppDnsRoot
				changed++
			}
		}
		if _, set := fmap["21.17"]; set {
			if m.Config.ChefServerPath != src.Config.ChefServerPath {
				m.Config.ChefServerPath = src.Config.ChefServerPath
				changed++
			}
		}
		if _, set := fmap["21.18"]; set {
			if m.Config.ChefClientInterval != src.Config.ChefClientInterval {
				m.Config.ChefClientInterval = src.Config.ChefClientInterval
				changed++
			}
		}
		if _, set := fmap["21.19"]; set {
			if m.Config.DeploymentTag != src.Config.DeploymentTag {
				m.Config.DeploymentTag = src.Config.DeploymentTag
				changed++
			}
		}
		if _, set := fmap["21.20"]; set {
			if m.Config.TlsKeyFile != src.Config.TlsKeyFile {
				m.Config.TlsKeyFile = src.Config.TlsKeyFile
				changed++
			}
		}
		if _, set := fmap["21.21"]; set {
			if m.Config.TlsCaFile != src.Config.TlsCaFile {
				m.Config.TlsCaFile = src.Config.TlsCaFile
				changed++
			}
		}
		if _, set := fmap["21.22"]; set {
			if m.Config.CrmAccessPrivateKey != src.Config.CrmAccessPrivateKey {
				m.Config.CrmAccessPrivateKey = src.Config.CrmAccessPrivateKey
				changed++
			}
		}
		if _, set := fmap["21.23"]; set {
			if m.Config.AccessApiAddr != src.Config.AccessApiAddr {
				m.Config.AccessApiAddr = src.Config.AccessApiAddr
				changed++
			}
		}
		if _, set := fmap["21.24"]; set {
			if m.Config.CacheDir != src.Config.CacheDir {
				m.Config.CacheDir = src.Config.CacheDir
				changed++
			}
		}
		if _, set := fmap["21.25"]; set {
			if m.Config.SecondaryCrmAccessPrivateKey != src.Config.SecondaryCrmAccessPrivateKey {
				m.Config.SecondaryCrmAccessPrivateKey = src.Config.SecondaryCrmAccessPrivateKey
				changed++
			}
		}
	}
	if _, set := fmap["22"]; set {
		if src.ResTagMap != nil {
			m.ResTagMap = make(map[string]*ResTagTableKey)
			for k0, _ := range src.ResTagMap {
				m.ResTagMap[k0] = &ResTagTableKey{}
				if _, set := fmap["22.1"]; set {
					if m.ResTagMap[k0].Name != src.ResTagMap[k0].Name {
						m.ResTagMap[k0].Name = src.ResTagMap[k0].Name
						changed++
					}
				}
				if _, set := fmap["22.2"]; set {
					if m.ResTagMap[k0].Organization != src.ResTagMap[k0].Organization {
						m.ResTagMap[k0].Organization = src.ResTagMap[k0].Organization
						changed++
					}
				}
			}
		} else if m.ResTagMap != nil {
			m.ResTagMap = nil
			changed++
		}
	}
	if _, set := fmap["23"]; set {
		if src.AccessVars != nil {
			m.AccessVars = make(map[string]string)
			for k0, _ := range src.AccessVars {
				m.AccessVars[k0] = src.AccessVars[k0]
				changed++
			}
		} else if m.AccessVars != nil {
			m.AccessVars = nil
			changed++
		}
	}
	if _, set := fmap["24"]; set {
		if m.VmImageVersion != src.VmImageVersion {
			m.VmImageVersion = src.VmImageVersion
			changed++
		}
	}
	if _, set := fmap["26"]; set {
		if m.Deployment != src.Deployment {
			m.Deployment = src.Deployment
			changed++
		}
	}
	if _, set := fmap["27"]; set {
		if m.InfraApiAccess != src.InfraApiAccess {
			m.InfraApiAccess = src.InfraApiAccess
			changed++
		}
	}
	if _, set := fmap["28"]; set {
		if _, set := fmap["28.1"]; set {
			if m.InfraConfig.ExternalNetworkName != src.InfraConfig.ExternalNetworkName {
				m.InfraConfig.ExternalNetworkName = src.InfraConfig.ExternalNetworkName
				changed++
			}
		}
		if _, set := fmap["28.2"]; set {
			if m.InfraConfig.FlavorName != src.InfraConfig.FlavorName {
				m.InfraConfig.FlavorName = src.InfraConfig.FlavorName
				changed++
			}
		}
	}
	if _, set := fmap["29"]; set {
		if src.ChefClientKey != nil {
			m.ChefClientKey = make(map[string]string)
			for k0, _ := range src.ChefClientKey {
				m.ChefClientKey[k0] = src.ChefClientKey[k0]
				changed++
			}
		} else if m.ChefClientKey != nil {
			m.ChefClientKey = nil
			changed++
		}
	}
	if _, set := fmap["30"]; set {
		if m.MaintenanceState != src.MaintenanceState {
			m.MaintenanceState = src.MaintenanceState
			changed++
		}
	}
	if _, set := fmap["31"]; set {
		if m.OverridePolicyContainerVersion != src.OverridePolicyContainerVersion {
			m.OverridePolicyContainerVersion = src.OverridePolicyContainerVersion
			changed++
		}
	}
	if _, set := fmap["32"]; set {
		if m.VmPool != src.VmPool {
			m.VmPool = src.VmPool
			changed++
		}
	}
	if _, set := fmap["33"]; set {
		if m.CrmAccessPublicKey != src.CrmAccessPublicKey {
			m.CrmAccessPublicKey = src.CrmAccessPublicKey
			changed++
		}
	}
	if _, set := fmap["34"]; set {
		if m.CrmAccessKeyUpgradeRequired != src.CrmAccessKeyUpgradeRequired {
			m.CrmAccessKeyUpgradeRequired = src.CrmAccessKeyUpgradeRequired
			changed++
		}
	}
	if _, set := fmap["35"]; set {
		if _, set := fmap["35.1"]; set {
			if m.CreatedAt.Seconds != src.CreatedAt.Seconds {
				m.CreatedAt.Seconds = src.CreatedAt.Seconds
				changed++
			}
		}
		if _, set := fmap["35.2"]; set {
			if m.CreatedAt.Nanos != src.CreatedAt.Nanos {
				m.CreatedAt.Nanos = src.CreatedAt.Nanos
				changed++
			}
		}
	}
	if _, set := fmap["36"]; set {
		if _, set := fmap["36.1"]; set {
			if m.UpdatedAt.Seconds != src.UpdatedAt.Seconds {
				m.UpdatedAt.Seconds = src.UpdatedAt.Seconds
				changed++
			}
		}
		if _, set := fmap["36.2"]; set {
			if m.UpdatedAt.Nanos != src.UpdatedAt.Nanos {
				m.UpdatedAt.Nanos = src.UpdatedAt.Nanos
				changed++
			}
		}
	}
	if _, set := fmap["37"]; set {
		if m.TrustPolicy != src.TrustPolicy {
			m.TrustPolicy = src.TrustPolicy
			changed++
		}
	}
	if _, set := fmap["38"]; set {
		if m.TrustPolicyState != src.TrustPolicyState {
			m.TrustPolicyState = src.TrustPolicyState
			changed++
		}
	}
	if _, set := fmap["39"]; set {
		if src.ResourceQuotas != nil {
			m.ResourceQuotas = src.ResourceQuotas
			changed++
		} else if m.ResourceQuotas != nil {
			m.ResourceQuotas = nil
			changed++
		}
	}
	if _, set := fmap["40"]; set {
		if m.DefaultResourceAlertThreshold != src.DefaultResourceAlertThreshold {
			m.DefaultResourceAlertThreshold = src.DefaultResourceAlertThreshold
			changed++
		}
	}
	if _, set := fmap["41"]; set {
		if m.HostController != src.HostController {
			m.HostController = src.HostController
			changed++
		}
	}
	if _, set := fmap["42"]; set {
		if m.KafkaCluster != src.KafkaCluster {
			m.KafkaCluster = src.KafkaCluster
			changed++
		}
	}
	if _, set := fmap["43"]; set {
		if m.KafkaUser != src.KafkaUser {
			m.KafkaUser = src.KafkaUser
			changed++
		}
	}
	if _, set := fmap["44"]; set {
		if m.KafkaPassword != src.KafkaPassword {
			m.KafkaPassword = src.KafkaPassword
			changed++
		}
	}
	if _, set := fmap["45"]; set {
		if _, set := fmap["45.1"]; set {
			if _, set := fmap["45.1.1"]; set {
				if m.GpuConfig.Driver.Name != src.GpuConfig.Driver.Name {
					m.GpuConfig.Driver.Name = src.GpuConfig.Driver.Name
					changed++
				}
			}
			if _, set := fmap["45.1.2"]; set {
				if m.GpuConfig.Driver.Organization != src.GpuConfig.Driver.Organization {
					m.GpuConfig.Driver.Organization = src.GpuConfig.Driver.Organization
					changed++
				}
			}
		}
		if _, set := fmap["45.2"]; set {
			if src.GpuConfig.Properties != nil {
				m.GpuConfig.Properties = make(map[string]string)
				for k1, _ := range src.GpuConfig.Properties {
					m.GpuConfig.Properties[k1] = src.GpuConfig.Properties[k1]
					changed++
				}
			} else if m.GpuConfig.Properties != nil {
				m.GpuConfig.Properties = nil
				changed++
			}
		}
		if _, set := fmap["45.3"]; set {
			if m.GpuConfig.LicenseConfig != src.GpuConfig.LicenseConfig {
				m.GpuConfig.LicenseConfig = src.GpuConfig.LicenseConfig
				changed++
			}
		}
		if _, set := fmap["45.4"]; set {
			if m.GpuConfig.LicenseConfigMd5Sum != src.GpuConfig.LicenseConfigMd5Sum {
				m.GpuConfig.LicenseConfigMd5Sum = src.GpuConfig.LicenseConfigMd5Sum
				changed++
			}
		}
	}
	if _, set := fmap["46"]; set {
		if m.EnableDefaultServerlessCluster != src.EnableDefaultServerlessCluster {
			m.EnableDefaultServerlessCluster = src.EnableDefaultServerlessCluster
			changed++
		}
	}
	if _, set := fmap["47"]; set {
		if src.AllianceOrgs != nil {
			m.AllianceOrgs = src.AllianceOrgs
			changed++
		} else if m.AllianceOrgs != nil {
			m.AllianceOrgs = nil
			changed++
		}
	}
	if _, set := fmap["48"]; set {
		if m.SingleKubernetesClusterOwner != src.SingleKubernetesClusterOwner {
			m.SingleKubernetesClusterOwner = src.SingleKubernetesClusterOwner
			changed++
		}
	}
	if _, set := fmap["49"]; set {
		if m.DeletePrepare != src.DeletePrepare {
			m.DeletePrepare = src.DeletePrepare
			changed++
		}
	}
	if _, set := fmap["50"]; set {
		if m.PlatformHighAvailability != src.PlatformHighAvailability {
			m.PlatformHighAvailability = src.PlatformHighAvailability
			changed++
		}
	}
	if _, set := fmap["51"]; set {
		if m.SecondaryCrmAccessPublicKey != src.SecondaryCrmAccessPublicKey {
			m.SecondaryCrmAccessPublicKey = src.SecondaryCrmAccessPublicKey
			changed++
		}
	}
	if _, set := fmap["52"]; set {
		if m.SecondaryCrmAccessKeyUpgradeRequired != src.SecondaryCrmAccessKeyUpgradeRequired {
			m.SecondaryCrmAccessKeyUpgradeRequired = src.SecondaryCrmAccessKeyUpgradeRequired
			changed++
		}
	}
	if _, set := fmap["53"]; set {
		if m.SecondaryNotifySrvAddr != src.SecondaryNotifySrvAddr {
			m.SecondaryNotifySrvAddr = src.SecondaryNotifySrvAddr
			changed++
		}
	}
	if _, set := fmap["54"]; set {
		if m.DnsLabel != src.DnsLabel {
			m.DnsLabel = src.DnsLabel
			changed++
		}
	}
	if _, set := fmap["55"]; set {
		if m.RootLbFqdn != src.RootLbFqdn {
			m.RootLbFqdn = src.RootLbFqdn
			changed++
		}
	}
	return changed
}

func (m *Cloudlet) DeepCopyIn(src *Cloudlet) {
	m.Key.DeepCopyIn(&src.Key)
	m.Location = src.Location
	m.IpSupport = src.IpSupport
	m.StaticIps = src.StaticIps
	m.NumDynamicIps = src.NumDynamicIps
	m.TimeLimits.DeepCopyIn(&src.TimeLimits)
	if src.Errors != nil {
		m.Errors = make([]string, len(src.Errors), len(src.Errors))
		for ii, s := range src.Errors {
			m.Errors[ii] = s
		}
	} else {
		m.Errors = nil
	}
	m.Status.DeepCopyIn(&src.Status)
	m.State = src.State
	m.CrmOverride = src.CrmOverride
	m.DeploymentLocal = src.DeploymentLocal
	m.PlatformType = src.PlatformType
	m.NotifySrvAddr = src.NotifySrvAddr
	m.Flavor.DeepCopyIn(&src.Flavor)
	m.PhysicalName = src.PhysicalName
	if src.EnvVar != nil {
		m.EnvVar = make(map[string]string)
		for k, v := range src.EnvVar {
			m.EnvVar[k] = v
		}
	} else {
		m.EnvVar = nil
	}
	m.ContainerVersion = src.ContainerVersion
	m.Config.DeepCopyIn(&src.Config)
	if src.ResTagMap != nil {
		m.ResTagMap = make(map[string]*ResTagTableKey)
		for k, v := range src.ResTagMap {
			var tmp_v ResTagTableKey
			tmp_v.DeepCopyIn(v)
			m.ResTagMap[k] = &tmp_v
		}
	} else {
		m.ResTagMap = nil
	}
	if src.AccessVars != nil {
		m.AccessVars = make(map[string]string)
		for k, v := range src.AccessVars {
			m.AccessVars[k] = v
		}
	} else {
		m.AccessVars = nil
	}
	m.VmImageVersion = src.VmImageVersion
	m.Deployment = src.Deployment
	m.InfraApiAccess = src.InfraApiAccess
	m.InfraConfig.DeepCopyIn(&src.InfraConfig)
	if src.ChefClientKey != nil {
		m.ChefClientKey = make(map[string]string)
		for k, v := range src.ChefClientKey {
			m.ChefClientKey[k] = v
		}
	} else {
		m.ChefClientKey = nil
	}
	m.MaintenanceState = src.MaintenanceState
	m.OverridePolicyContainerVersion = src.OverridePolicyContainerVersion
	m.VmPool = src.VmPool
	m.CrmAccessPublicKey = src.CrmAccessPublicKey
	m.CrmAccessKeyUpgradeRequired = src.CrmAccessKeyUpgradeRequired
	m.CreatedAt = src.CreatedAt
	m.UpdatedAt = src.UpdatedAt
	m.TrustPolicy = src.TrustPolicy
	m.TrustPolicyState = src.TrustPolicyState
	if src.ResourceQuotas != nil {
		m.ResourceQuotas = make([]ResourceQuota, len(src.ResourceQuotas), len(src.ResourceQuotas))
		for ii, s := range src.ResourceQuotas {
			m.ResourceQuotas[ii].DeepCopyIn(&s)
		}
	} else {
		m.ResourceQuotas = nil
	}
	m.DefaultResourceAlertThreshold = src.DefaultResourceAlertThreshold
	m.HostController = src.HostController
	m.KafkaCluster = src.KafkaCluster
	m.KafkaUser = src.KafkaUser
	m.KafkaPassword = src.KafkaPassword
	m.GpuConfig.DeepCopyIn(&src.GpuConfig)
	m.EnableDefaultServerlessCluster = src.EnableDefaultServerlessCluster
	if src.AllianceOrgs != nil {
		m.AllianceOrgs = make([]string, len(src.AllianceOrgs), len(src.AllianceOrgs))
		for ii, s := range src.AllianceOrgs {
			m.AllianceOrgs[ii] = s
		}
	} else {
		m.AllianceOrgs = nil
	}
	m.SingleKubernetesClusterOwner = src.SingleKubernetesClusterOwner
	m.DeletePrepare = src.DeletePrepare
	m.PlatformHighAvailability = src.PlatformHighAvailability
	m.SecondaryCrmAccessPublicKey = src.SecondaryCrmAccessPublicKey
	m.SecondaryCrmAccessKeyUpgradeRequired = src.SecondaryCrmAccessKeyUpgradeRequired
	m.SecondaryNotifySrvAddr = src.SecondaryNotifySrvAddr
	m.DnsLabel = src.DnsLabel
	m.RootLbFqdn = src.RootLbFqdn
}

func (s *Cloudlet) HasFields() bool {
	return true
}

type CloudletStore interface {
	Create(ctx context.Context, m *Cloudlet, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *Cloudlet, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *Cloudlet, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *Cloudlet, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*Cloudlet, int64, error)
	Get(ctx context.Context, key *CloudletKey, buf *Cloudlet) bool
	STMGet(stm concurrency.STM, key *CloudletKey, buf *Cloudlet) bool
	STMPut(stm concurrency.STM, obj *Cloudlet, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *CloudletKey)
}

type CloudletStoreImpl struct {
	kvstore objstore.KVStore
}

func NewCloudletStore(kvstore objstore.KVStore) *CloudletStoreImpl {
	return &CloudletStoreImpl{kvstore: kvstore}
}

func (s *CloudletStoreImpl) Create(ctx context.Context, m *Cloudlet, wait func(int64)) (*Result, error) {
	err := m.Validate(CloudletAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Cloudlet", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletStoreImpl) Update(ctx context.Context, m *Cloudlet, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Cloudlet", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur Cloudlet
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletStoreImpl) Put(ctx context.Context, m *Cloudlet, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(CloudletAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Cloudlet", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletStoreImpl) Delete(ctx context.Context, m *Cloudlet, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Cloudlet", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletStoreImpl) LoadOne(key string) (*Cloudlet, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj Cloudlet
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse Cloudlet data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *CloudletStoreImpl) Get(ctx context.Context, key *CloudletKey, buf *Cloudlet) bool {
	keystr := objstore.DbKeyString("Cloudlet", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *CloudletStoreImpl) STMGet(stm concurrency.STM, key *CloudletKey, buf *Cloudlet) bool {
	keystr := objstore.DbKeyString("Cloudlet", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *CloudletStoreImpl) parseGetData(val []byte, buf *Cloudlet) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = Cloudlet{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *CloudletStoreImpl) STMPut(stm concurrency.STM, obj *Cloudlet, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("Cloudlet", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("Cloudlet json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *CloudletStoreImpl) STMDel(stm concurrency.STM, key *CloudletKey) {
	keystr := objstore.DbKeyString("Cloudlet", key)
	stm.Del(keystr)
}

type CloudletKeyWatcher struct {
	cb func(ctx context.Context)
}

type CloudletCacheData struct {
	Obj    *Cloudlet
	ModRev int64
}

// CloudletCache caches Cloudlet objects in memory in a hash table
// and keeps them in sync with the database.
type CloudletCache struct {
	Objs          map[CloudletKey]*CloudletCacheData
	Mux           util.Mutex
	List          map[CloudletKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *CloudletKey, old *Cloudlet, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *Cloudlet, new *Cloudlet)
	DeletedCbs    []func(ctx context.Context, old *Cloudlet)
	KeyWatchers   map[CloudletKey][]*CloudletKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *CloudletKey)
	DeletedKeyCbs []func(ctx context.Context, key *CloudletKey)
}

func NewCloudletCache() *CloudletCache {
	cache := CloudletCache{}
	InitCloudletCache(&cache)
	return &cache
}

func InitCloudletCache(cache *CloudletCache) {
	cache.Objs = make(map[CloudletKey]*CloudletCacheData)
	cache.KeyWatchers = make(map[CloudletKey][]*CloudletKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *CloudletCache) GetTypeString() string {
	return "Cloudlet"
}

func (c *CloudletCache) Get(key *CloudletKey, valbuf *Cloudlet) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *CloudletCache) GetWithRev(key *CloudletKey, valbuf *Cloudlet, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *CloudletCache) HasKey(key *CloudletKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *CloudletCache) GetAllKeys(ctx context.Context, cb func(key *CloudletKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *CloudletCache) Update(ctx context.Context, in *Cloudlet, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *Cloudlet) (*Cloudlet, bool) {
		return in, true
	})
}

func (c *CloudletCache) UpdateModFunc(ctx context.Context, key *CloudletKey, modRev int64, modFunc func(old *Cloudlet) (new *Cloudlet, changed bool)) {
	c.Mux.Lock()
	var old *Cloudlet
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	for _, cb := range c.UpdatedCbs {
		newCopy := &Cloudlet{}
		newCopy.DeepCopyIn(new)
		defer cb(ctx, old, newCopy)
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			defer cb(ctx, new.GetKey(), old, modRev)
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &Cloudlet{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &CloudletCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *CloudletCache) Delete(ctx context.Context, in *Cloudlet, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *Cloudlet) bool {
		return true
	})
}

func (c *CloudletCache) DeleteCondFunc(ctx context.Context, in *Cloudlet, modRev int64, condFunc func(old *Cloudlet) bool) {
	c.Mux.Lock()
	var old *Cloudlet
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	c.Mux.Unlock()
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, in.GetKey(), old, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *CloudletCache) Prune(ctx context.Context, validKeys map[CloudletKey]struct{}) {
	notify := make(map[CloudletKey]*CloudletCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, old.Obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *CloudletCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *CloudletCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *CloudletCache) Show(filter *Cloudlet, cb func(ret *Cloudlet) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func CloudletGenericNotifyCb(fn func(key *CloudletKey, old *Cloudlet)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*CloudletKey), obj.(*Cloudlet))
	}
}

func (c *CloudletCache) SetNotifyCb(fn func(ctx context.Context, obj *CloudletKey, old *Cloudlet, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *CloudletKey, old *Cloudlet, modRev int64){fn}
}

func (c *CloudletCache) SetUpdatedCb(fn func(ctx context.Context, old *Cloudlet, new *Cloudlet)) {
	c.UpdatedCbs = []func(ctx context.Context, old *Cloudlet, new *Cloudlet){fn}
}

func (c *CloudletCache) SetDeletedCb(fn func(ctx context.Context, old *Cloudlet)) {
	c.DeletedCbs = []func(ctx context.Context, old *Cloudlet){fn}
}

func (c *CloudletCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *CloudletKey){fn}
}

func (c *CloudletCache) SetDeletedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *CloudletKey){fn}
}

func (c *CloudletCache) AddUpdatedCb(fn func(ctx context.Context, old *Cloudlet, new *Cloudlet)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *CloudletCache) AddDeletedCb(fn func(ctx context.Context, old *Cloudlet)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *CloudletCache) AddNotifyCb(fn func(ctx context.Context, obj *CloudletKey, old *Cloudlet, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *CloudletCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *CloudletCache) AddDeletedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *CloudletCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *CloudletCache) WatchKey(key *CloudletKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*CloudletKeyWatcher, 0)
	}
	watcher := CloudletKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching Cloudlet", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *CloudletCache) TriggerKeyWatchers(ctx context.Context, key *CloudletKey) {
	watchers := make([]*CloudletKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *CloudletCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := Cloudlet{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse Cloudlet data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *CloudletCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := Cloudlet{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	CloudletKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *CloudletCache) SyncListStart(ctx context.Context) {
	c.List = make(map[CloudletKey]struct{})
}

func (c *CloudletCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[CloudletKey]*CloudletCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, val.Obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *CloudletCache) WaitForState(ctx context.Context, key *CloudletKey, targetState TrackedState, transitionStates map[TrackedState]struct{}, errorState TrackedState, timeout time.Duration, successMsg string, send func(*Result) error, opts ...WaitStateOps) error {
	curState := TrackedState_TRACKED_STATE_UNKNOWN
	done := make(chan string, 1)
	failed := make(chan bool, 1)
	var lastMsgCnt int
	var err error

	var wSpec WaitStateSpec
	for _, op := range opts {
		if err := op(&wSpec); err != nil {
			return err
		}
	}

	var streamCancel context.CancelFunc
	if wSpec.StreamCache != nil {
		checkStreamMsg := func() {
			streamObj := StreamObj{}
			if !wSpec.StreamCache.Get(wSpec.StreamKey, &streamObj) {
				return
			}
			if len(streamObj.Status.Msgs) > 0 || streamObj.Status.MsgCount > 0 {
				if lastMsgCnt < int(streamObj.Status.MsgCount) {
					for ii := 0; ii < len(streamObj.Status.Msgs); ii++ {
						send(&Result{Message: streamObj.Status.Msgs[ii]})
						lastMsgCnt++
					}
				}
			}
		}

		streamCancel = wSpec.StreamCache.WatchKey(wSpec.StreamKey, func(ctx context.Context) {
			checkStreamMsg()
		})

		// After setting up watch, check if any status messages were received in the meantime
		checkStreamMsg()
	}

	cancel := c.WatchKey(key, func(ctx context.Context) {
		info := Cloudlet{}
		if c.Get(key, &info) {
			curState = info.State
		} else {
			curState = TrackedState_NOT_PRESENT
		}
		log.SpanLog(ctx, log.DebugLevelApi, "Watch event for Cloudlet", "key", key, "state", TrackedState_CamelName[int32(curState)])
		if curState == errorState {
			failed <- true
		} else if curState == targetState {
			msg := ""
			if curState == TrackedState_NOT_PRESENT {
				msg = TrackedState_CamelName[int32(curState)]
			}
			done <- msg
		}
	})
	// After setting up watch, check current state,
	// as it may have already changed to target state
	info := Cloudlet{}
	if c.Get(key, &info) {
		curState = info.State
	} else {
		curState = TrackedState_NOT_PRESENT
	}
	if curState == targetState {
		msg := ""
		if curState == TrackedState_NOT_PRESENT {
			msg = TrackedState_CamelName[int32(curState)]
		}
		done <- msg
	}

	select {
	case doneMsg := <-done:
		if doneMsg != "" {
			send(&Result{Message: doneMsg})
		}
		err = nil
		if successMsg != "" && send != nil {
			send(&Result{Message: successMsg})
		}
	case <-failed:
		if c.Get(key, &info) {
			errs := strings.Join(info.Errors, ", ")
			err = fmt.Errorf("Encountered failures: %s", errs)
		} else {
			// this shouldn't happen, since only way to get here
			// is if info state is set to Error
			err = errors.New("Unknown failure")
		}
	case <-time.After(timeout):
		hasInfo := c.Get(key, &info)
		if hasInfo && info.State == errorState {
			// error may have been sent back before watch started
			errs := strings.Join(info.Errors, ", ")
			err = fmt.Errorf("Encountered failures: %s", errs)
		} else if _, found := transitionStates[info.State]; hasInfo && found {
			// no success response, but state is a valid transition
			// state. That means work is still in progress.
			// Notify user that this is not an error.
			// Do not undo since CRM is still busy.
			if send != nil {
				msg := fmt.Sprintf("Timed out while work still in progress state %s. Please use ShowCloudlet to check current status", TrackedState_CamelName[int32(info.State)])
				send(&Result{Message: msg})
			}
			err = nil
		} else {
			err = fmt.Errorf("Timed out; expected state %s but is %s",
				TrackedState_CamelName[int32(targetState)],
				TrackedState_CamelName[int32(curState)])
		}
	}
	cancel()
	if streamCancel != nil {
		streamCancel()
	}
	// note: do not close done/failed, garbage collector will deal with it.
	return err
}

func (c *CloudletCache) UsesOrg(org string) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		if key.Organization == org {
			return true
		}
	}
	return false
}

func (m *Cloudlet) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *Cloudlet) GetKey() *CloudletKey {
	return &m.Key
}

func (m *Cloudlet) GetKeyVal() CloudletKey {
	return m.Key
}

func (m *Cloudlet) SetKey(key *CloudletKey) {
	m.Key = *key
}

func CmpSortCloudlet(a Cloudlet, b Cloudlet) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *Cloudlet) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := IpSupport_name[int32(m.IpSupport)]; !ok {
		return errors.New("invalid IpSupport")
	}
	if err := m.TimeLimits.ValidateEnums(); err != nil {
		return err
	}
	if err := m.Status.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := TrackedState_name[int32(m.State)]; !ok {
		return errors.New("invalid State")
	}
	if _, ok := CRMOverride_name[int32(m.CrmOverride)]; !ok {
		return errors.New("invalid CrmOverride")
	}
	if _, ok := PlatformType_name[int32(m.PlatformType)]; !ok {
		return errors.New("invalid PlatformType")
	}
	if err := m.Flavor.ValidateEnums(); err != nil {
		return err
	}
	if err := m.Config.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := InfraApiAccess_name[int32(m.InfraApiAccess)]; !ok {
		return errors.New("invalid InfraApiAccess")
	}
	if err := m.InfraConfig.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := distributed_match_engine.MaintenanceState_name[int32(m.MaintenanceState)]; !ok {
		return errors.New("invalid MaintenanceState")
	}
	if _, ok := TrackedState_name[int32(m.TrustPolicyState)]; !ok {
		return errors.New("invalid TrustPolicyState")
	}
	for _, e := range m.ResourceQuotas {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if err := m.GpuConfig.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *Cloudlet) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	s.TimeLimits.ClearTagged(tags)
	if _, found := tags["nocmp"]; found {
		s.Errors = nil
	}
	if _, found := tags["nocmp"]; found {
		s.Status = StatusInfo{}
	}
	if _, found := tags["nocmp"]; found {
		s.NotifySrvAddr = ""
	}
	s.Flavor.ClearTagged(tags)
	s.Config.ClearTagged(tags)
	s.InfraConfig.ClearTagged(tags)
	if _, found := tags["nocmp"]; found {
		s.CrmAccessPublicKey = ""
	}
	if _, found := tags["timestamp"]; found {
		s.CreatedAt = distributed_match_engine.Timestamp{}
	}
	if _, found := tags["timestamp"]; found {
		s.UpdatedAt = distributed_match_engine.Timestamp{}
	}
	if s.ResourceQuotas != nil {
		for ii := 0; ii < len(s.ResourceQuotas); ii++ {
			s.ResourceQuotas[ii].ClearTagged(tags)
		}
	}
	if _, found := tags["nocmp"]; found {
		s.HostController = ""
	}
	s.GpuConfig.ClearTagged(tags)
	if _, found := tags["nocmp"]; found {
		s.SecondaryCrmAccessPublicKey = ""
	}
	if _, found := tags["nocmp"]; found {
		s.SecondaryNotifySrvAddr = ""
	}
}

func IgnoreCloudletFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Errors")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Status")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "NotifySrvAddr")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Config.NotifyCtrlAddrs")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Config.PlatformTag")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Config.Span")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Config.CrmAccessPrivateKey")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Config.AccessApiAddr")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Config.SecondaryCrmAccessPrivateKey")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "CrmAccessPublicKey")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "CreatedAt")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "UpdatedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "HostController")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "SecondaryCrmAccessPublicKey")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "SecondaryNotifySrvAddr")
	}
	return cmpopts.IgnoreFields(Cloudlet{}, names...)
}

func (m *FlavorMatch) CopyInFields(src *FlavorMatch) int {
	changed := 0
	if m.Key.Organization != src.Key.Organization {
		m.Key.Organization = src.Key.Organization
		changed++
	}
	if m.Key.Name != src.Key.Name {
		m.Key.Name = src.Key.Name
		changed++
	}
	if m.Key.FederatedOrganization != src.Key.FederatedOrganization {
		m.Key.FederatedOrganization = src.Key.FederatedOrganization
		changed++
	}
	if m.FlavorName != src.FlavorName {
		m.FlavorName = src.FlavorName
		changed++
	}
	if m.AvailabilityZone != src.AvailabilityZone {
		m.AvailabilityZone = src.AvailabilityZone
		changed++
	}
	return changed
}

func (m *FlavorMatch) DeepCopyIn(src *FlavorMatch) {
	m.Key.DeepCopyIn(&src.Key)
	m.FlavorName = src.FlavorName
	m.AvailabilityZone = src.AvailabilityZone
}

func (m *FlavorMatch) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *FlavorMatch) GetKey() *CloudletKey {
	return &m.Key
}

func (m *FlavorMatch) GetKeyVal() CloudletKey {
	return m.Key
}

func (m *FlavorMatch) SetKey(key *CloudletKey) {
	m.Key = *key
}

func CmpSortFlavorMatch(a FlavorMatch, b FlavorMatch) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *FlavorMatch) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *FlavorMatch) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
}

func (m *CloudletManifest) CopyInFields(src *CloudletManifest) int {
	changed := 0
	if m.Manifest != src.Manifest {
		m.Manifest = src.Manifest
		changed++
	}
	return changed
}

func (m *CloudletManifest) DeepCopyIn(src *CloudletManifest) {
	m.Manifest = src.Manifest
}

// Helper method to check that enums have valid values
func (m *CloudletManifest) ValidateEnums() error {
	return nil
}

func (s *CloudletManifest) ClearTagged(tags map[string]struct{}) {
}

func (m *PropertyInfo) CopyInFields(src *PropertyInfo) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.Description != src.Description {
		m.Description = src.Description
		changed++
	}
	if m.Value != src.Value {
		m.Value = src.Value
		changed++
	}
	if m.Secret != src.Secret {
		m.Secret = src.Secret
		changed++
	}
	if m.Mandatory != src.Mandatory {
		m.Mandatory = src.Mandatory
		changed++
	}
	if m.Internal != src.Internal {
		m.Internal = src.Internal
		changed++
	}
	return changed
}

func (m *PropertyInfo) DeepCopyIn(src *PropertyInfo) {
	m.Name = src.Name
	m.Description = src.Description
	m.Value = src.Value
	m.Secret = src.Secret
	m.Mandatory = src.Mandatory
	m.Internal = src.Internal
}

// Helper method to check that enums have valid values
func (m *PropertyInfo) ValidateEnums() error {
	return nil
}

func (s *PropertyInfo) ClearTagged(tags map[string]struct{}) {
}

func (m *CloudletProps) CopyInFields(src *CloudletProps) int {
	changed := 0
	if m.PlatformType != src.PlatformType {
		m.PlatformType = src.PlatformType
		changed++
	}
	if src.Properties != nil {
		m.Properties = make(map[string]*PropertyInfo)
		for k0, _ := range src.Properties {
			m.Properties[k0] = &PropertyInfo{}
			if m.Properties[k0].Name != src.Properties[k0].Name {
				m.Properties[k0].Name = src.Properties[k0].Name
				changed++
			}
			if m.Properties[k0].Description != src.Properties[k0].Description {
				m.Properties[k0].Description = src.Properties[k0].Description
				changed++
			}
			if m.Properties[k0].Value != src.Properties[k0].Value {
				m.Properties[k0].Value = src.Properties[k0].Value
				changed++
			}
			if m.Properties[k0].Secret != src.Properties[k0].Secret {
				m.Properties[k0].Secret = src.Properties[k0].Secret
				changed++
			}
			if m.Properties[k0].Mandatory != src.Properties[k0].Mandatory {
				m.Properties[k0].Mandatory = src.Properties[k0].Mandatory
				changed++
			}
			if m.Properties[k0].Internal != src.Properties[k0].Internal {
				m.Properties[k0].Internal = src.Properties[k0].Internal
				changed++
			}
		}
	} else if m.Properties != nil {
		m.Properties = nil
		changed++
	}
	if m.Organization != src.Organization {
		m.Organization = src.Organization
		changed++
	}
	return changed
}

func (m *CloudletProps) DeepCopyIn(src *CloudletProps) {
	m.PlatformType = src.PlatformType
	if src.Properties != nil {
		m.Properties = make(map[string]*PropertyInfo)
		for k, v := range src.Properties {
			var tmp_v PropertyInfo
			tmp_v.DeepCopyIn(v)
			m.Properties[k] = &tmp_v
		}
	} else {
		m.Properties = nil
	}
	m.Organization = src.Organization
}

// Helper method to check that enums have valid values
func (m *CloudletProps) ValidateEnums() error {
	if _, ok := PlatformType_name[int32(m.PlatformType)]; !ok {
		return errors.New("invalid PlatformType")
	}
	return nil
}

func (s *CloudletProps) ClearTagged(tags map[string]struct{}) {
}

func (m *CloudletResourceQuotaProps) CopyInFields(src *CloudletResourceQuotaProps) int {
	changed := 0
	if m.PlatformType != src.PlatformType {
		m.PlatformType = src.PlatformType
		changed++
	}
	if src.Properties != nil {
		m.Properties = src.Properties
		changed++
	} else if m.Properties != nil {
		m.Properties = nil
		changed++
	}
	if m.Organization != src.Organization {
		m.Organization = src.Organization
		changed++
	}
	return changed
}

func (m *CloudletResourceQuotaProps) DeepCopyIn(src *CloudletResourceQuotaProps) {
	m.PlatformType = src.PlatformType
	if src.Properties != nil {
		m.Properties = make([]InfraResource, len(src.Properties), len(src.Properties))
		for ii, s := range src.Properties {
			m.Properties[ii].DeepCopyIn(&s)
		}
	} else {
		m.Properties = nil
	}
	m.Organization = src.Organization
}

// Helper method to check that enums have valid values
func (m *CloudletResourceQuotaProps) ValidateEnums() error {
	if _, ok := PlatformType_name[int32(m.PlatformType)]; !ok {
		return errors.New("invalid PlatformType")
	}
	for _, e := range m.Properties {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *CloudletResourceQuotaProps) ClearTagged(tags map[string]struct{}) {
	if s.Properties != nil {
		for ii := 0; ii < len(s.Properties); ii++ {
			s.Properties[ii].ClearTagged(tags)
		}
	}
}

func (m *CloudletResourceUsage) CopyInFields(src *CloudletResourceUsage) int {
	changed := 0
	if m.Key.Organization != src.Key.Organization {
		m.Key.Organization = src.Key.Organization
		changed++
	}
	if m.Key.Name != src.Key.Name {
		m.Key.Name = src.Key.Name
		changed++
	}
	if m.Key.FederatedOrganization != src.Key.FederatedOrganization {
		m.Key.FederatedOrganization = src.Key.FederatedOrganization
		changed++
	}
	if m.InfraUsage != src.InfraUsage {
		m.InfraUsage = src.InfraUsage
		changed++
	}
	if src.Info != nil {
		m.Info = src.Info
		changed++
	} else if m.Info != nil {
		m.Info = nil
		changed++
	}
	return changed
}

func (m *CloudletResourceUsage) DeepCopyIn(src *CloudletResourceUsage) {
	m.Key.DeepCopyIn(&src.Key)
	m.InfraUsage = src.InfraUsage
	if src.Info != nil {
		m.Info = make([]InfraResource, len(src.Info), len(src.Info))
		for ii, s := range src.Info {
			m.Info[ii].DeepCopyIn(&s)
		}
	} else {
		m.Info = nil
	}
}

func (m *CloudletResourceUsage) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *CloudletResourceUsage) GetKey() *CloudletKey {
	return &m.Key
}

func (m *CloudletResourceUsage) GetKeyVal() CloudletKey {
	return m.Key
}

func (m *CloudletResourceUsage) SetKey(key *CloudletKey) {
	m.Key = *key
}

func CmpSortCloudletResourceUsage(a CloudletResourceUsage, b CloudletResourceUsage) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *CloudletResourceUsage) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.Info {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *CloudletResourceUsage) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	if s.Info != nil {
		for ii := 0; ii < len(s.Info); ii++ {
			s.Info[ii].ClearTagged(tags)
		}
	}
}

func (m *CloudletAllianceOrg) CopyInFields(src *CloudletAllianceOrg) int {
	changed := 0
	if m.Key.Organization != src.Key.Organization {
		m.Key.Organization = src.Key.Organization
		changed++
	}
	if m.Key.Name != src.Key.Name {
		m.Key.Name = src.Key.Name
		changed++
	}
	if m.Key.FederatedOrganization != src.Key.FederatedOrganization {
		m.Key.FederatedOrganization = src.Key.FederatedOrganization
		changed++
	}
	if m.Organization != src.Organization {
		m.Organization = src.Organization
		changed++
	}
	return changed
}

func (m *CloudletAllianceOrg) DeepCopyIn(src *CloudletAllianceOrg) {
	m.Key.DeepCopyIn(&src.Key)
	m.Organization = src.Organization
}

func (m *CloudletAllianceOrg) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *CloudletAllianceOrg) GetKey() *CloudletKey {
	return &m.Key
}

func (m *CloudletAllianceOrg) GetKeyVal() CloudletKey {
	return m.Key
}

func (m *CloudletAllianceOrg) SetKey(key *CloudletKey) {
	m.Key = *key
}

func CmpSortCloudletAllianceOrg(a CloudletAllianceOrg, b CloudletAllianceOrg) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *CloudletAllianceOrg) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *CloudletAllianceOrg) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
}

func (m *FlavorInfo) CopyInFields(src *FlavorInfo) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.Vcpus != src.Vcpus {
		m.Vcpus = src.Vcpus
		changed++
	}
	if m.Ram != src.Ram {
		m.Ram = src.Ram
		changed++
	}
	if m.Disk != src.Disk {
		m.Disk = src.Disk
		changed++
	}
	if src.PropMap != nil {
		m.PropMap = make(map[string]string)
		for k0, _ := range src.PropMap {
			m.PropMap[k0] = src.PropMap[k0]
			changed++
		}
	} else if m.PropMap != nil {
		m.PropMap = nil
		changed++
	}
	return changed
}

func (m *FlavorInfo) DeepCopyIn(src *FlavorInfo) {
	m.Name = src.Name
	m.Vcpus = src.Vcpus
	m.Ram = src.Ram
	m.Disk = src.Disk
	if src.PropMap != nil {
		m.PropMap = make(map[string]string)
		for k, v := range src.PropMap {
			m.PropMap[k] = v
		}
	} else {
		m.PropMap = nil
	}
}

// Helper method to check that enums have valid values
func (m *FlavorInfo) ValidateEnums() error {
	return nil
}

func (s *FlavorInfo) ClearTagged(tags map[string]struct{}) {
}

func (m *OSAZone) CopyInFields(src *OSAZone) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	return changed
}

func (m *OSAZone) DeepCopyIn(src *OSAZone) {
	m.Name = src.Name
	m.Status = src.Status
}

// Helper method to check that enums have valid values
func (m *OSAZone) ValidateEnums() error {
	return nil
}

func (s *OSAZone) ClearTagged(tags map[string]struct{}) {
}

func (m *OSImage) CopyInFields(src *OSImage) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.Tags != src.Tags {
		m.Tags = src.Tags
		changed++
	}
	if m.Properties != src.Properties {
		m.Properties = src.Properties
		changed++
	}
	if m.DiskFormat != src.DiskFormat {
		m.DiskFormat = src.DiskFormat
		changed++
	}
	return changed
}

func (m *OSImage) DeepCopyIn(src *OSImage) {
	m.Name = src.Name
	m.Tags = src.Tags
	m.Properties = src.Properties
	m.DiskFormat = src.DiskFormat
}

// Helper method to check that enums have valid values
func (m *OSImage) ValidateEnums() error {
	return nil
}

func (s *OSImage) ClearTagged(tags map[string]struct{}) {
}

func (m *CloudletInfo) Matches(o *CloudletInfo, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.State != 0 {
		if o.State != m.State {
			return false
		}
	}
	if !opts.Filter || o.NotifyId != 0 {
		if o.NotifyId != m.NotifyId {
			return false
		}
	}
	if !opts.Filter || o.Controller != "" {
		if o.Controller != m.Controller {
			return false
		}
	}
	if !opts.Filter || o.OsMaxRam != 0 {
		if o.OsMaxRam != m.OsMaxRam {
			return false
		}
	}
	if !opts.Filter || o.OsMaxVcores != 0 {
		if o.OsMaxVcores != m.OsMaxVcores {
			return false
		}
	}
	if !opts.Filter || o.OsMaxVolGb != 0 {
		if o.OsMaxVolGb != m.OsMaxVolGb {
			return false
		}
	}
	if !opts.Filter || o.Errors != nil {
		if len(m.Errors) == 0 && len(o.Errors) > 0 || len(m.Errors) > 0 && len(o.Errors) == 0 {
			return false
		} else if m.Errors != nil && o.Errors != nil {
			if !opts.Filter && len(m.Errors) != len(o.Errors) {
				return false
			}
			found := 0
			for oIndex, _ := range o.Errors {
				for mIndex, _ := range m.Errors {
					if o.Errors[oIndex] == m.Errors[mIndex] {
						found++
						break
					}
				}
			}
			if found != len(o.Errors) {
				return false
			}
		}
	}
	if !opts.Filter || o.Flavors != nil {
		if len(m.Flavors) == 0 && len(o.Flavors) > 0 || len(m.Flavors) > 0 && len(o.Flavors) == 0 {
			return false
		} else if m.Flavors != nil && o.Flavors != nil {
			if !opts.Filter && len(m.Flavors) != len(o.Flavors) {
				return false
			}
		}
	}
	if !opts.Filter || o.ContainerVersion != "" {
		if o.ContainerVersion != m.ContainerVersion {
			return false
		}
	}
	if !opts.Filter || o.AvailabilityZones != nil {
		if len(m.AvailabilityZones) == 0 && len(o.AvailabilityZones) > 0 || len(m.AvailabilityZones) > 0 && len(o.AvailabilityZones) == 0 {
			return false
		} else if m.AvailabilityZones != nil && o.AvailabilityZones != nil {
			if !opts.Filter && len(m.AvailabilityZones) != len(o.AvailabilityZones) {
				return false
			}
		}
	}
	if !opts.Filter || o.OsImages != nil {
		if len(m.OsImages) == 0 && len(o.OsImages) > 0 || len(m.OsImages) > 0 && len(o.OsImages) == 0 {
			return false
		} else if m.OsImages != nil && o.OsImages != nil {
			if !opts.Filter && len(m.OsImages) != len(o.OsImages) {
				return false
			}
		}
	}
	if !opts.Filter || o.ControllerCacheReceived != false {
		if o.ControllerCacheReceived != m.ControllerCacheReceived {
			return false
		}
	}
	if !opts.Filter || o.MaintenanceState != 0 {
		if o.MaintenanceState != m.MaintenanceState {
			return false
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.Filter || o.TrustPolicyState != 0 {
		if o.TrustPolicyState != m.TrustPolicyState {
			return false
		}
	}
	if !opts.Filter || o.CompatibilityVersion != 0 {
		if o.CompatibilityVersion != m.CompatibilityVersion {
			return false
		}
	}
	if !opts.Filter || o.Properties != nil {
		if len(m.Properties) == 0 && len(o.Properties) > 0 || len(m.Properties) > 0 && len(o.Properties) == 0 {
			return false
		} else if m.Properties != nil && o.Properties != nil {
			if !opts.Filter && len(m.Properties) != len(o.Properties) {
				return false
			}
			for k, _ := range o.Properties {
				_, ok := m.Properties[k]
				if !ok {
					return false
				}
				if o.Properties[k] != m.Properties[k] {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.NodeInfos != nil {
		if len(m.NodeInfos) == 0 && len(o.NodeInfos) > 0 || len(m.NodeInfos) > 0 && len(o.NodeInfos) == 0 {
			return false
		} else if m.NodeInfos != nil && o.NodeInfos != nil {
			if !opts.Filter && len(m.NodeInfos) != len(o.NodeInfos) {
				return false
			}
		}
	}
	if !opts.Filter || o.ActiveCrmInstance != "" {
		if o.ActiveCrmInstance != m.ActiveCrmInstance {
			return false
		}
	}
	if !opts.Filter || o.StandbyCrm != false {
		if o.StandbyCrm != m.StandbyCrm {
			return false
		}
	}
	return true
}

const CloudletInfoFieldKey = "2"
const CloudletInfoFieldKeyOrganization = "2.1"
const CloudletInfoFieldKeyName = "2.2"
const CloudletInfoFieldKeyFederatedOrganization = "2.3"
const CloudletInfoFieldState = "3"
const CloudletInfoFieldNotifyId = "4"
const CloudletInfoFieldController = "5"
const CloudletInfoFieldOsMaxRam = "6"
const CloudletInfoFieldOsMaxVcores = "7"
const CloudletInfoFieldOsMaxVolGb = "8"
const CloudletInfoFieldErrors = "9"
const CloudletInfoFieldFlavors = "10"
const CloudletInfoFieldFlavorsName = "10.1"
const CloudletInfoFieldFlavorsVcpus = "10.2"
const CloudletInfoFieldFlavorsRam = "10.3"
const CloudletInfoFieldFlavorsDisk = "10.4"
const CloudletInfoFieldFlavorsPropMap = "10.5"
const CloudletInfoFieldFlavorsPropMapKey = "10.5.1"
const CloudletInfoFieldFlavorsPropMapValue = "10.5.2"
const CloudletInfoFieldStatus = "11"
const CloudletInfoFieldStatusTaskNumber = "11.1"
const CloudletInfoFieldStatusMaxTasks = "11.2"
const CloudletInfoFieldStatusTaskName = "11.3"
const CloudletInfoFieldStatusStepName = "11.4"
const CloudletInfoFieldStatusMsgCount = "11.5"
const CloudletInfoFieldStatusMsgs = "11.6"
const CloudletInfoFieldContainerVersion = "12"
const CloudletInfoFieldAvailabilityZones = "13"
const CloudletInfoFieldAvailabilityZonesName = "13.1"
const CloudletInfoFieldAvailabilityZonesStatus = "13.2"
const CloudletInfoFieldOsImages = "14"
const CloudletInfoFieldOsImagesName = "14.1"
const CloudletInfoFieldOsImagesTags = "14.2"
const CloudletInfoFieldOsImagesProperties = "14.3"
const CloudletInfoFieldOsImagesDiskFormat = "14.4"
const CloudletInfoFieldControllerCacheReceived = "15"
const CloudletInfoFieldMaintenanceState = "16"
const CloudletInfoFieldResourcesSnapshot = "17"
const CloudletInfoFieldResourcesSnapshotPlatformVms = "17.1"
const CloudletInfoFieldResourcesSnapshotPlatformVmsName = "17.1.1"
const CloudletInfoFieldResourcesSnapshotPlatformVmsType = "17.1.2"
const CloudletInfoFieldResourcesSnapshotPlatformVmsStatus = "17.1.3"
const CloudletInfoFieldResourcesSnapshotPlatformVmsInfraFlavor = "17.1.4"
const CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddresses = "17.1.5"
const CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddressesExternalIp = "17.1.5.1"
const CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddressesInternalIp = "17.1.5.2"
const CloudletInfoFieldResourcesSnapshotPlatformVmsContainers = "17.1.6"
const CloudletInfoFieldResourcesSnapshotPlatformVmsContainersName = "17.1.6.1"
const CloudletInfoFieldResourcesSnapshotPlatformVmsContainersType = "17.1.6.2"
const CloudletInfoFieldResourcesSnapshotPlatformVmsContainersStatus = "17.1.6.3"
const CloudletInfoFieldResourcesSnapshotPlatformVmsContainersClusterip = "17.1.6.4"
const CloudletInfoFieldResourcesSnapshotPlatformVmsContainersRestarts = "17.1.6.5"
const CloudletInfoFieldResourcesSnapshotInfo = "17.2"
const CloudletInfoFieldResourcesSnapshotInfoName = "17.2.1"
const CloudletInfoFieldResourcesSnapshotInfoValue = "17.2.2"
const CloudletInfoFieldResourcesSnapshotInfoInfraMaxValue = "17.2.3"
const CloudletInfoFieldResourcesSnapshotInfoQuotaMaxValue = "17.2.4"
const CloudletInfoFieldResourcesSnapshotInfoDescription = "17.2.5"
const CloudletInfoFieldResourcesSnapshotInfoUnits = "17.2.6"
const CloudletInfoFieldResourcesSnapshotInfoAlertThreshold = "17.2.7"
const CloudletInfoFieldResourcesSnapshotClusterInsts = "17.3"
const CloudletInfoFieldResourcesSnapshotClusterInstsClusterKey = "17.3.1"
const CloudletInfoFieldResourcesSnapshotClusterInstsClusterKeyName = "17.3.1.1"
const CloudletInfoFieldResourcesSnapshotClusterInstsOrganization = "17.3.2"
const CloudletInfoFieldResourcesSnapshotVmAppInsts = "17.4"
const CloudletInfoFieldResourcesSnapshotVmAppInstsAppKey = "17.4.1"
const CloudletInfoFieldResourcesSnapshotVmAppInstsAppKeyOrganization = "17.4.1.1"
const CloudletInfoFieldResourcesSnapshotVmAppInstsAppKeyName = "17.4.1.2"
const CloudletInfoFieldResourcesSnapshotVmAppInstsAppKeyVersion = "17.4.1.3"
const CloudletInfoFieldResourcesSnapshotVmAppInstsClusterInstKey = "17.4.2"
const CloudletInfoFieldResourcesSnapshotVmAppInstsClusterInstKeyClusterKey = "17.4.2.1"
const CloudletInfoFieldResourcesSnapshotVmAppInstsClusterInstKeyClusterKeyName = "17.4.2.1.1"
const CloudletInfoFieldResourcesSnapshotVmAppInstsClusterInstKeyOrganization = "17.4.2.2"
const CloudletInfoFieldTrustPolicyState = "18"
const CloudletInfoFieldCompatibilityVersion = "19"
const CloudletInfoFieldProperties = "20"
const CloudletInfoFieldPropertiesKey = "20.1"
const CloudletInfoFieldPropertiesValue = "20.2"
const CloudletInfoFieldNodeInfos = "21"
const CloudletInfoFieldNodeInfosName = "21.1"
const CloudletInfoFieldNodeInfosAllocatable = "21.2"
const CloudletInfoFieldNodeInfosAllocatableKey = "21.2.1"
const CloudletInfoFieldNodeInfosAllocatableValue = "21.2.2"
const CloudletInfoFieldNodeInfosAllocatableValueWhole = "21.2.2.1"
const CloudletInfoFieldNodeInfosAllocatableValueNanos = "21.2.2.2"
const CloudletInfoFieldNodeInfosCapacity = "21.3"
const CloudletInfoFieldNodeInfosCapacityKey = "21.3.1"
const CloudletInfoFieldNodeInfosCapacityValue = "21.3.2"
const CloudletInfoFieldNodeInfosCapacityValueWhole = "21.3.2.1"
const CloudletInfoFieldNodeInfosCapacityValueNanos = "21.3.2.2"
const CloudletInfoFieldActiveCrmInstance = "22"
const CloudletInfoFieldStandbyCrm = "23"

var CloudletInfoAllFields = []string{
	CloudletInfoFieldKeyOrganization,
	CloudletInfoFieldKeyName,
	CloudletInfoFieldKeyFederatedOrganization,
	CloudletInfoFieldState,
	CloudletInfoFieldNotifyId,
	CloudletInfoFieldController,
	CloudletInfoFieldOsMaxRam,
	CloudletInfoFieldOsMaxVcores,
	CloudletInfoFieldOsMaxVolGb,
	CloudletInfoFieldErrors,
	CloudletInfoFieldFlavorsName,
	CloudletInfoFieldFlavorsVcpus,
	CloudletInfoFieldFlavorsRam,
	CloudletInfoFieldFlavorsDisk,
	CloudletInfoFieldFlavorsPropMapKey,
	CloudletInfoFieldFlavorsPropMapValue,
	CloudletInfoFieldStatusTaskNumber,
	CloudletInfoFieldStatusMaxTasks,
	CloudletInfoFieldStatusTaskName,
	CloudletInfoFieldStatusStepName,
	CloudletInfoFieldStatusMsgCount,
	CloudletInfoFieldStatusMsgs,
	CloudletInfoFieldContainerVersion,
	CloudletInfoFieldAvailabilityZonesName,
	CloudletInfoFieldAvailabilityZonesStatus,
	CloudletInfoFieldOsImagesName,
	CloudletInfoFieldOsImagesTags,
	CloudletInfoFieldOsImagesProperties,
	CloudletInfoFieldOsImagesDiskFormat,
	CloudletInfoFieldControllerCacheReceived,
	CloudletInfoFieldMaintenanceState,
	CloudletInfoFieldResourcesSnapshotPlatformVmsName,
	CloudletInfoFieldResourcesSnapshotPlatformVmsType,
	CloudletInfoFieldResourcesSnapshotPlatformVmsStatus,
	CloudletInfoFieldResourcesSnapshotPlatformVmsInfraFlavor,
	CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddressesExternalIp,
	CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddressesInternalIp,
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersName,
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersType,
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersStatus,
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersClusterip,
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersRestarts,
	CloudletInfoFieldResourcesSnapshotInfoName,
	CloudletInfoFieldResourcesSnapshotInfoValue,
	CloudletInfoFieldResourcesSnapshotInfoInfraMaxValue,
	CloudletInfoFieldResourcesSnapshotInfoQuotaMaxValue,
	CloudletInfoFieldResourcesSnapshotInfoDescription,
	CloudletInfoFieldResourcesSnapshotInfoUnits,
	CloudletInfoFieldResourcesSnapshotInfoAlertThreshold,
	CloudletInfoFieldResourcesSnapshotClusterInstsClusterKeyName,
	CloudletInfoFieldResourcesSnapshotClusterInstsOrganization,
	CloudletInfoFieldResourcesSnapshotVmAppInstsAppKeyOrganization,
	CloudletInfoFieldResourcesSnapshotVmAppInstsAppKeyName,
	CloudletInfoFieldResourcesSnapshotVmAppInstsAppKeyVersion,
	CloudletInfoFieldResourcesSnapshotVmAppInstsClusterInstKeyClusterKeyName,
	CloudletInfoFieldResourcesSnapshotVmAppInstsClusterInstKeyOrganization,
	CloudletInfoFieldTrustPolicyState,
	CloudletInfoFieldCompatibilityVersion,
	CloudletInfoFieldPropertiesKey,
	CloudletInfoFieldPropertiesValue,
	CloudletInfoFieldNodeInfosName,
	CloudletInfoFieldNodeInfosAllocatableKey,
	CloudletInfoFieldNodeInfosAllocatableValueWhole,
	CloudletInfoFieldNodeInfosAllocatableValueNanos,
	CloudletInfoFieldNodeInfosCapacityKey,
	CloudletInfoFieldNodeInfosCapacityValueWhole,
	CloudletInfoFieldNodeInfosCapacityValueNanos,
	CloudletInfoFieldActiveCrmInstance,
	CloudletInfoFieldStandbyCrm,
}

var CloudletInfoAllFieldsMap = map[string]struct{}{
	CloudletInfoFieldKeyOrganization:                                         struct{}{},
	CloudletInfoFieldKeyName:                                                 struct{}{},
	CloudletInfoFieldKeyFederatedOrganization:                                struct{}{},
	CloudletInfoFieldState:                                                   struct{}{},
	CloudletInfoFieldNotifyId:                                                struct{}{},
	CloudletInfoFieldController:                                              struct{}{},
	CloudletInfoFieldOsMaxRam:                                                struct{}{},
	CloudletInfoFieldOsMaxVcores:                                             struct{}{},
	CloudletInfoFieldOsMaxVolGb:                                              struct{}{},
	CloudletInfoFieldErrors:                                                  struct{}{},
	CloudletInfoFieldFlavorsName:                                             struct{}{},
	CloudletInfoFieldFlavorsVcpus:                                            struct{}{},
	CloudletInfoFieldFlavorsRam:                                              struct{}{},
	CloudletInfoFieldFlavorsDisk:                                             struct{}{},
	CloudletInfoFieldFlavorsPropMapKey:                                       struct{}{},
	CloudletInfoFieldFlavorsPropMapValue:                                     struct{}{},
	CloudletInfoFieldStatusTaskNumber:                                        struct{}{},
	CloudletInfoFieldStatusMaxTasks:                                          struct{}{},
	CloudletInfoFieldStatusTaskName:                                          struct{}{},
	CloudletInfoFieldStatusStepName:                                          struct{}{},
	CloudletInfoFieldStatusMsgCount:                                          struct{}{},
	CloudletInfoFieldStatusMsgs:                                              struct{}{},
	CloudletInfoFieldContainerVersion:                                        struct{}{},
	CloudletInfoFieldAvailabilityZonesName:                                   struct{}{},
	CloudletInfoFieldAvailabilityZonesStatus:                                 struct{}{},
	CloudletInfoFieldOsImagesName:                                            struct{}{},
	CloudletInfoFieldOsImagesTags:                                            struct{}{},
	CloudletInfoFieldOsImagesProperties:                                      struct{}{},
	CloudletInfoFieldOsImagesDiskFormat:                                      struct{}{},
	CloudletInfoFieldControllerCacheReceived:                                 struct{}{},
	CloudletInfoFieldMaintenanceState:                                        struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsName:                        struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsType:                        struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsStatus:                      struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsInfraFlavor:                 struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddressesExternalIp:       struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddressesInternalIp:       struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersName:              struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersType:              struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersStatus:            struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersClusterip:         struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersRestarts:          struct{}{},
	CloudletInfoFieldResourcesSnapshotInfoName:                               struct{}{},
	CloudletInfoFieldResourcesSnapshotInfoValue:                              struct{}{},
	CloudletInfoFieldResourcesSnapshotInfoInfraMaxValue:                      struct{}{},
	CloudletInfoFieldResourcesSnapshotInfoQuotaMaxValue:                      struct{}{},
	CloudletInfoFieldResourcesSnapshotInfoDescription:                        struct{}{},
	CloudletInfoFieldResourcesSnapshotInfoUnits:                              struct{}{},
	CloudletInfoFieldResourcesSnapshotInfoAlertThreshold:                     struct{}{},
	CloudletInfoFieldResourcesSnapshotClusterInstsClusterKeyName:             struct{}{},
	CloudletInfoFieldResourcesSnapshotClusterInstsOrganization:               struct{}{},
	CloudletInfoFieldResourcesSnapshotVmAppInstsAppKeyOrganization:           struct{}{},
	CloudletInfoFieldResourcesSnapshotVmAppInstsAppKeyName:                   struct{}{},
	CloudletInfoFieldResourcesSnapshotVmAppInstsAppKeyVersion:                struct{}{},
	CloudletInfoFieldResourcesSnapshotVmAppInstsClusterInstKeyClusterKeyName: struct{}{},
	CloudletInfoFieldResourcesSnapshotVmAppInstsClusterInstKeyOrganization:   struct{}{},
	CloudletInfoFieldTrustPolicyState:                                        struct{}{},
	CloudletInfoFieldCompatibilityVersion:                                    struct{}{},
	CloudletInfoFieldPropertiesKey:                                           struct{}{},
	CloudletInfoFieldPropertiesValue:                                         struct{}{},
	CloudletInfoFieldNodeInfosName:                                           struct{}{},
	CloudletInfoFieldNodeInfosAllocatableKey:                                 struct{}{},
	CloudletInfoFieldNodeInfosAllocatableValueWhole:                          struct{}{},
	CloudletInfoFieldNodeInfosAllocatableValueNanos:                          struct{}{},
	CloudletInfoFieldNodeInfosCapacityKey:                                    struct{}{},
	CloudletInfoFieldNodeInfosCapacityValueWhole:                             struct{}{},
	CloudletInfoFieldNodeInfosCapacityValueNanos:                             struct{}{},
	CloudletInfoFieldActiveCrmInstance:                                       struct{}{},
	CloudletInfoFieldStandbyCrm:                                              struct{}{},
}

var CloudletInfoAllFieldsStringMap = map[string]string{
	CloudletInfoFieldKeyOrganization:                                         "Key Organization",
	CloudletInfoFieldKeyName:                                                 "Key Name",
	CloudletInfoFieldKeyFederatedOrganization:                                "Key Federated Organization",
	CloudletInfoFieldState:                                                   "State",
	CloudletInfoFieldNotifyId:                                                "Notify Id",
	CloudletInfoFieldController:                                              "Controller",
	CloudletInfoFieldOsMaxRam:                                                "Os Max Ram",
	CloudletInfoFieldOsMaxVcores:                                             "Os Max Vcores",
	CloudletInfoFieldOsMaxVolGb:                                              "Os Max Vol Gb",
	CloudletInfoFieldErrors:                                                  "Errors",
	CloudletInfoFieldFlavorsName:                                             "Flavors Name",
	CloudletInfoFieldFlavorsVcpus:                                            "Flavors Vcpus",
	CloudletInfoFieldFlavorsRam:                                              "Flavors Ram",
	CloudletInfoFieldFlavorsDisk:                                             "Flavors Disk",
	CloudletInfoFieldFlavorsPropMapKey:                                       "Flavors Prop Map Key",
	CloudletInfoFieldFlavorsPropMapValue:                                     "Flavors Prop Map Value",
	CloudletInfoFieldStatusTaskNumber:                                        "Status Task Number",
	CloudletInfoFieldStatusMaxTasks:                                          "Status Max Tasks",
	CloudletInfoFieldStatusTaskName:                                          "Status Task Name",
	CloudletInfoFieldStatusStepName:                                          "Status Step Name",
	CloudletInfoFieldStatusMsgCount:                                          "Status Msg Count",
	CloudletInfoFieldStatusMsgs:                                              "Status Msgs",
	CloudletInfoFieldContainerVersion:                                        "Container Version",
	CloudletInfoFieldAvailabilityZonesName:                                   "Availability Zones Name",
	CloudletInfoFieldAvailabilityZonesStatus:                                 "Availability Zones Status",
	CloudletInfoFieldOsImagesName:                                            "Os Images Name",
	CloudletInfoFieldOsImagesTags:                                            "Os Images Tags",
	CloudletInfoFieldOsImagesProperties:                                      "Os Images Properties",
	CloudletInfoFieldOsImagesDiskFormat:                                      "Os Images Disk Format",
	CloudletInfoFieldControllerCacheReceived:                                 "Controller Cache Received",
	CloudletInfoFieldMaintenanceState:                                        "Maintenance State",
	CloudletInfoFieldResourcesSnapshotPlatformVmsName:                        "Resources Snapshot Platform Vms Name",
	CloudletInfoFieldResourcesSnapshotPlatformVmsType:                        "Resources Snapshot Platform Vms Type",
	CloudletInfoFieldResourcesSnapshotPlatformVmsStatus:                      "Resources Snapshot Platform Vms Status",
	CloudletInfoFieldResourcesSnapshotPlatformVmsInfraFlavor:                 "Resources Snapshot Platform Vms Infra Flavor",
	CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddressesExternalIp:       "Resources Snapshot Platform Vms Ipaddresses External Ip",
	CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddressesInternalIp:       "Resources Snapshot Platform Vms Ipaddresses Internal Ip",
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersName:              "Resources Snapshot Platform Vms Containers Name",
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersType:              "Resources Snapshot Platform Vms Containers Type",
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersStatus:            "Resources Snapshot Platform Vms Containers Status",
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersClusterip:         "Resources Snapshot Platform Vms Containers Clusterip",
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersRestarts:          "Resources Snapshot Platform Vms Containers Restarts",
	CloudletInfoFieldResourcesSnapshotInfoName:                               "Resources Snapshot Info Name",
	CloudletInfoFieldResourcesSnapshotInfoValue:                              "Resources Snapshot Info Value",
	CloudletInfoFieldResourcesSnapshotInfoInfraMaxValue:                      "Resources Snapshot Info Infra Max Value",
	CloudletInfoFieldResourcesSnapshotInfoQuotaMaxValue:                      "Resources Snapshot Info Quota Max Value",
	CloudletInfoFieldResourcesSnapshotInfoDescription:                        "Resources Snapshot Info Description",
	CloudletInfoFieldResourcesSnapshotInfoUnits:                              "Resources Snapshot Info Units",
	CloudletInfoFieldResourcesSnapshotInfoAlertThreshold:                     "Resources Snapshot Info Alert Threshold",
	CloudletInfoFieldResourcesSnapshotClusterInstsClusterKeyName:             "Resources Snapshot Cluster Insts Cluster Key Name",
	CloudletInfoFieldResourcesSnapshotClusterInstsOrganization:               "Resources Snapshot Cluster Insts Organization",
	CloudletInfoFieldResourcesSnapshotVmAppInstsAppKeyOrganization:           "Resources Snapshot Vm App Insts App Key Organization",
	CloudletInfoFieldResourcesSnapshotVmAppInstsAppKeyName:                   "Resources Snapshot Vm App Insts App Key Name",
	CloudletInfoFieldResourcesSnapshotVmAppInstsAppKeyVersion:                "Resources Snapshot Vm App Insts App Key Version",
	CloudletInfoFieldResourcesSnapshotVmAppInstsClusterInstKeyClusterKeyName: "Resources Snapshot Vm App Insts Cluster Inst Key Cluster Key Name",
	CloudletInfoFieldResourcesSnapshotVmAppInstsClusterInstKeyOrganization:   "Resources Snapshot Vm App Insts Cluster Inst Key Organization",
	CloudletInfoFieldTrustPolicyState:                                        "Trust Policy State",
	CloudletInfoFieldCompatibilityVersion:                                    "Compatibility Version",
	CloudletInfoFieldPropertiesKey:                                           "Properties Key",
	CloudletInfoFieldPropertiesValue:                                         "Properties Value",
	CloudletInfoFieldNodeInfosName:                                           "Node Infos Name",
	CloudletInfoFieldNodeInfosAllocatableKey:                                 "Node Infos Allocatable Key",
	CloudletInfoFieldNodeInfosAllocatableValueWhole:                          "Node Infos Allocatable Value Whole",
	CloudletInfoFieldNodeInfosAllocatableValueNanos:                          "Node Infos Allocatable Value Nanos",
	CloudletInfoFieldNodeInfosCapacityKey:                                    "Node Infos Capacity Key",
	CloudletInfoFieldNodeInfosCapacityValueWhole:                             "Node Infos Capacity Value Whole",
	CloudletInfoFieldNodeInfosCapacityValueNanos:                             "Node Infos Capacity Value Nanos",
	CloudletInfoFieldActiveCrmInstance:                                       "Active Crm Instance",
	CloudletInfoFieldStandbyCrm:                                              "Standby Crm",
}

func (m *CloudletInfo) IsKeyField(s string) bool {
	return strings.HasPrefix(s, CloudletInfoFieldKey+".") || s == CloudletInfoFieldKey
}

func (m *CloudletInfo) DiffFields(o *CloudletInfo, fields map[string]struct{}) {
	if m.Key.Organization != o.Key.Organization {
		fields[CloudletInfoFieldKeyOrganization] = struct{}{}
		fields[CloudletInfoFieldKey] = struct{}{}
	}
	if m.Key.Name != o.Key.Name {
		fields[CloudletInfoFieldKeyName] = struct{}{}
		fields[CloudletInfoFieldKey] = struct{}{}
	}
	if m.Key.FederatedOrganization != o.Key.FederatedOrganization {
		fields[CloudletInfoFieldKeyFederatedOrganization] = struct{}{}
		fields[CloudletInfoFieldKey] = struct{}{}
	}
	if m.State != o.State {
		fields[CloudletInfoFieldState] = struct{}{}
	}
	if m.NotifyId != o.NotifyId {
		fields[CloudletInfoFieldNotifyId] = struct{}{}
	}
	if m.Controller != o.Controller {
		fields[CloudletInfoFieldController] = struct{}{}
	}
	if m.OsMaxRam != o.OsMaxRam {
		fields[CloudletInfoFieldOsMaxRam] = struct{}{}
	}
	if m.OsMaxVcores != o.OsMaxVcores {
		fields[CloudletInfoFieldOsMaxVcores] = struct{}{}
	}
	if m.OsMaxVolGb != o.OsMaxVolGb {
		fields[CloudletInfoFieldOsMaxVolGb] = struct{}{}
	}
	if len(m.Errors) != len(o.Errors) {
		fields[CloudletInfoFieldErrors] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.Errors); i0++ {
			if m.Errors[i0] != o.Errors[i0] {
				fields[CloudletInfoFieldErrors] = struct{}{}
				break
			}
		}
	}
	if m.Flavors != nil && o.Flavors != nil {
		if len(m.Flavors) != len(o.Flavors) {
			fields[CloudletInfoFieldFlavors] = struct{}{}
		} else {
			for i0 := 0; i0 < len(m.Flavors); i0++ {
				if m.Flavors[i0].Name != o.Flavors[i0].Name {
					fields[CloudletInfoFieldFlavorsName] = struct{}{}
					fields[CloudletInfoFieldFlavors] = struct{}{}
				}
				if m.Flavors[i0].Vcpus != o.Flavors[i0].Vcpus {
					fields[CloudletInfoFieldFlavorsVcpus] = struct{}{}
					fields[CloudletInfoFieldFlavors] = struct{}{}
				}
				if m.Flavors[i0].Ram != o.Flavors[i0].Ram {
					fields[CloudletInfoFieldFlavorsRam] = struct{}{}
					fields[CloudletInfoFieldFlavors] = struct{}{}
				}
				if m.Flavors[i0].Disk != o.Flavors[i0].Disk {
					fields[CloudletInfoFieldFlavorsDisk] = struct{}{}
					fields[CloudletInfoFieldFlavors] = struct{}{}
				}
				if m.Flavors[i0].PropMap != nil && o.Flavors[i0].PropMap != nil {
					if len(m.Flavors[i0].PropMap) != len(o.Flavors[i0].PropMap) {
						fields[CloudletInfoFieldFlavorsPropMap] = struct{}{}
						fields[CloudletInfoFieldFlavors] = struct{}{}
					} else {
						for k1, _ := range m.Flavors[i0].PropMap {
							_, vok1 := o.Flavors[i0].PropMap[k1]
							if !vok1 {
								fields[CloudletInfoFieldFlavorsPropMap] = struct{}{}
								fields[CloudletInfoFieldFlavors] = struct{}{}
							} else {
								if m.Flavors[i0].PropMap[k1] != o.Flavors[i0].PropMap[k1] {
									fields[CloudletInfoFieldFlavorsPropMap] = struct{}{}
									fields[CloudletInfoFieldFlavors] = struct{}{}
									break
								}
							}
						}
					}
				} else if (m.Flavors[i0].PropMap != nil && o.Flavors[i0].PropMap == nil) || (m.Flavors[i0].PropMap == nil && o.Flavors[i0].PropMap != nil) {
					fields[CloudletInfoFieldFlavorsPropMap] = struct{}{}
					fields[CloudletInfoFieldFlavors] = struct{}{}
				}
			}
		}
	} else if (m.Flavors != nil && o.Flavors == nil) || (m.Flavors == nil && o.Flavors != nil) {
		fields[CloudletInfoFieldFlavors] = struct{}{}
	}
	if m.Status.TaskNumber != o.Status.TaskNumber {
		fields[CloudletInfoFieldStatusTaskNumber] = struct{}{}
		fields[CloudletInfoFieldStatus] = struct{}{}
	}
	if m.Status.MaxTasks != o.Status.MaxTasks {
		fields[CloudletInfoFieldStatusMaxTasks] = struct{}{}
		fields[CloudletInfoFieldStatus] = struct{}{}
	}
	if m.Status.TaskName != o.Status.TaskName {
		fields[CloudletInfoFieldStatusTaskName] = struct{}{}
		fields[CloudletInfoFieldStatus] = struct{}{}
	}
	if m.Status.StepName != o.Status.StepName {
		fields[CloudletInfoFieldStatusStepName] = struct{}{}
		fields[CloudletInfoFieldStatus] = struct{}{}
	}
	if m.Status.MsgCount != o.Status.MsgCount {
		fields[CloudletInfoFieldStatusMsgCount] = struct{}{}
		fields[CloudletInfoFieldStatus] = struct{}{}
	}
	if len(m.Status.Msgs) != len(o.Status.Msgs) {
		fields[CloudletInfoFieldStatusMsgs] = struct{}{}
		fields[CloudletInfoFieldStatus] = struct{}{}
	} else {
		for i1 := 0; i1 < len(m.Status.Msgs); i1++ {
			if m.Status.Msgs[i1] != o.Status.Msgs[i1] {
				fields[CloudletInfoFieldStatusMsgs] = struct{}{}
				fields[CloudletInfoFieldStatus] = struct{}{}
				break
			}
		}
	}
	if m.ContainerVersion != o.ContainerVersion {
		fields[CloudletInfoFieldContainerVersion] = struct{}{}
	}
	if m.AvailabilityZones != nil && o.AvailabilityZones != nil {
		if len(m.AvailabilityZones) != len(o.AvailabilityZones) {
			fields[CloudletInfoFieldAvailabilityZones] = struct{}{}
		} else {
			for i0 := 0; i0 < len(m.AvailabilityZones); i0++ {
				if m.AvailabilityZones[i0].Name != o.AvailabilityZones[i0].Name {
					fields[CloudletInfoFieldAvailabilityZonesName] = struct{}{}
					fields[CloudletInfoFieldAvailabilityZones] = struct{}{}
				}
				if m.AvailabilityZones[i0].Status != o.AvailabilityZones[i0].Status {
					fields[CloudletInfoFieldAvailabilityZonesStatus] = struct{}{}
					fields[CloudletInfoFieldAvailabilityZones] = struct{}{}
				}
			}
		}
	} else if (m.AvailabilityZones != nil && o.AvailabilityZones == nil) || (m.AvailabilityZones == nil && o.AvailabilityZones != nil) {
		fields[CloudletInfoFieldAvailabilityZones] = struct{}{}
	}
	if m.OsImages != nil && o.OsImages != nil {
		if len(m.OsImages) != len(o.OsImages) {
			fields[CloudletInfoFieldOsImages] = struct{}{}
		} else {
			for i0 := 0; i0 < len(m.OsImages); i0++ {
				if m.OsImages[i0].Name != o.OsImages[i0].Name {
					fields[CloudletInfoFieldOsImagesName] = struct{}{}
					fields[CloudletInfoFieldOsImages] = struct{}{}
				}
				if m.OsImages[i0].Tags != o.OsImages[i0].Tags {
					fields[CloudletInfoFieldOsImagesTags] = struct{}{}
					fields[CloudletInfoFieldOsImages] = struct{}{}
				}
				if m.OsImages[i0].Properties != o.OsImages[i0].Properties {
					fields[CloudletInfoFieldOsImagesProperties] = struct{}{}
					fields[CloudletInfoFieldOsImages] = struct{}{}
				}
				if m.OsImages[i0].DiskFormat != o.OsImages[i0].DiskFormat {
					fields[CloudletInfoFieldOsImagesDiskFormat] = struct{}{}
					fields[CloudletInfoFieldOsImages] = struct{}{}
				}
			}
		}
	} else if (m.OsImages != nil && o.OsImages == nil) || (m.OsImages == nil && o.OsImages != nil) {
		fields[CloudletInfoFieldOsImages] = struct{}{}
	}
	if m.ControllerCacheReceived != o.ControllerCacheReceived {
		fields[CloudletInfoFieldControllerCacheReceived] = struct{}{}
	}
	if m.MaintenanceState != o.MaintenanceState {
		fields[CloudletInfoFieldMaintenanceState] = struct{}{}
	}
	if len(m.ResourcesSnapshot.PlatformVms) != len(o.ResourcesSnapshot.PlatformVms) {
		fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
		fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
	} else {
		for i1 := 0; i1 < len(m.ResourcesSnapshot.PlatformVms); i1++ {
			if m.ResourcesSnapshot.PlatformVms[i1].Name != o.ResourcesSnapshot.PlatformVms[i1].Name {
				fields[CloudletInfoFieldResourcesSnapshotPlatformVmsName] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.PlatformVms[i1].Type != o.ResourcesSnapshot.PlatformVms[i1].Type {
				fields[CloudletInfoFieldResourcesSnapshotPlatformVmsType] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.PlatformVms[i1].Status != o.ResourcesSnapshot.PlatformVms[i1].Status {
				fields[CloudletInfoFieldResourcesSnapshotPlatformVmsStatus] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.PlatformVms[i1].InfraFlavor != o.ResourcesSnapshot.PlatformVms[i1].InfraFlavor {
				fields[CloudletInfoFieldResourcesSnapshotPlatformVmsInfraFlavor] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if len(m.ResourcesSnapshot.PlatformVms[i1].Ipaddresses) != len(o.ResourcesSnapshot.PlatformVms[i1].Ipaddresses) {
				fields[CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddresses] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			} else {
				for i2 := 0; i2 < len(m.ResourcesSnapshot.PlatformVms[i1].Ipaddresses); i2++ {
					if m.ResourcesSnapshot.PlatformVms[i1].Ipaddresses[i2].ExternalIp != o.ResourcesSnapshot.PlatformVms[i1].Ipaddresses[i2].ExternalIp {
						fields[CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddressesExternalIp] = struct{}{}
						fields[CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddresses] = struct{}{}
						fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
						fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
					}
					if m.ResourcesSnapshot.PlatformVms[i1].Ipaddresses[i2].InternalIp != o.ResourcesSnapshot.PlatformVms[i1].Ipaddresses[i2].InternalIp {
						fields[CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddressesInternalIp] = struct{}{}
						fields[CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddresses] = struct{}{}
						fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
						fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
					}
				}
			}
			if m.ResourcesSnapshot.PlatformVms[i1].Containers != nil && o.ResourcesSnapshot.PlatformVms[i1].Containers != nil {
				if len(m.ResourcesSnapshot.PlatformVms[i1].Containers) != len(o.ResourcesSnapshot.PlatformVms[i1].Containers) {
					fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainers] = struct{}{}
					fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
					fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
				} else {
					for i2 := 0; i2 < len(m.ResourcesSnapshot.PlatformVms[i1].Containers); i2++ {
						if m.ResourcesSnapshot.PlatformVms[i1].Containers[i2].Name != o.ResourcesSnapshot.PlatformVms[i1].Containers[i2].Name {
							fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainersName] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainers] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
						}
						if m.ResourcesSnapshot.PlatformVms[i1].Containers[i2].Type != o.ResourcesSnapshot.PlatformVms[i1].Containers[i2].Type {
							fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainersType] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainers] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
						}
						if m.ResourcesSnapshot.PlatformVms[i1].Containers[i2].Status != o.ResourcesSnapshot.PlatformVms[i1].Containers[i2].Status {
							fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainersStatus] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainers] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
						}
						if m.ResourcesSnapshot.PlatformVms[i1].Containers[i2].Clusterip != o.ResourcesSnapshot.PlatformVms[i1].Containers[i2].Clusterip {
							fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainersClusterip] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainers] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
						}
						if m.ResourcesSnapshot.PlatformVms[i1].Containers[i2].Restarts != o.ResourcesSnapshot.PlatformVms[i1].Containers[i2].Restarts {
							fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainersRestarts] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainers] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
						}
					}
				}
			} else if (m.ResourcesSnapshot.PlatformVms[i1].Containers != nil && o.ResourcesSnapshot.PlatformVms[i1].Containers == nil) || (m.ResourcesSnapshot.PlatformVms[i1].Containers == nil && o.ResourcesSnapshot.PlatformVms[i1].Containers != nil) {
				fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainers] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
		}
	}
	if len(m.ResourcesSnapshot.Info) != len(o.ResourcesSnapshot.Info) {
		fields[CloudletInfoFieldResourcesSnapshotInfo] = struct{}{}
		fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
	} else {
		for i1 := 0; i1 < len(m.ResourcesSnapshot.Info); i1++ {
			if m.ResourcesSnapshot.Info[i1].Name != o.ResourcesSnapshot.Info[i1].Name {
				fields[CloudletInfoFieldResourcesSnapshotInfoName] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotInfo] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.Info[i1].Value != o.ResourcesSnapshot.Info[i1].Value {
				fields[CloudletInfoFieldResourcesSnapshotInfoValue] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotInfo] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.Info[i1].InfraMaxValue != o.ResourcesSnapshot.Info[i1].InfraMaxValue {
				fields[CloudletInfoFieldResourcesSnapshotInfoInfraMaxValue] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotInfo] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.Info[i1].QuotaMaxValue != o.ResourcesSnapshot.Info[i1].QuotaMaxValue {
				fields[CloudletInfoFieldResourcesSnapshotInfoQuotaMaxValue] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotInfo] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.Info[i1].Description != o.ResourcesSnapshot.Info[i1].Description {
				fields[CloudletInfoFieldResourcesSnapshotInfoDescription] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotInfo] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.Info[i1].Units != o.ResourcesSnapshot.Info[i1].Units {
				fields[CloudletInfoFieldResourcesSnapshotInfoUnits] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotInfo] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.Info[i1].AlertThreshold != o.ResourcesSnapshot.Info[i1].AlertThreshold {
				fields[CloudletInfoFieldResourcesSnapshotInfoAlertThreshold] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotInfo] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
		}
	}
	if len(m.ResourcesSnapshot.ClusterInsts) != len(o.ResourcesSnapshot.ClusterInsts) {
		fields[CloudletInfoFieldResourcesSnapshotClusterInsts] = struct{}{}
		fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
	} else {
		for i1 := 0; i1 < len(m.ResourcesSnapshot.ClusterInsts); i1++ {
			if m.ResourcesSnapshot.ClusterInsts[i1].ClusterKey.Name != o.ResourcesSnapshot.ClusterInsts[i1].ClusterKey.Name {
				fields[CloudletInfoFieldResourcesSnapshotClusterInstsClusterKeyName] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotClusterInstsClusterKey] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotClusterInsts] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.ClusterInsts[i1].Organization != o.ResourcesSnapshot.ClusterInsts[i1].Organization {
				fields[CloudletInfoFieldResourcesSnapshotClusterInstsOrganization] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotClusterInsts] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
		}
	}
	if len(m.ResourcesSnapshot.VmAppInsts) != len(o.ResourcesSnapshot.VmAppInsts) {
		fields[CloudletInfoFieldResourcesSnapshotVmAppInsts] = struct{}{}
		fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
	} else {
		for i1 := 0; i1 < len(m.ResourcesSnapshot.VmAppInsts); i1++ {
			if m.ResourcesSnapshot.VmAppInsts[i1].AppKey.Organization != o.ResourcesSnapshot.VmAppInsts[i1].AppKey.Organization {
				fields[CloudletInfoFieldResourcesSnapshotVmAppInstsAppKeyOrganization] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotVmAppInstsAppKey] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotVmAppInsts] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.VmAppInsts[i1].AppKey.Name != o.ResourcesSnapshot.VmAppInsts[i1].AppKey.Name {
				fields[CloudletInfoFieldResourcesSnapshotVmAppInstsAppKeyName] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotVmAppInstsAppKey] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotVmAppInsts] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.VmAppInsts[i1].AppKey.Version != o.ResourcesSnapshot.VmAppInsts[i1].AppKey.Version {
				fields[CloudletInfoFieldResourcesSnapshotVmAppInstsAppKeyVersion] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotVmAppInstsAppKey] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotVmAppInsts] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.VmAppInsts[i1].ClusterInstKey.ClusterKey.Name != o.ResourcesSnapshot.VmAppInsts[i1].ClusterInstKey.ClusterKey.Name {
				fields[CloudletInfoFieldResourcesSnapshotVmAppInstsClusterInstKeyClusterKeyName] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotVmAppInstsClusterInstKeyClusterKey] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotVmAppInstsClusterInstKey] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotVmAppInsts] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.VmAppInsts[i1].ClusterInstKey.Organization != o.ResourcesSnapshot.VmAppInsts[i1].ClusterInstKey.Organization {
				fields[CloudletInfoFieldResourcesSnapshotVmAppInstsClusterInstKeyOrganization] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotVmAppInstsClusterInstKey] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotVmAppInsts] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
		}
	}
	if m.TrustPolicyState != o.TrustPolicyState {
		fields[CloudletInfoFieldTrustPolicyState] = struct{}{}
	}
	if m.CompatibilityVersion != o.CompatibilityVersion {
		fields[CloudletInfoFieldCompatibilityVersion] = struct{}{}
	}
	if m.Properties != nil && o.Properties != nil {
		if len(m.Properties) != len(o.Properties) {
			fields[CloudletInfoFieldProperties] = struct{}{}
		} else {
			for k0, _ := range m.Properties {
				_, vok0 := o.Properties[k0]
				if !vok0 {
					fields[CloudletInfoFieldProperties] = struct{}{}
				} else {
					if m.Properties[k0] != o.Properties[k0] {
						fields[CloudletInfoFieldProperties] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.Properties != nil && o.Properties == nil) || (m.Properties == nil && o.Properties != nil) {
		fields[CloudletInfoFieldProperties] = struct{}{}
	}
	if m.NodeInfos != nil && o.NodeInfos != nil {
		if len(m.NodeInfos) != len(o.NodeInfos) {
			fields[CloudletInfoFieldNodeInfos] = struct{}{}
		} else {
			for i0 := 0; i0 < len(m.NodeInfos); i0++ {
				if m.NodeInfos[i0].Name != o.NodeInfos[i0].Name {
					fields[CloudletInfoFieldNodeInfosName] = struct{}{}
					fields[CloudletInfoFieldNodeInfos] = struct{}{}
				}
				if m.NodeInfos[i0].Allocatable != nil && o.NodeInfos[i0].Allocatable != nil {
					if len(m.NodeInfos[i0].Allocatable) != len(o.NodeInfos[i0].Allocatable) {
						fields[CloudletInfoFieldNodeInfosAllocatable] = struct{}{}
						fields[CloudletInfoFieldNodeInfos] = struct{}{}
					} else {
						for k1, _ := range m.NodeInfos[i0].Allocatable {
							_, vok1 := o.NodeInfos[i0].Allocatable[k1]
							if !vok1 {
								fields[CloudletInfoFieldNodeInfosAllocatable] = struct{}{}
								fields[CloudletInfoFieldNodeInfos] = struct{}{}
							} else {
								if m.NodeInfos[i0].Allocatable[k1].Whole != o.NodeInfos[i0].Allocatable[k1].Whole {
									fields[CloudletInfoFieldNodeInfosAllocatableValueWhole] = struct{}{}
									fields[CloudletInfoFieldNodeInfosAllocatableValue] = struct{}{}
									fields[CloudletInfoFieldNodeInfosAllocatable] = struct{}{}
									fields[CloudletInfoFieldNodeInfos] = struct{}{}
								}
								if m.NodeInfos[i0].Allocatable[k1].Nanos != o.NodeInfos[i0].Allocatable[k1].Nanos {
									fields[CloudletInfoFieldNodeInfosAllocatableValueNanos] = struct{}{}
									fields[CloudletInfoFieldNodeInfosAllocatableValue] = struct{}{}
									fields[CloudletInfoFieldNodeInfosAllocatable] = struct{}{}
									fields[CloudletInfoFieldNodeInfos] = struct{}{}
								}
							}
						}
					}
				} else if (m.NodeInfos[i0].Allocatable != nil && o.NodeInfos[i0].Allocatable == nil) || (m.NodeInfos[i0].Allocatable == nil && o.NodeInfos[i0].Allocatable != nil) {
					fields[CloudletInfoFieldNodeInfosAllocatable] = struct{}{}
					fields[CloudletInfoFieldNodeInfos] = struct{}{}
				}
				if m.NodeInfos[i0].Capacity != nil && o.NodeInfos[i0].Capacity != nil {
					if len(m.NodeInfos[i0].Capacity) != len(o.NodeInfos[i0].Capacity) {
						fields[CloudletInfoFieldNodeInfosCapacity] = struct{}{}
						fields[CloudletInfoFieldNodeInfos] = struct{}{}
					} else {
						for k1, _ := range m.NodeInfos[i0].Capacity {
							_, vok1 := o.NodeInfos[i0].Capacity[k1]
							if !vok1 {
								fields[CloudletInfoFieldNodeInfosCapacity] = struct{}{}
								fields[CloudletInfoFieldNodeInfos] = struct{}{}
							} else {
								if m.NodeInfos[i0].Capacity[k1].Whole != o.NodeInfos[i0].Capacity[k1].Whole {
									fields[CloudletInfoFieldNodeInfosCapacityValueWhole] = struct{}{}
									fields[CloudletInfoFieldNodeInfosCapacityValue] = struct{}{}
									fields[CloudletInfoFieldNodeInfosCapacity] = struct{}{}
									fields[CloudletInfoFieldNodeInfos] = struct{}{}
								}
								if m.NodeInfos[i0].Capacity[k1].Nanos != o.NodeInfos[i0].Capacity[k1].Nanos {
									fields[CloudletInfoFieldNodeInfosCapacityValueNanos] = struct{}{}
									fields[CloudletInfoFieldNodeInfosCapacityValue] = struct{}{}
									fields[CloudletInfoFieldNodeInfosCapacity] = struct{}{}
									fields[CloudletInfoFieldNodeInfos] = struct{}{}
								}
							}
						}
					}
				} else if (m.NodeInfos[i0].Capacity != nil && o.NodeInfos[i0].Capacity == nil) || (m.NodeInfos[i0].Capacity == nil && o.NodeInfos[i0].Capacity != nil) {
					fields[CloudletInfoFieldNodeInfosCapacity] = struct{}{}
					fields[CloudletInfoFieldNodeInfos] = struct{}{}
				}
			}
		}
	} else if (m.NodeInfos != nil && o.NodeInfos == nil) || (m.NodeInfos == nil && o.NodeInfos != nil) {
		fields[CloudletInfoFieldNodeInfos] = struct{}{}
	}
	if m.ActiveCrmInstance != o.ActiveCrmInstance {
		fields[CloudletInfoFieldActiveCrmInstance] = struct{}{}
	}
	if m.StandbyCrm != o.StandbyCrm {
		fields[CloudletInfoFieldStandbyCrm] = struct{}{}
	}
}

func (m *CloudletInfo) CopyInFields(src *CloudletInfo) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
		if _, set := fmap["2.2"]; set {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
		if _, set := fmap["2.3"]; set {
			if m.Key.FederatedOrganization != src.Key.FederatedOrganization {
				m.Key.FederatedOrganization = src.Key.FederatedOrganization
				changed++
			}
		}
	}
	if _, set := fmap["3"]; set {
		if m.State != src.State {
			m.State = src.State
			changed++
		}
	}
	if _, set := fmap["4"]; set {
		if m.NotifyId != src.NotifyId {
			m.NotifyId = src.NotifyId
			changed++
		}
	}
	if _, set := fmap["5"]; set {
		if m.Controller != src.Controller {
			m.Controller = src.Controller
			changed++
		}
	}
	if _, set := fmap["6"]; set {
		if m.OsMaxRam != src.OsMaxRam {
			m.OsMaxRam = src.OsMaxRam
			changed++
		}
	}
	if _, set := fmap["7"]; set {
		if m.OsMaxVcores != src.OsMaxVcores {
			m.OsMaxVcores = src.OsMaxVcores
			changed++
		}
	}
	if _, set := fmap["8"]; set {
		if m.OsMaxVolGb != src.OsMaxVolGb {
			m.OsMaxVolGb = src.OsMaxVolGb
			changed++
		}
	}
	if _, set := fmap["9"]; set {
		if src.Errors != nil {
			m.Errors = src.Errors
			changed++
		} else if m.Errors != nil {
			m.Errors = nil
			changed++
		}
	}
	if _, set := fmap["10"]; set {
		if src.Flavors != nil {
			m.Flavors = src.Flavors
			changed++
		} else if m.Flavors != nil {
			m.Flavors = nil
			changed++
		}
	}
	if _, set := fmap["11"]; set {
		if _, set := fmap["11.1"]; set {
			if m.Status.TaskNumber != src.Status.TaskNumber {
				m.Status.TaskNumber = src.Status.TaskNumber
				changed++
			}
		}
		if _, set := fmap["11.2"]; set {
			if m.Status.MaxTasks != src.Status.MaxTasks {
				m.Status.MaxTasks = src.Status.MaxTasks
				changed++
			}
		}
		if _, set := fmap["11.3"]; set {
			if m.Status.TaskName != src.Status.TaskName {
				m.Status.TaskName = src.Status.TaskName
				changed++
			}
		}
		if _, set := fmap["11.4"]; set {
			if m.Status.StepName != src.Status.StepName {
				m.Status.StepName = src.Status.StepName
				changed++
			}
		}
		if _, set := fmap["11.5"]; set {
			if m.Status.MsgCount != src.Status.MsgCount {
				m.Status.MsgCount = src.Status.MsgCount
				changed++
			}
		}
		if _, set := fmap["11.6"]; set {
			if src.Status.Msgs != nil {
				m.Status.Msgs = src.Status.Msgs
				changed++
			} else if m.Status.Msgs != nil {
				m.Status.Msgs = nil
				changed++
			}
		}
	}
	if _, set := fmap["12"]; set {
		if m.ContainerVersion != src.ContainerVersion {
			m.ContainerVersion = src.ContainerVersion
			changed++
		}
	}
	if _, set := fmap["13"]; set {
		if src.AvailabilityZones != nil {
			m.AvailabilityZones = src.AvailabilityZones
			changed++
		} else if m.AvailabilityZones != nil {
			m.AvailabilityZones = nil
			changed++
		}
	}
	if _, set := fmap["14"]; set {
		if src.OsImages != nil {
			m.OsImages = src.OsImages
			changed++
		} else if m.OsImages != nil {
			m.OsImages = nil
			changed++
		}
	}
	if _, set := fmap["15"]; set {
		if m.ControllerCacheReceived != src.ControllerCacheReceived {
			m.ControllerCacheReceived = src.ControllerCacheReceived
			changed++
		}
	}
	if _, set := fmap["16"]; set {
		if m.MaintenanceState != src.MaintenanceState {
			m.MaintenanceState = src.MaintenanceState
			changed++
		}
	}
	if _, set := fmap["17"]; set {
		if _, set := fmap["17.1"]; set {
			if src.ResourcesSnapshot.PlatformVms != nil {
				m.ResourcesSnapshot.PlatformVms = src.ResourcesSnapshot.PlatformVms
				changed++
			} else if m.ResourcesSnapshot.PlatformVms != nil {
				m.ResourcesSnapshot.PlatformVms = nil
				changed++
			}
		}
		if _, set := fmap["17.2"]; set {
			if src.ResourcesSnapshot.Info != nil {
				m.ResourcesSnapshot.Info = src.ResourcesSnapshot.Info
				changed++
			} else if m.ResourcesSnapshot.Info != nil {
				m.ResourcesSnapshot.Info = nil
				changed++
			}
		}
		if _, set := fmap["17.3"]; set {
			if src.ResourcesSnapshot.ClusterInsts != nil {
				m.ResourcesSnapshot.ClusterInsts = src.ResourcesSnapshot.ClusterInsts
				changed++
			} else if m.ResourcesSnapshot.ClusterInsts != nil {
				m.ResourcesSnapshot.ClusterInsts = nil
				changed++
			}
		}
		if _, set := fmap["17.4"]; set {
			if src.ResourcesSnapshot.VmAppInsts != nil {
				m.ResourcesSnapshot.VmAppInsts = src.ResourcesSnapshot.VmAppInsts
				changed++
			} else if m.ResourcesSnapshot.VmAppInsts != nil {
				m.ResourcesSnapshot.VmAppInsts = nil
				changed++
			}
		}
	}
	if _, set := fmap["18"]; set {
		if m.TrustPolicyState != src.TrustPolicyState {
			m.TrustPolicyState = src.TrustPolicyState
			changed++
		}
	}
	if _, set := fmap["19"]; set {
		if m.CompatibilityVersion != src.CompatibilityVersion {
			m.CompatibilityVersion = src.CompatibilityVersion
			changed++
		}
	}
	if _, set := fmap["20"]; set {
		if src.Properties != nil {
			m.Properties = make(map[string]string)
			for k0, _ := range src.Properties {
				m.Properties[k0] = src.Properties[k0]
				changed++
			}
		} else if m.Properties != nil {
			m.Properties = nil
			changed++
		}
	}
	if _, set := fmap["21"]; set {
		if src.NodeInfos != nil {
			m.NodeInfos = src.NodeInfos
			changed++
		} else if m.NodeInfos != nil {
			m.NodeInfos = nil
			changed++
		}
	}
	if _, set := fmap["22"]; set {
		if m.ActiveCrmInstance != src.ActiveCrmInstance {
			m.ActiveCrmInstance = src.ActiveCrmInstance
			changed++
		}
	}
	if _, set := fmap["23"]; set {
		if m.StandbyCrm != src.StandbyCrm {
			m.StandbyCrm = src.StandbyCrm
			changed++
		}
	}
	return changed
}

func (m *CloudletInfo) DeepCopyIn(src *CloudletInfo) {
	m.Key.DeepCopyIn(&src.Key)
	m.State = src.State
	m.NotifyId = src.NotifyId
	m.Controller = src.Controller
	m.OsMaxRam = src.OsMaxRam
	m.OsMaxVcores = src.OsMaxVcores
	m.OsMaxVolGb = src.OsMaxVolGb
	if src.Errors != nil {
		m.Errors = make([]string, len(src.Errors), len(src.Errors))
		for ii, s := range src.Errors {
			m.Errors[ii] = s
		}
	} else {
		m.Errors = nil
	}
	if src.Flavors != nil {
		m.Flavors = make([]*FlavorInfo, len(src.Flavors), len(src.Flavors))
		for ii, s := range src.Flavors {
			var tmp_s FlavorInfo
			tmp_s.DeepCopyIn(s)
			m.Flavors[ii] = &tmp_s
		}
	} else {
		m.Flavors = nil
	}
	m.Status.DeepCopyIn(&src.Status)
	m.ContainerVersion = src.ContainerVersion
	if src.AvailabilityZones != nil {
		m.AvailabilityZones = make([]*OSAZone, len(src.AvailabilityZones), len(src.AvailabilityZones))
		for ii, s := range src.AvailabilityZones {
			var tmp_s OSAZone
			tmp_s.DeepCopyIn(s)
			m.AvailabilityZones[ii] = &tmp_s
		}
	} else {
		m.AvailabilityZones = nil
	}
	if src.OsImages != nil {
		m.OsImages = make([]*OSImage, len(src.OsImages), len(src.OsImages))
		for ii, s := range src.OsImages {
			var tmp_s OSImage
			tmp_s.DeepCopyIn(s)
			m.OsImages[ii] = &tmp_s
		}
	} else {
		m.OsImages = nil
	}
	m.ControllerCacheReceived = src.ControllerCacheReceived
	m.MaintenanceState = src.MaintenanceState
	m.ResourcesSnapshot.DeepCopyIn(&src.ResourcesSnapshot)
	m.TrustPolicyState = src.TrustPolicyState
	m.CompatibilityVersion = src.CompatibilityVersion
	if src.Properties != nil {
		m.Properties = make(map[string]string)
		for k, v := range src.Properties {
			m.Properties[k] = v
		}
	} else {
		m.Properties = nil
	}
	if src.NodeInfos != nil {
		m.NodeInfos = make([]*NodeInfo, len(src.NodeInfos), len(src.NodeInfos))
		for ii, s := range src.NodeInfos {
			var tmp_s NodeInfo
			tmp_s.DeepCopyIn(s)
			m.NodeInfos[ii] = &tmp_s
		}
	} else {
		m.NodeInfos = nil
	}
	m.ActiveCrmInstance = src.ActiveCrmInstance
	m.StandbyCrm = src.StandbyCrm
}

func (s *CloudletInfo) HasFields() bool {
	return true
}

type CloudletInfoStore interface {
	Create(ctx context.Context, m *CloudletInfo, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *CloudletInfo, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *CloudletInfo, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *CloudletInfo, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*CloudletInfo, int64, error)
	Get(ctx context.Context, key *CloudletKey, buf *CloudletInfo) bool
	STMGet(stm concurrency.STM, key *CloudletKey, buf *CloudletInfo) bool
	STMPut(stm concurrency.STM, obj *CloudletInfo, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *CloudletKey)
}

type CloudletInfoStoreImpl struct {
	kvstore objstore.KVStore
}

func NewCloudletInfoStore(kvstore objstore.KVStore) *CloudletInfoStoreImpl {
	return &CloudletInfoStoreImpl{kvstore: kvstore}
}

func (s *CloudletInfoStoreImpl) Create(ctx context.Context, m *CloudletInfo, wait func(int64)) (*Result, error) {
	err := m.Validate(CloudletInfoAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("CloudletInfo", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletInfoStoreImpl) Update(ctx context.Context, m *CloudletInfo, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("CloudletInfo", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur CloudletInfo
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletInfoStoreImpl) Put(ctx context.Context, m *CloudletInfo, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(CloudletInfoAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("CloudletInfo", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletInfoStoreImpl) Delete(ctx context.Context, m *CloudletInfo, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("CloudletInfo", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletInfoStoreImpl) LoadOne(key string) (*CloudletInfo, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj CloudletInfo
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse CloudletInfo data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *CloudletInfoStoreImpl) Get(ctx context.Context, key *CloudletKey, buf *CloudletInfo) bool {
	keystr := objstore.DbKeyString("CloudletInfo", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *CloudletInfoStoreImpl) STMGet(stm concurrency.STM, key *CloudletKey, buf *CloudletInfo) bool {
	keystr := objstore.DbKeyString("CloudletInfo", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *CloudletInfoStoreImpl) parseGetData(val []byte, buf *CloudletInfo) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = CloudletInfo{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *CloudletInfoStoreImpl) STMPut(stm concurrency.STM, obj *CloudletInfo, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("CloudletInfo", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("CloudletInfo json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *CloudletInfoStoreImpl) STMDel(stm concurrency.STM, key *CloudletKey) {
	keystr := objstore.DbKeyString("CloudletInfo", key)
	stm.Del(keystr)
}

type CloudletInfoKeyWatcher struct {
	cb func(ctx context.Context)
}

type CloudletInfoCacheData struct {
	Obj    *CloudletInfo
	ModRev int64
}

// CloudletInfoCache caches CloudletInfo objects in memory in a hash table
// and keeps them in sync with the database.
type CloudletInfoCache struct {
	Objs          map[CloudletKey]*CloudletInfoCacheData
	Mux           util.Mutex
	List          map[CloudletKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *CloudletKey, old *CloudletInfo, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *CloudletInfo, new *CloudletInfo)
	DeletedCbs    []func(ctx context.Context, old *CloudletInfo)
	KeyWatchers   map[CloudletKey][]*CloudletInfoKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *CloudletKey)
	DeletedKeyCbs []func(ctx context.Context, key *CloudletKey)
}

func NewCloudletInfoCache() *CloudletInfoCache {
	cache := CloudletInfoCache{}
	InitCloudletInfoCache(&cache)
	return &cache
}

func InitCloudletInfoCache(cache *CloudletInfoCache) {
	cache.Objs = make(map[CloudletKey]*CloudletInfoCacheData)
	cache.KeyWatchers = make(map[CloudletKey][]*CloudletInfoKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *CloudletInfoCache) GetTypeString() string {
	return "CloudletInfo"
}

func (c *CloudletInfoCache) Get(key *CloudletKey, valbuf *CloudletInfo) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *CloudletInfoCache) GetWithRev(key *CloudletKey, valbuf *CloudletInfo, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *CloudletInfoCache) HasKey(key *CloudletKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *CloudletInfoCache) GetAllKeys(ctx context.Context, cb func(key *CloudletKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *CloudletInfoCache) Update(ctx context.Context, in *CloudletInfo, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *CloudletInfo) (*CloudletInfo, bool) {
		return in, true
	})
}

func (c *CloudletInfoCache) UpdateModFunc(ctx context.Context, key *CloudletKey, modRev int64, modFunc func(old *CloudletInfo) (new *CloudletInfo, changed bool)) {
	c.Mux.Lock()
	var old *CloudletInfo
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	for _, cb := range c.UpdatedCbs {
		newCopy := &CloudletInfo{}
		newCopy.DeepCopyIn(new)
		defer cb(ctx, old, newCopy)
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			defer cb(ctx, new.GetKey(), old, modRev)
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &CloudletInfo{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &CloudletInfoCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *CloudletInfoCache) Delete(ctx context.Context, in *CloudletInfo, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *CloudletInfo) bool {
		return true
	})
}

func (c *CloudletInfoCache) DeleteCondFunc(ctx context.Context, in *CloudletInfo, modRev int64, condFunc func(old *CloudletInfo) bool) {
	c.Mux.Lock()
	var old *CloudletInfo
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	c.Mux.Unlock()
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, in.GetKey(), old, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *CloudletInfoCache) Prune(ctx context.Context, validKeys map[CloudletKey]struct{}) {
	notify := make(map[CloudletKey]*CloudletInfoCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, old.Obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *CloudletInfoCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *CloudletInfoCache) Flush(ctx context.Context, notifyId int64) {
	log.SpanLog(ctx, log.DebugLevelApi, "CacheFlush CloudletInfo", "notifyId", notifyId, "FlushAll", c.FlushAll)
	flushed := make(map[CloudletKey]*CloudletInfoCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if !c.FlushAll && val.Obj.NotifyId != notifyId {
			continue
		}
		flushed[key] = c.Objs[key]
		log.SpanLog(ctx, log.DebugLevelApi, "CacheFlush CloudletInfo delete", "key", key)
		delete(c.Objs, key)
	}
	c.Mux.Unlock()
	if len(flushed) > 0 {
		for key, old := range flushed {
			for _, cb := range c.NotifyCbs {
				if cb != nil {
					cb(ctx, &key, old.Obj, old.ModRev)
				}
			}
			for _, cb := range c.DeletedKeyCbs {
				cb(ctx, &key)
			}
			if old.Obj != nil {
				for _, cb := range c.DeletedCbs {
					cb(ctx, old.Obj)
				}
			}
			c.TriggerKeyWatchers(ctx, &key)
		}
	}
}

func (c *CloudletInfoCache) Show(filter *CloudletInfo, cb func(ret *CloudletInfo) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func CloudletInfoGenericNotifyCb(fn func(key *CloudletKey, old *CloudletInfo)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*CloudletKey), obj.(*CloudletInfo))
	}
}

func (c *CloudletInfoCache) SetNotifyCb(fn func(ctx context.Context, obj *CloudletKey, old *CloudletInfo, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *CloudletKey, old *CloudletInfo, modRev int64){fn}
}

func (c *CloudletInfoCache) SetUpdatedCb(fn func(ctx context.Context, old *CloudletInfo, new *CloudletInfo)) {
	c.UpdatedCbs = []func(ctx context.Context, old *CloudletInfo, new *CloudletInfo){fn}
}

func (c *CloudletInfoCache) SetDeletedCb(fn func(ctx context.Context, old *CloudletInfo)) {
	c.DeletedCbs = []func(ctx context.Context, old *CloudletInfo){fn}
}

func (c *CloudletInfoCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *CloudletKey){fn}
}

func (c *CloudletInfoCache) SetDeletedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *CloudletKey){fn}
}

func (c *CloudletInfoCache) AddUpdatedCb(fn func(ctx context.Context, old *CloudletInfo, new *CloudletInfo)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *CloudletInfoCache) AddDeletedCb(fn func(ctx context.Context, old *CloudletInfo)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *CloudletInfoCache) AddNotifyCb(fn func(ctx context.Context, obj *CloudletKey, old *CloudletInfo, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *CloudletInfoCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *CloudletInfoCache) AddDeletedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *CloudletInfoCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *CloudletInfoCache) WatchKey(key *CloudletKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*CloudletInfoKeyWatcher, 0)
	}
	watcher := CloudletInfoKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching CloudletInfo", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *CloudletInfoCache) TriggerKeyWatchers(ctx context.Context, key *CloudletKey) {
	watchers := make([]*CloudletInfoKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *CloudletInfoCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := CloudletInfo{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse CloudletInfo data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *CloudletInfoCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := CloudletInfo{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	CloudletKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *CloudletInfoCache) SyncListStart(ctx context.Context) {
	c.List = make(map[CloudletKey]struct{})
}

func (c *CloudletInfoCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[CloudletKey]*CloudletInfoCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, val.Obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *CloudletInfoCache) UsesOrg(org string) bool {
	return false
}

func (m *CloudletInfo) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *CloudletInfo) GetKey() *CloudletKey {
	return &m.Key
}

func (m *CloudletInfo) GetKeyVal() CloudletKey {
	return m.Key
}

func (m *CloudletInfo) SetKey(key *CloudletKey) {
	m.Key = *key
}

func CmpSortCloudletInfo(a CloudletInfo, b CloudletInfo) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *CloudletInfo) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := distributed_match_engine.CloudletState_name[int32(m.State)]; !ok {
		return errors.New("invalid State")
	}
	for _, e := range m.Flavors {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if err := m.Status.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.AvailabilityZones {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.OsImages {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if _, ok := distributed_match_engine.MaintenanceState_name[int32(m.MaintenanceState)]; !ok {
		return errors.New("invalid MaintenanceState")
	}
	if err := m.ResourcesSnapshot.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := TrackedState_name[int32(m.TrustPolicyState)]; !ok {
		return errors.New("invalid TrustPolicyState")
	}
	for _, e := range m.NodeInfos {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *CloudletInfo) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	if _, found := tags["nocmp"]; found {
		s.NotifyId = 0
	}
	if _, found := tags["nocmp"]; found {
		s.Controller = ""
	}
	if s.Flavors != nil {
		for ii := 0; ii < len(s.Flavors); ii++ {
			s.Flavors[ii].ClearTagged(tags)
		}
	}
	if _, found := tags["nocmp"]; found {
		s.Status = StatusInfo{}
	}
	if s.AvailabilityZones != nil {
		for ii := 0; ii < len(s.AvailabilityZones); ii++ {
			s.AvailabilityZones[ii].ClearTagged(tags)
		}
	}
	if s.OsImages != nil {
		for ii := 0; ii < len(s.OsImages); ii++ {
			s.OsImages[ii].ClearTagged(tags)
		}
	}
	s.ResourcesSnapshot.ClearTagged(tags)
	if _, found := tags["nocmp"]; found {
		s.CompatibilityVersion = 0
	}
	if s.NodeInfos != nil {
		for ii := 0; ii < len(s.NodeInfos); ii++ {
			s.NodeInfos[ii].ClearTagged(tags)
		}
	}
}

func IgnoreCloudletInfoFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "NotifyId")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Controller")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Status")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "CompatibilityVersion")
	}
	return cmpopts.IgnoreFields(CloudletInfo{}, names...)
}

func (m *CloudletMetrics) CopyInFields(src *CloudletMetrics) int {
	changed := 0
	if m.Foo != src.Foo {
		m.Foo = src.Foo
		changed++
	}
	return changed
}

func (m *CloudletMetrics) DeepCopyIn(src *CloudletMetrics) {
	m.Foo = src.Foo
}

// Helper method to check that enums have valid values
func (m *CloudletMetrics) ValidateEnums() error {
	return nil
}

func (s *CloudletMetrics) ClearTagged(tags map[string]struct{}) {
}

var PlatformTypeStrings = []string{
	"PLATFORM_TYPE_FAKE",
	"PLATFORM_TYPE_DIND",
	"PLATFORM_TYPE_OPENSTACK",
	"PLATFORM_TYPE_AZURE",
	"PLATFORM_TYPE_GCP",
	"PLATFORM_TYPE_EDGEBOX",
	"PLATFORM_TYPE_FAKEINFRA",
	"PLATFORM_TYPE_VSPHERE",
	"PLATFORM_TYPE_AWS_EKS",
	"PLATFORM_TYPE_VM_POOL",
	"PLATFORM_TYPE_AWS_EC2",
	"PLATFORM_TYPE_VCD",
	"PLATFORM_TYPE_K8S_BARE_METAL",
	"PLATFORM_TYPE_KIND",
	"PLATFORM_TYPE_KINDINFRA",
	"PLATFORM_TYPE_FAKE_SINGLE_CLUSTER",
	"PLATFORM_TYPE_FEDERATION",
	"PLATFORM_TYPE_FAKE_VM_POOL",
}

const (
	PlatformTypePLATFORM_TYPE_FAKE                uint64 = 1 << 0
	PlatformTypePLATFORM_TYPE_DIND                uint64 = 1 << 1
	PlatformTypePLATFORM_TYPE_OPENSTACK           uint64 = 1 << 2
	PlatformTypePLATFORM_TYPE_AZURE               uint64 = 1 << 3
	PlatformTypePLATFORM_TYPE_GCP                 uint64 = 1 << 4
	PlatformTypePLATFORM_TYPE_EDGEBOX             uint64 = 1 << 5
	PlatformTypePLATFORM_TYPE_FAKEINFRA           uint64 = 1 << 6
	PlatformTypePLATFORM_TYPE_VSPHERE             uint64 = 1 << 7
	PlatformTypePLATFORM_TYPE_AWS_EKS             uint64 = 1 << 8
	PlatformTypePLATFORM_TYPE_VM_POOL             uint64 = 1 << 9
	PlatformTypePLATFORM_TYPE_AWS_EC2             uint64 = 1 << 10
	PlatformTypePLATFORM_TYPE_VCD                 uint64 = 1 << 11
	PlatformTypePLATFORM_TYPE_K8S_BARE_METAL      uint64 = 1 << 12
	PlatformTypePLATFORM_TYPE_KIND                uint64 = 1 << 13
	PlatformTypePLATFORM_TYPE_KINDINFRA           uint64 = 1 << 14
	PlatformTypePLATFORM_TYPE_FAKE_SINGLE_CLUSTER uint64 = 1 << 15
	PlatformTypePLATFORM_TYPE_FEDERATION          uint64 = 1 << 16
	PlatformTypePLATFORM_TYPE_FAKE_VM_POOL        uint64 = 1 << 17
)

var PlatformType_CamelName = map[int32]string{
	// PLATFORM_TYPE_FAKE -> PlatformTypeFake
	0: "PlatformTypeFake",
	// PLATFORM_TYPE_DIND -> PlatformTypeDind
	1: "PlatformTypeDind",
	// PLATFORM_TYPE_OPENSTACK -> PlatformTypeOpenstack
	2: "PlatformTypeOpenstack",
	// PLATFORM_TYPE_AZURE -> PlatformTypeAzure
	3: "PlatformTypeAzure",
	// PLATFORM_TYPE_GCP -> PlatformTypeGcp
	4: "PlatformTypeGcp",
	// PLATFORM_TYPE_EDGEBOX -> PlatformTypeEdgebox
	5: "PlatformTypeEdgebox",
	// PLATFORM_TYPE_FAKEINFRA -> PlatformTypeFakeinfra
	6: "PlatformTypeFakeinfra",
	// PLATFORM_TYPE_VSPHERE -> PlatformTypeVsphere
	7: "PlatformTypeVsphere",
	// PLATFORM_TYPE_AWS_EKS -> PlatformTypeAwsEks
	8: "PlatformTypeAwsEks",
	// PLATFORM_TYPE_VM_POOL -> PlatformTypeVmPool
	9: "PlatformTypeVmPool",
	// PLATFORM_TYPE_AWS_EC2 -> PlatformTypeAwsEc2
	10: "PlatformTypeAwsEc2",
	// PLATFORM_TYPE_VCD -> PlatformTypeVcd
	11: "PlatformTypeVcd",
	// PLATFORM_TYPE_K8S_BARE_METAL -> PlatformTypeK8SBareMetal
	12: "PlatformTypeK8SBareMetal",
	// PLATFORM_TYPE_KIND -> PlatformTypeKind
	13: "PlatformTypeKind",
	// PLATFORM_TYPE_KINDINFRA -> PlatformTypeKindinfra
	14: "PlatformTypeKindinfra",
	// PLATFORM_TYPE_FAKE_SINGLE_CLUSTER -> PlatformTypeFakeSingleCluster
	15: "PlatformTypeFakeSingleCluster",
	// PLATFORM_TYPE_FEDERATION -> PlatformTypeFederation
	16: "PlatformTypeFederation",
	// PLATFORM_TYPE_FAKE_VM_POOL -> PlatformTypeFakeVmPool
	17: "PlatformTypeFakeVmPool",
}
var PlatformType_CamelValue = map[string]int32{
	"PlatformTypeFake":              0,
	"PlatformTypeDind":              1,
	"PlatformTypeOpenstack":         2,
	"PlatformTypeAzure":             3,
	"PlatformTypeGcp":               4,
	"PlatformTypeEdgebox":           5,
	"PlatformTypeFakeinfra":         6,
	"PlatformTypeVsphere":           7,
	"PlatformTypeAwsEks":            8,
	"PlatformTypeVmPool":            9,
	"PlatformTypeAwsEc2":            10,
	"PlatformTypeVcd":               11,
	"PlatformTypeK8SBareMetal":      12,
	"PlatformTypeKind":              13,
	"PlatformTypeKindinfra":         14,
	"PlatformTypeFakeSingleCluster": 15,
	"PlatformTypeFederation":        16,
	"PlatformTypeFakeVmPool":        17,
}

func (e *PlatformType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := PlatformType_CamelValue[util.CamelCase(str)]
	if !ok {
		// may have omitted common prefix
		val, ok = PlatformType_CamelValue["PlatformType"+util.CamelCase(str)]
	}
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = PlatformType_CamelName[val]
		}
	}
	if !ok {
		return fmt.Errorf("Invalid PlatformType value %q", str)
	}
	*e = PlatformType(val)
	return nil
}

func (e PlatformType) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(PlatformType_CamelName, int32(e))
	str = strings.TrimPrefix(str, "PlatformType")
	return str, nil
}

// custom JSON encoding/decoding
func (e *PlatformType) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := PlatformType_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = PlatformType_CamelValue["PlatformType"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = PlatformType_CamelName[val]
			}
		}
		if !ok {
			return fmt.Errorf("Invalid PlatformType value %q", str)
		}
		*e = PlatformType(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		_, ok := PlatformType_CamelName[val]
		if !ok {
			return fmt.Errorf("Invalid PlatformType value %d", val)
		}
		*e = PlatformType(val)
		return nil
	}
	return fmt.Errorf("Invalid PlatformType value %v", b)
}

func (e PlatformType) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(PlatformType_CamelName, int32(e))
	str = strings.TrimPrefix(str, "PlatformType")
	return json.Marshal(str)
}

var PlatformTypeCommonPrefix = "PlatformType"

var InfraApiAccessStrings = []string{
	"DIRECT_ACCESS",
	"RESTRICTED_ACCESS",
}

const (
	InfraApiAccessDIRECT_ACCESS     uint64 = 1 << 0
	InfraApiAccessRESTRICTED_ACCESS uint64 = 1 << 1
)

var InfraApiAccess_CamelName = map[int32]string{
	// DIRECT_ACCESS -> DirectAccess
	0: "DirectAccess",
	// RESTRICTED_ACCESS -> RestrictedAccess
	1: "RestrictedAccess",
}
var InfraApiAccess_CamelValue = map[string]int32{
	"DirectAccess":     0,
	"RestrictedAccess": 1,
}

func (e *InfraApiAccess) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := InfraApiAccess_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = InfraApiAccess_CamelName[val]
		}
	}
	if !ok {
		return fmt.Errorf("Invalid InfraApiAccess value %q", str)
	}
	*e = InfraApiAccess(val)
	return nil
}

func (e InfraApiAccess) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(InfraApiAccess_CamelName, int32(e))
	return str, nil
}

// custom JSON encoding/decoding
func (e *InfraApiAccess) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := InfraApiAccess_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = InfraApiAccess_CamelName[val]
			}
		}
		if !ok {
			return fmt.Errorf("Invalid InfraApiAccess value %q", str)
		}
		*e = InfraApiAccess(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		_, ok := InfraApiAccess_CamelName[val]
		if !ok {
			return fmt.Errorf("Invalid InfraApiAccess value %d", val)
		}
		*e = InfraApiAccess(val)
		return nil
	}
	return fmt.Errorf("Invalid InfraApiAccess value %v", b)
}

func (e InfraApiAccess) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(InfraApiAccess_CamelName, int32(e))
	return json.Marshal(str)
}

var OSTypeStrings = []string{
	"LINUX",
	"WINDOWS",
	"OTHERS",
}

const (
	OSTypeLINUX   uint64 = 1 << 0
	OSTypeWINDOWS uint64 = 1 << 1
	OSTypeOTHERS  uint64 = 1 << 2
)

var OSType_CamelName = map[int32]string{
	// LINUX -> Linux
	0: "Linux",
	// WINDOWS -> Windows
	1: "Windows",
	// OTHERS -> Others
	20: "Others",
}
var OSType_CamelValue = map[string]int32{
	"Linux":   0,
	"Windows": 1,
	"Others":  20,
}

func (e *OSType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := OSType_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = OSType_CamelName[val]
		}
	}
	if !ok {
		return fmt.Errorf("Invalid OSType value %q", str)
	}
	*e = OSType(val)
	return nil
}

func (e OSType) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(OSType_CamelName, int32(e))
	return str, nil
}

// custom JSON encoding/decoding
func (e *OSType) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := OSType_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = OSType_CamelName[val]
			}
		}
		if !ok {
			return fmt.Errorf("Invalid OSType value %q", str)
		}
		*e = OSType(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		_, ok := OSType_CamelName[val]
		if !ok {
			return fmt.Errorf("Invalid OSType value %d", val)
		}
		*e = OSType(val)
		return nil
	}
	return fmt.Errorf("Invalid OSType value %v", b)
}

func (e OSType) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(OSType_CamelName, int32(e))
	return json.Marshal(str)
}

var ReportScheduleStrings = []string{
	"EveryWeek",
	"Every15Days",
	"Every30Days",
	"EveryMonth",
}

const (
	ReportScheduleEveryWeek   uint64 = 1 << 0
	ReportScheduleEvery15Days uint64 = 1 << 1
	ReportScheduleEvery30Days uint64 = 1 << 2
	ReportScheduleEveryMonth  uint64 = 1 << 3
)

var ReportSchedule_CamelName = map[int32]string{
	// EveryWeek -> EveryWeek
	0: "EveryWeek",
	// Every15Days -> Every15Days
	1: "Every15Days",
	// Every30Days -> Every30Days
	2: "Every30Days",
	// EveryMonth -> EveryMonth
	3: "EveryMonth",
}
var ReportSchedule_CamelValue = map[string]int32{
	"EveryWeek":   0,
	"Every15Days": 1,
	"Every30Days": 2,
	"EveryMonth":  3,
}

func (e *ReportSchedule) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := ReportSchedule_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = ReportSchedule_CamelName[val]
		}
	}
	if !ok {
		return fmt.Errorf("Invalid ReportSchedule value %q", str)
	}
	*e = ReportSchedule(val)
	return nil
}

func (e ReportSchedule) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(ReportSchedule_CamelName, int32(e))
	return str, nil
}

// custom JSON encoding/decoding
func (e *ReportSchedule) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := ReportSchedule_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = ReportSchedule_CamelName[val]
			}
		}
		if !ok {
			return fmt.Errorf("Invalid ReportSchedule value %q", str)
		}
		*e = ReportSchedule(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		_, ok := ReportSchedule_CamelName[val]
		if !ok {
			return fmt.Errorf("Invalid ReportSchedule value %d", val)
		}
		*e = ReportSchedule(val)
		return nil
	}
	return fmt.Errorf("Invalid ReportSchedule value %v", b)
}

func (e ReportSchedule) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(ReportSchedule_CamelName, int32(e))
	return json.Marshal(str)
}
func (m *GPUDriver) IsValidArgsForCreateGPUDriver() error {
	if m.LicenseConfigMd5Sum != "" {
		return fmt.Errorf("Invalid field specified: LicenseConfigMd5Sum, this field is only for internal use")
	}
	if m.State != "" {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	return nil
}

func (m *GPUDriver) IsValidArgsForDeleteGPUDriver() error {
	if m.LicenseConfigMd5Sum != "" {
		return fmt.Errorf("Invalid field specified: LicenseConfigMd5Sum, this field is only for internal use")
	}
	if m.State != "" {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	return nil
}

func (m *GPUDriver) IsValidArgsForUpdateGPUDriver() error {
	if m.Builds != nil {
		return fmt.Errorf("Invalid field specified: Builds, this field is only for internal use")
	}
	if m.LicenseConfigMd5Sum != "" {
		return fmt.Errorf("Invalid field specified: LicenseConfigMd5Sum, this field is only for internal use")
	}
	if m.State != "" {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.IgnoreState != false {
		return fmt.Errorf("Invalid field specified: IgnoreState, this field is only for internal use")
	}
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	return nil
}

func (m *GPUDriverBuildMember) IsValidArgsForAddGPUDriverBuild() error {
	return nil
}

func (m *GPUDriverBuildMember) IsValidArgsForRemoveGPUDriverBuild() error {
	if m.Build.DriverPath != "" {
		return fmt.Errorf("Invalid field specified: Build.DriverPath, this field is only for internal use")
	}
	if m.Build.OperatingSystem != 0 {
		return fmt.Errorf("Invalid field specified: Build.OperatingSystem, this field is only for internal use")
	}
	if m.Build.KernelVersion != "" {
		return fmt.Errorf("Invalid field specified: Build.KernelVersion, this field is only for internal use")
	}
	if m.Build.HypervisorInfo != "" {
		return fmt.Errorf("Invalid field specified: Build.HypervisorInfo, this field is only for internal use")
	}
	return nil
}

func (m *GPUDriverBuildMember) IsValidArgsForGetGPUDriverBuildURL() error {
	if m.Build.DriverPath != "" {
		return fmt.Errorf("Invalid field specified: Build.DriverPath, this field is only for internal use")
	}
	if m.Build.DriverPathCreds != "" {
		return fmt.Errorf("Invalid field specified: Build.DriverPathCreds, this field is only for internal use")
	}
	if m.Build.OperatingSystem != 0 {
		return fmt.Errorf("Invalid field specified: Build.OperatingSystem, this field is only for internal use")
	}
	if m.Build.KernelVersion != "" {
		return fmt.Errorf("Invalid field specified: Build.KernelVersion, this field is only for internal use")
	}
	if m.Build.HypervisorInfo != "" {
		return fmt.Errorf("Invalid field specified: Build.HypervisorInfo, this field is only for internal use")
	}
	if m.Build.Md5Sum != "" {
		return fmt.Errorf("Invalid field specified: Build.Md5Sum, this field is only for internal use")
	}
	return nil
}

func (m *Cloudlet) IsValidArgsForCreateCloudlet() error {
	if m.Errors != nil {
		return fmt.Errorf("Invalid field specified: Errors, this field is only for internal use")
	}
	if m.Status.TaskNumber != 0 {
		return fmt.Errorf("Invalid field specified: Status.TaskNumber, this field is only for internal use")
	}
	if m.Status.MaxTasks != 0 {
		return fmt.Errorf("Invalid field specified: Status.MaxTasks, this field is only for internal use")
	}
	if m.Status.TaskName != "" {
		return fmt.Errorf("Invalid field specified: Status.TaskName, this field is only for internal use")
	}
	if m.Status.StepName != "" {
		return fmt.Errorf("Invalid field specified: Status.StepName, this field is only for internal use")
	}
	if m.Status.MsgCount != 0 {
		return fmt.Errorf("Invalid field specified: Status.MsgCount, this field is only for internal use")
	}
	if m.Status.Msgs != nil {
		return fmt.Errorf("Invalid field specified: Status.Msgs, this field is only for internal use")
	}
	if m.State != 0 {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.Config.ContainerRegistryPath != "" {
		return fmt.Errorf("Invalid field specified: Config.ContainerRegistryPath, this field is only for internal use")
	}
	if m.Config.CloudletVmImagePath != "" {
		return fmt.Errorf("Invalid field specified: Config.CloudletVmImagePath, this field is only for internal use")
	}
	if m.Config.NotifyCtrlAddrs != "" {
		return fmt.Errorf("Invalid field specified: Config.NotifyCtrlAddrs, this field is only for internal use")
	}
	if m.Config.TlsCertFile != "" {
		return fmt.Errorf("Invalid field specified: Config.TlsCertFile, this field is only for internal use")
	}
	if m.Config.EnvVar != nil {
		return fmt.Errorf("Invalid field specified: Config.EnvVar, this field is only for internal use")
	}
	if m.Config.PlatformTag != "" {
		return fmt.Errorf("Invalid field specified: Config.PlatformTag, this field is only for internal use")
	}
	if m.Config.TestMode != false {
		return fmt.Errorf("Invalid field specified: Config.TestMode, this field is only for internal use")
	}
	if m.Config.Span != "" {
		return fmt.Errorf("Invalid field specified: Config.Span, this field is only for internal use")
	}
	if m.Config.CleanupMode != false {
		return fmt.Errorf("Invalid field specified: Config.CleanupMode, this field is only for internal use")
	}
	if m.Config.Region != "" {
		return fmt.Errorf("Invalid field specified: Config.Region, this field is only for internal use")
	}
	if m.Config.CommercialCerts != false {
		return fmt.Errorf("Invalid field specified: Config.CommercialCerts, this field is only for internal use")
	}
	if m.Config.UseVaultPki != false {
		return fmt.Errorf("Invalid field specified: Config.UseVaultPki, this field is only for internal use")
	}
	if m.Config.AppDnsRoot != "" {
		return fmt.Errorf("Invalid field specified: Config.AppDnsRoot, this field is only for internal use")
	}
	if m.Config.ChefServerPath != "" {
		return fmt.Errorf("Invalid field specified: Config.ChefServerPath, this field is only for internal use")
	}
	if m.Config.ChefClientInterval != 0 {
		return fmt.Errorf("Invalid field specified: Config.ChefClientInterval, this field is only for internal use")
	}
	if m.Config.DeploymentTag != "" {
		return fmt.Errorf("Invalid field specified: Config.DeploymentTag, this field is only for internal use")
	}
	if m.Config.TlsKeyFile != "" {
		return fmt.Errorf("Invalid field specified: Config.TlsKeyFile, this field is only for internal use")
	}
	if m.Config.TlsCaFile != "" {
		return fmt.Errorf("Invalid field specified: Config.TlsCaFile, this field is only for internal use")
	}
	if m.Config.CrmAccessPrivateKey != "" {
		return fmt.Errorf("Invalid field specified: Config.CrmAccessPrivateKey, this field is only for internal use")
	}
	if m.Config.AccessApiAddr != "" {
		return fmt.Errorf("Invalid field specified: Config.AccessApiAddr, this field is only for internal use")
	}
	if m.Config.CacheDir != "" {
		return fmt.Errorf("Invalid field specified: Config.CacheDir, this field is only for internal use")
	}
	if m.Config.SecondaryCrmAccessPrivateKey != "" {
		return fmt.Errorf("Invalid field specified: Config.SecondaryCrmAccessPrivateKey, this field is only for internal use")
	}
	if m.ResTagMap != nil {
		return fmt.Errorf("Invalid field specified: ResTagMap, this field is only for internal use")
	}
	if m.ChefClientKey != nil {
		return fmt.Errorf("Invalid field specified: ChefClientKey, this field is only for internal use")
	}
	if m.CrmAccessPublicKey != "" {
		return fmt.Errorf("Invalid field specified: CrmAccessPublicKey, this field is only for internal use")
	}
	if m.CrmAccessKeyUpgradeRequired != false {
		return fmt.Errorf("Invalid field specified: CrmAccessKeyUpgradeRequired, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	if m.TrustPolicyState != 0 {
		return fmt.Errorf("Invalid field specified: TrustPolicyState, this field is only for internal use")
	}
	if m.HostController != "" {
		return fmt.Errorf("Invalid field specified: HostController, this field is only for internal use")
	}
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	if m.SecondaryCrmAccessPublicKey != "" {
		return fmt.Errorf("Invalid field specified: SecondaryCrmAccessPublicKey, this field is only for internal use")
	}
	if m.SecondaryCrmAccessKeyUpgradeRequired != false {
		return fmt.Errorf("Invalid field specified: SecondaryCrmAccessKeyUpgradeRequired, this field is only for internal use")
	}
	if m.DnsLabel != "" {
		return fmt.Errorf("Invalid field specified: DnsLabel, this field is only for internal use")
	}
	if m.RootLbFqdn != "" {
		return fmt.Errorf("Invalid field specified: RootLbFqdn, this field is only for internal use")
	}
	return nil
}

func (m *Cloudlet) IsValidArgsForDeleteCloudlet() error {
	if m.Errors != nil {
		return fmt.Errorf("Invalid field specified: Errors, this field is only for internal use")
	}
	if m.Status.TaskNumber != 0 {
		return fmt.Errorf("Invalid field specified: Status.TaskNumber, this field is only for internal use")
	}
	if m.Status.MaxTasks != 0 {
		return fmt.Errorf("Invalid field specified: Status.MaxTasks, this field is only for internal use")
	}
	if m.Status.TaskName != "" {
		return fmt.Errorf("Invalid field specified: Status.TaskName, this field is only for internal use")
	}
	if m.Status.StepName != "" {
		return fmt.Errorf("Invalid field specified: Status.StepName, this field is only for internal use")
	}
	if m.Status.MsgCount != 0 {
		return fmt.Errorf("Invalid field specified: Status.MsgCount, this field is only for internal use")
	}
	if m.Status.Msgs != nil {
		return fmt.Errorf("Invalid field specified: Status.Msgs, this field is only for internal use")
	}
	if m.State != 0 {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.Config.ContainerRegistryPath != "" {
		return fmt.Errorf("Invalid field specified: Config.ContainerRegistryPath, this field is only for internal use")
	}
	if m.Config.CloudletVmImagePath != "" {
		return fmt.Errorf("Invalid field specified: Config.CloudletVmImagePath, this field is only for internal use")
	}
	if m.Config.NotifyCtrlAddrs != "" {
		return fmt.Errorf("Invalid field specified: Config.NotifyCtrlAddrs, this field is only for internal use")
	}
	if m.Config.TlsCertFile != "" {
		return fmt.Errorf("Invalid field specified: Config.TlsCertFile, this field is only for internal use")
	}
	if m.Config.EnvVar != nil {
		return fmt.Errorf("Invalid field specified: Config.EnvVar, this field is only for internal use")
	}
	if m.Config.PlatformTag != "" {
		return fmt.Errorf("Invalid field specified: Config.PlatformTag, this field is only for internal use")
	}
	if m.Config.TestMode != false {
		return fmt.Errorf("Invalid field specified: Config.TestMode, this field is only for internal use")
	}
	if m.Config.Span != "" {
		return fmt.Errorf("Invalid field specified: Config.Span, this field is only for internal use")
	}
	if m.Config.CleanupMode != false {
		return fmt.Errorf("Invalid field specified: Config.CleanupMode, this field is only for internal use")
	}
	if m.Config.Region != "" {
		return fmt.Errorf("Invalid field specified: Config.Region, this field is only for internal use")
	}
	if m.Config.CommercialCerts != false {
		return fmt.Errorf("Invalid field specified: Config.CommercialCerts, this field is only for internal use")
	}
	if m.Config.UseVaultPki != false {
		return fmt.Errorf("Invalid field specified: Config.UseVaultPki, this field is only for internal use")
	}
	if m.Config.AppDnsRoot != "" {
		return fmt.Errorf("Invalid field specified: Config.AppDnsRoot, this field is only for internal use")
	}
	if m.Config.ChefServerPath != "" {
		return fmt.Errorf("Invalid field specified: Config.ChefServerPath, this field is only for internal use")
	}
	if m.Config.ChefClientInterval != 0 {
		return fmt.Errorf("Invalid field specified: Config.ChefClientInterval, this field is only for internal use")
	}
	if m.Config.DeploymentTag != "" {
		return fmt.Errorf("Invalid field specified: Config.DeploymentTag, this field is only for internal use")
	}
	if m.Config.TlsKeyFile != "" {
		return fmt.Errorf("Invalid field specified: Config.TlsKeyFile, this field is only for internal use")
	}
	if m.Config.TlsCaFile != "" {
		return fmt.Errorf("Invalid field specified: Config.TlsCaFile, this field is only for internal use")
	}
	if m.Config.CrmAccessPrivateKey != "" {
		return fmt.Errorf("Invalid field specified: Config.CrmAccessPrivateKey, this field is only for internal use")
	}
	if m.Config.AccessApiAddr != "" {
		return fmt.Errorf("Invalid field specified: Config.AccessApiAddr, this field is only for internal use")
	}
	if m.Config.CacheDir != "" {
		return fmt.Errorf("Invalid field specified: Config.CacheDir, this field is only for internal use")
	}
	if m.Config.SecondaryCrmAccessPrivateKey != "" {
		return fmt.Errorf("Invalid field specified: Config.SecondaryCrmAccessPrivateKey, this field is only for internal use")
	}
	if m.ResTagMap != nil {
		return fmt.Errorf("Invalid field specified: ResTagMap, this field is only for internal use")
	}
	if m.ChefClientKey != nil {
		return fmt.Errorf("Invalid field specified: ChefClientKey, this field is only for internal use")
	}
	if m.CrmAccessPublicKey != "" {
		return fmt.Errorf("Invalid field specified: CrmAccessPublicKey, this field is only for internal use")
	}
	if m.CrmAccessKeyUpgradeRequired != false {
		return fmt.Errorf("Invalid field specified: CrmAccessKeyUpgradeRequired, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	if m.TrustPolicyState != 0 {
		return fmt.Errorf("Invalid field specified: TrustPolicyState, this field is only for internal use")
	}
	if m.HostController != "" {
		return fmt.Errorf("Invalid field specified: HostController, this field is only for internal use")
	}
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	if m.SecondaryCrmAccessPublicKey != "" {
		return fmt.Errorf("Invalid field specified: SecondaryCrmAccessPublicKey, this field is only for internal use")
	}
	if m.SecondaryCrmAccessKeyUpgradeRequired != false {
		return fmt.Errorf("Invalid field specified: SecondaryCrmAccessKeyUpgradeRequired, this field is only for internal use")
	}
	if m.DnsLabel != "" {
		return fmt.Errorf("Invalid field specified: DnsLabel, this field is only for internal use")
	}
	if m.RootLbFqdn != "" {
		return fmt.Errorf("Invalid field specified: RootLbFqdn, this field is only for internal use")
	}
	return nil
}

func (m *Cloudlet) IsValidArgsForUpdateCloudlet() error {
	if m.Errors != nil {
		return fmt.Errorf("Invalid field specified: Errors, this field is only for internal use")
	}
	if m.Status.TaskNumber != 0 {
		return fmt.Errorf("Invalid field specified: Status.TaskNumber, this field is only for internal use")
	}
	if m.Status.MaxTasks != 0 {
		return fmt.Errorf("Invalid field specified: Status.MaxTasks, this field is only for internal use")
	}
	if m.Status.TaskName != "" {
		return fmt.Errorf("Invalid field specified: Status.TaskName, this field is only for internal use")
	}
	if m.Status.StepName != "" {
		return fmt.Errorf("Invalid field specified: Status.StepName, this field is only for internal use")
	}
	if m.Status.MsgCount != 0 {
		return fmt.Errorf("Invalid field specified: Status.MsgCount, this field is only for internal use")
	}
	if m.Status.Msgs != nil {
		return fmt.Errorf("Invalid field specified: Status.Msgs, this field is only for internal use")
	}
	if m.State != 0 {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.DeploymentLocal != false {
		return fmt.Errorf("Invalid field specified: DeploymentLocal, this field is only for internal use")
	}
	if m.PlatformType != 0 {
		return fmt.Errorf("Invalid field specified: PlatformType, this field is only for internal use")
	}
	if m.Flavor.Name != "" {
		return fmt.Errorf("Invalid field specified: Flavor.Name, this field is only for internal use")
	}
	if m.PhysicalName != "" {
		return fmt.Errorf("Invalid field specified: PhysicalName, this field is only for internal use")
	}
	if m.ContainerVersion != "" {
		return fmt.Errorf("Invalid field specified: ContainerVersion, this field is only for internal use")
	}
	if m.Config.ContainerRegistryPath != "" {
		return fmt.Errorf("Invalid field specified: Config.ContainerRegistryPath, this field is only for internal use")
	}
	if m.Config.CloudletVmImagePath != "" {
		return fmt.Errorf("Invalid field specified: Config.CloudletVmImagePath, this field is only for internal use")
	}
	if m.Config.NotifyCtrlAddrs != "" {
		return fmt.Errorf("Invalid field specified: Config.NotifyCtrlAddrs, this field is only for internal use")
	}
	if m.Config.TlsCertFile != "" {
		return fmt.Errorf("Invalid field specified: Config.TlsCertFile, this field is only for internal use")
	}
	if m.Config.EnvVar != nil {
		return fmt.Errorf("Invalid field specified: Config.EnvVar, this field is only for internal use")
	}
	if m.Config.PlatformTag != "" {
		return fmt.Errorf("Invalid field specified: Config.PlatformTag, this field is only for internal use")
	}
	if m.Config.TestMode != false {
		return fmt.Errorf("Invalid field specified: Config.TestMode, this field is only for internal use")
	}
	if m.Config.Span != "" {
		return fmt.Errorf("Invalid field specified: Config.Span, this field is only for internal use")
	}
	if m.Config.CleanupMode != false {
		return fmt.Errorf("Invalid field specified: Config.CleanupMode, this field is only for internal use")
	}
	if m.Config.Region != "" {
		return fmt.Errorf("Invalid field specified: Config.Region, this field is only for internal use")
	}
	if m.Config.CommercialCerts != false {
		return fmt.Errorf("Invalid field specified: Config.CommercialCerts, this field is only for internal use")
	}
	if m.Config.UseVaultPki != false {
		return fmt.Errorf("Invalid field specified: Config.UseVaultPki, this field is only for internal use")
	}
	if m.Config.AppDnsRoot != "" {
		return fmt.Errorf("Invalid field specified: Config.AppDnsRoot, this field is only for internal use")
	}
	if m.Config.ChefServerPath != "" {
		return fmt.Errorf("Invalid field specified: Config.ChefServerPath, this field is only for internal use")
	}
	if m.Config.ChefClientInterval != 0 {
		return fmt.Errorf("Invalid field specified: Config.ChefClientInterval, this field is only for internal use")
	}
	if m.Config.DeploymentTag != "" {
		return fmt.Errorf("Invalid field specified: Config.DeploymentTag, this field is only for internal use")
	}
	if m.Config.TlsKeyFile != "" {
		return fmt.Errorf("Invalid field specified: Config.TlsKeyFile, this field is only for internal use")
	}
	if m.Config.TlsCaFile != "" {
		return fmt.Errorf("Invalid field specified: Config.TlsCaFile, this field is only for internal use")
	}
	if m.Config.CrmAccessPrivateKey != "" {
		return fmt.Errorf("Invalid field specified: Config.CrmAccessPrivateKey, this field is only for internal use")
	}
	if m.Config.AccessApiAddr != "" {
		return fmt.Errorf("Invalid field specified: Config.AccessApiAddr, this field is only for internal use")
	}
	if m.Config.CacheDir != "" {
		return fmt.Errorf("Invalid field specified: Config.CacheDir, this field is only for internal use")
	}
	if m.Config.SecondaryCrmAccessPrivateKey != "" {
		return fmt.Errorf("Invalid field specified: Config.SecondaryCrmAccessPrivateKey, this field is only for internal use")
	}
	if m.ResTagMap != nil {
		return fmt.Errorf("Invalid field specified: ResTagMap, this field is only for internal use")
	}
	if m.VmImageVersion != "" {
		return fmt.Errorf("Invalid field specified: VmImageVersion, this field is only for internal use")
	}
	if m.Deployment != "" {
		return fmt.Errorf("Invalid field specified: Deployment, this field is only for internal use")
	}
	if m.InfraApiAccess != 0 {
		return fmt.Errorf("Invalid field specified: InfraApiAccess, this field is only for internal use")
	}
	if m.InfraConfig.ExternalNetworkName != "" {
		return fmt.Errorf("Invalid field specified: InfraConfig.ExternalNetworkName, this field is only for internal use")
	}
	if m.InfraConfig.FlavorName != "" {
		return fmt.Errorf("Invalid field specified: InfraConfig.FlavorName, this field is only for internal use")
	}
	if m.ChefClientKey != nil {
		return fmt.Errorf("Invalid field specified: ChefClientKey, this field is only for internal use")
	}
	if m.OverridePolicyContainerVersion != false {
		return fmt.Errorf("Invalid field specified: OverridePolicyContainerVersion, this field is only for internal use")
	}
	if m.VmPool != "" {
		return fmt.Errorf("Invalid field specified: VmPool, this field is only for internal use")
	}
	if m.CrmAccessPublicKey != "" {
		return fmt.Errorf("Invalid field specified: CrmAccessPublicKey, this field is only for internal use")
	}
	if m.CrmAccessKeyUpgradeRequired != false {
		return fmt.Errorf("Invalid field specified: CrmAccessKeyUpgradeRequired, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	if m.TrustPolicyState != 0 {
		return fmt.Errorf("Invalid field specified: TrustPolicyState, this field is only for internal use")
	}
	if m.HostController != "" {
		return fmt.Errorf("Invalid field specified: HostController, this field is only for internal use")
	}
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	if m.SecondaryCrmAccessPublicKey != "" {
		return fmt.Errorf("Invalid field specified: SecondaryCrmAccessPublicKey, this field is only for internal use")
	}
	if m.SecondaryCrmAccessKeyUpgradeRequired != false {
		return fmt.Errorf("Invalid field specified: SecondaryCrmAccessKeyUpgradeRequired, this field is only for internal use")
	}
	if m.DnsLabel != "" {
		return fmt.Errorf("Invalid field specified: DnsLabel, this field is only for internal use")
	}
	if m.RootLbFqdn != "" {
		return fmt.Errorf("Invalid field specified: RootLbFqdn, this field is only for internal use")
	}
	return nil
}

func (m *CloudletKey) IsValidArgsForGetCloudletManifest() error {
	return nil
}

func (m *CloudletProps) IsValidArgsForGetCloudletProps() error {
	if m.Properties != nil {
		return fmt.Errorf("Invalid field specified: Properties, this field is only for internal use")
	}
	return nil
}

func (m *CloudletResourceQuotaProps) IsValidArgsForGetCloudletResourceQuotaProps() error {
	if m.Properties != nil {
		return fmt.Errorf("Invalid field specified: Properties, this field is only for internal use")
	}
	return nil
}

func (m *CloudletResourceUsage) IsValidArgsForGetCloudletResourceUsage() error {
	if m.Info != nil {
		return fmt.Errorf("Invalid field specified: Info, this field is only for internal use")
	}
	return nil
}

func (m *CloudletResMap) IsValidArgsForAddCloudletResMapping() error {
	return nil
}

func (m *CloudletResMap) IsValidArgsForRemoveCloudletResMapping() error {
	return nil
}

func (m *CloudletAllianceOrg) IsValidArgsForAddCloudletAllianceOrg() error {
	return nil
}

func (m *CloudletAllianceOrg) IsValidArgsForRemoveCloudletAllianceOrg() error {
	return nil
}

func (m *FlavorMatch) IsValidArgsForFindFlavorMatch() error {
	return nil
}

func (m *CloudletKey) IsValidArgsForShowFlavorsForCloudlet() error {
	return nil
}

func (m *CloudletKey) IsValidArgsForGetOrganizationsOnCloudlet() error {
	return nil
}

func (m *CloudletKey) IsValidArgsForRevokeAccessKey() error {
	return nil
}

func (m *CloudletKey) IsValidArgsForGenerateAccessKey() error {
	return nil
}

func (m *Cloudlet) IsValidArgsForPlatformDeleteCloudlet() error {
	if m.Errors != nil {
		return fmt.Errorf("Invalid field specified: Errors, this field is only for internal use")
	}
	if m.Status.TaskNumber != 0 {
		return fmt.Errorf("Invalid field specified: Status.TaskNumber, this field is only for internal use")
	}
	if m.Status.MaxTasks != 0 {
		return fmt.Errorf("Invalid field specified: Status.MaxTasks, this field is only for internal use")
	}
	if m.Status.TaskName != "" {
		return fmt.Errorf("Invalid field specified: Status.TaskName, this field is only for internal use")
	}
	if m.Status.StepName != "" {
		return fmt.Errorf("Invalid field specified: Status.StepName, this field is only for internal use")
	}
	if m.Status.MsgCount != 0 {
		return fmt.Errorf("Invalid field specified: Status.MsgCount, this field is only for internal use")
	}
	if m.Status.Msgs != nil {
		return fmt.Errorf("Invalid field specified: Status.Msgs, this field is only for internal use")
	}
	if m.State != 0 {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.Config.ContainerRegistryPath != "" {
		return fmt.Errorf("Invalid field specified: Config.ContainerRegistryPath, this field is only for internal use")
	}
	if m.Config.CloudletVmImagePath != "" {
		return fmt.Errorf("Invalid field specified: Config.CloudletVmImagePath, this field is only for internal use")
	}
	if m.Config.NotifyCtrlAddrs != "" {
		return fmt.Errorf("Invalid field specified: Config.NotifyCtrlAddrs, this field is only for internal use")
	}
	if m.Config.TlsCertFile != "" {
		return fmt.Errorf("Invalid field specified: Config.TlsCertFile, this field is only for internal use")
	}
	if m.Config.EnvVar != nil {
		return fmt.Errorf("Invalid field specified: Config.EnvVar, this field is only for internal use")
	}
	if m.Config.PlatformTag != "" {
		return fmt.Errorf("Invalid field specified: Config.PlatformTag, this field is only for internal use")
	}
	if m.Config.TestMode != false {
		return fmt.Errorf("Invalid field specified: Config.TestMode, this field is only for internal use")
	}
	if m.Config.Span != "" {
		return fmt.Errorf("Invalid field specified: Config.Span, this field is only for internal use")
	}
	if m.Config.CleanupMode != false {
		return fmt.Errorf("Invalid field specified: Config.CleanupMode, this field is only for internal use")
	}
	if m.Config.Region != "" {
		return fmt.Errorf("Invalid field specified: Config.Region, this field is only for internal use")
	}
	if m.Config.CommercialCerts != false {
		return fmt.Errorf("Invalid field specified: Config.CommercialCerts, this field is only for internal use")
	}
	if m.Config.UseVaultPki != false {
		return fmt.Errorf("Invalid field specified: Config.UseVaultPki, this field is only for internal use")
	}
	if m.Config.AppDnsRoot != "" {
		return fmt.Errorf("Invalid field specified: Config.AppDnsRoot, this field is only for internal use")
	}
	if m.Config.ChefServerPath != "" {
		return fmt.Errorf("Invalid field specified: Config.ChefServerPath, this field is only for internal use")
	}
	if m.Config.ChefClientInterval != 0 {
		return fmt.Errorf("Invalid field specified: Config.ChefClientInterval, this field is only for internal use")
	}
	if m.Config.DeploymentTag != "" {
		return fmt.Errorf("Invalid field specified: Config.DeploymentTag, this field is only for internal use")
	}
	if m.Config.TlsKeyFile != "" {
		return fmt.Errorf("Invalid field specified: Config.TlsKeyFile, this field is only for internal use")
	}
	if m.Config.TlsCaFile != "" {
		return fmt.Errorf("Invalid field specified: Config.TlsCaFile, this field is only for internal use")
	}
	if m.Config.CrmAccessPrivateKey != "" {
		return fmt.Errorf("Invalid field specified: Config.CrmAccessPrivateKey, this field is only for internal use")
	}
	if m.Config.AccessApiAddr != "" {
		return fmt.Errorf("Invalid field specified: Config.AccessApiAddr, this field is only for internal use")
	}
	if m.Config.CacheDir != "" {
		return fmt.Errorf("Invalid field specified: Config.CacheDir, this field is only for internal use")
	}
	if m.Config.SecondaryCrmAccessPrivateKey != "" {
		return fmt.Errorf("Invalid field specified: Config.SecondaryCrmAccessPrivateKey, this field is only for internal use")
	}
	if m.ChefClientKey != nil {
		return fmt.Errorf("Invalid field specified: ChefClientKey, this field is only for internal use")
	}
	if m.CrmAccessPublicKey != "" {
		return fmt.Errorf("Invalid field specified: CrmAccessPublicKey, this field is only for internal use")
	}
	if m.CrmAccessKeyUpgradeRequired != false {
		return fmt.Errorf("Invalid field specified: CrmAccessKeyUpgradeRequired, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	if m.TrustPolicyState != 0 {
		return fmt.Errorf("Invalid field specified: TrustPolicyState, this field is only for internal use")
	}
	if m.HostController != "" {
		return fmt.Errorf("Invalid field specified: HostController, this field is only for internal use")
	}
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	if m.SecondaryCrmAccessPublicKey != "" {
		return fmt.Errorf("Invalid field specified: SecondaryCrmAccessPublicKey, this field is only for internal use")
	}
	if m.SecondaryCrmAccessKeyUpgradeRequired != false {
		return fmt.Errorf("Invalid field specified: SecondaryCrmAccessKeyUpgradeRequired, this field is only for internal use")
	}
	if m.DnsLabel != "" {
		return fmt.Errorf("Invalid field specified: DnsLabel, this field is only for internal use")
	}
	if m.RootLbFqdn != "" {
		return fmt.Errorf("Invalid field specified: RootLbFqdn, this field is only for internal use")
	}
	return nil
}

func (m *CloudletInfo) IsValidArgsForInjectCloudletInfo() error {
	return nil
}

func (m *CloudletInfo) IsValidArgsForEvictCloudletInfo() error {
	return nil
}

func (m *OperationTimeLimits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateClusterInstTimeout != 0 {
		n += 1 + sovCloudlet(uint64(m.CreateClusterInstTimeout))
	}
	if m.UpdateClusterInstTimeout != 0 {
		n += 1 + sovCloudlet(uint64(m.UpdateClusterInstTimeout))
	}
	if m.DeleteClusterInstTimeout != 0 {
		n += 1 + sovCloudlet(uint64(m.DeleteClusterInstTimeout))
	}
	if m.CreateAppInstTimeout != 0 {
		n += 1 + sovCloudlet(uint64(m.CreateAppInstTimeout))
	}
	if m.UpdateAppInstTimeout != 0 {
		n += 1 + sovCloudlet(uint64(m.UpdateAppInstTimeout))
	}
	if m.DeleteAppInstTimeout != 0 {
		n += 1 + sovCloudlet(uint64(m.DeleteAppInstTimeout))
	}
	return n
}

func (m *CloudletInternal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if len(m.Props) > 0 {
		for k, v := range m.Props {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 1 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PlatformConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContainerRegistryPath)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.CloudletVmImagePath)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.NotifyCtrlAddrs)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.TlsCertFile)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if len(m.EnvVar) > 0 {
		for k, v := range m.EnvVar {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 1 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	l = len(m.PlatformTag)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.TestMode {
		n += 2
	}
	l = len(m.Span)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.CleanupMode {
		n += 2
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.CommercialCerts {
		n += 2
	}
	if m.UseVaultPki {
		n += 2
	}
	l = len(m.AppDnsRoot)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.ChefServerPath)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	if m.ChefClientInterval != 0 {
		n += 2 + sovCloudlet(uint64(m.ChefClientInterval))
	}
	l = len(m.DeploymentTag)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.TlsKeyFile)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.TlsCaFile)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.CrmAccessPrivateKey)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.AccessApiAddr)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.CacheDir)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.SecondaryCrmAccessPrivateKey)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *CloudletResMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if len(m.Mapping) > 0 {
		for k, v := range m.Mapping {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 1 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *InfraConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExternalNetworkName)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.FlavorName)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *ResourceQuota) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovCloudlet(uint64(m.Value))
	}
	if m.AlertThreshold != 0 {
		n += 1 + sovCloudlet(uint64(m.AlertThreshold))
	}
	return n
}

func (m *GPUDriverKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *GPUDriverBuild) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.DriverPath)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.DriverPathCreds)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.OperatingSystem != 0 {
		n += 1 + sovCloudlet(uint64(m.OperatingSystem))
	}
	l = len(m.KernelVersion)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.HypervisorInfo)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Md5Sum)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *GPUDriverBuildMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	l = m.Build.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if m.IgnoreState {
		n += 2
	}
	return n
}

func (m *GPUDriverBuildURL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BuildUrlPath)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.Validity != 0 {
		n += 1 + sovCloudlet(uint64(m.Validity))
	}
	return n
}

func (m *GPUDriver) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if len(m.Builds) > 0 {
		for _, e := range m.Builds {
			l = e.Size()
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	l = len(m.LicenseConfig)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.LicenseConfigMd5Sum)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if len(m.Properties) > 0 {
		for k, v := range m.Properties {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 1 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.IgnoreState {
		n += 2
	}
	if m.DeletePrepare {
		n += 2
	}
	return n
}

func (m *GPUConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Driver.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if len(m.Properties) > 0 {
		for k, v := range m.Properties {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 1 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	l = len(m.LicenseConfig)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.LicenseConfigMd5Sum)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *Cloudlet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	l = m.Location.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if m.IpSupport != 0 {
		n += 1 + sovCloudlet(uint64(m.IpSupport))
	}
	l = len(m.StaticIps)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.NumDynamicIps != 0 {
		n += 1 + sovCloudlet(uint64(m.NumDynamicIps))
	}
	l = m.TimeLimits.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	l = m.Status.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if m.State != 0 {
		n += 1 + sovCloudlet(uint64(m.State))
	}
	if m.CrmOverride != 0 {
		n += 1 + sovCloudlet(uint64(m.CrmOverride))
	}
	if m.DeploymentLocal {
		n += 2
	}
	if m.PlatformType != 0 {
		n += 1 + sovCloudlet(uint64(m.PlatformType))
	}
	l = len(m.NotifySrvAddr)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = m.Flavor.Size()
	n += 2 + l + sovCloudlet(uint64(l))
	l = len(m.PhysicalName)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	if len(m.EnvVar) > 0 {
		for k, v := range m.EnvVar {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 2 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	l = len(m.ContainerVersion)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = m.Config.Size()
	n += 2 + l + sovCloudlet(uint64(l))
	if len(m.ResTagMap) > 0 {
		for k, v := range m.ResTagMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCloudlet(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	if len(m.AccessVars) > 0 {
		for k, v := range m.AccessVars {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 2 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	l = len(m.VmImageVersion)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Deployment)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	if m.InfraApiAccess != 0 {
		n += 2 + sovCloudlet(uint64(m.InfraApiAccess))
	}
	l = m.InfraConfig.Size()
	n += 2 + l + sovCloudlet(uint64(l))
	if len(m.ChefClientKey) > 0 {
		for k, v := range m.ChefClientKey {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 2 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	if m.MaintenanceState != 0 {
		n += 2 + sovCloudlet(uint64(m.MaintenanceState))
	}
	if m.OverridePolicyContainerVersion {
		n += 3
	}
	l = len(m.VmPool)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.CrmAccessPublicKey)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	if m.CrmAccessKeyUpgradeRequired {
		n += 3
	}
	l = m.CreatedAt.Size()
	n += 2 + l + sovCloudlet(uint64(l))
	l = m.UpdatedAt.Size()
	n += 2 + l + sovCloudlet(uint64(l))
	l = len(m.TrustPolicy)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	if m.TrustPolicyState != 0 {
		n += 2 + sovCloudlet(uint64(m.TrustPolicyState))
	}
	if len(m.ResourceQuotas) > 0 {
		for _, e := range m.ResourceQuotas {
			l = e.Size()
			n += 2 + l + sovCloudlet(uint64(l))
		}
	}
	if m.DefaultResourceAlertThreshold != 0 {
		n += 2 + sovCloudlet(uint64(m.DefaultResourceAlertThreshold))
	}
	l = len(m.HostController)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.KafkaCluster)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.KafkaUser)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.KafkaPassword)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = m.GpuConfig.Size()
	n += 2 + l + sovCloudlet(uint64(l))
	if m.EnableDefaultServerlessCluster {
		n += 3
	}
	if len(m.AllianceOrgs) > 0 {
		for _, s := range m.AllianceOrgs {
			l = len(s)
			n += 2 + l + sovCloudlet(uint64(l))
		}
	}
	l = len(m.SingleKubernetesClusterOwner)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	if m.DeletePrepare {
		n += 3
	}
	if m.PlatformHighAvailability {
		n += 3
	}
	l = len(m.SecondaryCrmAccessPublicKey)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	if m.SecondaryCrmAccessKeyUpgradeRequired {
		n += 3
	}
	l = len(m.SecondaryNotifySrvAddr)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.DnsLabel)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.RootLbFqdn)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *FlavorMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	l = len(m.FlavorName)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.AvailabilityZone)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *CloudletManifest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Manifest)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *PropertyInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.Secret {
		n += 2
	}
	if m.Mandatory {
		n += 2
	}
	if m.Internal {
		n += 2
	}
	return n
}

func (m *CloudletProps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlatformType != 0 {
		n += 1 + sovCloudlet(uint64(m.PlatformType))
	}
	if len(m.Properties) > 0 {
		for k, v := range m.Properties {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCloudlet(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *CloudletResourceQuotaProps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlatformType != 0 {
		n += 1 + sovCloudlet(uint64(m.PlatformType))
	}
	if len(m.Properties) > 0 {
		for _, e := range m.Properties {
			l = e.Size()
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *CloudletResourceUsage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if m.InfraUsage {
		n += 2
	}
	if len(m.Info) > 0 {
		for _, e := range m.Info {
			l = e.Size()
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	return n
}

func (m *CloudletAllianceOrg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *FlavorInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.Vcpus != 0 {
		n += 1 + sovCloudlet(uint64(m.Vcpus))
	}
	if m.Ram != 0 {
		n += 1 + sovCloudlet(uint64(m.Ram))
	}
	if m.Disk != 0 {
		n += 1 + sovCloudlet(uint64(m.Disk))
	}
	if len(m.PropMap) > 0 {
		for k, v := range m.PropMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 1 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *OSAZone) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *OSImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Tags)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Properties)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.DiskFormat)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *CloudletInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if m.State != 0 {
		n += 1 + sovCloudlet(uint64(m.State))
	}
	if m.NotifyId != 0 {
		n += 1 + sovCloudlet(uint64(m.NotifyId))
	}
	l = len(m.Controller)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.OsMaxRam != 0 {
		n += 1 + sovCloudlet(uint64(m.OsMaxRam))
	}
	if m.OsMaxVcores != 0 {
		n += 1 + sovCloudlet(uint64(m.OsMaxVcores))
	}
	if m.OsMaxVolGb != 0 {
		n += 1 + sovCloudlet(uint64(m.OsMaxVolGb))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	if len(m.Flavors) > 0 {
		for _, e := range m.Flavors {
			l = e.Size()
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	l = m.Status.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	l = len(m.ContainerVersion)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if len(m.AvailabilityZones) > 0 {
		for _, e := range m.AvailabilityZones {
			l = e.Size()
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	if len(m.OsImages) > 0 {
		for _, e := range m.OsImages {
			l = e.Size()
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	if m.ControllerCacheReceived {
		n += 2
	}
	if m.MaintenanceState != 0 {
		n += 2 + sovCloudlet(uint64(m.MaintenanceState))
	}
	l = m.ResourcesSnapshot.Size()
	n += 2 + l + sovCloudlet(uint64(l))
	if m.TrustPolicyState != 0 {
		n += 2 + sovCloudlet(uint64(m.TrustPolicyState))
	}
	if m.CompatibilityVersion != 0 {
		n += 2 + sovCloudlet(uint64(m.CompatibilityVersion))
	}
	if len(m.Properties) > 0 {
		for k, v := range m.Properties {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 2 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	if len(m.NodeInfos) > 0 {
		for _, e := range m.NodeInfos {
			l = e.Size()
			n += 2 + l + sovCloudlet(uint64(l))
		}
	}
	l = len(m.ActiveCrmInstance)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	if m.StandbyCrm {
		n += 3
	}
	return n
}

func (m *CloudletMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Foo != 0 {
		n += 1 + sovCloudlet(uint64(m.Foo))
	}
	return n
}

func sovCloudlet(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCloudlet(x uint64) (n int) {
	return sovCloudlet(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *OperationTimeLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperationTimeLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperationTimeLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateClusterInstTimeout", wireType)
			}
			m.CreateClusterInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateClusterInstTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateClusterInstTimeout", wireType)
			}
			m.UpdateClusterInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateClusterInstTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteClusterInstTimeout", wireType)
			}
			m.DeleteClusterInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteClusterInstTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAppInstTimeout", wireType)
			}
			m.CreateAppInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAppInstTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAppInstTimeout", wireType)
			}
			m.UpdateAppInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAppInstTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteAppInstTimeout", wireType)
			}
			m.DeleteAppInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteAppInstTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletInternal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletInternal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletInternal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Props == nil {
				m.Props = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Props[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlatformConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlatformConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlatformConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerRegistryPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerRegistryPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletVmImagePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudletVmImagePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyCtrlAddrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotifyCtrlAddrs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsCertFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsCertFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvVar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnvVar == nil {
				m.EnvVar = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EnvVar[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlatformTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TestMode = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Span = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CleanupMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CleanupMode = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommercialCerts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CommercialCerts = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseVaultPki", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseVaultPki = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppDnsRoot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppDnsRoot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChefServerPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChefServerPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChefClientInterval", wireType)
			}
			m.ChefClientInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChefClientInterval |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsKeyFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsKeyFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsCaFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsCaFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrmAccessPrivateKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrmAccessPrivateKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessApiAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessApiAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryCrmAccessPrivateKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondaryCrmAccessPrivateKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletResMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletResMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletResMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mapping == nil {
				m.Mapping = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Mapping[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfraConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfraConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfraConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalNetworkName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalNetworkName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlavorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlavorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceQuota) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceQuota: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceQuota: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlertThreshold", wireType)
			}
			m.AlertThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlertThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUDriverKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUDriverKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUDriverKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUDriverBuild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUDriverBuild: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUDriverBuild: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriverPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DriverPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriverPathCreds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DriverPathCreds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystem", wireType)
			}
			m.OperatingSystem = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperatingSystem |= OSType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KernelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HypervisorInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HypervisorInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5Sum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5Sum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUDriverBuildMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUDriverBuildMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUDriverBuildMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Build.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreState = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUDriverBuildURL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUDriverBuildURL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUDriverBuildURL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildUrlPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildUrlPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validity", wireType)
			}
			m.Validity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Validity |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUDriver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUDriver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUDriver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Builds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Builds = append(m.Builds, GPUDriverBuild{})
			if err := m.Builds[len(m.Builds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LicenseConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LicenseConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LicenseConfigMd5Sum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LicenseConfigMd5Sum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Properties[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreState = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletePrepare", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeletePrepare = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Driver.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Properties[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LicenseConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LicenseConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LicenseConfigMd5Sum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LicenseConfigMd5Sum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cloudlet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cloudlet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cloudlet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpSupport", wireType)
			}
			m.IpSupport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpSupport |= IpSupport(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticIps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticIps = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumDynamicIps", wireType)
			}
			m.NumDynamicIps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumDynamicIps |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TimeLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= TrackedState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrmOverride", wireType)
			}
			m.CrmOverride = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrmOverride |= CRMOverride(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentLocal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeploymentLocal = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformType", wireType)
			}
			m.PlatformType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlatformType |= PlatformType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifySrvAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotifySrvAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flavor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Flavor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvVar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnvVar == nil {
				m.EnvVar = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EnvVar[mapkey] = mapvalue
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResTagMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResTagMap == nil {
				m.ResTagMap = make(map[string]*ResTagTableKey)
			}
			var mapkey string
			var mapvalue *ResTagTableKey
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCloudlet
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ResTagTableKey{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResTagMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessVars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessVars == nil {
				m.AccessVars = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AccessVars[mapkey] = mapvalue
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmImageVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmImageVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deployment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraApiAccess", wireType)
			}
			m.InfraApiAccess = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InfraApiAccess |= InfraApiAccess(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InfraConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChefClientKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChefClientKey == nil {
				m.ChefClientKey = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ChefClientKey[mapkey] = mapvalue
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceState", wireType)
			}
			m.MaintenanceState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaintenanceState |= dme_proto.MaintenanceState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverridePolicyContainerVersion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverridePolicyContainerVersion = bool(v != 0)
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmPool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmPool = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrmAccessPublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrmAccessPublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrmAccessKeyUpgradeRequired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CrmAccessKeyUpgradeRequired = bool(v != 0)
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustPolicyState", wireType)
			}
			m.TrustPolicyState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrustPolicyState |= TrackedState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceQuotas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceQuotas = append(m.ResourceQuotas, ResourceQuota{})
			if err := m.ResourceQuotas[len(m.ResourceQuotas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultResourceAlertThreshold", wireType)
			}
			m.DefaultResourceAlertThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultResourceAlertThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostController", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostController = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KafkaCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KafkaCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KafkaUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KafkaUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KafkaPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KafkaPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GpuConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableDefaultServerlessCluster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableDefaultServerlessCluster = bool(v != 0)
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllianceOrgs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllianceOrgs = append(m.AllianceOrgs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleKubernetesClusterOwner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SingleKubernetesClusterOwner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletePrepare", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeletePrepare = bool(v != 0)
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformHighAvailability", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlatformHighAvailability = bool(v != 0)
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryCrmAccessPublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondaryCrmAccessPublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryCrmAccessKeyUpgradeRequired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SecondaryCrmAccessKeyUpgradeRequired = bool(v != 0)
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryNotifySrvAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondaryNotifySrvAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootLbFqdn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootLbFqdn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlavorMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlavorMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlavorMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlavorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlavorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletManifest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletManifest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletManifest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manifest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manifest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropertyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropertyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropertyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Secret = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mandatory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mandatory = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Internal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Internal = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletProps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletProps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletProps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformType", wireType)
			}
			m.PlatformType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlatformType |= PlatformType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = make(map[string]*PropertyInfo)
			}
			var mapkey string
			var mapvalue *PropertyInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCloudlet
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PropertyInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Properties[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletResourceQuotaProps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletResourceQuotaProps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletResourceQuotaProps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformType", wireType)
			}
			m.PlatformType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlatformType |= PlatformType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = append(m.Properties, InfraResource{})
			if err := m.Properties[len(m.Properties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletResourceUsage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletResourceUsage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletResourceUsage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraUsage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InfraUsage = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = append(m.Info, InfraResource{})
			if err := m.Info[len(m.Info)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletAllianceOrg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletAllianceOrg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletAllianceOrg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlavorInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlavorInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlavorInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vcpus", wireType)
			}
			m.Vcpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vcpus |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ram", wireType)
			}
			m.Ram = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ram |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disk", wireType)
			}
			m.Disk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Disk |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PropMap == nil {
				m.PropMap = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PropMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSAZone) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSAZone: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSAZone: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSImage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSImage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSImage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= dme_proto.CloudletState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyId", wireType)
			}
			m.NotifyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotifyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsMaxRam", wireType)
			}
			m.OsMaxRam = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OsMaxRam |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsMaxVcores", wireType)
			}
			m.OsMaxVcores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OsMaxVcores |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsMaxVolGb", wireType)
			}
			m.OsMaxVolGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OsMaxVolGb |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flavors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flavors = append(m.Flavors, &FlavorInfo{})
			if err := m.Flavors[len(m.Flavors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityZones", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityZones = append(m.AvailabilityZones, &OSAZone{})
			if err := m.AvailabilityZones[len(m.AvailabilityZones)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsImages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OsImages = append(m.OsImages, &OSImage{})
			if err := m.OsImages[len(m.OsImages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControllerCacheReceived", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ControllerCacheReceived = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceState", wireType)
			}
			m.MaintenanceState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaintenanceState |= dme_proto.MaintenanceState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcesSnapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourcesSnapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustPolicyState", wireType)
			}
			m.TrustPolicyState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrustPolicyState |= TrackedState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompatibilityVersion", wireType)
			}
			m.CompatibilityVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompatibilityVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Properties[mapkey] = mapvalue
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeInfos = append(m.NodeInfos, &NodeInfo{})
			if err := m.NodeInfos[len(m.NodeInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveCrmInstance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveCrmInstance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandbyCrm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StandbyCrm = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Foo", wireType)
			}
			m.Foo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Foo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCloudlet(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCloudlet
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCloudlet
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCloudlet
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCloudlet        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCloudlet          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCloudlet = fmt.Errorf("proto: unexpected end of group")
)
