// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cloudlet.proto

package edgeproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/mobiledgex/edge-cloud/protogen"
import distributed_match_engine "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto"
import _ "github.com/gogo/protobuf/gogoproto"

import strings "strings"
import reflect "reflect"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import "encoding/json"
import "github.com/mobiledgex/edge-cloud/objstore"
import "github.com/coreos/etcd/clientv3/concurrency"
import "github.com/mobiledgex/edge-cloud/util"
import "github.com/mobiledgex/edge-cloud/log"
import "errors"
import "strconv"
import "github.com/google/go-cmp/cmp"
import "github.com/google/go-cmp/cmp/cmpopts"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Platform Type
//
// PlatformType is the supported list of cloudlet types
type PlatformType int32

const (
	// Fake Cloudlet
	PlatformType_PLATFORM_TYPE_FAKE PlatformType = 0
	// DIND Cloudlet
	PlatformType_PLATFORM_TYPE_DIND PlatformType = 1
	// Openstack Cloudlet
	PlatformType_PLATFORM_TYPE_OPENSTACK PlatformType = 2
	// Azure Cloudlet
	PlatformType_PLATFORM_TYPE_AZURE PlatformType = 3
	// GCP Cloudlet
	PlatformType_PLATFORM_TYPE_GCP PlatformType = 4
	// Edgebox Cloudlet
	PlatformType_PLATFORM_TYPE_EDGEBOX PlatformType = 5
	// Fake Infra Cloudlet
	PlatformType_PLATFORM_TYPE_FAKEINFRA PlatformType = 6
	// VMWare VSphere (ESXi)
	PlatformType_PLATFORM_TYPE_VSPHERE PlatformType = 7
	// AWS EKS Cloudlet
	PlatformType_PLATFORM_TYPE_AWS PlatformType = 8
	// VM Pool Cloudlet
	PlatformType_PLATFORM_TYPE_VM_POOL PlatformType = 9
	// AWS EC2 VM Cloudlet
	PlatformType_PLATFORM_TYPE_AWS_VM PlatformType = 10
)

var PlatformType_name = map[int32]string{
	0:  "PLATFORM_TYPE_FAKE",
	1:  "PLATFORM_TYPE_DIND",
	2:  "PLATFORM_TYPE_OPENSTACK",
	3:  "PLATFORM_TYPE_AZURE",
	4:  "PLATFORM_TYPE_GCP",
	5:  "PLATFORM_TYPE_EDGEBOX",
	6:  "PLATFORM_TYPE_FAKEINFRA",
	7:  "PLATFORM_TYPE_VSPHERE",
	8:  "PLATFORM_TYPE_AWS",
	9:  "PLATFORM_TYPE_VM_POOL",
	10: "PLATFORM_TYPE_AWS_VM",
}
var PlatformType_value = map[string]int32{
	"PLATFORM_TYPE_FAKE":      0,
	"PLATFORM_TYPE_DIND":      1,
	"PLATFORM_TYPE_OPENSTACK": 2,
	"PLATFORM_TYPE_AZURE":     3,
	"PLATFORM_TYPE_GCP":       4,
	"PLATFORM_TYPE_EDGEBOX":   5,
	"PLATFORM_TYPE_FAKEINFRA": 6,
	"PLATFORM_TYPE_VSPHERE":   7,
	"PLATFORM_TYPE_AWS":       8,
	"PLATFORM_TYPE_VM_POOL":   9,
	"PLATFORM_TYPE_AWS_VM":    10,
}

func (x PlatformType) String() string {
	return proto.EnumName(PlatformType_name, int32(x))
}
func (PlatformType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCloudlet, []int{0} }

// Infra API Access
//
// InfraApiAccess is the type of access available to Infra API endpoint
type InfraApiAccess int32

const (
	// Infra API endpoint is accessible from public network
	InfraApiAccess_DIRECT_ACCESS InfraApiAccess = 0
	// Infra API endpoint is not accessible from public network
	InfraApiAccess_RESTRICTED_ACCESS InfraApiAccess = 1
)

var InfraApiAccess_name = map[int32]string{
	0: "DIRECT_ACCESS",
	1: "RESTRICTED_ACCESS",
}
var InfraApiAccess_value = map[string]int32{
	"DIRECT_ACCESS":     0,
	"RESTRICTED_ACCESS": 1,
}

func (x InfraApiAccess) String() string {
	return proto.EnumName(InfraApiAccess_name, int32(x))
}
func (InfraApiAccess) EnumDescriptor() ([]byte, []int) { return fileDescriptorCloudlet, []int{1} }

// CloudletState is the state of the Cloudlet.
type CloudletState int32

const (
	// Unknown
	CloudletState_CLOUDLET_STATE_UNKNOWN CloudletState = 0
	// Create/Delete/Update encountered errors (see Errors field of CloudletInfo)
	CloudletState_CLOUDLET_STATE_ERRORS CloudletState = 1
	// Cloudlet is created and ready
	CloudletState_CLOUDLET_STATE_READY CloudletState = 2
	// Cloudlet is offline (unreachable)
	CloudletState_CLOUDLET_STATE_OFFLINE CloudletState = 3
	// Cloudlet is not present
	CloudletState_CLOUDLET_STATE_NOT_PRESENT CloudletState = 4
	// Cloudlet is initializing
	CloudletState_CLOUDLET_STATE_INIT CloudletState = 5
	// Cloudlet is upgrading
	CloudletState_CLOUDLET_STATE_UPGRADE CloudletState = 6
	// Cloudlet needs data to synchronize
	CloudletState_CLOUDLET_STATE_NEED_SYNC CloudletState = 7
)

var CloudletState_name = map[int32]string{
	0: "CLOUDLET_STATE_UNKNOWN",
	1: "CLOUDLET_STATE_ERRORS",
	2: "CLOUDLET_STATE_READY",
	3: "CLOUDLET_STATE_OFFLINE",
	4: "CLOUDLET_STATE_NOT_PRESENT",
	5: "CLOUDLET_STATE_INIT",
	6: "CLOUDLET_STATE_UPGRADE",
	7: "CLOUDLET_STATE_NEED_SYNC",
}
var CloudletState_value = map[string]int32{
	"CLOUDLET_STATE_UNKNOWN":     0,
	"CLOUDLET_STATE_ERRORS":      1,
	"CLOUDLET_STATE_READY":       2,
	"CLOUDLET_STATE_OFFLINE":     3,
	"CLOUDLET_STATE_NOT_PRESENT": 4,
	"CLOUDLET_STATE_INIT":        5,
	"CLOUDLET_STATE_UPGRADE":     6,
	"CLOUDLET_STATE_NEED_SYNC":   7,
}

func (x CloudletState) String() string {
	return proto.EnumName(CloudletState_name, int32(x))
}
func (CloudletState) EnumDescriptor() ([]byte, []int) { return fileDescriptorCloudlet, []int{2} }

// Cloudlet unique key
//
// CloudletKey uniquely identifies a Cloudlet.
type CloudletKey struct {
	// Organization of the cloudlet site
	Organization string `protobuf:"bytes,1,opt,name=organization,proto3" json:"organization,omitempty"`
	// Name of the cloudlet
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *CloudletKey) Reset()                    { *m = CloudletKey{} }
func (m *CloudletKey) String() string            { return proto.CompactTextString(m) }
func (*CloudletKey) ProtoMessage()               {}
func (*CloudletKey) Descriptor() ([]byte, []int) { return fileDescriptorCloudlet, []int{0} }

// Operation time limits
//
// Time limits for cloudlet create, update and delete operations
type OperationTimeLimits struct {
	// override default max time to create a cluster instance (duration)
	CreateClusterInstTimeout Duration `protobuf:"varint,1,opt,name=create_cluster_inst_timeout,json=createClusterInstTimeout,proto3,casttype=Duration" json:"create_cluster_inst_timeout,omitempty"`
	// override default max time to update a cluster instance (duration)
	UpdateClusterInstTimeout Duration `protobuf:"varint,2,opt,name=update_cluster_inst_timeout,json=updateClusterInstTimeout,proto3,casttype=Duration" json:"update_cluster_inst_timeout,omitempty"`
	// override default max time to delete a cluster instance (duration)
	DeleteClusterInstTimeout Duration `protobuf:"varint,3,opt,name=delete_cluster_inst_timeout,json=deleteClusterInstTimeout,proto3,casttype=Duration" json:"delete_cluster_inst_timeout,omitempty"`
	// override default max time to create an app instance (duration)
	CreateAppInstTimeout Duration `protobuf:"varint,4,opt,name=create_app_inst_timeout,json=createAppInstTimeout,proto3,casttype=Duration" json:"create_app_inst_timeout,omitempty"`
	// override default max time to update an app instance (duration)
	UpdateAppInstTimeout Duration `protobuf:"varint,5,opt,name=update_app_inst_timeout,json=updateAppInstTimeout,proto3,casttype=Duration" json:"update_app_inst_timeout,omitempty"`
	// override default max time to delete an app instance (duration)
	DeleteAppInstTimeout Duration `protobuf:"varint,6,opt,name=delete_app_inst_timeout,json=deleteAppInstTimeout,proto3,casttype=Duration" json:"delete_app_inst_timeout,omitempty"`
}

func (m *OperationTimeLimits) Reset()                    { *m = OperationTimeLimits{} }
func (m *OperationTimeLimits) String() string            { return proto.CompactTextString(m) }
func (*OperationTimeLimits) ProtoMessage()               {}
func (*OperationTimeLimits) Descriptor() ([]byte, []int) { return fileDescriptorCloudlet, []int{1} }

//
// Platform specific configuration required for Cloudlet management
type PlatformConfig struct {
	// Path to Docker registry holding edge-cloud image
	ContainerRegistryPath string `protobuf:"bytes,1,opt,name=container_registry_path,json=containerRegistryPath,proto3" json:"container_registry_path,omitempty"`
	// Path to platform base image
	CloudletVmImagePath string `protobuf:"bytes,2,opt,name=cloudlet_vm_image_path,json=cloudletVmImagePath,proto3" json:"cloudlet_vm_image_path,omitempty"`
	// Address of controller notify port (can be multiple of these)
	NotifyCtrlAddrs string `protobuf:"bytes,3,opt,name=notify_ctrl_addrs,json=notifyCtrlAddrs,proto3" json:"notify_ctrl_addrs,omitempty"`
	// Vault address
	VaultAddr string `protobuf:"bytes,4,opt,name=vault_addr,json=vaultAddr,proto3" json:"vault_addr,omitempty"`
	// TLS cert file
	TlsCertFile string `protobuf:"bytes,5,opt,name=tls_cert_file,json=tlsCertFile,proto3" json:"tls_cert_file,omitempty"`
	// Environment variables
	EnvVar map[string]string `protobuf:"bytes,6,rep,name=env_var,json=envVar" json:"env_var,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Tag of edge-cloud image
	PlatformTag string `protobuf:"bytes,8,opt,name=platform_tag,json=platformTag,proto3" json:"platform_tag,omitempty"`
	// Internal Test flag
	TestMode bool `protobuf:"varint,9,opt,name=test_mode,json=testMode,proto3" json:"test_mode,omitempty"`
	// Span string
	Span string `protobuf:"bytes,10,opt,name=span,proto3" json:"span,omitempty"`
	// Internal cleanup flag
	CleanupMode bool `protobuf:"varint,11,opt,name=cleanup_mode,json=cleanupMode,proto3" json:"cleanup_mode,omitempty"`
	// Region
	Region string `protobuf:"bytes,12,opt,name=region,proto3" json:"region,omitempty"`
	// Get certs from vault or generate your own for the root load balancer
	CommercialCerts bool `protobuf:"varint,13,opt,name=commercial_certs,json=commercialCerts,proto3" json:"commercial_certs,omitempty"`
	// Use Vault certs for internal TLS communication
	UseVaultCerts bool `protobuf:"varint,14,opt,name=use_vault_certs,json=useVaultCerts,proto3" json:"use_vault_certs,omitempty"`
	// Use Vault CAs to authenticate TLS communication
	UseVaultCas bool `protobuf:"varint,15,opt,name=use_vault_cas,json=useVaultCas,proto3" json:"use_vault_cas,omitempty"`
	// App domain name root
	AppDnsRoot string `protobuf:"bytes,16,opt,name=app_dns_root,json=appDnsRoot,proto3" json:"app_dns_root,omitempty"`
	// Path to Chef Server
	ChefServerPath string `protobuf:"bytes,17,opt,name=chef_server_path,json=chefServerPath,proto3" json:"chef_server_path,omitempty"`
	// Chef client interval
	ChefClientInterval Duration `protobuf:"varint,18,opt,name=chef_client_interval,json=chefClientInterval,proto3,casttype=Duration" json:"chef_client_interval,omitempty"`
	// Deployment Tag
	DeploymentTag string `protobuf:"bytes,19,opt,name=deployment_tag,json=deploymentTag,proto3" json:"deployment_tag,omitempty"`
}

func (m *PlatformConfig) Reset()                    { *m = PlatformConfig{} }
func (m *PlatformConfig) String() string            { return proto.CompactTextString(m) }
func (*PlatformConfig) ProtoMessage()               {}
func (*PlatformConfig) Descriptor() ([]byte, []int) { return fileDescriptorCloudlet, []int{2} }

// optional resource input consists of a resource specifier and clouldkey name
type CloudletResMap struct {
	// Resource cloudlet key
	Key CloudletKey `protobuf:"bytes,1,opt,name=key" json:"key"`
	// Resource mapping info
	Mapping map[string]string `protobuf:"bytes,2,rep,name=mapping" json:"mapping,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CloudletResMap) Reset()                    { *m = CloudletResMap{} }
func (m *CloudletResMap) String() string            { return proto.CompactTextString(m) }
func (*CloudletResMap) ProtoMessage()               {}
func (*CloudletResMap) Descriptor() ([]byte, []int) { return fileDescriptorCloudlet, []int{3} }

// Infra specific configuration used for Cloudlet deployments
type InfraConfig struct {
	// Infra specific external network name
	ExternalNetworkName string `protobuf:"bytes,1,opt,name=external_network_name,json=externalNetworkName,proto3" json:"external_network_name,omitempty"`
	// Infra specific flavor name
	FlavorName string `protobuf:"bytes,2,opt,name=flavor_name,json=flavorName,proto3" json:"flavor_name,omitempty"`
}

func (m *InfraConfig) Reset()                    { *m = InfraConfig{} }
func (m *InfraConfig) String() string            { return proto.CompactTextString(m) }
func (*InfraConfig) ProtoMessage()               {}
func (*InfraConfig) Descriptor() ([]byte, []int) { return fileDescriptorCloudlet, []int{4} }

// Cloudlet
//
// A Cloudlet is a set of compute resources at a particular location, provided by an Operator.
type Cloudlet struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty"`
	// required: true
	// Unique identifier key
	Key CloudletKey `protobuf:"bytes,2,opt,name=key" json:"key"`
	// Location of the Cloudlet site
	Location distributed_match_engine.Loc `protobuf:"bytes,5,opt,name=location" json:"location"`
	// Type of IP support provided by Cloudlet (see IpSupport)
	IpSupport IpSupport `protobuf:"varint,6,opt,name=ip_support,json=ipSupport,proto3,enum=edgeproto.IpSupport" json:"ip_support,omitempty"`
	// List of static IPs for static IP support
	StaticIps string `protobuf:"bytes,7,opt,name=static_ips,json=staticIps,proto3" json:"static_ips,omitempty"`
	// Number of dynamic IPs available for dynamic IP support
	NumDynamicIps int32 `protobuf:"varint,8,opt,name=num_dynamic_ips,json=numDynamicIps,proto3" json:"num_dynamic_ips,omitempty"`
	// time limits which override global settings if non-zero
	TimeLimits OperationTimeLimits `protobuf:"bytes,9,opt,name=time_limits,json=timeLimits" json:"time_limits"`
	// Any errors trying to create, update, or delete the Cloudlet.
	Errors []string `protobuf:"bytes,10,rep,name=errors" json:"errors,omitempty"`
	// status is used to reflect progress of creation or other events
	Status StatusInfo `protobuf:"bytes,11,opt,name=status" json:"status"`
	// Current state of the cloudlet
	State TrackedState `protobuf:"varint,12,opt,name=state,proto3,enum=edgeproto.TrackedState" json:"state,omitempty"`
	// Override actions to CRM
	CrmOverride CRMOverride `protobuf:"varint,13,opt,name=crm_override,json=crmOverride,proto3,enum=edgeproto.CRMOverride" json:"crm_override,omitempty"`
	// Deploy cloudlet services locally
	DeploymentLocal bool `protobuf:"varint,14,opt,name=deployment_local,json=deploymentLocal,proto3" json:"deployment_local,omitempty"`
	// Platform type
	PlatformType PlatformType `protobuf:"varint,15,opt,name=platform_type,json=platformType,proto3,enum=edgeproto.PlatformType" json:"platform_type,omitempty"`
	// Address for the CRM notify listener to run on
	NotifySrvAddr string `protobuf:"bytes,16,opt,name=notify_srv_addr,json=notifySrvAddr,proto3" json:"notify_srv_addr,omitempty"`
	// Min system resource requirements for platform
	Flavor FlavorKey `protobuf:"bytes,17,opt,name=flavor" json:"flavor"`
	// Physical infrastructure cloudlet name
	PhysicalName string `protobuf:"bytes,18,opt,name=physical_name,json=physicalName,proto3" json:"physical_name,omitempty"`
	// Single Key-Value pair of env var to be passed to CRM
	EnvVar map[string]string `protobuf:"bytes,19,rep,name=env_var,json=envVar" json:"env_var,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Cloudlet container version
	ContainerVersion string `protobuf:"bytes,20,opt,name=container_version,json=containerVersion,proto3" json:"container_version,omitempty"`
	// Platform Config Info
	Config PlatformConfig `protobuf:"bytes,21,opt,name=config" json:"config"`
	// Optional resource to restagtbl key map key values = [gpu, nas, nic]
	ResTagMap map[string]*ResTagTableKey `protobuf:"bytes,22,rep,name=res_tag_map,json=resTagMap" json:"res_tag_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Variables required to access cloudlet
	AccessVars map[string]string `protobuf:"bytes,23,rep,name=access_vars,json=accessVars" json:"access_vars,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// MobiledgeX baseimage version where CRM services reside
	VmImageVersion string `protobuf:"bytes,24,opt,name=vm_image_version,json=vmImageVersion,proto3" json:"vm_image_version,omitempty"`
	// Deployment type to bring up CRM services (docker, kubernetes)
	Deployment string `protobuf:"bytes,26,opt,name=deployment,proto3" json:"deployment,omitempty"`
	// Infra Access Type is the type of access available to Infra API Endpoint
	InfraApiAccess InfraApiAccess `protobuf:"varint,27,opt,name=infra_api_access,json=infraApiAccess,proto3,enum=edgeproto.InfraApiAccess" json:"infra_api_access,omitempty"`
	// Infra specific config
	InfraConfig InfraConfig `protobuf:"bytes,28,opt,name=infra_config,json=infraConfig" json:"infra_config"`
	// Chef client key
	ChefClientKey map[string]string `protobuf:"bytes,29,rep,name=chef_client_key,json=chefClientKey" json:"chef_client_key,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// State for maintenance
	MaintenanceState MaintenanceState `protobuf:"varint,30,opt,name=maintenance_state,json=maintenanceState,proto3,enum=edgeproto.MaintenanceState" json:"maintenance_state,omitempty"`
	// Override container version from policy file
	OverridePolicyContainerVersion bool `protobuf:"varint,31,opt,name=override_policy_container_version,json=overridePolicyContainerVersion,proto3" json:"override_policy_container_version,omitempty"`
	// VM Pool
	VmPool string `protobuf:"bytes,32,opt,name=vm_pool,json=vmPool,proto3" json:"vm_pool,omitempty"`
}

func (m *Cloudlet) Reset()                    { *m = Cloudlet{} }
func (m *Cloudlet) String() string            { return proto.CompactTextString(m) }
func (*Cloudlet) ProtoMessage()               {}
func (*Cloudlet) Descriptor() ([]byte, []int) { return fileDescriptorCloudlet, []int{5} }

type FlavorMatch struct {
	// Cloudlet ctx
	Key              CloudletKey `protobuf:"bytes,1,opt,name=key" json:"key"`
	FlavorName       string      `protobuf:"bytes,3,opt,name=flavor_name,json=flavorName,proto3" json:"flavor_name,omitempty"`
	AvailabilityZone string      `protobuf:"bytes,4,opt,name=availability_zone,json=availabilityZone,proto3" json:"availability_zone,omitempty"`
}

func (m *FlavorMatch) Reset()                    { *m = FlavorMatch{} }
func (m *FlavorMatch) String() string            { return proto.CompactTextString(m) }
func (*FlavorMatch) ProtoMessage()               {}
func (*FlavorMatch) Descriptor() ([]byte, []int) { return fileDescriptorCloudlet, []int{6} }

type CloudletManifest struct {
	// Manifest to bringup cloudlet VM and services.
	Manifest string `protobuf:"bytes,2,opt,name=manifest,proto3" json:"manifest,omitempty"`
}

func (m *CloudletManifest) Reset()                    { *m = CloudletManifest{} }
func (m *CloudletManifest) String() string            { return proto.CompactTextString(m) }
func (*CloudletManifest) ProtoMessage()               {}
func (*CloudletManifest) Descriptor() ([]byte, []int) { return fileDescriptorCloudlet, []int{7} }

type PropertyInfo struct {
	// Name of the property
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Description of the property
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Default value of the property
	Value string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	// Is the property a secret value, will be hidden
	Secret bool `protobuf:"varint,4,opt,name=secret,proto3" json:"secret,omitempty"`
	// Is the property mandatory
	Mandatory bool `protobuf:"varint,5,opt,name=mandatory,proto3" json:"mandatory,omitempty"`
	// Is the property internal, not to be set by Operator
	Internal bool `protobuf:"varint,6,opt,name=internal,proto3" json:"internal,omitempty"`
}

func (m *PropertyInfo) Reset()                    { *m = PropertyInfo{} }
func (m *PropertyInfo) String() string            { return proto.CompactTextString(m) }
func (*PropertyInfo) ProtoMessage()               {}
func (*PropertyInfo) Descriptor() ([]byte, []int) { return fileDescriptorCloudlet, []int{8} }

type CloudletProps struct {
	// Platform type
	PlatformType PlatformType `protobuf:"varint,1,opt,name=platform_type,json=platformType,proto3,enum=edgeproto.PlatformType" json:"platform_type,omitempty"`
	// Single Key-Value pair of env var to be passed to CRM
	Properties map[string]*PropertyInfo `protobuf:"bytes,2,rep,name=properties" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *CloudletProps) Reset()                    { *m = CloudletProps{} }
func (m *CloudletProps) String() string            { return proto.CompactTextString(m) }
func (*CloudletProps) ProtoMessage()               {}
func (*CloudletProps) Descriptor() ([]byte, []int) { return fileDescriptorCloudlet, []int{9} }

// Flavor details from the Cloudlet
type FlavorInfo struct {
	// Name of the flavor on the Cloudlet
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Number of VCPU cores on the Cloudlet
	Vcpus uint64 `protobuf:"varint,2,opt,name=vcpus,proto3" json:"vcpus,omitempty"`
	// Ram in MB on the Cloudlet
	Ram uint64 `protobuf:"varint,3,opt,name=ram,proto3" json:"ram,omitempty"`
	// Amount of disk in GB on the Cloudlet
	Disk uint64 `protobuf:"varint,4,opt,name=disk,proto3" json:"disk,omitempty"`
	// OS Flavor Properties, if any
	PropMap map[string]string `protobuf:"bytes,5,rep,name=prop_map,json=propMap" json:"prop_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *FlavorInfo) Reset()                    { *m = FlavorInfo{} }
func (m *FlavorInfo) String() string            { return proto.CompactTextString(m) }
func (*FlavorInfo) ProtoMessage()               {}
func (*FlavorInfo) Descriptor() ([]byte, []int) { return fileDescriptorCloudlet, []int{10} }

type OSAZone struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *OSAZone) Reset()                    { *m = OSAZone{} }
func (m *OSAZone) String() string            { return proto.CompactTextString(m) }
func (*OSAZone) ProtoMessage()               {}
func (*OSAZone) Descriptor() ([]byte, []int) { return fileDescriptorCloudlet, []int{11} }

type OSImage struct {
	// image name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// optional tags present on image
	Tags string `protobuf:"bytes,2,opt,name=tags,proto3" json:"tags,omitempty"`
	// image properties/metadata
	Properties string `protobuf:"bytes,3,opt,name=properties,proto3" json:"properties,omitempty"`
	// format qcow2, img, etc
	DiskFormat string `protobuf:"bytes,4,opt,name=disk_format,json=diskFormat,proto3" json:"disk_format,omitempty"`
}

func (m *OSImage) Reset()                    { *m = OSImage{} }
func (m *OSImage) String() string            { return proto.CompactTextString(m) }
func (*OSImage) ProtoMessage()               {}
func (*OSImage) Descriptor() ([]byte, []int) { return fileDescriptorCloudlet, []int{12} }

// CloudletInfo provides information from the Cloudlet Resource Manager about the state of the Cloudlet.
type CloudletInfo struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty"`
	// Unique identifier key
	Key CloudletKey `protobuf:"bytes,2,opt,name=key" json:"key"`
	// State of cloudlet
	State CloudletState `protobuf:"varint,3,opt,name=state,proto3,enum=edgeproto.CloudletState" json:"state,omitempty"`
	// Id of client assigned by server (internal use only)
	NotifyId int64 `protobuf:"varint,4,opt,name=notify_id,json=notifyId,proto3" json:"notify_id,omitempty"`
	// Connected controller unique id
	Controller string `protobuf:"bytes,5,opt,name=controller,proto3" json:"controller,omitempty"`
	// Maximum Ram in MB on the Cloudlet
	OsMaxRam uint64 `protobuf:"varint,6,opt,name=os_max_ram,json=osMaxRam,proto3" json:"os_max_ram,omitempty"`
	// Maximum number of VCPU cores on the Cloudlet
	OsMaxVcores uint64 `protobuf:"varint,7,opt,name=os_max_vcores,json=osMaxVcores,proto3" json:"os_max_vcores,omitempty"`
	// Maximum amount of disk in GB on the Cloudlet
	OsMaxVolGb uint64 `protobuf:"varint,8,opt,name=os_max_vol_gb,json=osMaxVolGb,proto3" json:"os_max_vol_gb,omitempty"`
	// Any errors encountered while making changes to the Cloudlet
	Errors []string `protobuf:"bytes,9,rep,name=errors" json:"errors,omitempty"`
	// Supported flavors by the Cloudlet
	Flavors []*FlavorInfo `protobuf:"bytes,10,rep,name=flavors" json:"flavors,omitempty"`
	// status is used to reflect progress of creation or other events
	Status StatusInfo `protobuf:"bytes,11,opt,name=status" json:"status"`
	// Cloudlet container version
	ContainerVersion string `protobuf:"bytes,12,opt,name=container_version,json=containerVersion,proto3" json:"container_version,omitempty"`
	// Availability Zones if any
	AvailabilityZones []*OSAZone `protobuf:"bytes,13,rep,name=availability_zones,json=availabilityZones" json:"availability_zones,omitempty"`
	// Local Images availble to cloudlet
	OsImages []*OSImage `protobuf:"bytes,14,rep,name=os_images,json=osImages" json:"os_images,omitempty"`
	// Indicates all controller data has been sent to CRM
	ControllerCacheReceived bool `protobuf:"varint,15,opt,name=controller_cache_received,json=controllerCacheReceived,proto3" json:"controller_cache_received,omitempty"`
	// State for maintenance
	MaintenanceState MaintenanceState `protobuf:"varint,16,opt,name=maintenance_state,json=maintenanceState,proto3,enum=edgeproto.MaintenanceState" json:"maintenance_state,omitempty"`
}

func (m *CloudletInfo) Reset()                    { *m = CloudletInfo{} }
func (m *CloudletInfo) String() string            { return proto.CompactTextString(m) }
func (*CloudletInfo) ProtoMessage()               {}
func (*CloudletInfo) Descriptor() ([]byte, []int) { return fileDescriptorCloudlet, []int{13} }

// (TODO) CloudletMetrics provide metrics collected about the Cloudlet. They are sent to a metrics collector for analytics. They are not stored in the persistent distributed database, but are stored as a time series in some other database or files.
type CloudletMetrics struct {
	// what goes here?
	Foo uint64 `protobuf:"varint,5,opt,name=foo,proto3" json:"foo,omitempty"`
}

func (m *CloudletMetrics) Reset()                    { *m = CloudletMetrics{} }
func (m *CloudletMetrics) String() string            { return proto.CompactTextString(m) }
func (*CloudletMetrics) ProtoMessage()               {}
func (*CloudletMetrics) Descriptor() ([]byte, []int) { return fileDescriptorCloudlet, []int{14} }

func init() {
	proto.RegisterType((*CloudletKey)(nil), "edgeproto.CloudletKey")
	proto.RegisterType((*OperationTimeLimits)(nil), "edgeproto.OperationTimeLimits")
	proto.RegisterType((*PlatformConfig)(nil), "edgeproto.PlatformConfig")
	proto.RegisterType((*CloudletResMap)(nil), "edgeproto.CloudletResMap")
	proto.RegisterType((*InfraConfig)(nil), "edgeproto.InfraConfig")
	proto.RegisterType((*Cloudlet)(nil), "edgeproto.Cloudlet")
	proto.RegisterType((*FlavorMatch)(nil), "edgeproto.FlavorMatch")
	proto.RegisterType((*CloudletManifest)(nil), "edgeproto.CloudletManifest")
	proto.RegisterType((*PropertyInfo)(nil), "edgeproto.PropertyInfo")
	proto.RegisterType((*CloudletProps)(nil), "edgeproto.CloudletProps")
	proto.RegisterType((*FlavorInfo)(nil), "edgeproto.FlavorInfo")
	proto.RegisterType((*OSAZone)(nil), "edgeproto.OSAZone")
	proto.RegisterType((*OSImage)(nil), "edgeproto.OSImage")
	proto.RegisterType((*CloudletInfo)(nil), "edgeproto.CloudletInfo")
	proto.RegisterType((*CloudletMetrics)(nil), "edgeproto.CloudletMetrics")
	proto.RegisterEnum("edgeproto.PlatformType", PlatformType_name, PlatformType_value)
	proto.RegisterEnum("edgeproto.InfraApiAccess", InfraApiAccess_name, InfraApiAccess_value)
	proto.RegisterEnum("edgeproto.CloudletState", CloudletState_name, CloudletState_value)
}
func (this *CloudletKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&edgeproto.CloudletKey{")
	s = append(s, "Organization: "+fmt.Sprintf("%#v", this.Organization)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCloudlet(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for CloudletApi service

type CloudletApiClient interface {
	// Create Cloudlet. Sets up Cloudlet services on the Operator's compute resources,
	// and integrated as part of MobiledgeX edge resource portfolio.
	// These resources are managed from the Edge Controller.
	CreateCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_CreateCloudletClient, error)
	// Delete Cloudlet. Removes the Cloudlet services where they are no longer managed
	// from the Edge Controller.
	DeleteCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_DeleteCloudletClient, error)
	// Update Cloudlet. Updates the Cloudlet configuration and manages the upgrade of Cloudlet services.
	UpdateCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_UpdateCloudletClient, error)
	// Show Cloudlets. Lists all the cloudlets managed from Edge Controller.
	ShowCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_ShowCloudletClient, error)
	// Get Cloudlet Manifest. Shows deployment manifest required to setup cloudlet
	GetCloudletManifest(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (*CloudletManifest, error)
	// Get Cloudlet Properties. Shows all the infra properties used to setup cloudlet
	GetCloudletProps(ctx context.Context, in *CloudletProps, opts ...grpc.CallOption) (*CloudletProps, error)
	// Add Optional Resource tag table
	AddCloudletResMapping(ctx context.Context, in *CloudletResMap, opts ...grpc.CallOption) (*Result, error)
	// Add Optional Resource tag table
	RemoveCloudletResMapping(ctx context.Context, in *CloudletResMap, opts ...grpc.CallOption) (*Result, error)
	// Discover if flavor produces a matching platform flavor
	FindFlavorMatch(ctx context.Context, in *FlavorMatch, opts ...grpc.CallOption) (*FlavorMatch, error)
}

type cloudletApiClient struct {
	cc *grpc.ClientConn
}

func NewCloudletApiClient(cc *grpc.ClientConn) CloudletApiClient {
	return &cloudletApiClient{cc}
}

func (c *cloudletApiClient) CreateCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_CreateCloudletClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CloudletApi_serviceDesc.Streams[0], c.cc, "/edgeproto.CloudletApi/CreateCloudlet", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletApiCreateCloudletClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletApi_CreateCloudletClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type cloudletApiCreateCloudletClient struct {
	grpc.ClientStream
}

func (x *cloudletApiCreateCloudletClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cloudletApiClient) DeleteCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_DeleteCloudletClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CloudletApi_serviceDesc.Streams[1], c.cc, "/edgeproto.CloudletApi/DeleteCloudlet", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletApiDeleteCloudletClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletApi_DeleteCloudletClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type cloudletApiDeleteCloudletClient struct {
	grpc.ClientStream
}

func (x *cloudletApiDeleteCloudletClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cloudletApiClient) UpdateCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_UpdateCloudletClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CloudletApi_serviceDesc.Streams[2], c.cc, "/edgeproto.CloudletApi/UpdateCloudlet", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletApiUpdateCloudletClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletApi_UpdateCloudletClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type cloudletApiUpdateCloudletClient struct {
	grpc.ClientStream
}

func (x *cloudletApiUpdateCloudletClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cloudletApiClient) ShowCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_ShowCloudletClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CloudletApi_serviceDesc.Streams[3], c.cc, "/edgeproto.CloudletApi/ShowCloudlet", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletApiShowCloudletClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletApi_ShowCloudletClient interface {
	Recv() (*Cloudlet, error)
	grpc.ClientStream
}

type cloudletApiShowCloudletClient struct {
	grpc.ClientStream
}

func (x *cloudletApiShowCloudletClient) Recv() (*Cloudlet, error) {
	m := new(Cloudlet)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cloudletApiClient) GetCloudletManifest(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (*CloudletManifest, error) {
	out := new(CloudletManifest)
	err := grpc.Invoke(ctx, "/edgeproto.CloudletApi/GetCloudletManifest", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) GetCloudletProps(ctx context.Context, in *CloudletProps, opts ...grpc.CallOption) (*CloudletProps, error) {
	out := new(CloudletProps)
	err := grpc.Invoke(ctx, "/edgeproto.CloudletApi/GetCloudletProps", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) AddCloudletResMapping(ctx context.Context, in *CloudletResMap, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.CloudletApi/AddCloudletResMapping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) RemoveCloudletResMapping(ctx context.Context, in *CloudletResMap, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.CloudletApi/RemoveCloudletResMapping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) FindFlavorMatch(ctx context.Context, in *FlavorMatch, opts ...grpc.CallOption) (*FlavorMatch, error) {
	out := new(FlavorMatch)
	err := grpc.Invoke(ctx, "/edgeproto.CloudletApi/FindFlavorMatch", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CloudletApi service

type CloudletApiServer interface {
	// Create Cloudlet. Sets up Cloudlet services on the Operator's compute resources,
	// and integrated as part of MobiledgeX edge resource portfolio.
	// These resources are managed from the Edge Controller.
	CreateCloudlet(*Cloudlet, CloudletApi_CreateCloudletServer) error
	// Delete Cloudlet. Removes the Cloudlet services where they are no longer managed
	// from the Edge Controller.
	DeleteCloudlet(*Cloudlet, CloudletApi_DeleteCloudletServer) error
	// Update Cloudlet. Updates the Cloudlet configuration and manages the upgrade of Cloudlet services.
	UpdateCloudlet(*Cloudlet, CloudletApi_UpdateCloudletServer) error
	// Show Cloudlets. Lists all the cloudlets managed from Edge Controller.
	ShowCloudlet(*Cloudlet, CloudletApi_ShowCloudletServer) error
	// Get Cloudlet Manifest. Shows deployment manifest required to setup cloudlet
	GetCloudletManifest(context.Context, *Cloudlet) (*CloudletManifest, error)
	// Get Cloudlet Properties. Shows all the infra properties used to setup cloudlet
	GetCloudletProps(context.Context, *CloudletProps) (*CloudletProps, error)
	// Add Optional Resource tag table
	AddCloudletResMapping(context.Context, *CloudletResMap) (*Result, error)
	// Add Optional Resource tag table
	RemoveCloudletResMapping(context.Context, *CloudletResMap) (*Result, error)
	// Discover if flavor produces a matching platform flavor
	FindFlavorMatch(context.Context, *FlavorMatch) (*FlavorMatch, error)
}

func RegisterCloudletApiServer(s *grpc.Server, srv CloudletApiServer) {
	s.RegisterService(&_CloudletApi_serviceDesc, srv)
}

func _CloudletApi_CreateCloudlet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Cloudlet)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletApiServer).CreateCloudlet(m, &cloudletApiCreateCloudletServer{stream})
}

type CloudletApi_CreateCloudletServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type cloudletApiCreateCloudletServer struct {
	grpc.ServerStream
}

func (x *cloudletApiCreateCloudletServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _CloudletApi_DeleteCloudlet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Cloudlet)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletApiServer).DeleteCloudlet(m, &cloudletApiDeleteCloudletServer{stream})
}

type CloudletApi_DeleteCloudletServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type cloudletApiDeleteCloudletServer struct {
	grpc.ServerStream
}

func (x *cloudletApiDeleteCloudletServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _CloudletApi_UpdateCloudlet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Cloudlet)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletApiServer).UpdateCloudlet(m, &cloudletApiUpdateCloudletServer{stream})
}

type CloudletApi_UpdateCloudletServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type cloudletApiUpdateCloudletServer struct {
	grpc.ServerStream
}

func (x *cloudletApiUpdateCloudletServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _CloudletApi_ShowCloudlet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Cloudlet)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletApiServer).ShowCloudlet(m, &cloudletApiShowCloudletServer{stream})
}

type CloudletApi_ShowCloudletServer interface {
	Send(*Cloudlet) error
	grpc.ServerStream
}

type cloudletApiShowCloudletServer struct {
	grpc.ServerStream
}

func (x *cloudletApiShowCloudletServer) Send(m *Cloudlet) error {
	return x.ServerStream.SendMsg(m)
}

func _CloudletApi_GetCloudletManifest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Cloudlet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).GetCloudletManifest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/GetCloudletManifest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).GetCloudletManifest(ctx, req.(*Cloudlet))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_GetCloudletProps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletProps)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).GetCloudletProps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/GetCloudletProps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).GetCloudletProps(ctx, req.(*CloudletProps))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_AddCloudletResMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletResMap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).AddCloudletResMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/AddCloudletResMapping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).AddCloudletResMapping(ctx, req.(*CloudletResMap))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_RemoveCloudletResMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletResMap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).RemoveCloudletResMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/RemoveCloudletResMapping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).RemoveCloudletResMapping(ctx, req.(*CloudletResMap))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_FindFlavorMatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlavorMatch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).FindFlavorMatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/FindFlavorMatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).FindFlavorMatch(ctx, req.(*FlavorMatch))
	}
	return interceptor(ctx, in, info, handler)
}

var _CloudletApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.CloudletApi",
	HandlerType: (*CloudletApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCloudletManifest",
			Handler:    _CloudletApi_GetCloudletManifest_Handler,
		},
		{
			MethodName: "GetCloudletProps",
			Handler:    _CloudletApi_GetCloudletProps_Handler,
		},
		{
			MethodName: "AddCloudletResMapping",
			Handler:    _CloudletApi_AddCloudletResMapping_Handler,
		},
		{
			MethodName: "RemoveCloudletResMapping",
			Handler:    _CloudletApi_RemoveCloudletResMapping_Handler,
		},
		{
			MethodName: "FindFlavorMatch",
			Handler:    _CloudletApi_FindFlavorMatch_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreateCloudlet",
			Handler:       _CloudletApi_CreateCloudlet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DeleteCloudlet",
			Handler:       _CloudletApi_DeleteCloudlet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdateCloudlet",
			Handler:       _CloudletApi_UpdateCloudlet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowCloudlet",
			Handler:       _CloudletApi_ShowCloudlet_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cloudlet.proto",
}

// Client API for CloudletInfoApi service

type CloudletInfoApiClient interface {
	// Show CloudletInfos
	ShowCloudletInfo(ctx context.Context, in *CloudletInfo, opts ...grpc.CallOption) (CloudletInfoApi_ShowCloudletInfoClient, error)
	// Inject (create) a CloudletInfo for regression testing
	InjectCloudletInfo(ctx context.Context, in *CloudletInfo, opts ...grpc.CallOption) (*Result, error)
	// Evict (delete) a CloudletInfo for regression testing
	EvictCloudletInfo(ctx context.Context, in *CloudletInfo, opts ...grpc.CallOption) (*Result, error)
}

type cloudletInfoApiClient struct {
	cc *grpc.ClientConn
}

func NewCloudletInfoApiClient(cc *grpc.ClientConn) CloudletInfoApiClient {
	return &cloudletInfoApiClient{cc}
}

func (c *cloudletInfoApiClient) ShowCloudletInfo(ctx context.Context, in *CloudletInfo, opts ...grpc.CallOption) (CloudletInfoApi_ShowCloudletInfoClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CloudletInfoApi_serviceDesc.Streams[0], c.cc, "/edgeproto.CloudletInfoApi/ShowCloudletInfo", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletInfoApiShowCloudletInfoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletInfoApi_ShowCloudletInfoClient interface {
	Recv() (*CloudletInfo, error)
	grpc.ClientStream
}

type cloudletInfoApiShowCloudletInfoClient struct {
	grpc.ClientStream
}

func (x *cloudletInfoApiShowCloudletInfoClient) Recv() (*CloudletInfo, error) {
	m := new(CloudletInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cloudletInfoApiClient) InjectCloudletInfo(ctx context.Context, in *CloudletInfo, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.CloudletInfoApi/InjectCloudletInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletInfoApiClient) EvictCloudletInfo(ctx context.Context, in *CloudletInfo, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.CloudletInfoApi/EvictCloudletInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CloudletInfoApi service

type CloudletInfoApiServer interface {
	// Show CloudletInfos
	ShowCloudletInfo(*CloudletInfo, CloudletInfoApi_ShowCloudletInfoServer) error
	// Inject (create) a CloudletInfo for regression testing
	InjectCloudletInfo(context.Context, *CloudletInfo) (*Result, error)
	// Evict (delete) a CloudletInfo for regression testing
	EvictCloudletInfo(context.Context, *CloudletInfo) (*Result, error)
}

func RegisterCloudletInfoApiServer(s *grpc.Server, srv CloudletInfoApiServer) {
	s.RegisterService(&_CloudletInfoApi_serviceDesc, srv)
}

func _CloudletInfoApi_ShowCloudletInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CloudletInfo)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletInfoApiServer).ShowCloudletInfo(m, &cloudletInfoApiShowCloudletInfoServer{stream})
}

type CloudletInfoApi_ShowCloudletInfoServer interface {
	Send(*CloudletInfo) error
	grpc.ServerStream
}

type cloudletInfoApiShowCloudletInfoServer struct {
	grpc.ServerStream
}

func (x *cloudletInfoApiShowCloudletInfoServer) Send(m *CloudletInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _CloudletInfoApi_InjectCloudletInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletInfoApiServer).InjectCloudletInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletInfoApi/InjectCloudletInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletInfoApiServer).InjectCloudletInfo(ctx, req.(*CloudletInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletInfoApi_EvictCloudletInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletInfoApiServer).EvictCloudletInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletInfoApi/EvictCloudletInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletInfoApiServer).EvictCloudletInfo(ctx, req.(*CloudletInfo))
	}
	return interceptor(ctx, in, info, handler)
}

var _CloudletInfoApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.CloudletInfoApi",
	HandlerType: (*CloudletInfoApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InjectCloudletInfo",
			Handler:    _CloudletInfoApi_InjectCloudletInfo_Handler,
		},
		{
			MethodName: "EvictCloudletInfo",
			Handler:    _CloudletInfoApi_EvictCloudletInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowCloudletInfo",
			Handler:       _CloudletInfoApi_ShowCloudletInfo_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cloudlet.proto",
}

// Client API for CloudletMetricsApi service

type CloudletMetricsApiClient interface {
	// Show Cloudlet metrics
	ShowCloudletMetrics(ctx context.Context, in *CloudletMetrics, opts ...grpc.CallOption) (CloudletMetricsApi_ShowCloudletMetricsClient, error)
}

type cloudletMetricsApiClient struct {
	cc *grpc.ClientConn
}

func NewCloudletMetricsApiClient(cc *grpc.ClientConn) CloudletMetricsApiClient {
	return &cloudletMetricsApiClient{cc}
}

func (c *cloudletMetricsApiClient) ShowCloudletMetrics(ctx context.Context, in *CloudletMetrics, opts ...grpc.CallOption) (CloudletMetricsApi_ShowCloudletMetricsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CloudletMetricsApi_serviceDesc.Streams[0], c.cc, "/edgeproto.CloudletMetricsApi/ShowCloudletMetrics", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletMetricsApiShowCloudletMetricsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletMetricsApi_ShowCloudletMetricsClient interface {
	Recv() (*CloudletMetrics, error)
	grpc.ClientStream
}

type cloudletMetricsApiShowCloudletMetricsClient struct {
	grpc.ClientStream
}

func (x *cloudletMetricsApiShowCloudletMetricsClient) Recv() (*CloudletMetrics, error) {
	m := new(CloudletMetrics)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for CloudletMetricsApi service

type CloudletMetricsApiServer interface {
	// Show Cloudlet metrics
	ShowCloudletMetrics(*CloudletMetrics, CloudletMetricsApi_ShowCloudletMetricsServer) error
}

func RegisterCloudletMetricsApiServer(s *grpc.Server, srv CloudletMetricsApiServer) {
	s.RegisterService(&_CloudletMetricsApi_serviceDesc, srv)
}

func _CloudletMetricsApi_ShowCloudletMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CloudletMetrics)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletMetricsApiServer).ShowCloudletMetrics(m, &cloudletMetricsApiShowCloudletMetricsServer{stream})
}

type CloudletMetricsApi_ShowCloudletMetricsServer interface {
	Send(*CloudletMetrics) error
	grpc.ServerStream
}

type cloudletMetricsApiShowCloudletMetricsServer struct {
	grpc.ServerStream
}

func (x *cloudletMetricsApiShowCloudletMetricsServer) Send(m *CloudletMetrics) error {
	return x.ServerStream.SendMsg(m)
}

var _CloudletMetricsApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.CloudletMetricsApi",
	HandlerType: (*CloudletMetricsApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowCloudletMetrics",
			Handler:       _CloudletMetricsApi_ShowCloudletMetrics_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cloudlet.proto",
}

func (m *CloudletKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Organization) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Organization)))
		i += copy(dAtA[i:], m.Organization)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *OperationTimeLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperationTimeLimits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CreateClusterInstTimeout != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.CreateClusterInstTimeout))
	}
	if m.UpdateClusterInstTimeout != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.UpdateClusterInstTimeout))
	}
	if m.DeleteClusterInstTimeout != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.DeleteClusterInstTimeout))
	}
	if m.CreateAppInstTimeout != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.CreateAppInstTimeout))
	}
	if m.UpdateAppInstTimeout != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.UpdateAppInstTimeout))
	}
	if m.DeleteAppInstTimeout != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.DeleteAppInstTimeout))
	}
	return i, nil
}

func (m *PlatformConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlatformConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ContainerRegistryPath) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.ContainerRegistryPath)))
		i += copy(dAtA[i:], m.ContainerRegistryPath)
	}
	if len(m.CloudletVmImagePath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.CloudletVmImagePath)))
		i += copy(dAtA[i:], m.CloudletVmImagePath)
	}
	if len(m.NotifyCtrlAddrs) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.NotifyCtrlAddrs)))
		i += copy(dAtA[i:], m.NotifyCtrlAddrs)
	}
	if len(m.VaultAddr) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.VaultAddr)))
		i += copy(dAtA[i:], m.VaultAddr)
	}
	if len(m.TlsCertFile) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.TlsCertFile)))
		i += copy(dAtA[i:], m.TlsCertFile)
	}
	if len(m.EnvVar) > 0 {
		for k, _ := range m.EnvVar {
			dAtA[i] = 0x32
			i++
			v := m.EnvVar[k]
			mapSize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			i = encodeVarintCloudlet(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.PlatformTag) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.PlatformTag)))
		i += copy(dAtA[i:], m.PlatformTag)
	}
	if m.TestMode {
		dAtA[i] = 0x48
		i++
		if m.TestMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Span) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Span)))
		i += copy(dAtA[i:], m.Span)
	}
	if m.CleanupMode {
		dAtA[i] = 0x58
		i++
		if m.CleanupMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Region) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Region)))
		i += copy(dAtA[i:], m.Region)
	}
	if m.CommercialCerts {
		dAtA[i] = 0x68
		i++
		if m.CommercialCerts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UseVaultCerts {
		dAtA[i] = 0x70
		i++
		if m.UseVaultCerts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UseVaultCas {
		dAtA[i] = 0x78
		i++
		if m.UseVaultCas {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.AppDnsRoot) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.AppDnsRoot)))
		i += copy(dAtA[i:], m.AppDnsRoot)
	}
	if len(m.ChefServerPath) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.ChefServerPath)))
		i += copy(dAtA[i:], m.ChefServerPath)
	}
	if m.ChefClientInterval != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.ChefClientInterval))
	}
	if len(m.DeploymentTag) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.DeploymentTag)))
		i += copy(dAtA[i:], m.DeploymentTag)
	}
	return i, nil
}

func (m *CloudletResMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletResMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCloudlet(dAtA, i, uint64(m.Key.Size()))
	n1, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if len(m.Mapping) > 0 {
		for k, _ := range m.Mapping {
			dAtA[i] = 0x12
			i++
			v := m.Mapping[k]
			mapSize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			i = encodeVarintCloudlet(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *InfraConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfraConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ExternalNetworkName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.ExternalNetworkName)))
		i += copy(dAtA[i:], m.ExternalNetworkName)
	}
	if len(m.FlavorName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.FlavorName)))
		i += copy(dAtA[i:], m.FlavorName)
	}
	return i, nil
}

func (m *Cloudlet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cloudlet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintCloudlet(dAtA, i, uint64(m.Key.Size()))
	n2, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x2a
	i++
	i = encodeVarintCloudlet(dAtA, i, uint64(m.Location.Size()))
	n3, err := m.Location.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if m.IpSupport != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.IpSupport))
	}
	if len(m.StaticIps) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.StaticIps)))
		i += copy(dAtA[i:], m.StaticIps)
	}
	if m.NumDynamicIps != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.NumDynamicIps))
	}
	dAtA[i] = 0x4a
	i++
	i = encodeVarintCloudlet(dAtA, i, uint64(m.TimeLimits.Size()))
	n4, err := m.TimeLimits.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x5a
	i++
	i = encodeVarintCloudlet(dAtA, i, uint64(m.Status.Size()))
	n5, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if m.State != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.State))
	}
	if m.CrmOverride != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.CrmOverride))
	}
	if m.DeploymentLocal {
		dAtA[i] = 0x70
		i++
		if m.DeploymentLocal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PlatformType != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.PlatformType))
	}
	if len(m.NotifySrvAddr) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.NotifySrvAddr)))
		i += copy(dAtA[i:], m.NotifySrvAddr)
	}
	dAtA[i] = 0x8a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintCloudlet(dAtA, i, uint64(m.Flavor.Size()))
	n6, err := m.Flavor.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if len(m.PhysicalName) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.PhysicalName)))
		i += copy(dAtA[i:], m.PhysicalName)
	}
	if len(m.EnvVar) > 0 {
		for k, _ := range m.EnvVar {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			v := m.EnvVar[k]
			mapSize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			i = encodeVarintCloudlet(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.ContainerVersion) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.ContainerVersion)))
		i += copy(dAtA[i:], m.ContainerVersion)
	}
	dAtA[i] = 0xaa
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintCloudlet(dAtA, i, uint64(m.Config.Size()))
	n7, err := m.Config.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if len(m.ResTagMap) > 0 {
		for k, _ := range m.ResTagMap {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			v := m.ResTagMap[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCloudlet(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCloudlet(uint64(len(k))) + msgSize
			i = encodeVarintCloudlet(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCloudlet(dAtA, i, uint64(v.Size()))
				n8, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n8
			}
		}
	}
	if len(m.AccessVars) > 0 {
		for k, _ := range m.AccessVars {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			v := m.AccessVars[k]
			mapSize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			i = encodeVarintCloudlet(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.VmImageVersion) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.VmImageVersion)))
		i += copy(dAtA[i:], m.VmImageVersion)
	}
	if len(m.Deployment) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Deployment)))
		i += copy(dAtA[i:], m.Deployment)
	}
	if m.InfraApiAccess != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.InfraApiAccess))
	}
	dAtA[i] = 0xe2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintCloudlet(dAtA, i, uint64(m.InfraConfig.Size()))
	n9, err := m.InfraConfig.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if len(m.ChefClientKey) > 0 {
		for k, _ := range m.ChefClientKey {
			dAtA[i] = 0xea
			i++
			dAtA[i] = 0x1
			i++
			v := m.ChefClientKey[k]
			mapSize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			i = encodeVarintCloudlet(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.MaintenanceState != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.MaintenanceState))
	}
	if m.OverridePolicyContainerVersion {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		if m.OverridePolicyContainerVersion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.VmPool) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.VmPool)))
		i += copy(dAtA[i:], m.VmPool)
	}
	return i, nil
}

func (m *FlavorMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlavorMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCloudlet(dAtA, i, uint64(m.Key.Size()))
	n10, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if len(m.FlavorName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.FlavorName)))
		i += copy(dAtA[i:], m.FlavorName)
	}
	if len(m.AvailabilityZone) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.AvailabilityZone)))
		i += copy(dAtA[i:], m.AvailabilityZone)
	}
	return i, nil
}

func (m *CloudletManifest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletManifest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Manifest) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Manifest)))
		i += copy(dAtA[i:], m.Manifest)
	}
	return i, nil
}

func (m *PropertyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropertyInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Secret {
		dAtA[i] = 0x20
		i++
		if m.Secret {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Mandatory {
		dAtA[i] = 0x28
		i++
		if m.Mandatory {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Internal {
		dAtA[i] = 0x30
		i++
		if m.Internal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CloudletProps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletProps) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlatformType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.PlatformType))
	}
	if len(m.Properties) > 0 {
		for k, _ := range m.Properties {
			dAtA[i] = 0x12
			i++
			v := m.Properties[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCloudlet(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCloudlet(uint64(len(k))) + msgSize
			i = encodeVarintCloudlet(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCloudlet(dAtA, i, uint64(v.Size()))
				n11, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n11
			}
		}
	}
	return i, nil
}

func (m *FlavorInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlavorInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Vcpus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.Vcpus))
	}
	if m.Ram != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.Ram))
	}
	if m.Disk != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.Disk))
	}
	if len(m.PropMap) > 0 {
		for k, _ := range m.PropMap {
			dAtA[i] = 0x2a
			i++
			v := m.PropMap[k]
			mapSize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			i = encodeVarintCloudlet(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *OSAZone) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OSAZone) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	return i, nil
}

func (m *OSImage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OSImage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Tags) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Tags)))
		i += copy(dAtA[i:], m.Tags)
	}
	if len(m.Properties) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Properties)))
		i += copy(dAtA[i:], m.Properties)
	}
	if len(m.DiskFormat) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.DiskFormat)))
		i += copy(dAtA[i:], m.DiskFormat)
	}
	return i, nil
}

func (m *CloudletInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintCloudlet(dAtA, i, uint64(m.Key.Size()))
	n12, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	if m.State != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.State))
	}
	if m.NotifyId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.NotifyId))
	}
	if len(m.Controller) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Controller)))
		i += copy(dAtA[i:], m.Controller)
	}
	if m.OsMaxRam != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.OsMaxRam))
	}
	if m.OsMaxVcores != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.OsMaxVcores))
	}
	if m.OsMaxVolGb != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.OsMaxVolGb))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Flavors) > 0 {
		for _, msg := range m.Flavors {
			dAtA[i] = 0x52
			i++
			i = encodeVarintCloudlet(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x5a
	i++
	i = encodeVarintCloudlet(dAtA, i, uint64(m.Status.Size()))
	n13, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	if len(m.ContainerVersion) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.ContainerVersion)))
		i += copy(dAtA[i:], m.ContainerVersion)
	}
	if len(m.AvailabilityZones) > 0 {
		for _, msg := range m.AvailabilityZones {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintCloudlet(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OsImages) > 0 {
		for _, msg := range m.OsImages {
			dAtA[i] = 0x72
			i++
			i = encodeVarintCloudlet(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ControllerCacheReceived {
		dAtA[i] = 0x78
		i++
		if m.ControllerCacheReceived {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaintenanceState != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.MaintenanceState))
	}
	return i, nil
}

func (m *CloudletMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletMetrics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Foo != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCloudlet(dAtA, i, uint64(m.Foo))
	}
	return i, nil
}

func encodeVarintCloudlet(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CloudletKey) Matches(o *CloudletKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.Organization != "" {
		if o.Organization != m.Organization {
			return false
		}
	}
	if !opts.Filter || o.Name != "" {
		if o.Name != m.Name {
			return false
		}
	}
	return true
}

func (m *CloudletKey) CopyInFields(src *CloudletKey) int {
	changed := 0
	if m.Organization != src.Organization {
		m.Organization = src.Organization
		changed++
	}
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	return changed
}

func (m *CloudletKey) DeepCopyIn(src *CloudletKey) {
	m.Organization = src.Organization
	m.Name = src.Name
}

func (m *CloudletKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal CloudletKey key string", "obj", m)
	}
	return string(key)
}

func CloudletKeyStringParse(str string, key *CloudletKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal CloudletKey key string", "str", str)
	}
}

func (m *CloudletKey) NotFoundError() error {
	return fmt.Errorf("Cloudlet key %s not found", m.GetKeyString())
}

func (m *CloudletKey) ExistsError() error {
	return fmt.Errorf("Cloudlet key %s already exists", m.GetKeyString())
}

var CloudletKeyTagOrganization = "cloudletorg"
var CloudletKeyTagName = "cloudlet"

func (m *CloudletKey) GetTags() map[string]string {
	tags := make(map[string]string)
	tags["cloudletorg"] = m.Organization
	tags["cloudlet"] = m.Name
	return tags
}

// Helper method to check that enums have valid values
func (m *CloudletKey) ValidateEnums() error {
	return nil
}

func (m *OperationTimeLimits) CopyInFields(src *OperationTimeLimits) int {
	changed := 0
	if m.CreateClusterInstTimeout != src.CreateClusterInstTimeout {
		m.CreateClusterInstTimeout = src.CreateClusterInstTimeout
		changed++
	}
	if m.UpdateClusterInstTimeout != src.UpdateClusterInstTimeout {
		m.UpdateClusterInstTimeout = src.UpdateClusterInstTimeout
		changed++
	}
	if m.DeleteClusterInstTimeout != src.DeleteClusterInstTimeout {
		m.DeleteClusterInstTimeout = src.DeleteClusterInstTimeout
		changed++
	}
	if m.CreateAppInstTimeout != src.CreateAppInstTimeout {
		m.CreateAppInstTimeout = src.CreateAppInstTimeout
		changed++
	}
	if m.UpdateAppInstTimeout != src.UpdateAppInstTimeout {
		m.UpdateAppInstTimeout = src.UpdateAppInstTimeout
		changed++
	}
	if m.DeleteAppInstTimeout != src.DeleteAppInstTimeout {
		m.DeleteAppInstTimeout = src.DeleteAppInstTimeout
		changed++
	}
	return changed
}

func (m *OperationTimeLimits) DeepCopyIn(src *OperationTimeLimits) {
	m.CreateClusterInstTimeout = src.CreateClusterInstTimeout
	m.UpdateClusterInstTimeout = src.UpdateClusterInstTimeout
	m.DeleteClusterInstTimeout = src.DeleteClusterInstTimeout
	m.CreateAppInstTimeout = src.CreateAppInstTimeout
	m.UpdateAppInstTimeout = src.UpdateAppInstTimeout
	m.DeleteAppInstTimeout = src.DeleteAppInstTimeout
}

// Helper method to check that enums have valid values
func (m *OperationTimeLimits) ValidateEnums() error {
	return nil
}

func (m *PlatformConfig) CopyInFields(src *PlatformConfig) int {
	changed := 0
	if m.ContainerRegistryPath != src.ContainerRegistryPath {
		m.ContainerRegistryPath = src.ContainerRegistryPath
		changed++
	}
	if m.CloudletVmImagePath != src.CloudletVmImagePath {
		m.CloudletVmImagePath = src.CloudletVmImagePath
		changed++
	}
	if m.NotifyCtrlAddrs != src.NotifyCtrlAddrs {
		m.NotifyCtrlAddrs = src.NotifyCtrlAddrs
		changed++
	}
	if m.VaultAddr != src.VaultAddr {
		m.VaultAddr = src.VaultAddr
		changed++
	}
	if m.TlsCertFile != src.TlsCertFile {
		m.TlsCertFile = src.TlsCertFile
		changed++
	}
	if src.EnvVar != nil {
		m.EnvVar = make(map[string]string)
		for k0, _ := range src.EnvVar {
			m.EnvVar[k0] = src.EnvVar[k0]
		}
	} else if m.EnvVar != nil {
		m.EnvVar = nil
		changed++
	}
	if m.PlatformTag != src.PlatformTag {
		m.PlatformTag = src.PlatformTag
		changed++
	}
	if m.TestMode != src.TestMode {
		m.TestMode = src.TestMode
		changed++
	}
	if m.Span != src.Span {
		m.Span = src.Span
		changed++
	}
	if m.CleanupMode != src.CleanupMode {
		m.CleanupMode = src.CleanupMode
		changed++
	}
	if m.Region != src.Region {
		m.Region = src.Region
		changed++
	}
	if m.CommercialCerts != src.CommercialCerts {
		m.CommercialCerts = src.CommercialCerts
		changed++
	}
	if m.UseVaultCerts != src.UseVaultCerts {
		m.UseVaultCerts = src.UseVaultCerts
		changed++
	}
	if m.UseVaultCas != src.UseVaultCas {
		m.UseVaultCas = src.UseVaultCas
		changed++
	}
	if m.AppDnsRoot != src.AppDnsRoot {
		m.AppDnsRoot = src.AppDnsRoot
		changed++
	}
	if m.ChefServerPath != src.ChefServerPath {
		m.ChefServerPath = src.ChefServerPath
		changed++
	}
	if m.ChefClientInterval != src.ChefClientInterval {
		m.ChefClientInterval = src.ChefClientInterval
		changed++
	}
	if m.DeploymentTag != src.DeploymentTag {
		m.DeploymentTag = src.DeploymentTag
		changed++
	}
	return changed
}

func (m *PlatformConfig) DeepCopyIn(src *PlatformConfig) {
	m.ContainerRegistryPath = src.ContainerRegistryPath
	m.CloudletVmImagePath = src.CloudletVmImagePath
	m.NotifyCtrlAddrs = src.NotifyCtrlAddrs
	m.VaultAddr = src.VaultAddr
	m.TlsCertFile = src.TlsCertFile
	if src.EnvVar != nil {
		m.EnvVar = make(map[string]string)
		for k, v := range src.EnvVar {
			m.EnvVar[k] = v
		}
	} else {
		m.EnvVar = nil
	}
	m.PlatformTag = src.PlatformTag
	m.TestMode = src.TestMode
	m.Span = src.Span
	m.CleanupMode = src.CleanupMode
	m.Region = src.Region
	m.CommercialCerts = src.CommercialCerts
	m.UseVaultCerts = src.UseVaultCerts
	m.UseVaultCas = src.UseVaultCas
	m.AppDnsRoot = src.AppDnsRoot
	m.ChefServerPath = src.ChefServerPath
	m.ChefClientInterval = src.ChefClientInterval
	m.DeploymentTag = src.DeploymentTag
}

// Helper method to check that enums have valid values
func (m *PlatformConfig) ValidateEnums() error {
	return nil
}

func (m *CloudletResMap) CopyInFields(src *CloudletResMap) int {
	changed := 0
	if m.Key.Organization != src.Key.Organization {
		m.Key.Organization = src.Key.Organization
		changed++
	}
	if m.Key.Name != src.Key.Name {
		m.Key.Name = src.Key.Name
		changed++
	}
	if src.Mapping != nil {
		m.Mapping = make(map[string]string)
		for k0, _ := range src.Mapping {
			m.Mapping[k0] = src.Mapping[k0]
		}
	} else if m.Mapping != nil {
		m.Mapping = nil
		changed++
	}
	return changed
}

func (m *CloudletResMap) DeepCopyIn(src *CloudletResMap) {
	m.Key.DeepCopyIn(&src.Key)
	if src.Mapping != nil {
		m.Mapping = make(map[string]string)
		for k, v := range src.Mapping {
			m.Mapping[k] = v
		}
	} else {
		m.Mapping = nil
	}
}

func (m *CloudletResMap) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *CloudletResMap) GetKey() *CloudletKey {
	return &m.Key
}

func (m *CloudletResMap) GetKeyVal() CloudletKey {
	return m.Key
}

func (m *CloudletResMap) SetKey(key *CloudletKey) {
	m.Key = *key
}

func CmpSortCloudletResMap(a CloudletResMap, b CloudletResMap) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *CloudletResMap) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *InfraConfig) CopyInFields(src *InfraConfig) int {
	changed := 0
	if m.ExternalNetworkName != src.ExternalNetworkName {
		m.ExternalNetworkName = src.ExternalNetworkName
		changed++
	}
	if m.FlavorName != src.FlavorName {
		m.FlavorName = src.FlavorName
		changed++
	}
	return changed
}

func (m *InfraConfig) DeepCopyIn(src *InfraConfig) {
	m.ExternalNetworkName = src.ExternalNetworkName
	m.FlavorName = src.FlavorName
}

// Helper method to check that enums have valid values
func (m *InfraConfig) ValidateEnums() error {
	return nil
}

func (m *Cloudlet) Matches(o *Cloudlet, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.IpSupport != 0 {
		if o.IpSupport != m.IpSupport {
			return false
		}
	}
	if !opts.Filter || o.StaticIps != "" {
		if o.StaticIps != m.StaticIps {
			return false
		}
	}
	if !opts.Filter || o.NumDynamicIps != 0 {
		if o.NumDynamicIps != m.NumDynamicIps {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Errors != nil {
			if m.Errors == nil && o.Errors != nil || m.Errors != nil && o.Errors == nil {
				return false
			} else if m.Errors != nil && o.Errors != nil {
				if len(m.Errors) != len(o.Errors) {
					return false
				}
				for i := 0; i < len(m.Errors); i++ {
					if o.Errors[i] != m.Errors[i] {
						return false
					}
				}
			}
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.State != 0 {
			if o.State != m.State {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.CrmOverride != 0 {
			if o.CrmOverride != m.CrmOverride {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DeploymentLocal != false {
			if o.DeploymentLocal != m.DeploymentLocal {
				return false
			}
		}
	}
	if !opts.Filter || o.PlatformType != 0 {
		if o.PlatformType != m.PlatformType {
			return false
		}
	}
	if !opts.Filter || o.NotifySrvAddr != "" {
		if o.NotifySrvAddr != m.NotifySrvAddr {
			return false
		}
	}
	if !m.Flavor.Matches(&o.Flavor, fopts...) {
		return false
	}
	if !opts.Filter || o.PhysicalName != "" {
		if o.PhysicalName != m.PhysicalName {
			return false
		}
	}
	if !opts.Filter || o.EnvVar != nil {
		if m.EnvVar == nil && o.EnvVar != nil || m.EnvVar != nil && o.EnvVar == nil {
			return false
		} else if m.EnvVar != nil && o.EnvVar != nil {
			if len(m.EnvVar) != len(o.EnvVar) {
				return false
			}
			for k, _ := range m.EnvVar {
				_, ok := o.EnvVar[k]
				if !ok {
					return false
				}
				if o.EnvVar[k] != m.EnvVar[k] {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.ContainerVersion != "" {
		if o.ContainerVersion != m.ContainerVersion {
			return false
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.ResTagMap != nil {
			if m.ResTagMap == nil && o.ResTagMap != nil || m.ResTagMap != nil && o.ResTagMap == nil {
				return false
			} else if m.ResTagMap != nil && o.ResTagMap != nil {
				if len(m.ResTagMap) != len(o.ResTagMap) {
					return false
				}
				for k, _ := range m.ResTagMap {
					_, ok := o.ResTagMap[k]
					if !ok {
						return false
					}
					if !m.ResTagMap[k].Matches(o.ResTagMap[k], fopts...) {
						return false
					}
				}
			}
		}
	}
	if !opts.Filter || o.AccessVars != nil {
		if m.AccessVars == nil && o.AccessVars != nil || m.AccessVars != nil && o.AccessVars == nil {
			return false
		} else if m.AccessVars != nil && o.AccessVars != nil {
			if len(m.AccessVars) != len(o.AccessVars) {
				return false
			}
			for k, _ := range m.AccessVars {
				_, ok := o.AccessVars[k]
				if !ok {
					return false
				}
				if o.AccessVars[k] != m.AccessVars[k] {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.VmImageVersion != "" {
		if o.VmImageVersion != m.VmImageVersion {
			return false
		}
	}
	if !opts.Filter || o.Deployment != "" {
		if o.Deployment != m.Deployment {
			return false
		}
	}
	if !opts.Filter || o.InfraApiAccess != 0 {
		if o.InfraApiAccess != m.InfraApiAccess {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.ChefClientKey != nil {
			if m.ChefClientKey == nil && o.ChefClientKey != nil || m.ChefClientKey != nil && o.ChefClientKey == nil {
				return false
			} else if m.ChefClientKey != nil && o.ChefClientKey != nil {
				if len(m.ChefClientKey) != len(o.ChefClientKey) {
					return false
				}
				for k, _ := range m.ChefClientKey {
					_, ok := o.ChefClientKey[k]
					if !ok {
						return false
					}
					if o.ChefClientKey[k] != m.ChefClientKey[k] {
						return false
					}
				}
			}
		}
	}
	if !opts.Filter || o.MaintenanceState != 0 {
		if o.MaintenanceState != m.MaintenanceState {
			return false
		}
	}
	if !opts.Filter || o.OverridePolicyContainerVersion != false {
		if o.OverridePolicyContainerVersion != m.OverridePolicyContainerVersion {
			return false
		}
	}
	if !opts.Filter || o.VmPool != "" {
		if o.VmPool != m.VmPool {
			return false
		}
	}
	return true
}

const CloudletFieldKey = "2"
const CloudletFieldKeyOrganization = "2.1"
const CloudletFieldKeyName = "2.2"
const CloudletFieldLocation = "5"
const CloudletFieldLocationLatitude = "5.1"
const CloudletFieldLocationLongitude = "5.2"
const CloudletFieldLocationHorizontalAccuracy = "5.3"
const CloudletFieldLocationVerticalAccuracy = "5.4"
const CloudletFieldLocationAltitude = "5.5"
const CloudletFieldLocationCourse = "5.6"
const CloudletFieldLocationSpeed = "5.7"
const CloudletFieldLocationTimestamp = "5.8"
const CloudletFieldLocationTimestampSeconds = "5.8.1"
const CloudletFieldLocationTimestampNanos = "5.8.2"
const CloudletFieldIpSupport = "6"
const CloudletFieldStaticIps = "7"
const CloudletFieldNumDynamicIps = "8"
const CloudletFieldTimeLimits = "9"
const CloudletFieldTimeLimitsCreateClusterInstTimeout = "9.1"
const CloudletFieldTimeLimitsUpdateClusterInstTimeout = "9.2"
const CloudletFieldTimeLimitsDeleteClusterInstTimeout = "9.3"
const CloudletFieldTimeLimitsCreateAppInstTimeout = "9.4"
const CloudletFieldTimeLimitsUpdateAppInstTimeout = "9.5"
const CloudletFieldTimeLimitsDeleteAppInstTimeout = "9.6"
const CloudletFieldErrors = "10"
const CloudletFieldStatus = "11"
const CloudletFieldStatusTaskNumber = "11.1"
const CloudletFieldStatusMaxTasks = "11.2"
const CloudletFieldStatusTaskName = "11.3"
const CloudletFieldStatusStepName = "11.4"
const CloudletFieldState = "12"
const CloudletFieldCrmOverride = "13"
const CloudletFieldDeploymentLocal = "14"
const CloudletFieldPlatformType = "15"
const CloudletFieldNotifySrvAddr = "16"
const CloudletFieldFlavor = "17"
const CloudletFieldFlavorName = "17.1"
const CloudletFieldPhysicalName = "18"
const CloudletFieldEnvVar = "19"
const CloudletFieldEnvVarKey = "19.1"
const CloudletFieldEnvVarValue = "19.2"
const CloudletFieldContainerVersion = "20"
const CloudletFieldConfig = "21"
const CloudletFieldConfigContainerRegistryPath = "21.1"
const CloudletFieldConfigCloudletVmImagePath = "21.2"
const CloudletFieldConfigNotifyCtrlAddrs = "21.3"
const CloudletFieldConfigVaultAddr = "21.4"
const CloudletFieldConfigTlsCertFile = "21.5"
const CloudletFieldConfigEnvVar = "21.6"
const CloudletFieldConfigEnvVarKey = "21.6.1"
const CloudletFieldConfigEnvVarValue = "21.6.2"
const CloudletFieldConfigPlatformTag = "21.8"
const CloudletFieldConfigTestMode = "21.9"
const CloudletFieldConfigSpan = "21.10"
const CloudletFieldConfigCleanupMode = "21.11"
const CloudletFieldConfigRegion = "21.12"
const CloudletFieldConfigCommercialCerts = "21.13"
const CloudletFieldConfigUseVaultCerts = "21.14"
const CloudletFieldConfigUseVaultCas = "21.15"
const CloudletFieldConfigAppDnsRoot = "21.16"
const CloudletFieldConfigChefServerPath = "21.17"
const CloudletFieldConfigChefClientInterval = "21.18"
const CloudletFieldConfigDeploymentTag = "21.19"
const CloudletFieldResTagMap = "22"
const CloudletFieldResTagMapKey = "22.1"
const CloudletFieldResTagMapValue = "22.2"
const CloudletFieldResTagMapValueName = "22.2.1"
const CloudletFieldResTagMapValueOrganization = "22.2.2"
const CloudletFieldAccessVars = "23"
const CloudletFieldAccessVarsKey = "23.1"
const CloudletFieldAccessVarsValue = "23.2"
const CloudletFieldVmImageVersion = "24"
const CloudletFieldDeployment = "26"
const CloudletFieldInfraApiAccess = "27"
const CloudletFieldInfraConfig = "28"
const CloudletFieldInfraConfigExternalNetworkName = "28.1"
const CloudletFieldInfraConfigFlavorName = "28.2"
const CloudletFieldChefClientKey = "29"
const CloudletFieldChefClientKeyKey = "29.1"
const CloudletFieldChefClientKeyValue = "29.2"
const CloudletFieldMaintenanceState = "30"
const CloudletFieldOverridePolicyContainerVersion = "31"
const CloudletFieldVmPool = "32"

var CloudletAllFields = []string{
	CloudletFieldKeyOrganization,
	CloudletFieldKeyName,
	CloudletFieldLocationLatitude,
	CloudletFieldLocationLongitude,
	CloudletFieldLocationHorizontalAccuracy,
	CloudletFieldLocationVerticalAccuracy,
	CloudletFieldLocationAltitude,
	CloudletFieldLocationCourse,
	CloudletFieldLocationSpeed,
	CloudletFieldLocationTimestampSeconds,
	CloudletFieldLocationTimestampNanos,
	CloudletFieldIpSupport,
	CloudletFieldStaticIps,
	CloudletFieldNumDynamicIps,
	CloudletFieldTimeLimitsCreateClusterInstTimeout,
	CloudletFieldTimeLimitsUpdateClusterInstTimeout,
	CloudletFieldTimeLimitsDeleteClusterInstTimeout,
	CloudletFieldTimeLimitsCreateAppInstTimeout,
	CloudletFieldTimeLimitsUpdateAppInstTimeout,
	CloudletFieldTimeLimitsDeleteAppInstTimeout,
	CloudletFieldErrors,
	CloudletFieldStatusTaskNumber,
	CloudletFieldStatusMaxTasks,
	CloudletFieldStatusTaskName,
	CloudletFieldStatusStepName,
	CloudletFieldState,
	CloudletFieldCrmOverride,
	CloudletFieldDeploymentLocal,
	CloudletFieldPlatformType,
	CloudletFieldNotifySrvAddr,
	CloudletFieldFlavorName,
	CloudletFieldPhysicalName,
	CloudletFieldEnvVarKey,
	CloudletFieldEnvVarValue,
	CloudletFieldContainerVersion,
	CloudletFieldConfigContainerRegistryPath,
	CloudletFieldConfigCloudletVmImagePath,
	CloudletFieldConfigNotifyCtrlAddrs,
	CloudletFieldConfigVaultAddr,
	CloudletFieldConfigTlsCertFile,
	CloudletFieldConfigEnvVarKey,
	CloudletFieldConfigEnvVarValue,
	CloudletFieldConfigPlatformTag,
	CloudletFieldConfigTestMode,
	CloudletFieldConfigSpan,
	CloudletFieldConfigCleanupMode,
	CloudletFieldConfigRegion,
	CloudletFieldConfigCommercialCerts,
	CloudletFieldConfigUseVaultCerts,
	CloudletFieldConfigUseVaultCas,
	CloudletFieldConfigAppDnsRoot,
	CloudletFieldConfigChefServerPath,
	CloudletFieldConfigChefClientInterval,
	CloudletFieldConfigDeploymentTag,
	CloudletFieldResTagMapKey,
	CloudletFieldResTagMapValueName,
	CloudletFieldResTagMapValueOrganization,
	CloudletFieldAccessVarsKey,
	CloudletFieldAccessVarsValue,
	CloudletFieldVmImageVersion,
	CloudletFieldDeployment,
	CloudletFieldInfraApiAccess,
	CloudletFieldInfraConfigExternalNetworkName,
	CloudletFieldInfraConfigFlavorName,
	CloudletFieldChefClientKeyKey,
	CloudletFieldChefClientKeyValue,
	CloudletFieldMaintenanceState,
	CloudletFieldOverridePolicyContainerVersion,
	CloudletFieldVmPool,
}

var CloudletAllFieldsMap = map[string]struct{}{
	CloudletFieldKeyOrganization:                    struct{}{},
	CloudletFieldKeyName:                            struct{}{},
	CloudletFieldLocationLatitude:                   struct{}{},
	CloudletFieldLocationLongitude:                  struct{}{},
	CloudletFieldLocationHorizontalAccuracy:         struct{}{},
	CloudletFieldLocationVerticalAccuracy:           struct{}{},
	CloudletFieldLocationAltitude:                   struct{}{},
	CloudletFieldLocationCourse:                     struct{}{},
	CloudletFieldLocationSpeed:                      struct{}{},
	CloudletFieldLocationTimestampSeconds:           struct{}{},
	CloudletFieldLocationTimestampNanos:             struct{}{},
	CloudletFieldIpSupport:                          struct{}{},
	CloudletFieldStaticIps:                          struct{}{},
	CloudletFieldNumDynamicIps:                      struct{}{},
	CloudletFieldTimeLimitsCreateClusterInstTimeout: struct{}{},
	CloudletFieldTimeLimitsUpdateClusterInstTimeout: struct{}{},
	CloudletFieldTimeLimitsDeleteClusterInstTimeout: struct{}{},
	CloudletFieldTimeLimitsCreateAppInstTimeout:     struct{}{},
	CloudletFieldTimeLimitsUpdateAppInstTimeout:     struct{}{},
	CloudletFieldTimeLimitsDeleteAppInstTimeout:     struct{}{},
	CloudletFieldErrors:                             struct{}{},
	CloudletFieldStatusTaskNumber:                   struct{}{},
	CloudletFieldStatusMaxTasks:                     struct{}{},
	CloudletFieldStatusTaskName:                     struct{}{},
	CloudletFieldStatusStepName:                     struct{}{},
	CloudletFieldState:                              struct{}{},
	CloudletFieldCrmOverride:                        struct{}{},
	CloudletFieldDeploymentLocal:                    struct{}{},
	CloudletFieldPlatformType:                       struct{}{},
	CloudletFieldNotifySrvAddr:                      struct{}{},
	CloudletFieldFlavorName:                         struct{}{},
	CloudletFieldPhysicalName:                       struct{}{},
	CloudletFieldEnvVarKey:                          struct{}{},
	CloudletFieldEnvVarValue:                        struct{}{},
	CloudletFieldContainerVersion:                   struct{}{},
	CloudletFieldConfigContainerRegistryPath:        struct{}{},
	CloudletFieldConfigCloudletVmImagePath:          struct{}{},
	CloudletFieldConfigNotifyCtrlAddrs:              struct{}{},
	CloudletFieldConfigVaultAddr:                    struct{}{},
	CloudletFieldConfigTlsCertFile:                  struct{}{},
	CloudletFieldConfigEnvVarKey:                    struct{}{},
	CloudletFieldConfigEnvVarValue:                  struct{}{},
	CloudletFieldConfigPlatformTag:                  struct{}{},
	CloudletFieldConfigTestMode:                     struct{}{},
	CloudletFieldConfigSpan:                         struct{}{},
	CloudletFieldConfigCleanupMode:                  struct{}{},
	CloudletFieldConfigRegion:                       struct{}{},
	CloudletFieldConfigCommercialCerts:              struct{}{},
	CloudletFieldConfigUseVaultCerts:                struct{}{},
	CloudletFieldConfigUseVaultCas:                  struct{}{},
	CloudletFieldConfigAppDnsRoot:                   struct{}{},
	CloudletFieldConfigChefServerPath:               struct{}{},
	CloudletFieldConfigChefClientInterval:           struct{}{},
	CloudletFieldConfigDeploymentTag:                struct{}{},
	CloudletFieldResTagMapKey:                       struct{}{},
	CloudletFieldResTagMapValueName:                 struct{}{},
	CloudletFieldResTagMapValueOrganization:         struct{}{},
	CloudletFieldAccessVarsKey:                      struct{}{},
	CloudletFieldAccessVarsValue:                    struct{}{},
	CloudletFieldVmImageVersion:                     struct{}{},
	CloudletFieldDeployment:                         struct{}{},
	CloudletFieldInfraApiAccess:                     struct{}{},
	CloudletFieldInfraConfigExternalNetworkName:     struct{}{},
	CloudletFieldInfraConfigFlavorName:              struct{}{},
	CloudletFieldChefClientKeyKey:                   struct{}{},
	CloudletFieldChefClientKeyValue:                 struct{}{},
	CloudletFieldMaintenanceState:                   struct{}{},
	CloudletFieldOverridePolicyContainerVersion:     struct{}{},
	CloudletFieldVmPool:                             struct{}{},
}

var CloudletAllFieldsStringMap = map[string]string{
	CloudletFieldKeyOrganization:                    "Key Organization",
	CloudletFieldKeyName:                            "Key Name",
	CloudletFieldLocationLatitude:                   "Location Latitude",
	CloudletFieldLocationLongitude:                  "Location Longitude",
	CloudletFieldLocationHorizontalAccuracy:         "Location Horizontal Accuracy",
	CloudletFieldLocationVerticalAccuracy:           "Location Vertical Accuracy",
	CloudletFieldLocationAltitude:                   "Location Altitude",
	CloudletFieldLocationCourse:                     "Location Course",
	CloudletFieldLocationSpeed:                      "Location Speed",
	CloudletFieldLocationTimestampSeconds:           "Location Timestamp Seconds",
	CloudletFieldLocationTimestampNanos:             "Location Timestamp Nanos",
	CloudletFieldIpSupport:                          "Ip Support",
	CloudletFieldStaticIps:                          "Static Ips",
	CloudletFieldNumDynamicIps:                      "Num Dynamic Ips",
	CloudletFieldTimeLimitsCreateClusterInstTimeout: "Time Limits Create Cluster Inst Timeout",
	CloudletFieldTimeLimitsUpdateClusterInstTimeout: "Time Limits Update Cluster Inst Timeout",
	CloudletFieldTimeLimitsDeleteClusterInstTimeout: "Time Limits Delete Cluster Inst Timeout",
	CloudletFieldTimeLimitsCreateAppInstTimeout:     "Time Limits Create App Inst Timeout",
	CloudletFieldTimeLimitsUpdateAppInstTimeout:     "Time Limits Update App Inst Timeout",
	CloudletFieldTimeLimitsDeleteAppInstTimeout:     "Time Limits Delete App Inst Timeout",
	CloudletFieldErrors:                             "Errors",
	CloudletFieldStatusTaskNumber:                   "Status Task Number",
	CloudletFieldStatusMaxTasks:                     "Status Max Tasks",
	CloudletFieldStatusTaskName:                     "Status Task Name",
	CloudletFieldStatusStepName:                     "Status Step Name",
	CloudletFieldState:                              "State",
	CloudletFieldCrmOverride:                        "Crm Override",
	CloudletFieldDeploymentLocal:                    "Deployment Local",
	CloudletFieldPlatformType:                       "Platform Type",
	CloudletFieldNotifySrvAddr:                      "Notify Srv Addr",
	CloudletFieldFlavorName:                         "Flavor Name",
	CloudletFieldPhysicalName:                       "Physical Name",
	CloudletFieldEnvVarKey:                          "Env Var Key",
	CloudletFieldEnvVarValue:                        "Env Var Value",
	CloudletFieldContainerVersion:                   "Container Version",
	CloudletFieldConfigContainerRegistryPath:        "Config Container Registry Path",
	CloudletFieldConfigCloudletVmImagePath:          "Config Cloudlet Vm Image Path",
	CloudletFieldConfigNotifyCtrlAddrs:              "Config Notify Ctrl Addrs",
	CloudletFieldConfigVaultAddr:                    "Config Vault Addr",
	CloudletFieldConfigTlsCertFile:                  "Config Tls Cert File",
	CloudletFieldConfigEnvVarKey:                    "Config Env Var Key",
	CloudletFieldConfigEnvVarValue:                  "Config Env Var Value",
	CloudletFieldConfigPlatformTag:                  "Config Platform Tag",
	CloudletFieldConfigTestMode:                     "Config Test Mode",
	CloudletFieldConfigSpan:                         "Config Span",
	CloudletFieldConfigCleanupMode:                  "Config Cleanup Mode",
	CloudletFieldConfigRegion:                       "Config Region",
	CloudletFieldConfigCommercialCerts:              "Config Commercial Certs",
	CloudletFieldConfigUseVaultCerts:                "Config Use Vault Certs",
	CloudletFieldConfigUseVaultCas:                  "Config Use Vault Cas",
	CloudletFieldConfigAppDnsRoot:                   "Config App Dns Root",
	CloudletFieldConfigChefServerPath:               "Config Chef Server Path",
	CloudletFieldConfigChefClientInterval:           "Config Chef Client Interval",
	CloudletFieldConfigDeploymentTag:                "Config Deployment Tag",
	CloudletFieldResTagMapKey:                       "Res Tag Map Key",
	CloudletFieldResTagMapValueName:                 "Res Tag Map Value Name",
	CloudletFieldResTagMapValueOrganization:         "Res Tag Map Value Organization",
	CloudletFieldAccessVarsKey:                      "Access Vars Key",
	CloudletFieldAccessVarsValue:                    "Access Vars Value",
	CloudletFieldVmImageVersion:                     "Vm Image Version",
	CloudletFieldDeployment:                         "Deployment",
	CloudletFieldInfraApiAccess:                     "Infra Api Access",
	CloudletFieldInfraConfigExternalNetworkName:     "Infra Config External Network Name",
	CloudletFieldInfraConfigFlavorName:              "Infra Config Flavor Name",
	CloudletFieldChefClientKeyKey:                   "Chef Client Key Key",
	CloudletFieldChefClientKeyValue:                 "Chef Client Key Value",
	CloudletFieldMaintenanceState:                   "Maintenance State",
	CloudletFieldOverridePolicyContainerVersion:     "Override Policy Container Version",
	CloudletFieldVmPool:                             "Vm Pool",
}

func (m *Cloudlet) IsKeyField(s string) bool {
	return strings.HasPrefix(s, CloudletFieldKey+".") || s == CloudletFieldKey
}

func (m *Cloudlet) DiffFields(o *Cloudlet, fields map[string]struct{}) {
	if m.Key.Organization != o.Key.Organization {
		fields[CloudletFieldKeyOrganization] = struct{}{}
		fields[CloudletFieldKey] = struct{}{}
	}
	if m.Key.Name != o.Key.Name {
		fields[CloudletFieldKeyName] = struct{}{}
		fields[CloudletFieldKey] = struct{}{}
	}
	if m.Location.Latitude != o.Location.Latitude {
		fields[CloudletFieldLocationLatitude] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.Location.Longitude != o.Location.Longitude {
		fields[CloudletFieldLocationLongitude] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.Location.HorizontalAccuracy != o.Location.HorizontalAccuracy {
		fields[CloudletFieldLocationHorizontalAccuracy] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.Location.VerticalAccuracy != o.Location.VerticalAccuracy {
		fields[CloudletFieldLocationVerticalAccuracy] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.Location.Altitude != o.Location.Altitude {
		fields[CloudletFieldLocationAltitude] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.Location.Course != o.Location.Course {
		fields[CloudletFieldLocationCourse] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.Location.Speed != o.Location.Speed {
		fields[CloudletFieldLocationSpeed] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.Location.Timestamp != nil && o.Location.Timestamp != nil {
		if m.Location.Timestamp.Seconds != o.Location.Timestamp.Seconds {
			fields[CloudletFieldLocationTimestampSeconds] = struct{}{}
			fields[CloudletFieldLocationTimestamp] = struct{}{}
			fields[CloudletFieldLocation] = struct{}{}
		}
		if m.Location.Timestamp.Nanos != o.Location.Timestamp.Nanos {
			fields[CloudletFieldLocationTimestampNanos] = struct{}{}
			fields[CloudletFieldLocationTimestamp] = struct{}{}
			fields[CloudletFieldLocation] = struct{}{}
		}
	} else if (m.Location.Timestamp != nil && o.Location.Timestamp == nil) || (m.Location.Timestamp == nil && o.Location.Timestamp != nil) {
		fields[CloudletFieldLocationTimestamp] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.IpSupport != o.IpSupport {
		fields[CloudletFieldIpSupport] = struct{}{}
	}
	if m.StaticIps != o.StaticIps {
		fields[CloudletFieldStaticIps] = struct{}{}
	}
	if m.NumDynamicIps != o.NumDynamicIps {
		fields[CloudletFieldNumDynamicIps] = struct{}{}
	}
	if m.TimeLimits.CreateClusterInstTimeout != o.TimeLimits.CreateClusterInstTimeout {
		fields[CloudletFieldTimeLimitsCreateClusterInstTimeout] = struct{}{}
		fields[CloudletFieldTimeLimits] = struct{}{}
	}
	if m.TimeLimits.UpdateClusterInstTimeout != o.TimeLimits.UpdateClusterInstTimeout {
		fields[CloudletFieldTimeLimitsUpdateClusterInstTimeout] = struct{}{}
		fields[CloudletFieldTimeLimits] = struct{}{}
	}
	if m.TimeLimits.DeleteClusterInstTimeout != o.TimeLimits.DeleteClusterInstTimeout {
		fields[CloudletFieldTimeLimitsDeleteClusterInstTimeout] = struct{}{}
		fields[CloudletFieldTimeLimits] = struct{}{}
	}
	if m.TimeLimits.CreateAppInstTimeout != o.TimeLimits.CreateAppInstTimeout {
		fields[CloudletFieldTimeLimitsCreateAppInstTimeout] = struct{}{}
		fields[CloudletFieldTimeLimits] = struct{}{}
	}
	if m.TimeLimits.UpdateAppInstTimeout != o.TimeLimits.UpdateAppInstTimeout {
		fields[CloudletFieldTimeLimitsUpdateAppInstTimeout] = struct{}{}
		fields[CloudletFieldTimeLimits] = struct{}{}
	}
	if m.TimeLimits.DeleteAppInstTimeout != o.TimeLimits.DeleteAppInstTimeout {
		fields[CloudletFieldTimeLimitsDeleteAppInstTimeout] = struct{}{}
		fields[CloudletFieldTimeLimits] = struct{}{}
	}
	if len(m.Errors) != len(o.Errors) {
		fields[CloudletFieldErrors] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.Errors); i0++ {
			if m.Errors[i0] != o.Errors[i0] {
				fields[CloudletFieldErrors] = struct{}{}
				break
			}
		}
	}
	if m.Status.TaskNumber != o.Status.TaskNumber {
		fields[CloudletFieldStatusTaskNumber] = struct{}{}
		fields[CloudletFieldStatus] = struct{}{}
	}
	if m.Status.MaxTasks != o.Status.MaxTasks {
		fields[CloudletFieldStatusMaxTasks] = struct{}{}
		fields[CloudletFieldStatus] = struct{}{}
	}
	if m.Status.TaskName != o.Status.TaskName {
		fields[CloudletFieldStatusTaskName] = struct{}{}
		fields[CloudletFieldStatus] = struct{}{}
	}
	if m.Status.StepName != o.Status.StepName {
		fields[CloudletFieldStatusStepName] = struct{}{}
		fields[CloudletFieldStatus] = struct{}{}
	}
	if m.State != o.State {
		fields[CloudletFieldState] = struct{}{}
	}
	if m.CrmOverride != o.CrmOverride {
		fields[CloudletFieldCrmOverride] = struct{}{}
	}
	if m.DeploymentLocal != o.DeploymentLocal {
		fields[CloudletFieldDeploymentLocal] = struct{}{}
	}
	if m.PlatformType != o.PlatformType {
		fields[CloudletFieldPlatformType] = struct{}{}
	}
	if m.NotifySrvAddr != o.NotifySrvAddr {
		fields[CloudletFieldNotifySrvAddr] = struct{}{}
	}
	if m.Flavor.Name != o.Flavor.Name {
		fields[CloudletFieldFlavorName] = struct{}{}
		fields[CloudletFieldFlavor] = struct{}{}
	}
	if m.PhysicalName != o.PhysicalName {
		fields[CloudletFieldPhysicalName] = struct{}{}
	}
	if m.EnvVar != nil && o.EnvVar != nil {
		if len(m.EnvVar) != len(o.EnvVar) {
			fields[CloudletFieldEnvVar] = struct{}{}
		} else {
			for k0, _ := range m.EnvVar {
				_, vok0 := o.EnvVar[k0]
				if !vok0 {
					fields[CloudletFieldEnvVar] = struct{}{}
				} else {
					if m.EnvVar[k0] != o.EnvVar[k0] {
						fields[CloudletFieldEnvVar] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.EnvVar != nil && o.EnvVar == nil) || (m.EnvVar == nil && o.EnvVar != nil) {
		fields[CloudletFieldEnvVar] = struct{}{}
	}
	if m.ContainerVersion != o.ContainerVersion {
		fields[CloudletFieldContainerVersion] = struct{}{}
	}
	if m.Config.ContainerRegistryPath != o.Config.ContainerRegistryPath {
		fields[CloudletFieldConfigContainerRegistryPath] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.CloudletVmImagePath != o.Config.CloudletVmImagePath {
		fields[CloudletFieldConfigCloudletVmImagePath] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.NotifyCtrlAddrs != o.Config.NotifyCtrlAddrs {
		fields[CloudletFieldConfigNotifyCtrlAddrs] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.VaultAddr != o.Config.VaultAddr {
		fields[CloudletFieldConfigVaultAddr] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.TlsCertFile != o.Config.TlsCertFile {
		fields[CloudletFieldConfigTlsCertFile] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.EnvVar != nil && o.Config.EnvVar != nil {
		if len(m.Config.EnvVar) != len(o.Config.EnvVar) {
			fields[CloudletFieldConfigEnvVar] = struct{}{}
			fields[CloudletFieldConfig] = struct{}{}
		} else {
			for k1, _ := range m.Config.EnvVar {
				_, vok1 := o.Config.EnvVar[k1]
				if !vok1 {
					fields[CloudletFieldConfigEnvVar] = struct{}{}
					fields[CloudletFieldConfig] = struct{}{}
				} else {
					if m.Config.EnvVar[k1] != o.Config.EnvVar[k1] {
						fields[CloudletFieldConfigEnvVar] = struct{}{}
						fields[CloudletFieldConfig] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.Config.EnvVar != nil && o.Config.EnvVar == nil) || (m.Config.EnvVar == nil && o.Config.EnvVar != nil) {
		fields[CloudletFieldConfigEnvVar] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.PlatformTag != o.Config.PlatformTag {
		fields[CloudletFieldConfigPlatformTag] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.TestMode != o.Config.TestMode {
		fields[CloudletFieldConfigTestMode] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.Span != o.Config.Span {
		fields[CloudletFieldConfigSpan] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.CleanupMode != o.Config.CleanupMode {
		fields[CloudletFieldConfigCleanupMode] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.Region != o.Config.Region {
		fields[CloudletFieldConfigRegion] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.CommercialCerts != o.Config.CommercialCerts {
		fields[CloudletFieldConfigCommercialCerts] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.UseVaultCerts != o.Config.UseVaultCerts {
		fields[CloudletFieldConfigUseVaultCerts] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.UseVaultCas != o.Config.UseVaultCas {
		fields[CloudletFieldConfigUseVaultCas] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.AppDnsRoot != o.Config.AppDnsRoot {
		fields[CloudletFieldConfigAppDnsRoot] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.ChefServerPath != o.Config.ChefServerPath {
		fields[CloudletFieldConfigChefServerPath] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.ChefClientInterval != o.Config.ChefClientInterval {
		fields[CloudletFieldConfigChefClientInterval] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.DeploymentTag != o.Config.DeploymentTag {
		fields[CloudletFieldConfigDeploymentTag] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.ResTagMap != nil && o.ResTagMap != nil {
		if len(m.ResTagMap) != len(o.ResTagMap) {
			fields[CloudletFieldResTagMap] = struct{}{}
		} else {
			for k0, _ := range m.ResTagMap {
				_, vok0 := o.ResTagMap[k0]
				if !vok0 {
					fields[CloudletFieldResTagMap] = struct{}{}
				} else {
					if m.ResTagMap[k0].Name != o.ResTagMap[k0].Name {
						fields[CloudletFieldResTagMapValueName] = struct{}{}
						fields[CloudletFieldResTagMapValue] = struct{}{}
						fields[CloudletFieldResTagMap] = struct{}{}
					}
					if m.ResTagMap[k0].Organization != o.ResTagMap[k0].Organization {
						fields[CloudletFieldResTagMapValueOrganization] = struct{}{}
						fields[CloudletFieldResTagMapValue] = struct{}{}
						fields[CloudletFieldResTagMap] = struct{}{}
					}
				}
			}
		}
	} else if (m.ResTagMap != nil && o.ResTagMap == nil) || (m.ResTagMap == nil && o.ResTagMap != nil) {
		fields[CloudletFieldResTagMap] = struct{}{}
	}
	if m.AccessVars != nil && o.AccessVars != nil {
		if len(m.AccessVars) != len(o.AccessVars) {
			fields[CloudletFieldAccessVars] = struct{}{}
		} else {
			for k0, _ := range m.AccessVars {
				_, vok0 := o.AccessVars[k0]
				if !vok0 {
					fields[CloudletFieldAccessVars] = struct{}{}
				} else {
					if m.AccessVars[k0] != o.AccessVars[k0] {
						fields[CloudletFieldAccessVars] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.AccessVars != nil && o.AccessVars == nil) || (m.AccessVars == nil && o.AccessVars != nil) {
		fields[CloudletFieldAccessVars] = struct{}{}
	}
	if m.VmImageVersion != o.VmImageVersion {
		fields[CloudletFieldVmImageVersion] = struct{}{}
	}
	if m.Deployment != o.Deployment {
		fields[CloudletFieldDeployment] = struct{}{}
	}
	if m.InfraApiAccess != o.InfraApiAccess {
		fields[CloudletFieldInfraApiAccess] = struct{}{}
	}
	if m.InfraConfig.ExternalNetworkName != o.InfraConfig.ExternalNetworkName {
		fields[CloudletFieldInfraConfigExternalNetworkName] = struct{}{}
		fields[CloudletFieldInfraConfig] = struct{}{}
	}
	if m.InfraConfig.FlavorName != o.InfraConfig.FlavorName {
		fields[CloudletFieldInfraConfigFlavorName] = struct{}{}
		fields[CloudletFieldInfraConfig] = struct{}{}
	}
	if m.ChefClientKey != nil && o.ChefClientKey != nil {
		if len(m.ChefClientKey) != len(o.ChefClientKey) {
			fields[CloudletFieldChefClientKey] = struct{}{}
		} else {
			for k0, _ := range m.ChefClientKey {
				_, vok0 := o.ChefClientKey[k0]
				if !vok0 {
					fields[CloudletFieldChefClientKey] = struct{}{}
				} else {
					if m.ChefClientKey[k0] != o.ChefClientKey[k0] {
						fields[CloudletFieldChefClientKey] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.ChefClientKey != nil && o.ChefClientKey == nil) || (m.ChefClientKey == nil && o.ChefClientKey != nil) {
		fields[CloudletFieldChefClientKey] = struct{}{}
	}
	if m.MaintenanceState != o.MaintenanceState {
		fields[CloudletFieldMaintenanceState] = struct{}{}
	}
	if m.OverridePolicyContainerVersion != o.OverridePolicyContainerVersion {
		fields[CloudletFieldOverridePolicyContainerVersion] = struct{}{}
	}
	if m.VmPool != o.VmPool {
		fields[CloudletFieldVmPool] = struct{}{}
	}
}

var UpdateCloudletFieldsMap = map[string]struct{}{
	CloudletFieldLocation:                           struct{}{},
	CloudletFieldLocationLatitude:                   struct{}{},
	CloudletFieldLocationLongitude:                  struct{}{},
	CloudletFieldLocationAltitude:                   struct{}{},
	CloudletFieldIpSupport:                          struct{}{},
	CloudletFieldStaticIps:                          struct{}{},
	CloudletFieldNumDynamicIps:                      struct{}{},
	CloudletFieldTimeLimits:                         struct{}{},
	CloudletFieldTimeLimitsCreateClusterInstTimeout: struct{}{},
	CloudletFieldTimeLimitsUpdateClusterInstTimeout: struct{}{},
	CloudletFieldTimeLimitsDeleteClusterInstTimeout: struct{}{},
	CloudletFieldTimeLimitsCreateAppInstTimeout:     struct{}{},
	CloudletFieldTimeLimitsUpdateAppInstTimeout:     struct{}{},
	CloudletFieldTimeLimitsDeleteAppInstTimeout:     struct{}{},
	CloudletFieldCrmOverride:                        struct{}{},
	CloudletFieldEnvVar:                             struct{}{},
	CloudletFieldEnvVarValue:                        struct{}{},
	CloudletFieldAccessVars:                         struct{}{},
	CloudletFieldAccessVarsValue:                    struct{}{},
	CloudletFieldMaintenanceState:                   struct{}{},
}

func (m *Cloudlet) ValidateUpdateFields() error {
	if m.Fields == nil {
		return fmt.Errorf("nothing specified to update")
	}
	fmap := MakeFieldMap(m.Fields)
	badFieldStrs := []string{}
	for field, _ := range fmap {
		if m.IsKeyField(field) {
			continue
		}
		if _, ok := UpdateCloudletFieldsMap[field]; !ok {
			if _, ok := CloudletAllFieldsStringMap[field]; !ok {
				continue
			}
			badFieldStrs = append(badFieldStrs, CloudletAllFieldsStringMap[field])
		}
	}
	if len(badFieldStrs) > 0 {
		return fmt.Errorf("specified field(s) %s cannot be modified", strings.Join(badFieldStrs, ","))
	}
	return nil
}

func (m *Cloudlet) CopyInFields(src *Cloudlet) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
		if _, set := fmap["2.2"]; set {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
	}
	if _, set := fmap["5"]; set {
		if _, set := fmap["5.1"]; set {
			if m.Location.Latitude != src.Location.Latitude {
				m.Location.Latitude = src.Location.Latitude
				changed++
			}
		}
		if _, set := fmap["5.2"]; set {
			if m.Location.Longitude != src.Location.Longitude {
				m.Location.Longitude = src.Location.Longitude
				changed++
			}
		}
		if _, set := fmap["5.3"]; set {
			if m.Location.HorizontalAccuracy != src.Location.HorizontalAccuracy {
				m.Location.HorizontalAccuracy = src.Location.HorizontalAccuracy
				changed++
			}
		}
		if _, set := fmap["5.4"]; set {
			if m.Location.VerticalAccuracy != src.Location.VerticalAccuracy {
				m.Location.VerticalAccuracy = src.Location.VerticalAccuracy
				changed++
			}
		}
		if _, set := fmap["5.5"]; set {
			if m.Location.Altitude != src.Location.Altitude {
				m.Location.Altitude = src.Location.Altitude
				changed++
			}
		}
		if _, set := fmap["5.6"]; set {
			if m.Location.Course != src.Location.Course {
				m.Location.Course = src.Location.Course
				changed++
			}
		}
		if _, set := fmap["5.7"]; set {
			if m.Location.Speed != src.Location.Speed {
				m.Location.Speed = src.Location.Speed
				changed++
			}
		}
		if _, set := fmap["5.8"]; set {
			if src.Location.Timestamp != nil {
				m.Location.Timestamp = &distributed_match_engine.Timestamp{}
				if _, set := fmap["5.8.1"]; set {
					if m.Location.Timestamp.Seconds != src.Location.Timestamp.Seconds {
						m.Location.Timestamp.Seconds = src.Location.Timestamp.Seconds
						changed++
					}
				}
				if _, set := fmap["5.8.2"]; set {
					if m.Location.Timestamp.Nanos != src.Location.Timestamp.Nanos {
						m.Location.Timestamp.Nanos = src.Location.Timestamp.Nanos
						changed++
					}
				}
			} else if m.Location.Timestamp != nil {
				m.Location.Timestamp = nil
				changed++
			}
		}
	}
	if _, set := fmap["6"]; set {
		if m.IpSupport != src.IpSupport {
			m.IpSupport = src.IpSupport
			changed++
		}
	}
	if _, set := fmap["7"]; set {
		if m.StaticIps != src.StaticIps {
			m.StaticIps = src.StaticIps
			changed++
		}
	}
	if _, set := fmap["8"]; set {
		if m.NumDynamicIps != src.NumDynamicIps {
			m.NumDynamicIps = src.NumDynamicIps
			changed++
		}
	}
	if _, set := fmap["9"]; set {
		if _, set := fmap["9.1"]; set {
			if m.TimeLimits.CreateClusterInstTimeout != src.TimeLimits.CreateClusterInstTimeout {
				m.TimeLimits.CreateClusterInstTimeout = src.TimeLimits.CreateClusterInstTimeout
				changed++
			}
		}
		if _, set := fmap["9.2"]; set {
			if m.TimeLimits.UpdateClusterInstTimeout != src.TimeLimits.UpdateClusterInstTimeout {
				m.TimeLimits.UpdateClusterInstTimeout = src.TimeLimits.UpdateClusterInstTimeout
				changed++
			}
		}
		if _, set := fmap["9.3"]; set {
			if m.TimeLimits.DeleteClusterInstTimeout != src.TimeLimits.DeleteClusterInstTimeout {
				m.TimeLimits.DeleteClusterInstTimeout = src.TimeLimits.DeleteClusterInstTimeout
				changed++
			}
		}
		if _, set := fmap["9.4"]; set {
			if m.TimeLimits.CreateAppInstTimeout != src.TimeLimits.CreateAppInstTimeout {
				m.TimeLimits.CreateAppInstTimeout = src.TimeLimits.CreateAppInstTimeout
				changed++
			}
		}
		if _, set := fmap["9.5"]; set {
			if m.TimeLimits.UpdateAppInstTimeout != src.TimeLimits.UpdateAppInstTimeout {
				m.TimeLimits.UpdateAppInstTimeout = src.TimeLimits.UpdateAppInstTimeout
				changed++
			}
		}
		if _, set := fmap["9.6"]; set {
			if m.TimeLimits.DeleteAppInstTimeout != src.TimeLimits.DeleteAppInstTimeout {
				m.TimeLimits.DeleteAppInstTimeout = src.TimeLimits.DeleteAppInstTimeout
				changed++
			}
		}
	}
	if _, set := fmap["10"]; set {
		if src.Errors != nil {
			m.Errors = src.Errors
			changed++
		} else if m.Errors != nil {
			m.Errors = nil
			changed++
		}
	}
	if _, set := fmap["11"]; set {
		if _, set := fmap["11.1"]; set {
			if m.Status.TaskNumber != src.Status.TaskNumber {
				m.Status.TaskNumber = src.Status.TaskNumber
				changed++
			}
		}
		if _, set := fmap["11.2"]; set {
			if m.Status.MaxTasks != src.Status.MaxTasks {
				m.Status.MaxTasks = src.Status.MaxTasks
				changed++
			}
		}
		if _, set := fmap["11.3"]; set {
			if m.Status.TaskName != src.Status.TaskName {
				m.Status.TaskName = src.Status.TaskName
				changed++
			}
		}
		if _, set := fmap["11.4"]; set {
			if m.Status.StepName != src.Status.StepName {
				m.Status.StepName = src.Status.StepName
				changed++
			}
		}
	}
	if _, set := fmap["12"]; set {
		if m.State != src.State {
			m.State = src.State
			changed++
		}
	}
	if _, set := fmap["13"]; set {
		if m.CrmOverride != src.CrmOverride {
			m.CrmOverride = src.CrmOverride
			changed++
		}
	}
	if _, set := fmap["14"]; set {
		if m.DeploymentLocal != src.DeploymentLocal {
			m.DeploymentLocal = src.DeploymentLocal
			changed++
		}
	}
	if _, set := fmap["15"]; set {
		if m.PlatformType != src.PlatformType {
			m.PlatformType = src.PlatformType
			changed++
		}
	}
	if _, set := fmap["16"]; set {
		if m.NotifySrvAddr != src.NotifySrvAddr {
			m.NotifySrvAddr = src.NotifySrvAddr
			changed++
		}
	}
	if _, set := fmap["17"]; set {
		if _, set := fmap["17.1"]; set {
			if m.Flavor.Name != src.Flavor.Name {
				m.Flavor.Name = src.Flavor.Name
				changed++
			}
		}
	}
	if _, set := fmap["18"]; set {
		if m.PhysicalName != src.PhysicalName {
			m.PhysicalName = src.PhysicalName
			changed++
		}
	}
	if _, set := fmap["19"]; set {
		if src.EnvVar != nil {
			m.EnvVar = make(map[string]string)
			for k0, _ := range src.EnvVar {
				m.EnvVar[k0] = src.EnvVar[k0]
			}
		} else if m.EnvVar != nil {
			m.EnvVar = nil
			changed++
		}
	}
	if _, set := fmap["20"]; set {
		if m.ContainerVersion != src.ContainerVersion {
			m.ContainerVersion = src.ContainerVersion
			changed++
		}
	}
	if _, set := fmap["21"]; set {
		if _, set := fmap["21.1"]; set {
			if m.Config.ContainerRegistryPath != src.Config.ContainerRegistryPath {
				m.Config.ContainerRegistryPath = src.Config.ContainerRegistryPath
				changed++
			}
		}
		if _, set := fmap["21.2"]; set {
			if m.Config.CloudletVmImagePath != src.Config.CloudletVmImagePath {
				m.Config.CloudletVmImagePath = src.Config.CloudletVmImagePath
				changed++
			}
		}
		if _, set := fmap["21.3"]; set {
			if m.Config.NotifyCtrlAddrs != src.Config.NotifyCtrlAddrs {
				m.Config.NotifyCtrlAddrs = src.Config.NotifyCtrlAddrs
				changed++
			}
		}
		if _, set := fmap["21.4"]; set {
			if m.Config.VaultAddr != src.Config.VaultAddr {
				m.Config.VaultAddr = src.Config.VaultAddr
				changed++
			}
		}
		if _, set := fmap["21.5"]; set {
			if m.Config.TlsCertFile != src.Config.TlsCertFile {
				m.Config.TlsCertFile = src.Config.TlsCertFile
				changed++
			}
		}
		if _, set := fmap["21.6"]; set {
			if src.Config.EnvVar != nil {
				m.Config.EnvVar = make(map[string]string)
				for k1, _ := range src.Config.EnvVar {
					m.Config.EnvVar[k1] = src.Config.EnvVar[k1]
				}
			} else if m.Config.EnvVar != nil {
				m.Config.EnvVar = nil
				changed++
			}
		}
		if _, set := fmap["21.8"]; set {
			if m.Config.PlatformTag != src.Config.PlatformTag {
				m.Config.PlatformTag = src.Config.PlatformTag
				changed++
			}
		}
		if _, set := fmap["21.9"]; set {
			if m.Config.TestMode != src.Config.TestMode {
				m.Config.TestMode = src.Config.TestMode
				changed++
			}
		}
		if _, set := fmap["21.10"]; set {
			if m.Config.Span != src.Config.Span {
				m.Config.Span = src.Config.Span
				changed++
			}
		}
		if _, set := fmap["21.11"]; set {
			if m.Config.CleanupMode != src.Config.CleanupMode {
				m.Config.CleanupMode = src.Config.CleanupMode
				changed++
			}
		}
		if _, set := fmap["21.12"]; set {
			if m.Config.Region != src.Config.Region {
				m.Config.Region = src.Config.Region
				changed++
			}
		}
		if _, set := fmap["21.13"]; set {
			if m.Config.CommercialCerts != src.Config.CommercialCerts {
				m.Config.CommercialCerts = src.Config.CommercialCerts
				changed++
			}
		}
		if _, set := fmap["21.14"]; set {
			if m.Config.UseVaultCerts != src.Config.UseVaultCerts {
				m.Config.UseVaultCerts = src.Config.UseVaultCerts
				changed++
			}
		}
		if _, set := fmap["21.15"]; set {
			if m.Config.UseVaultCas != src.Config.UseVaultCas {
				m.Config.UseVaultCas = src.Config.UseVaultCas
				changed++
			}
		}
		if _, set := fmap["21.16"]; set {
			if m.Config.AppDnsRoot != src.Config.AppDnsRoot {
				m.Config.AppDnsRoot = src.Config.AppDnsRoot
				changed++
			}
		}
		if _, set := fmap["21.17"]; set {
			if m.Config.ChefServerPath != src.Config.ChefServerPath {
				m.Config.ChefServerPath = src.Config.ChefServerPath
				changed++
			}
		}
		if _, set := fmap["21.18"]; set {
			if m.Config.ChefClientInterval != src.Config.ChefClientInterval {
				m.Config.ChefClientInterval = src.Config.ChefClientInterval
				changed++
			}
		}
		if _, set := fmap["21.19"]; set {
			if m.Config.DeploymentTag != src.Config.DeploymentTag {
				m.Config.DeploymentTag = src.Config.DeploymentTag
				changed++
			}
		}
	}
	if _, set := fmap["22"]; set {
		if src.ResTagMap != nil {
			m.ResTagMap = make(map[string]*ResTagTableKey)
			for k0, _ := range src.ResTagMap {
				m.ResTagMap[k0] = &ResTagTableKey{}
				if _, set := fmap["22.1"]; set {
					if m.ResTagMap[k0].Name != src.ResTagMap[k0].Name {
						m.ResTagMap[k0].Name = src.ResTagMap[k0].Name
						changed++
					}
				}
				if _, set := fmap["22.2"]; set {
					if m.ResTagMap[k0].Organization != src.ResTagMap[k0].Organization {
						m.ResTagMap[k0].Organization = src.ResTagMap[k0].Organization
						changed++
					}
				}
			}
		} else if m.ResTagMap != nil {
			m.ResTagMap = nil
			changed++
		}
	}
	if _, set := fmap["23"]; set {
		if src.AccessVars != nil {
			m.AccessVars = make(map[string]string)
			for k0, _ := range src.AccessVars {
				m.AccessVars[k0] = src.AccessVars[k0]
			}
		} else if m.AccessVars != nil {
			m.AccessVars = nil
			changed++
		}
	}
	if _, set := fmap["24"]; set {
		if m.VmImageVersion != src.VmImageVersion {
			m.VmImageVersion = src.VmImageVersion
			changed++
		}
	}
	if _, set := fmap["26"]; set {
		if m.Deployment != src.Deployment {
			m.Deployment = src.Deployment
			changed++
		}
	}
	if _, set := fmap["27"]; set {
		if m.InfraApiAccess != src.InfraApiAccess {
			m.InfraApiAccess = src.InfraApiAccess
			changed++
		}
	}
	if _, set := fmap["28"]; set {
		if _, set := fmap["28.1"]; set {
			if m.InfraConfig.ExternalNetworkName != src.InfraConfig.ExternalNetworkName {
				m.InfraConfig.ExternalNetworkName = src.InfraConfig.ExternalNetworkName
				changed++
			}
		}
		if _, set := fmap["28.2"]; set {
			if m.InfraConfig.FlavorName != src.InfraConfig.FlavorName {
				m.InfraConfig.FlavorName = src.InfraConfig.FlavorName
				changed++
			}
		}
	}
	if _, set := fmap["29"]; set {
		if src.ChefClientKey != nil {
			m.ChefClientKey = make(map[string]string)
			for k0, _ := range src.ChefClientKey {
				m.ChefClientKey[k0] = src.ChefClientKey[k0]
			}
		} else if m.ChefClientKey != nil {
			m.ChefClientKey = nil
			changed++
		}
	}
	if _, set := fmap["30"]; set {
		if m.MaintenanceState != src.MaintenanceState {
			m.MaintenanceState = src.MaintenanceState
			changed++
		}
	}
	if _, set := fmap["31"]; set {
		if m.OverridePolicyContainerVersion != src.OverridePolicyContainerVersion {
			m.OverridePolicyContainerVersion = src.OverridePolicyContainerVersion
			changed++
		}
	}
	if _, set := fmap["32"]; set {
		if m.VmPool != src.VmPool {
			m.VmPool = src.VmPool
			changed++
		}
	}
	return changed
}

func (m *Cloudlet) DeepCopyIn(src *Cloudlet) {
	m.Key.DeepCopyIn(&src.Key)
	m.Location = src.Location
	m.IpSupport = src.IpSupport
	m.StaticIps = src.StaticIps
	m.NumDynamicIps = src.NumDynamicIps
	m.TimeLimits.DeepCopyIn(&src.TimeLimits)
	if src.Errors != nil {
		m.Errors = make([]string, len(src.Errors), len(src.Errors))
		for ii, s := range src.Errors {
			m.Errors[ii] = s
		}
	} else {
		m.Errors = nil
	}
	m.Status.DeepCopyIn(&src.Status)
	m.State = src.State
	m.CrmOverride = src.CrmOverride
	m.DeploymentLocal = src.DeploymentLocal
	m.PlatformType = src.PlatformType
	m.NotifySrvAddr = src.NotifySrvAddr
	m.Flavor.DeepCopyIn(&src.Flavor)
	m.PhysicalName = src.PhysicalName
	if src.EnvVar != nil {
		m.EnvVar = make(map[string]string)
		for k, v := range src.EnvVar {
			m.EnvVar[k] = v
		}
	} else {
		m.EnvVar = nil
	}
	m.ContainerVersion = src.ContainerVersion
	m.Config.DeepCopyIn(&src.Config)
	if src.ResTagMap != nil {
		m.ResTagMap = make(map[string]*ResTagTableKey)
		for k, v := range src.ResTagMap {
			var tmp_v ResTagTableKey
			tmp_v.DeepCopyIn(v)
			m.ResTagMap[k] = &tmp_v
		}
	} else {
		m.ResTagMap = nil
	}
	if src.AccessVars != nil {
		m.AccessVars = make(map[string]string)
		for k, v := range src.AccessVars {
			m.AccessVars[k] = v
		}
	} else {
		m.AccessVars = nil
	}
	m.VmImageVersion = src.VmImageVersion
	m.Deployment = src.Deployment
	m.InfraApiAccess = src.InfraApiAccess
	m.InfraConfig.DeepCopyIn(&src.InfraConfig)
	if src.ChefClientKey != nil {
		m.ChefClientKey = make(map[string]string)
		for k, v := range src.ChefClientKey {
			m.ChefClientKey[k] = v
		}
	} else {
		m.ChefClientKey = nil
	}
	m.MaintenanceState = src.MaintenanceState
	m.OverridePolicyContainerVersion = src.OverridePolicyContainerVersion
	m.VmPool = src.VmPool
}

func (s *Cloudlet) HasFields() bool {
	return true
}

type CloudletStore struct {
	kvstore objstore.KVStore
}

func NewCloudletStore(kvstore objstore.KVStore) CloudletStore {
	return CloudletStore{kvstore: kvstore}
}

func (s *CloudletStore) Create(ctx context.Context, m *Cloudlet, wait func(int64)) (*Result, error) {
	err := m.Validate(CloudletAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Cloudlet", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletStore) Update(ctx context.Context, m *Cloudlet, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Cloudlet", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur Cloudlet
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletStore) Put(ctx context.Context, m *Cloudlet, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(CloudletAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Cloudlet", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletStore) Delete(ctx context.Context, m *Cloudlet, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Cloudlet", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletStore) LoadOne(key string) (*Cloudlet, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj Cloudlet
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse Cloudlet data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *CloudletStore) STMGet(stm concurrency.STM, key *CloudletKey, buf *Cloudlet) bool {
	keystr := objstore.DbKeyString("Cloudlet", key)
	valstr := stm.Get(keystr)
	if valstr == "" {
		return false
	}
	if buf != nil {
		err := json.Unmarshal([]byte(valstr), buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *CloudletStore) STMPut(stm concurrency.STM, obj *Cloudlet, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("Cloudlet", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("Cloudlet json marsahal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *CloudletStore) STMDel(stm concurrency.STM, key *CloudletKey) {
	keystr := objstore.DbKeyString("Cloudlet", key)
	stm.Del(keystr)
}

type CloudletKeyWatcher struct {
	cb func(ctx context.Context)
}

type CloudletCacheData struct {
	Obj    *Cloudlet
	ModRev int64
}

// CloudletCache caches Cloudlet objects in memory in a hash table
// and keeps them in sync with the database.
type CloudletCache struct {
	Objs          map[CloudletKey]*CloudletCacheData
	Mux           util.Mutex
	List          map[CloudletKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *CloudletKey, old *Cloudlet, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *Cloudlet, new *Cloudlet)
	DeletedCbs    []func(ctx context.Context, old *Cloudlet)
	KeyWatchers   map[CloudletKey][]*CloudletKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *CloudletKey)
	DeletedKeyCbs []func(ctx context.Context, key *CloudletKey)
}

func NewCloudletCache() *CloudletCache {
	cache := CloudletCache{}
	InitCloudletCache(&cache)
	return &cache
}

func InitCloudletCache(cache *CloudletCache) {
	cache.Objs = make(map[CloudletKey]*CloudletCacheData)
	cache.KeyWatchers = make(map[CloudletKey][]*CloudletKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *CloudletCache) GetTypeString() string {
	return "Cloudlet"
}

func (c *CloudletCache) Get(key *CloudletKey, valbuf *Cloudlet) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *CloudletCache) GetWithRev(key *CloudletKey, valbuf *Cloudlet, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *CloudletCache) HasKey(key *CloudletKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *CloudletCache) GetAllKeys(ctx context.Context, cb func(key *CloudletKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *CloudletCache) Update(ctx context.Context, in *Cloudlet, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *Cloudlet) (*Cloudlet, bool) {
		return in, true
	})
}

func (c *CloudletCache) UpdateModFunc(ctx context.Context, key *CloudletKey, modRev int64, modFunc func(old *Cloudlet) (new *Cloudlet, changed bool)) {
	c.Mux.Lock()
	var old *Cloudlet
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	for _, cb := range c.UpdatedCbs {
		newCopy := &Cloudlet{}
		newCopy.DeepCopyIn(new)
		defer cb(ctx, old, newCopy)
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			defer cb(ctx, new.GetKey(), old, modRev)
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &Cloudlet{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &CloudletCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *CloudletCache) Delete(ctx context.Context, in *Cloudlet, modRev int64) {
	c.Mux.Lock()
	var old *Cloudlet
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	c.Mux.Unlock()
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, in.GetKey(), old, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *CloudletCache) Prune(ctx context.Context, validKeys map[CloudletKey]struct{}) {
	notify := make(map[CloudletKey]*CloudletCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, old.Obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *CloudletCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *CloudletCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *CloudletCache) Show(filter *Cloudlet, cb func(ret *Cloudlet) error) error {
	log.DebugLog(log.DebugLevelApi, "Show Cloudlet", "count", len(c.Objs))
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		log.DebugLog(log.DebugLevelApi, "Compare Cloudlet", "filter", filter, "data", data)
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		log.DebugLog(log.DebugLevelApi, "Show Cloudlet", "obj", data.Obj)
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func CloudletGenericNotifyCb(fn func(key *CloudletKey, old *Cloudlet)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*CloudletKey), obj.(*Cloudlet))
	}
}

func (c *CloudletCache) SetNotifyCb(fn func(ctx context.Context, obj *CloudletKey, old *Cloudlet, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *CloudletKey, old *Cloudlet, modRev int64){fn}
}

func (c *CloudletCache) SetUpdatedCb(fn func(ctx context.Context, old *Cloudlet, new *Cloudlet)) {
	c.UpdatedCbs = []func(ctx context.Context, old *Cloudlet, new *Cloudlet){fn}
}

func (c *CloudletCache) SetDeletedCb(fn func(ctx context.Context, old *Cloudlet)) {
	c.DeletedCbs = []func(ctx context.Context, old *Cloudlet){fn}
}

func (c *CloudletCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *CloudletKey){fn}
}

func (c *CloudletCache) SetDeletedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *CloudletKey){fn}
}

func (c *CloudletCache) AddUpdatedCb(fn func(ctx context.Context, old *Cloudlet, new *Cloudlet)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *CloudletCache) AddDeletedCb(fn func(ctx context.Context, old *Cloudlet)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *CloudletCache) AddNotifyCb(fn func(ctx context.Context, obj *CloudletKey, old *Cloudlet, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *CloudletCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *CloudletCache) AddDeletedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *CloudletCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *CloudletCache) WatchKey(key *CloudletKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*CloudletKeyWatcher, 0)
	}
	watcher := CloudletKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching Cloudlet", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *CloudletCache) TriggerKeyWatchers(ctx context.Context, key *CloudletKey) {
	watchers := make([]*CloudletKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *CloudletCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := Cloudlet{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse Cloudlet data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *CloudletCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := Cloudlet{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	CloudletKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *CloudletCache) SyncListStart(ctx context.Context) {
	c.List = make(map[CloudletKey]struct{})
}

func (c *CloudletCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[CloudletKey]*CloudletCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, val.Obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *CloudletCache) UsesOrg(org string) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		if key.Organization == org {
			return true
		}
	}
	return false
}

func (m *Cloudlet) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *Cloudlet) GetKey() *CloudletKey {
	return &m.Key
}

func (m *Cloudlet) GetKeyVal() CloudletKey {
	return m.Key
}

func (m *Cloudlet) SetKey(key *CloudletKey) {
	m.Key = *key
}

func CmpSortCloudlet(a Cloudlet, b Cloudlet) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *Cloudlet) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := IpSupport_name[int32(m.IpSupport)]; !ok {
		return errors.New("invalid IpSupport")
	}
	if err := m.TimeLimits.ValidateEnums(); err != nil {
		return err
	}
	if err := m.Status.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := TrackedState_name[int32(m.State)]; !ok {
		return errors.New("invalid State")
	}
	if _, ok := CRMOverride_name[int32(m.CrmOverride)]; !ok {
		return errors.New("invalid CrmOverride")
	}
	if _, ok := PlatformType_name[int32(m.PlatformType)]; !ok {
		return errors.New("invalid PlatformType")
	}
	if err := m.Flavor.ValidateEnums(); err != nil {
		return err
	}
	if err := m.Config.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := InfraApiAccess_name[int32(m.InfraApiAccess)]; !ok {
		return errors.New("invalid InfraApiAccess")
	}
	if err := m.InfraConfig.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := MaintenanceState_name[int32(m.MaintenanceState)]; !ok {
		return errors.New("invalid MaintenanceState")
	}
	return nil
}

func IgnoreCloudletFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Errors")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Status")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "State")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "CrmOverride")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "DeploymentLocal")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "NotifySrvAddr")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Config")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Deployment")
	}
	return cmpopts.IgnoreFields(Cloudlet{}, names...)
}

func (m *FlavorMatch) CopyInFields(src *FlavorMatch) int {
	changed := 0
	if m.Key.Organization != src.Key.Organization {
		m.Key.Organization = src.Key.Organization
		changed++
	}
	if m.Key.Name != src.Key.Name {
		m.Key.Name = src.Key.Name
		changed++
	}
	if m.FlavorName != src.FlavorName {
		m.FlavorName = src.FlavorName
		changed++
	}
	if m.AvailabilityZone != src.AvailabilityZone {
		m.AvailabilityZone = src.AvailabilityZone
		changed++
	}
	return changed
}

func (m *FlavorMatch) DeepCopyIn(src *FlavorMatch) {
	m.Key.DeepCopyIn(&src.Key)
	m.FlavorName = src.FlavorName
	m.AvailabilityZone = src.AvailabilityZone
}

func (m *FlavorMatch) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *FlavorMatch) GetKey() *CloudletKey {
	return &m.Key
}

func (m *FlavorMatch) GetKeyVal() CloudletKey {
	return m.Key
}

func (m *FlavorMatch) SetKey(key *CloudletKey) {
	m.Key = *key
}

func CmpSortFlavorMatch(a FlavorMatch, b FlavorMatch) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *FlavorMatch) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *CloudletManifest) CopyInFields(src *CloudletManifest) int {
	changed := 0
	if m.Manifest != src.Manifest {
		m.Manifest = src.Manifest
		changed++
	}
	return changed
}

func (m *CloudletManifest) DeepCopyIn(src *CloudletManifest) {
	m.Manifest = src.Manifest
}

// Helper method to check that enums have valid values
func (m *CloudletManifest) ValidateEnums() error {
	return nil
}

func (m *PropertyInfo) CopyInFields(src *PropertyInfo) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.Description != src.Description {
		m.Description = src.Description
		changed++
	}
	if m.Value != src.Value {
		m.Value = src.Value
		changed++
	}
	if m.Secret != src.Secret {
		m.Secret = src.Secret
		changed++
	}
	if m.Mandatory != src.Mandatory {
		m.Mandatory = src.Mandatory
		changed++
	}
	if m.Internal != src.Internal {
		m.Internal = src.Internal
		changed++
	}
	return changed
}

func (m *PropertyInfo) DeepCopyIn(src *PropertyInfo) {
	m.Name = src.Name
	m.Description = src.Description
	m.Value = src.Value
	m.Secret = src.Secret
	m.Mandatory = src.Mandatory
	m.Internal = src.Internal
}

// Helper method to check that enums have valid values
func (m *PropertyInfo) ValidateEnums() error {
	return nil
}

func (m *CloudletProps) CopyInFields(src *CloudletProps) int {
	changed := 0
	if m.PlatformType != src.PlatformType {
		m.PlatformType = src.PlatformType
		changed++
	}
	if src.Properties != nil {
		m.Properties = make(map[string]*PropertyInfo)
		for k0, _ := range src.Properties {
			m.Properties[k0] = &PropertyInfo{}
			if m.Properties[k0].Name != src.Properties[k0].Name {
				m.Properties[k0].Name = src.Properties[k0].Name
				changed++
			}
			if m.Properties[k0].Description != src.Properties[k0].Description {
				m.Properties[k0].Description = src.Properties[k0].Description
				changed++
			}
			if m.Properties[k0].Value != src.Properties[k0].Value {
				m.Properties[k0].Value = src.Properties[k0].Value
				changed++
			}
			if m.Properties[k0].Secret != src.Properties[k0].Secret {
				m.Properties[k0].Secret = src.Properties[k0].Secret
				changed++
			}
			if m.Properties[k0].Mandatory != src.Properties[k0].Mandatory {
				m.Properties[k0].Mandatory = src.Properties[k0].Mandatory
				changed++
			}
			if m.Properties[k0].Internal != src.Properties[k0].Internal {
				m.Properties[k0].Internal = src.Properties[k0].Internal
				changed++
			}
		}
	} else if m.Properties != nil {
		m.Properties = nil
		changed++
	}
	return changed
}

func (m *CloudletProps) DeepCopyIn(src *CloudletProps) {
	m.PlatformType = src.PlatformType
	if src.Properties != nil {
		m.Properties = make(map[string]*PropertyInfo)
		for k, v := range src.Properties {
			var tmp_v PropertyInfo
			tmp_v.DeepCopyIn(v)
			m.Properties[k] = &tmp_v
		}
	} else {
		m.Properties = nil
	}
}

// Helper method to check that enums have valid values
func (m *CloudletProps) ValidateEnums() error {
	if _, ok := PlatformType_name[int32(m.PlatformType)]; !ok {
		return errors.New("invalid PlatformType")
	}
	return nil
}

func (m *FlavorInfo) CopyInFields(src *FlavorInfo) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.Vcpus != src.Vcpus {
		m.Vcpus = src.Vcpus
		changed++
	}
	if m.Ram != src.Ram {
		m.Ram = src.Ram
		changed++
	}
	if m.Disk != src.Disk {
		m.Disk = src.Disk
		changed++
	}
	if src.PropMap != nil {
		m.PropMap = make(map[string]string)
		for k0, _ := range src.PropMap {
			m.PropMap[k0] = src.PropMap[k0]
		}
	} else if m.PropMap != nil {
		m.PropMap = nil
		changed++
	}
	return changed
}

func (m *FlavorInfo) DeepCopyIn(src *FlavorInfo) {
	m.Name = src.Name
	m.Vcpus = src.Vcpus
	m.Ram = src.Ram
	m.Disk = src.Disk
	if src.PropMap != nil {
		m.PropMap = make(map[string]string)
		for k, v := range src.PropMap {
			m.PropMap[k] = v
		}
	} else {
		m.PropMap = nil
	}
}

// Helper method to check that enums have valid values
func (m *FlavorInfo) ValidateEnums() error {
	return nil
}

func (m *OSAZone) CopyInFields(src *OSAZone) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	return changed
}

func (m *OSAZone) DeepCopyIn(src *OSAZone) {
	m.Name = src.Name
	m.Status = src.Status
}

// Helper method to check that enums have valid values
func (m *OSAZone) ValidateEnums() error {
	return nil
}

func (m *OSImage) CopyInFields(src *OSImage) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.Tags != src.Tags {
		m.Tags = src.Tags
		changed++
	}
	if m.Properties != src.Properties {
		m.Properties = src.Properties
		changed++
	}
	if m.DiskFormat != src.DiskFormat {
		m.DiskFormat = src.DiskFormat
		changed++
	}
	return changed
}

func (m *OSImage) DeepCopyIn(src *OSImage) {
	m.Name = src.Name
	m.Tags = src.Tags
	m.Properties = src.Properties
	m.DiskFormat = src.DiskFormat
}

// Helper method to check that enums have valid values
func (m *OSImage) ValidateEnums() error {
	return nil
}

func (m *CloudletInfo) Matches(o *CloudletInfo, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.State != 0 {
		if o.State != m.State {
			return false
		}
	}
	if !opts.Filter || o.NotifyId != 0 {
		if o.NotifyId != m.NotifyId {
			return false
		}
	}
	if !opts.Filter || o.Controller != "" {
		if o.Controller != m.Controller {
			return false
		}
	}
	if !opts.Filter || o.OsMaxRam != 0 {
		if o.OsMaxRam != m.OsMaxRam {
			return false
		}
	}
	if !opts.Filter || o.OsMaxVcores != 0 {
		if o.OsMaxVcores != m.OsMaxVcores {
			return false
		}
	}
	if !opts.Filter || o.OsMaxVolGb != 0 {
		if o.OsMaxVolGb != m.OsMaxVolGb {
			return false
		}
	}
	if !opts.Filter || o.Errors != nil {
		if m.Errors == nil && o.Errors != nil || m.Errors != nil && o.Errors == nil {
			return false
		} else if m.Errors != nil && o.Errors != nil {
			if len(m.Errors) != len(o.Errors) {
				return false
			}
			for i := 0; i < len(m.Errors); i++ {
				if o.Errors[i] != m.Errors[i] {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.Flavors != nil {
		if m.Flavors == nil && o.Flavors != nil || m.Flavors != nil && o.Flavors == nil {
			return false
		} else if m.Flavors != nil && o.Flavors != nil {
			if len(m.Flavors) != len(o.Flavors) {
				return false
			}
			for i := 0; i < len(m.Flavors); i++ {
			}
		}
	}
	if !opts.Filter || o.ContainerVersion != "" {
		if o.ContainerVersion != m.ContainerVersion {
			return false
		}
	}
	if !opts.Filter || o.AvailabilityZones != nil {
		if m.AvailabilityZones == nil && o.AvailabilityZones != nil || m.AvailabilityZones != nil && o.AvailabilityZones == nil {
			return false
		} else if m.AvailabilityZones != nil && o.AvailabilityZones != nil {
			if len(m.AvailabilityZones) != len(o.AvailabilityZones) {
				return false
			}
			for i := 0; i < len(m.AvailabilityZones); i++ {
			}
		}
	}
	if !opts.Filter || o.OsImages != nil {
		if m.OsImages == nil && o.OsImages != nil || m.OsImages != nil && o.OsImages == nil {
			return false
		} else if m.OsImages != nil && o.OsImages != nil {
			if len(m.OsImages) != len(o.OsImages) {
				return false
			}
			for i := 0; i < len(m.OsImages); i++ {
			}
		}
	}
	if !opts.Filter || o.ControllerCacheReceived != false {
		if o.ControllerCacheReceived != m.ControllerCacheReceived {
			return false
		}
	}
	if !opts.Filter || o.MaintenanceState != 0 {
		if o.MaintenanceState != m.MaintenanceState {
			return false
		}
	}
	return true
}

const CloudletInfoFieldKey = "2"
const CloudletInfoFieldKeyOrganization = "2.1"
const CloudletInfoFieldKeyName = "2.2"
const CloudletInfoFieldState = "3"
const CloudletInfoFieldNotifyId = "4"
const CloudletInfoFieldController = "5"
const CloudletInfoFieldOsMaxRam = "6"
const CloudletInfoFieldOsMaxVcores = "7"
const CloudletInfoFieldOsMaxVolGb = "8"
const CloudletInfoFieldErrors = "9"
const CloudletInfoFieldFlavors = "10"
const CloudletInfoFieldFlavorsName = "10.1"
const CloudletInfoFieldFlavorsVcpus = "10.2"
const CloudletInfoFieldFlavorsRam = "10.3"
const CloudletInfoFieldFlavorsDisk = "10.4"
const CloudletInfoFieldFlavorsPropMap = "10.5"
const CloudletInfoFieldFlavorsPropMapKey = "10.5.1"
const CloudletInfoFieldFlavorsPropMapValue = "10.5.2"
const CloudletInfoFieldStatus = "11"
const CloudletInfoFieldStatusTaskNumber = "11.1"
const CloudletInfoFieldStatusMaxTasks = "11.2"
const CloudletInfoFieldStatusTaskName = "11.3"
const CloudletInfoFieldStatusStepName = "11.4"
const CloudletInfoFieldContainerVersion = "12"
const CloudletInfoFieldAvailabilityZones = "13"
const CloudletInfoFieldAvailabilityZonesName = "13.1"
const CloudletInfoFieldAvailabilityZonesStatus = "13.2"
const CloudletInfoFieldOsImages = "14"
const CloudletInfoFieldOsImagesName = "14.1"
const CloudletInfoFieldOsImagesTags = "14.2"
const CloudletInfoFieldOsImagesProperties = "14.3"
const CloudletInfoFieldOsImagesDiskFormat = "14.4"
const CloudletInfoFieldControllerCacheReceived = "15"
const CloudletInfoFieldMaintenanceState = "16"

var CloudletInfoAllFields = []string{
	CloudletInfoFieldKeyOrganization,
	CloudletInfoFieldKeyName,
	CloudletInfoFieldState,
	CloudletInfoFieldNotifyId,
	CloudletInfoFieldController,
	CloudletInfoFieldOsMaxRam,
	CloudletInfoFieldOsMaxVcores,
	CloudletInfoFieldOsMaxVolGb,
	CloudletInfoFieldErrors,
	CloudletInfoFieldFlavorsName,
	CloudletInfoFieldFlavorsVcpus,
	CloudletInfoFieldFlavorsRam,
	CloudletInfoFieldFlavorsDisk,
	CloudletInfoFieldFlavorsPropMapKey,
	CloudletInfoFieldFlavorsPropMapValue,
	CloudletInfoFieldStatusTaskNumber,
	CloudletInfoFieldStatusMaxTasks,
	CloudletInfoFieldStatusTaskName,
	CloudletInfoFieldStatusStepName,
	CloudletInfoFieldContainerVersion,
	CloudletInfoFieldAvailabilityZonesName,
	CloudletInfoFieldAvailabilityZonesStatus,
	CloudletInfoFieldOsImagesName,
	CloudletInfoFieldOsImagesTags,
	CloudletInfoFieldOsImagesProperties,
	CloudletInfoFieldOsImagesDiskFormat,
	CloudletInfoFieldControllerCacheReceived,
	CloudletInfoFieldMaintenanceState,
}

var CloudletInfoAllFieldsMap = map[string]struct{}{
	CloudletInfoFieldKeyOrganization:         struct{}{},
	CloudletInfoFieldKeyName:                 struct{}{},
	CloudletInfoFieldState:                   struct{}{},
	CloudletInfoFieldNotifyId:                struct{}{},
	CloudletInfoFieldController:              struct{}{},
	CloudletInfoFieldOsMaxRam:                struct{}{},
	CloudletInfoFieldOsMaxVcores:             struct{}{},
	CloudletInfoFieldOsMaxVolGb:              struct{}{},
	CloudletInfoFieldErrors:                  struct{}{},
	CloudletInfoFieldFlavorsName:             struct{}{},
	CloudletInfoFieldFlavorsVcpus:            struct{}{},
	CloudletInfoFieldFlavorsRam:              struct{}{},
	CloudletInfoFieldFlavorsDisk:             struct{}{},
	CloudletInfoFieldFlavorsPropMapKey:       struct{}{},
	CloudletInfoFieldFlavorsPropMapValue:     struct{}{},
	CloudletInfoFieldStatusTaskNumber:        struct{}{},
	CloudletInfoFieldStatusMaxTasks:          struct{}{},
	CloudletInfoFieldStatusTaskName:          struct{}{},
	CloudletInfoFieldStatusStepName:          struct{}{},
	CloudletInfoFieldContainerVersion:        struct{}{},
	CloudletInfoFieldAvailabilityZonesName:   struct{}{},
	CloudletInfoFieldAvailabilityZonesStatus: struct{}{},
	CloudletInfoFieldOsImagesName:            struct{}{},
	CloudletInfoFieldOsImagesTags:            struct{}{},
	CloudletInfoFieldOsImagesProperties:      struct{}{},
	CloudletInfoFieldOsImagesDiskFormat:      struct{}{},
	CloudletInfoFieldControllerCacheReceived: struct{}{},
	CloudletInfoFieldMaintenanceState:        struct{}{},
}

var CloudletInfoAllFieldsStringMap = map[string]string{
	CloudletInfoFieldKeyOrganization:         "Key Organization",
	CloudletInfoFieldKeyName:                 "Key Name",
	CloudletInfoFieldState:                   "State",
	CloudletInfoFieldNotifyId:                "Notify Id",
	CloudletInfoFieldController:              "Controller",
	CloudletInfoFieldOsMaxRam:                "Os Max Ram",
	CloudletInfoFieldOsMaxVcores:             "Os Max Vcores",
	CloudletInfoFieldOsMaxVolGb:              "Os Max Vol Gb",
	CloudletInfoFieldErrors:                  "Errors",
	CloudletInfoFieldFlavorsName:             "Flavors Name",
	CloudletInfoFieldFlavorsVcpus:            "Flavors Vcpus",
	CloudletInfoFieldFlavorsRam:              "Flavors Ram",
	CloudletInfoFieldFlavorsDisk:             "Flavors Disk",
	CloudletInfoFieldFlavorsPropMapKey:       "Flavors Prop Map Key",
	CloudletInfoFieldFlavorsPropMapValue:     "Flavors Prop Map Value",
	CloudletInfoFieldStatusTaskNumber:        "Status Task Number",
	CloudletInfoFieldStatusMaxTasks:          "Status Max Tasks",
	CloudletInfoFieldStatusTaskName:          "Status Task Name",
	CloudletInfoFieldStatusStepName:          "Status Step Name",
	CloudletInfoFieldContainerVersion:        "Container Version",
	CloudletInfoFieldAvailabilityZonesName:   "Availability Zones Name",
	CloudletInfoFieldAvailabilityZonesStatus: "Availability Zones Status",
	CloudletInfoFieldOsImagesName:            "Os Images Name",
	CloudletInfoFieldOsImagesTags:            "Os Images Tags",
	CloudletInfoFieldOsImagesProperties:      "Os Images Properties",
	CloudletInfoFieldOsImagesDiskFormat:      "Os Images Disk Format",
	CloudletInfoFieldControllerCacheReceived: "Controller Cache Received",
	CloudletInfoFieldMaintenanceState:        "Maintenance State",
}

func (m *CloudletInfo) IsKeyField(s string) bool {
	return strings.HasPrefix(s, CloudletInfoFieldKey+".") || s == CloudletInfoFieldKey
}

func (m *CloudletInfo) DiffFields(o *CloudletInfo, fields map[string]struct{}) {
	if m.Key.Organization != o.Key.Organization {
		fields[CloudletInfoFieldKeyOrganization] = struct{}{}
		fields[CloudletInfoFieldKey] = struct{}{}
	}
	if m.Key.Name != o.Key.Name {
		fields[CloudletInfoFieldKeyName] = struct{}{}
		fields[CloudletInfoFieldKey] = struct{}{}
	}
	if m.State != o.State {
		fields[CloudletInfoFieldState] = struct{}{}
	}
	if m.NotifyId != o.NotifyId {
		fields[CloudletInfoFieldNotifyId] = struct{}{}
	}
	if m.Controller != o.Controller {
		fields[CloudletInfoFieldController] = struct{}{}
	}
	if m.OsMaxRam != o.OsMaxRam {
		fields[CloudletInfoFieldOsMaxRam] = struct{}{}
	}
	if m.OsMaxVcores != o.OsMaxVcores {
		fields[CloudletInfoFieldOsMaxVcores] = struct{}{}
	}
	if m.OsMaxVolGb != o.OsMaxVolGb {
		fields[CloudletInfoFieldOsMaxVolGb] = struct{}{}
	}
	if len(m.Errors) != len(o.Errors) {
		fields[CloudletInfoFieldErrors] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.Errors); i0++ {
			if m.Errors[i0] != o.Errors[i0] {
				fields[CloudletInfoFieldErrors] = struct{}{}
				break
			}
		}
	}
	if m.Flavors != nil && o.Flavors != nil {
		if len(m.Flavors) != len(o.Flavors) {
			fields[CloudletInfoFieldFlavors] = struct{}{}
		} else {
			for i0 := 0; i0 < len(m.Flavors); i0++ {
				if m.Flavors[i0].Name != o.Flavors[i0].Name {
					fields[CloudletInfoFieldFlavorsName] = struct{}{}
					fields[CloudletInfoFieldFlavors] = struct{}{}
				}
				if m.Flavors[i0].Vcpus != o.Flavors[i0].Vcpus {
					fields[CloudletInfoFieldFlavorsVcpus] = struct{}{}
					fields[CloudletInfoFieldFlavors] = struct{}{}
				}
				if m.Flavors[i0].Ram != o.Flavors[i0].Ram {
					fields[CloudletInfoFieldFlavorsRam] = struct{}{}
					fields[CloudletInfoFieldFlavors] = struct{}{}
				}
				if m.Flavors[i0].Disk != o.Flavors[i0].Disk {
					fields[CloudletInfoFieldFlavorsDisk] = struct{}{}
					fields[CloudletInfoFieldFlavors] = struct{}{}
				}
				if m.Flavors[i0].PropMap != nil && o.Flavors[i0].PropMap != nil {
					if len(m.Flavors[i0].PropMap) != len(o.Flavors[i0].PropMap) {
						fields[CloudletInfoFieldFlavorsPropMap] = struct{}{}
						fields[CloudletInfoFieldFlavors] = struct{}{}
					} else {
						for k1, _ := range m.Flavors[i0].PropMap {
							_, vok1 := o.Flavors[i0].PropMap[k1]
							if !vok1 {
								fields[CloudletInfoFieldFlavorsPropMap] = struct{}{}
								fields[CloudletInfoFieldFlavors] = struct{}{}
							} else {
								if m.Flavors[i0].PropMap[k1] != o.Flavors[i0].PropMap[k1] {
									fields[CloudletInfoFieldFlavorsPropMap] = struct{}{}
									fields[CloudletInfoFieldFlavors] = struct{}{}
									break
								}
							}
						}
					}
				} else if (m.Flavors[i0].PropMap != nil && o.Flavors[i0].PropMap == nil) || (m.Flavors[i0].PropMap == nil && o.Flavors[i0].PropMap != nil) {
					fields[CloudletInfoFieldFlavorsPropMap] = struct{}{}
					fields[CloudletInfoFieldFlavors] = struct{}{}
				}
			}
		}
	} else if (m.Flavors != nil && o.Flavors == nil) || (m.Flavors == nil && o.Flavors != nil) {
		fields[CloudletInfoFieldFlavors] = struct{}{}
	}
	if m.Status.TaskNumber != o.Status.TaskNumber {
		fields[CloudletInfoFieldStatusTaskNumber] = struct{}{}
		fields[CloudletInfoFieldStatus] = struct{}{}
	}
	if m.Status.MaxTasks != o.Status.MaxTasks {
		fields[CloudletInfoFieldStatusMaxTasks] = struct{}{}
		fields[CloudletInfoFieldStatus] = struct{}{}
	}
	if m.Status.TaskName != o.Status.TaskName {
		fields[CloudletInfoFieldStatusTaskName] = struct{}{}
		fields[CloudletInfoFieldStatus] = struct{}{}
	}
	if m.Status.StepName != o.Status.StepName {
		fields[CloudletInfoFieldStatusStepName] = struct{}{}
		fields[CloudletInfoFieldStatus] = struct{}{}
	}
	if m.ContainerVersion != o.ContainerVersion {
		fields[CloudletInfoFieldContainerVersion] = struct{}{}
	}
	if m.AvailabilityZones != nil && o.AvailabilityZones != nil {
		if len(m.AvailabilityZones) != len(o.AvailabilityZones) {
			fields[CloudletInfoFieldAvailabilityZones] = struct{}{}
		} else {
			for i0 := 0; i0 < len(m.AvailabilityZones); i0++ {
				if m.AvailabilityZones[i0].Name != o.AvailabilityZones[i0].Name {
					fields[CloudletInfoFieldAvailabilityZonesName] = struct{}{}
					fields[CloudletInfoFieldAvailabilityZones] = struct{}{}
				}
				if m.AvailabilityZones[i0].Status != o.AvailabilityZones[i0].Status {
					fields[CloudletInfoFieldAvailabilityZonesStatus] = struct{}{}
					fields[CloudletInfoFieldAvailabilityZones] = struct{}{}
				}
			}
		}
	} else if (m.AvailabilityZones != nil && o.AvailabilityZones == nil) || (m.AvailabilityZones == nil && o.AvailabilityZones != nil) {
		fields[CloudletInfoFieldAvailabilityZones] = struct{}{}
	}
	if m.OsImages != nil && o.OsImages != nil {
		if len(m.OsImages) != len(o.OsImages) {
			fields[CloudletInfoFieldOsImages] = struct{}{}
		} else {
			for i0 := 0; i0 < len(m.OsImages); i0++ {
				if m.OsImages[i0].Name != o.OsImages[i0].Name {
					fields[CloudletInfoFieldOsImagesName] = struct{}{}
					fields[CloudletInfoFieldOsImages] = struct{}{}
				}
				if m.OsImages[i0].Tags != o.OsImages[i0].Tags {
					fields[CloudletInfoFieldOsImagesTags] = struct{}{}
					fields[CloudletInfoFieldOsImages] = struct{}{}
				}
				if m.OsImages[i0].Properties != o.OsImages[i0].Properties {
					fields[CloudletInfoFieldOsImagesProperties] = struct{}{}
					fields[CloudletInfoFieldOsImages] = struct{}{}
				}
				if m.OsImages[i0].DiskFormat != o.OsImages[i0].DiskFormat {
					fields[CloudletInfoFieldOsImagesDiskFormat] = struct{}{}
					fields[CloudletInfoFieldOsImages] = struct{}{}
				}
			}
		}
	} else if (m.OsImages != nil && o.OsImages == nil) || (m.OsImages == nil && o.OsImages != nil) {
		fields[CloudletInfoFieldOsImages] = struct{}{}
	}
	if m.ControllerCacheReceived != o.ControllerCacheReceived {
		fields[CloudletInfoFieldControllerCacheReceived] = struct{}{}
	}
	if m.MaintenanceState != o.MaintenanceState {
		fields[CloudletInfoFieldMaintenanceState] = struct{}{}
	}
}

func (m *CloudletInfo) CopyInFields(src *CloudletInfo) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
		if _, set := fmap["2.2"]; set {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
	}
	if _, set := fmap["3"]; set {
		if m.State != src.State {
			m.State = src.State
			changed++
		}
	}
	if _, set := fmap["4"]; set {
		if m.NotifyId != src.NotifyId {
			m.NotifyId = src.NotifyId
			changed++
		}
	}
	if _, set := fmap["5"]; set {
		if m.Controller != src.Controller {
			m.Controller = src.Controller
			changed++
		}
	}
	if _, set := fmap["6"]; set {
		if m.OsMaxRam != src.OsMaxRam {
			m.OsMaxRam = src.OsMaxRam
			changed++
		}
	}
	if _, set := fmap["7"]; set {
		if m.OsMaxVcores != src.OsMaxVcores {
			m.OsMaxVcores = src.OsMaxVcores
			changed++
		}
	}
	if _, set := fmap["8"]; set {
		if m.OsMaxVolGb != src.OsMaxVolGb {
			m.OsMaxVolGb = src.OsMaxVolGb
			changed++
		}
	}
	if _, set := fmap["9"]; set {
		if src.Errors != nil {
			m.Errors = src.Errors
			changed++
		} else if m.Errors != nil {
			m.Errors = nil
			changed++
		}
	}
	if _, set := fmap["10"]; set {
		if src.Flavors != nil {
			m.Flavors = src.Flavors
			changed++
		} else if m.Flavors != nil {
			m.Flavors = nil
			changed++
		}
	}
	if _, set := fmap["11"]; set {
		if _, set := fmap["11.1"]; set {
			if m.Status.TaskNumber != src.Status.TaskNumber {
				m.Status.TaskNumber = src.Status.TaskNumber
				changed++
			}
		}
		if _, set := fmap["11.2"]; set {
			if m.Status.MaxTasks != src.Status.MaxTasks {
				m.Status.MaxTasks = src.Status.MaxTasks
				changed++
			}
		}
		if _, set := fmap["11.3"]; set {
			if m.Status.TaskName != src.Status.TaskName {
				m.Status.TaskName = src.Status.TaskName
				changed++
			}
		}
		if _, set := fmap["11.4"]; set {
			if m.Status.StepName != src.Status.StepName {
				m.Status.StepName = src.Status.StepName
				changed++
			}
		}
	}
	if _, set := fmap["12"]; set {
		if m.ContainerVersion != src.ContainerVersion {
			m.ContainerVersion = src.ContainerVersion
			changed++
		}
	}
	if _, set := fmap["13"]; set {
		if src.AvailabilityZones != nil {
			m.AvailabilityZones = src.AvailabilityZones
			changed++
		} else if m.AvailabilityZones != nil {
			m.AvailabilityZones = nil
			changed++
		}
	}
	if _, set := fmap["14"]; set {
		if src.OsImages != nil {
			m.OsImages = src.OsImages
			changed++
		} else if m.OsImages != nil {
			m.OsImages = nil
			changed++
		}
	}
	if _, set := fmap["15"]; set {
		if m.ControllerCacheReceived != src.ControllerCacheReceived {
			m.ControllerCacheReceived = src.ControllerCacheReceived
			changed++
		}
	}
	if _, set := fmap["16"]; set {
		if m.MaintenanceState != src.MaintenanceState {
			m.MaintenanceState = src.MaintenanceState
			changed++
		}
	}
	return changed
}

func (m *CloudletInfo) DeepCopyIn(src *CloudletInfo) {
	m.Key.DeepCopyIn(&src.Key)
	m.State = src.State
	m.NotifyId = src.NotifyId
	m.Controller = src.Controller
	m.OsMaxRam = src.OsMaxRam
	m.OsMaxVcores = src.OsMaxVcores
	m.OsMaxVolGb = src.OsMaxVolGb
	if src.Errors != nil {
		m.Errors = make([]string, len(src.Errors), len(src.Errors))
		for ii, s := range src.Errors {
			m.Errors[ii] = s
		}
	} else {
		m.Errors = nil
	}
	if src.Flavors != nil {
		m.Flavors = make([]*FlavorInfo, len(src.Flavors), len(src.Flavors))
		for ii, s := range src.Flavors {
			var tmp_s FlavorInfo
			tmp_s.DeepCopyIn(s)
			m.Flavors[ii] = &tmp_s
		}
	} else {
		m.Flavors = nil
	}
	m.Status.DeepCopyIn(&src.Status)
	m.ContainerVersion = src.ContainerVersion
	if src.AvailabilityZones != nil {
		m.AvailabilityZones = make([]*OSAZone, len(src.AvailabilityZones), len(src.AvailabilityZones))
		for ii, s := range src.AvailabilityZones {
			var tmp_s OSAZone
			tmp_s.DeepCopyIn(s)
			m.AvailabilityZones[ii] = &tmp_s
		}
	} else {
		m.AvailabilityZones = nil
	}
	if src.OsImages != nil {
		m.OsImages = make([]*OSImage, len(src.OsImages), len(src.OsImages))
		for ii, s := range src.OsImages {
			var tmp_s OSImage
			tmp_s.DeepCopyIn(s)
			m.OsImages[ii] = &tmp_s
		}
	} else {
		m.OsImages = nil
	}
	m.ControllerCacheReceived = src.ControllerCacheReceived
	m.MaintenanceState = src.MaintenanceState
}

func (s *CloudletInfo) HasFields() bool {
	return true
}

type CloudletInfoStore struct {
	kvstore objstore.KVStore
}

func NewCloudletInfoStore(kvstore objstore.KVStore) CloudletInfoStore {
	return CloudletInfoStore{kvstore: kvstore}
}

func (s *CloudletInfoStore) Create(ctx context.Context, m *CloudletInfo, wait func(int64)) (*Result, error) {
	err := m.Validate(CloudletInfoAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("CloudletInfo", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletInfoStore) Update(ctx context.Context, m *CloudletInfo, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("CloudletInfo", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur CloudletInfo
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletInfoStore) Put(ctx context.Context, m *CloudletInfo, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(CloudletInfoAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("CloudletInfo", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletInfoStore) Delete(ctx context.Context, m *CloudletInfo, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("CloudletInfo", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletInfoStore) LoadOne(key string) (*CloudletInfo, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj CloudletInfo
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse CloudletInfo data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *CloudletInfoStore) STMGet(stm concurrency.STM, key *CloudletKey, buf *CloudletInfo) bool {
	keystr := objstore.DbKeyString("CloudletInfo", key)
	valstr := stm.Get(keystr)
	if valstr == "" {
		return false
	}
	if buf != nil {
		err := json.Unmarshal([]byte(valstr), buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *CloudletInfoStore) STMPut(stm concurrency.STM, obj *CloudletInfo, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("CloudletInfo", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("CloudletInfo json marsahal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *CloudletInfoStore) STMDel(stm concurrency.STM, key *CloudletKey) {
	keystr := objstore.DbKeyString("CloudletInfo", key)
	stm.Del(keystr)
}

type CloudletInfoKeyWatcher struct {
	cb func(ctx context.Context)
}

type CloudletInfoCacheData struct {
	Obj    *CloudletInfo
	ModRev int64
}

// CloudletInfoCache caches CloudletInfo objects in memory in a hash table
// and keeps them in sync with the database.
type CloudletInfoCache struct {
	Objs          map[CloudletKey]*CloudletInfoCacheData
	Mux           util.Mutex
	List          map[CloudletKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *CloudletKey, old *CloudletInfo, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *CloudletInfo, new *CloudletInfo)
	DeletedCbs    []func(ctx context.Context, old *CloudletInfo)
	KeyWatchers   map[CloudletKey][]*CloudletInfoKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *CloudletKey)
	DeletedKeyCbs []func(ctx context.Context, key *CloudletKey)
}

func NewCloudletInfoCache() *CloudletInfoCache {
	cache := CloudletInfoCache{}
	InitCloudletInfoCache(&cache)
	return &cache
}

func InitCloudletInfoCache(cache *CloudletInfoCache) {
	cache.Objs = make(map[CloudletKey]*CloudletInfoCacheData)
	cache.KeyWatchers = make(map[CloudletKey][]*CloudletInfoKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *CloudletInfoCache) GetTypeString() string {
	return "CloudletInfo"
}

func (c *CloudletInfoCache) Get(key *CloudletKey, valbuf *CloudletInfo) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *CloudletInfoCache) GetWithRev(key *CloudletKey, valbuf *CloudletInfo, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *CloudletInfoCache) HasKey(key *CloudletKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *CloudletInfoCache) GetAllKeys(ctx context.Context, cb func(key *CloudletKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *CloudletInfoCache) Update(ctx context.Context, in *CloudletInfo, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *CloudletInfo) (*CloudletInfo, bool) {
		return in, true
	})
}

func (c *CloudletInfoCache) UpdateModFunc(ctx context.Context, key *CloudletKey, modRev int64, modFunc func(old *CloudletInfo) (new *CloudletInfo, changed bool)) {
	c.Mux.Lock()
	var old *CloudletInfo
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	for _, cb := range c.UpdatedCbs {
		newCopy := &CloudletInfo{}
		newCopy.DeepCopyIn(new)
		defer cb(ctx, old, newCopy)
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			defer cb(ctx, new.GetKey(), old, modRev)
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &CloudletInfo{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &CloudletInfoCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *CloudletInfoCache) Delete(ctx context.Context, in *CloudletInfo, modRev int64) {
	c.Mux.Lock()
	var old *CloudletInfo
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	c.Mux.Unlock()
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, in.GetKey(), old, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *CloudletInfoCache) Prune(ctx context.Context, validKeys map[CloudletKey]struct{}) {
	notify := make(map[CloudletKey]*CloudletInfoCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, old.Obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *CloudletInfoCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *CloudletInfoCache) Flush(ctx context.Context, notifyId int64) {
	log.SpanLog(ctx, log.DebugLevelApi, "CacheFlush CloudletInfo", "notifyId", notifyId, "FlushAll", c.FlushAll)
	flushed := make(map[CloudletKey]*CloudletInfoCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if !c.FlushAll && val.Obj.NotifyId != notifyId {
			continue
		}
		flushed[key] = c.Objs[key]
		log.SpanLog(ctx, log.DebugLevelApi, "CacheFlush CloudletInfo delete", "key", key)
		delete(c.Objs, key)
	}
	c.Mux.Unlock()
	if len(flushed) > 0 {
		for key, old := range flushed {
			for _, cb := range c.NotifyCbs {
				if cb != nil {
					cb(ctx, &key, old.Obj, old.ModRev)
				}
			}
			for _, cb := range c.DeletedKeyCbs {
				cb(ctx, &key)
			}
			if old.Obj != nil {
				for _, cb := range c.DeletedCbs {
					cb(ctx, old.Obj)
				}
			}
			c.TriggerKeyWatchers(ctx, &key)
		}
	}
}

func (c *CloudletInfoCache) Show(filter *CloudletInfo, cb func(ret *CloudletInfo) error) error {
	log.DebugLog(log.DebugLevelApi, "Show CloudletInfo", "count", len(c.Objs))
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		log.DebugLog(log.DebugLevelApi, "Compare CloudletInfo", "filter", filter, "data", data)
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		log.DebugLog(log.DebugLevelApi, "Show CloudletInfo", "obj", data.Obj)
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func CloudletInfoGenericNotifyCb(fn func(key *CloudletKey, old *CloudletInfo)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*CloudletKey), obj.(*CloudletInfo))
	}
}

func (c *CloudletInfoCache) SetNotifyCb(fn func(ctx context.Context, obj *CloudletKey, old *CloudletInfo, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *CloudletKey, old *CloudletInfo, modRev int64){fn}
}

func (c *CloudletInfoCache) SetUpdatedCb(fn func(ctx context.Context, old *CloudletInfo, new *CloudletInfo)) {
	c.UpdatedCbs = []func(ctx context.Context, old *CloudletInfo, new *CloudletInfo){fn}
}

func (c *CloudletInfoCache) SetDeletedCb(fn func(ctx context.Context, old *CloudletInfo)) {
	c.DeletedCbs = []func(ctx context.Context, old *CloudletInfo){fn}
}

func (c *CloudletInfoCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *CloudletKey){fn}
}

func (c *CloudletInfoCache) SetDeletedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *CloudletKey){fn}
}

func (c *CloudletInfoCache) AddUpdatedCb(fn func(ctx context.Context, old *CloudletInfo, new *CloudletInfo)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *CloudletInfoCache) AddDeletedCb(fn func(ctx context.Context, old *CloudletInfo)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *CloudletInfoCache) AddNotifyCb(fn func(ctx context.Context, obj *CloudletKey, old *CloudletInfo, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *CloudletInfoCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *CloudletInfoCache) AddDeletedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *CloudletInfoCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *CloudletInfoCache) WatchKey(key *CloudletKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*CloudletInfoKeyWatcher, 0)
	}
	watcher := CloudletInfoKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching CloudletInfo", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *CloudletInfoCache) TriggerKeyWatchers(ctx context.Context, key *CloudletKey) {
	watchers := make([]*CloudletInfoKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *CloudletInfoCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := CloudletInfo{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse CloudletInfo data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *CloudletInfoCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := CloudletInfo{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	CloudletKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *CloudletInfoCache) SyncListStart(ctx context.Context) {
	c.List = make(map[CloudletKey]struct{})
}

func (c *CloudletInfoCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[CloudletKey]*CloudletInfoCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, val.Obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *CloudletInfoCache) UsesOrg(org string) bool {
	return false
}

func (m *CloudletInfo) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *CloudletInfo) GetKey() *CloudletKey {
	return &m.Key
}

func (m *CloudletInfo) GetKeyVal() CloudletKey {
	return m.Key
}

func (m *CloudletInfo) SetKey(key *CloudletKey) {
	m.Key = *key
}

func CmpSortCloudletInfo(a CloudletInfo, b CloudletInfo) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *CloudletInfo) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := CloudletState_name[int32(m.State)]; !ok {
		return errors.New("invalid State")
	}
	for _, e := range m.Flavors {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if err := m.Status.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.AvailabilityZones {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.OsImages {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if _, ok := MaintenanceState_name[int32(m.MaintenanceState)]; !ok {
		return errors.New("invalid MaintenanceState")
	}
	return nil
}

func IgnoreCloudletInfoFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "NotifyId")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Controller")
	}
	return cmpopts.IgnoreFields(CloudletInfo{}, names...)
}

func (m *CloudletMetrics) CopyInFields(src *CloudletMetrics) int {
	changed := 0
	if m.Foo != src.Foo {
		m.Foo = src.Foo
		changed++
	}
	return changed
}

func (m *CloudletMetrics) DeepCopyIn(src *CloudletMetrics) {
	m.Foo = src.Foo
}

// Helper method to check that enums have valid values
func (m *CloudletMetrics) ValidateEnums() error {
	return nil
}

var PlatformTypeStrings = []string{
	"PLATFORM_TYPE_FAKE",
	"PLATFORM_TYPE_DIND",
	"PLATFORM_TYPE_OPENSTACK",
	"PLATFORM_TYPE_AZURE",
	"PLATFORM_TYPE_GCP",
	"PLATFORM_TYPE_EDGEBOX",
	"PLATFORM_TYPE_FAKEINFRA",
	"PLATFORM_TYPE_VSPHERE",
	"PLATFORM_TYPE_AWS",
	"PLATFORM_TYPE_VM_POOL",
	"PLATFORM_TYPE_AWS_VM",
}

const (
	PlatformTypePLATFORM_TYPE_FAKE      uint64 = 1 << 0
	PlatformTypePLATFORM_TYPE_DIND      uint64 = 1 << 1
	PlatformTypePLATFORM_TYPE_OPENSTACK uint64 = 1 << 2
	PlatformTypePLATFORM_TYPE_AZURE     uint64 = 1 << 3
	PlatformTypePLATFORM_TYPE_GCP       uint64 = 1 << 4
	PlatformTypePLATFORM_TYPE_EDGEBOX   uint64 = 1 << 5
	PlatformTypePLATFORM_TYPE_FAKEINFRA uint64 = 1 << 6
	PlatformTypePLATFORM_TYPE_VSPHERE   uint64 = 1 << 7
	PlatformTypePLATFORM_TYPE_AWS       uint64 = 1 << 8
	PlatformTypePLATFORM_TYPE_VM_POOL   uint64 = 1 << 9
	PlatformTypePLATFORM_TYPE_AWS_VM    uint64 = 1 << 10
)

var PlatformType_CamelName = map[int32]string{
	// PLATFORM_TYPE_FAKE -> PlatformTypeFake
	0: "PlatformTypeFake",
	// PLATFORM_TYPE_DIND -> PlatformTypeDind
	1: "PlatformTypeDind",
	// PLATFORM_TYPE_OPENSTACK -> PlatformTypeOpenstack
	2: "PlatformTypeOpenstack",
	// PLATFORM_TYPE_AZURE -> PlatformTypeAzure
	3: "PlatformTypeAzure",
	// PLATFORM_TYPE_GCP -> PlatformTypeGcp
	4: "PlatformTypeGcp",
	// PLATFORM_TYPE_EDGEBOX -> PlatformTypeEdgebox
	5: "PlatformTypeEdgebox",
	// PLATFORM_TYPE_FAKEINFRA -> PlatformTypeFakeinfra
	6: "PlatformTypeFakeinfra",
	// PLATFORM_TYPE_VSPHERE -> PlatformTypeVsphere
	7: "PlatformTypeVsphere",
	// PLATFORM_TYPE_AWS -> PlatformTypeAws
	8: "PlatformTypeAws",
	// PLATFORM_TYPE_VM_POOL -> PlatformTypeVmPool
	9: "PlatformTypeVmPool",
	// PLATFORM_TYPE_AWS_VM -> PlatformTypeAwsVm
	10: "PlatformTypeAwsVm",
}
var PlatformType_CamelValue = map[string]int32{
	"PlatformTypeFake":      0,
	"PlatformTypeDind":      1,
	"PlatformTypeOpenstack": 2,
	"PlatformTypeAzure":     3,
	"PlatformTypeGcp":       4,
	"PlatformTypeEdgebox":   5,
	"PlatformTypeFakeinfra": 6,
	"PlatformTypeVsphere":   7,
	"PlatformTypeAws":       8,
	"PlatformTypeVmPool":    9,
	"PlatformTypeAwsVm":     10,
}

func (e *PlatformType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := PlatformType_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = PlatformType_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = PlatformType(val)
	return nil
}

func (e PlatformType) MarshalYAML() (interface{}, error) {
	return proto.EnumName(PlatformType_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *PlatformType) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := PlatformType_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = PlatformType_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = PlatformType(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = PlatformType(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

var InfraApiAccessStrings = []string{
	"DIRECT_ACCESS",
	"RESTRICTED_ACCESS",
}

const (
	InfraApiAccessDIRECT_ACCESS     uint64 = 1 << 0
	InfraApiAccessRESTRICTED_ACCESS uint64 = 1 << 1
)

var InfraApiAccess_CamelName = map[int32]string{
	// DIRECT_ACCESS -> DirectAccess
	0: "DirectAccess",
	// RESTRICTED_ACCESS -> RestrictedAccess
	1: "RestrictedAccess",
}
var InfraApiAccess_CamelValue = map[string]int32{
	"DirectAccess":     0,
	"RestrictedAccess": 1,
}

func (e *InfraApiAccess) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := InfraApiAccess_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = InfraApiAccess_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = InfraApiAccess(val)
	return nil
}

func (e InfraApiAccess) MarshalYAML() (interface{}, error) {
	return proto.EnumName(InfraApiAccess_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *InfraApiAccess) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := InfraApiAccess_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = InfraApiAccess_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = InfraApiAccess(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = InfraApiAccess(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

var CloudletStateStrings = []string{
	"CLOUDLET_STATE_UNKNOWN",
	"CLOUDLET_STATE_ERRORS",
	"CLOUDLET_STATE_READY",
	"CLOUDLET_STATE_OFFLINE",
	"CLOUDLET_STATE_NOT_PRESENT",
	"CLOUDLET_STATE_INIT",
	"CLOUDLET_STATE_UPGRADE",
	"CLOUDLET_STATE_NEED_SYNC",
}

const (
	CloudletStateCLOUDLET_STATE_UNKNOWN     uint64 = 1 << 0
	CloudletStateCLOUDLET_STATE_ERRORS      uint64 = 1 << 1
	CloudletStateCLOUDLET_STATE_READY       uint64 = 1 << 2
	CloudletStateCLOUDLET_STATE_OFFLINE     uint64 = 1 << 3
	CloudletStateCLOUDLET_STATE_NOT_PRESENT uint64 = 1 << 4
	CloudletStateCLOUDLET_STATE_INIT        uint64 = 1 << 5
	CloudletStateCLOUDLET_STATE_UPGRADE     uint64 = 1 << 6
	CloudletStateCLOUDLET_STATE_NEED_SYNC   uint64 = 1 << 7
)

var CloudletState_CamelName = map[int32]string{
	// CLOUDLET_STATE_UNKNOWN -> CloudletStateUnknown
	0: "CloudletStateUnknown",
	// CLOUDLET_STATE_ERRORS -> CloudletStateErrors
	1: "CloudletStateErrors",
	// CLOUDLET_STATE_READY -> CloudletStateReady
	2: "CloudletStateReady",
	// CLOUDLET_STATE_OFFLINE -> CloudletStateOffline
	3: "CloudletStateOffline",
	// CLOUDLET_STATE_NOT_PRESENT -> CloudletStateNotPresent
	4: "CloudletStateNotPresent",
	// CLOUDLET_STATE_INIT -> CloudletStateInit
	5: "CloudletStateInit",
	// CLOUDLET_STATE_UPGRADE -> CloudletStateUpgrade
	6: "CloudletStateUpgrade",
	// CLOUDLET_STATE_NEED_SYNC -> CloudletStateNeedSync
	7: "CloudletStateNeedSync",
}
var CloudletState_CamelValue = map[string]int32{
	"CloudletStateUnknown":    0,
	"CloudletStateErrors":     1,
	"CloudletStateReady":      2,
	"CloudletStateOffline":    3,
	"CloudletStateNotPresent": 4,
	"CloudletStateInit":       5,
	"CloudletStateUpgrade":    6,
	"CloudletStateNeedSync":   7,
}

func (e *CloudletState) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := CloudletState_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = CloudletState_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = CloudletState(val)
	return nil
}

func (e CloudletState) MarshalYAML() (interface{}, error) {
	return proto.EnumName(CloudletState_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *CloudletState) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := CloudletState_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = CloudletState_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = CloudletState(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = CloudletState(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}
func (m *CloudletKey) Size() (n int) {
	var l int
	_ = l
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *OperationTimeLimits) Size() (n int) {
	var l int
	_ = l
	if m.CreateClusterInstTimeout != 0 {
		n += 1 + sovCloudlet(uint64(m.CreateClusterInstTimeout))
	}
	if m.UpdateClusterInstTimeout != 0 {
		n += 1 + sovCloudlet(uint64(m.UpdateClusterInstTimeout))
	}
	if m.DeleteClusterInstTimeout != 0 {
		n += 1 + sovCloudlet(uint64(m.DeleteClusterInstTimeout))
	}
	if m.CreateAppInstTimeout != 0 {
		n += 1 + sovCloudlet(uint64(m.CreateAppInstTimeout))
	}
	if m.UpdateAppInstTimeout != 0 {
		n += 1 + sovCloudlet(uint64(m.UpdateAppInstTimeout))
	}
	if m.DeleteAppInstTimeout != 0 {
		n += 1 + sovCloudlet(uint64(m.DeleteAppInstTimeout))
	}
	return n
}

func (m *PlatformConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.ContainerRegistryPath)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.CloudletVmImagePath)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.NotifyCtrlAddrs)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.VaultAddr)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.TlsCertFile)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if len(m.EnvVar) > 0 {
		for k, v := range m.EnvVar {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 1 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	l = len(m.PlatformTag)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.TestMode {
		n += 2
	}
	l = len(m.Span)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.CleanupMode {
		n += 2
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.CommercialCerts {
		n += 2
	}
	if m.UseVaultCerts {
		n += 2
	}
	if m.UseVaultCas {
		n += 2
	}
	l = len(m.AppDnsRoot)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.ChefServerPath)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	if m.ChefClientInterval != 0 {
		n += 2 + sovCloudlet(uint64(m.ChefClientInterval))
	}
	l = len(m.DeploymentTag)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *CloudletResMap) Size() (n int) {
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if len(m.Mapping) > 0 {
		for k, v := range m.Mapping {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 1 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *InfraConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.ExternalNetworkName)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.FlavorName)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *Cloudlet) Size() (n int) {
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	l = m.Location.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if m.IpSupport != 0 {
		n += 1 + sovCloudlet(uint64(m.IpSupport))
	}
	l = len(m.StaticIps)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.NumDynamicIps != 0 {
		n += 1 + sovCloudlet(uint64(m.NumDynamicIps))
	}
	l = m.TimeLimits.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	l = m.Status.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if m.State != 0 {
		n += 1 + sovCloudlet(uint64(m.State))
	}
	if m.CrmOverride != 0 {
		n += 1 + sovCloudlet(uint64(m.CrmOverride))
	}
	if m.DeploymentLocal {
		n += 2
	}
	if m.PlatformType != 0 {
		n += 1 + sovCloudlet(uint64(m.PlatformType))
	}
	l = len(m.NotifySrvAddr)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = m.Flavor.Size()
	n += 2 + l + sovCloudlet(uint64(l))
	l = len(m.PhysicalName)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	if len(m.EnvVar) > 0 {
		for k, v := range m.EnvVar {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 2 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	l = len(m.ContainerVersion)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = m.Config.Size()
	n += 2 + l + sovCloudlet(uint64(l))
	if len(m.ResTagMap) > 0 {
		for k, v := range m.ResTagMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCloudlet(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	if len(m.AccessVars) > 0 {
		for k, v := range m.AccessVars {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 2 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	l = len(m.VmImageVersion)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Deployment)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	if m.InfraApiAccess != 0 {
		n += 2 + sovCloudlet(uint64(m.InfraApiAccess))
	}
	l = m.InfraConfig.Size()
	n += 2 + l + sovCloudlet(uint64(l))
	if len(m.ChefClientKey) > 0 {
		for k, v := range m.ChefClientKey {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 2 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	if m.MaintenanceState != 0 {
		n += 2 + sovCloudlet(uint64(m.MaintenanceState))
	}
	if m.OverridePolicyContainerVersion {
		n += 3
	}
	l = len(m.VmPool)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *FlavorMatch) Size() (n int) {
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	l = len(m.FlavorName)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.AvailabilityZone)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *CloudletManifest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Manifest)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *PropertyInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.Secret {
		n += 2
	}
	if m.Mandatory {
		n += 2
	}
	if m.Internal {
		n += 2
	}
	return n
}

func (m *CloudletProps) Size() (n int) {
	var l int
	_ = l
	if m.PlatformType != 0 {
		n += 1 + sovCloudlet(uint64(m.PlatformType))
	}
	if len(m.Properties) > 0 {
		for k, v := range m.Properties {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCloudlet(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FlavorInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.Vcpus != 0 {
		n += 1 + sovCloudlet(uint64(m.Vcpus))
	}
	if m.Ram != 0 {
		n += 1 + sovCloudlet(uint64(m.Ram))
	}
	if m.Disk != 0 {
		n += 1 + sovCloudlet(uint64(m.Disk))
	}
	if len(m.PropMap) > 0 {
		for k, v := range m.PropMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 1 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *OSAZone) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *OSImage) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Tags)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Properties)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.DiskFormat)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *CloudletInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if m.State != 0 {
		n += 1 + sovCloudlet(uint64(m.State))
	}
	if m.NotifyId != 0 {
		n += 1 + sovCloudlet(uint64(m.NotifyId))
	}
	l = len(m.Controller)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.OsMaxRam != 0 {
		n += 1 + sovCloudlet(uint64(m.OsMaxRam))
	}
	if m.OsMaxVcores != 0 {
		n += 1 + sovCloudlet(uint64(m.OsMaxVcores))
	}
	if m.OsMaxVolGb != 0 {
		n += 1 + sovCloudlet(uint64(m.OsMaxVolGb))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	if len(m.Flavors) > 0 {
		for _, e := range m.Flavors {
			l = e.Size()
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	l = m.Status.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	l = len(m.ContainerVersion)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if len(m.AvailabilityZones) > 0 {
		for _, e := range m.AvailabilityZones {
			l = e.Size()
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	if len(m.OsImages) > 0 {
		for _, e := range m.OsImages {
			l = e.Size()
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	if m.ControllerCacheReceived {
		n += 2
	}
	if m.MaintenanceState != 0 {
		n += 2 + sovCloudlet(uint64(m.MaintenanceState))
	}
	return n
}

func (m *CloudletMetrics) Size() (n int) {
	var l int
	_ = l
	if m.Foo != 0 {
		n += 1 + sovCloudlet(uint64(m.Foo))
	}
	return n
}

func sovCloudlet(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCloudlet(x uint64) (n int) {
	return sovCloudlet(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CloudletKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperationTimeLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperationTimeLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperationTimeLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateClusterInstTimeout", wireType)
			}
			m.CreateClusterInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateClusterInstTimeout |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateClusterInstTimeout", wireType)
			}
			m.UpdateClusterInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateClusterInstTimeout |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteClusterInstTimeout", wireType)
			}
			m.DeleteClusterInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteClusterInstTimeout |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAppInstTimeout", wireType)
			}
			m.CreateAppInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAppInstTimeout |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAppInstTimeout", wireType)
			}
			m.UpdateAppInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAppInstTimeout |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteAppInstTimeout", wireType)
			}
			m.DeleteAppInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteAppInstTimeout |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlatformConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlatformConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlatformConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerRegistryPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerRegistryPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletVmImagePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudletVmImagePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyCtrlAddrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotifyCtrlAddrs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsCertFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsCertFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvVar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnvVar == nil {
				m.EnvVar = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EnvVar[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlatformTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TestMode = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Span = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CleanupMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CleanupMode = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommercialCerts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CommercialCerts = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseVaultCerts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseVaultCerts = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseVaultCas", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseVaultCas = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppDnsRoot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppDnsRoot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChefServerPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChefServerPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChefClientInterval", wireType)
			}
			m.ChefClientInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChefClientInterval |= (Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletResMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletResMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletResMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mapping == nil {
				m.Mapping = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Mapping[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfraConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfraConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfraConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalNetworkName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalNetworkName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlavorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlavorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cloudlet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cloudlet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cloudlet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpSupport", wireType)
			}
			m.IpSupport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpSupport |= (IpSupport(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticIps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticIps = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumDynamicIps", wireType)
			}
			m.NumDynamicIps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumDynamicIps |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TimeLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (TrackedState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrmOverride", wireType)
			}
			m.CrmOverride = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrmOverride |= (CRMOverride(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentLocal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeploymentLocal = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformType", wireType)
			}
			m.PlatformType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlatformType |= (PlatformType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifySrvAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotifySrvAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flavor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Flavor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvVar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnvVar == nil {
				m.EnvVar = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EnvVar[mapkey] = mapvalue
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResTagMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResTagMap == nil {
				m.ResTagMap = make(map[string]*ResTagTableKey)
			}
			var mapkey string
			var mapvalue *ResTagTableKey
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCloudlet
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ResTagTableKey{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResTagMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessVars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessVars == nil {
				m.AccessVars = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AccessVars[mapkey] = mapvalue
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmImageVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmImageVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deployment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraApiAccess", wireType)
			}
			m.InfraApiAccess = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InfraApiAccess |= (InfraApiAccess(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InfraConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChefClientKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChefClientKey == nil {
				m.ChefClientKey = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ChefClientKey[mapkey] = mapvalue
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceState", wireType)
			}
			m.MaintenanceState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaintenanceState |= (MaintenanceState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverridePolicyContainerVersion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverridePolicyContainerVersion = bool(v != 0)
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmPool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmPool = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlavorMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlavorMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlavorMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlavorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlavorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletManifest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletManifest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletManifest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manifest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manifest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropertyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropertyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropertyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Secret = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mandatory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mandatory = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Internal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Internal = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletProps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletProps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletProps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformType", wireType)
			}
			m.PlatformType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlatformType |= (PlatformType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = make(map[string]*PropertyInfo)
			}
			var mapkey string
			var mapvalue *PropertyInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCloudlet
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PropertyInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Properties[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlavorInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlavorInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlavorInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vcpus", wireType)
			}
			m.Vcpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vcpus |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ram", wireType)
			}
			m.Ram = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ram |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disk", wireType)
			}
			m.Disk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Disk |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PropMap == nil {
				m.PropMap = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PropMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSAZone) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSAZone: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSAZone: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSImage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSImage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSImage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (CloudletState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyId", wireType)
			}
			m.NotifyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotifyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsMaxRam", wireType)
			}
			m.OsMaxRam = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OsMaxRam |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsMaxVcores", wireType)
			}
			m.OsMaxVcores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OsMaxVcores |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsMaxVolGb", wireType)
			}
			m.OsMaxVolGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OsMaxVolGb |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flavors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flavors = append(m.Flavors, &FlavorInfo{})
			if err := m.Flavors[len(m.Flavors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityZones", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityZones = append(m.AvailabilityZones, &OSAZone{})
			if err := m.AvailabilityZones[len(m.AvailabilityZones)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsImages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OsImages = append(m.OsImages, &OSImage{})
			if err := m.OsImages[len(m.OsImages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControllerCacheReceived", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ControllerCacheReceived = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceState", wireType)
			}
			m.MaintenanceState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaintenanceState |= (MaintenanceState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Foo", wireType)
			}
			m.Foo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Foo |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCloudlet(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCloudlet
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCloudlet(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCloudlet = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCloudlet   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("cloudlet.proto", fileDescriptorCloudlet) }

var fileDescriptorCloudlet = []byte{
	// 3283 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x19, 0x4b, 0x6c, 0x1b, 0xc7,
	0xd5, 0x2b, 0x51, 0x1f, 0x0e, 0x29, 0x6a, 0x35, 0xfa, 0xad, 0x69, 0x5b, 0x56, 0x18, 0x24, 0x70,
	0x5c, 0x5a, 0x6c, 0x65, 0xa4, 0x70, 0x85, 0xd8, 0x09, 0x45, 0x52, 0x36, 0xa1, 0x6f, 0x97, 0xb4,
	0xdc, 0x04, 0x28, 0x16, 0xa3, 0xe5, 0x88, 0xda, 0x7a, 0x77, 0x67, 0x3b, 0xbb, 0xa4, 0x4d, 0x9f,
	0xda, 0x5e, 0xfa, 0x39, 0xf5, 0x77, 0x68, 0x53, 0x34, 0xf5, 0xa5, 0x45, 0x10, 0xf4, 0x10, 0xe4,
	0x18, 0x14, 0x3d, 0x1b, 0xed, 0x25, 0x68, 0x0f, 0x05, 0x02, 0x24, 0x48, 0x8d, 0x1e, 0x8a, 0x5c,
	0x5a, 0x20, 0x92, 0x51, 0xf4, 0x50, 0x14, 0x33, 0xb3, 0x4b, 0xee, 0x92, 0x2b, 0x27, 0x52, 0x8a,
	0x5e, 0x88, 0x99, 0xf7, 0x9b, 0x37, 0xef, 0xbd, 0x79, 0x1f, 0x2e, 0xc8, 0xe8, 0x26, 0x69, 0x35,
	0x4c, 0xec, 0x2d, 0x39, 0x94, 0x78, 0x04, 0x26, 0x71, 0xa3, 0x89, 0xf9, 0x32, 0x7b, 0xbe, 0x49,
	0x48, 0xd3, 0xc4, 0x05, 0xe4, 0x18, 0x05, 0x64, 0xdb, 0xc4, 0x43, 0x9e, 0x41, 0x6c, 0x57, 0x10,
	0x66, 0xaf, 0x35, 0x0d, 0xef, 0xa0, 0xb5, 0xb7, 0xa4, 0x13, 0xab, 0x60, 0x91, 0x3d, 0xc3, 0x64,
	0x8c, 0xf7, 0x0b, 0xec, 0xf7, 0x0a, 0x97, 0x59, 0xe0, 0x74, 0x4d, 0x6c, 0x77, 0x17, 0x3e, 0x67,
	0x7a, 0xdf, 0x44, 0x6d, 0x42, 0x83, 0x1d, 0xc5, 0x6e, 0xcb, 0xf4, 0x8f, 0xcf, 0x4e, 0x51, 0xec,
	0x7a, 0xa8, 0xe9, 0xa1, 0x3d, 0x13, 0x07, 0x04, 0x3a, 0xb1, 0x2c, 0x12, 0x30, 0x97, 0x3e, 0xf5,
	0xd8, 0xc6, 0x15, 0x0b, 0x79, 0xfa, 0xc1, 0x15, 0x6c, 0x37, 0x0d, 0x1b, 0x17, 0x1a, 0x16, 0xbe,
	0xc2, 0x59, 0x0b, 0x26, 0xd1, 0x7d, 0x21, 0x33, 0x4d, 0xd2, 0x24, 0x02, 0xc8, 0x56, 0x02, 0x9a,
	0xa3, 0x20, 0x55, 0xf2, 0x8d, 0xb1, 0x8e, 0x3b, 0xf0, 0x2a, 0x48, 0x13, 0xda, 0x44, 0xb6, 0xf1,
	0x80, 0xdf, 0x5b, 0x91, 0x16, 0xa5, 0x4b, 0xc9, 0xd5, 0xc9, 0x77, 0x9f, 0x28, 0xa9, 0xc0, 0x66,
	0x84, 0x36, 0xd5, 0x08, 0x11, 0x5c, 0x04, 0x09, 0x1b, 0x59, 0x58, 0x19, 0xe2, 0xc4, 0xe9, 0x77,
	0x9f, 0x28, 0xe3, 0x01, 0xb1, 0xca, 0x31, 0x2b, 0xe9, 0xbf, 0x7f, 0xa2, 0x48, 0xff, 0xfa, 0x44,
	0x91, 0xde, 0x7e, 0x78, 0x51, 0xca, 0xfd, 0x71, 0x18, 0x4c, 0x6f, 0x3b, 0x98, 0x72, 0xee, 0xba,
	0x61, 0xe1, 0x0d, 0xc3, 0x32, 0x3c, 0x17, 0xae, 0x83, 0x73, 0x3a, 0xc5, 0xc8, 0xc3, 0x9a, 0x6e,
	0xb6, 0x5c, 0x0f, 0x53, 0xcd, 0xb0, 0x5d, 0x4f, 0xf3, 0x0c, 0x0b, 0x93, 0x96, 0xc7, 0x75, 0x19,
	0x5e, 0x4d, 0xff, 0xfb, 0xc3, 0x8b, 0xe3, 0xe5, 0x96, 0x60, 0x56, 0x15, 0xc1, 0x50, 0x12, 0xf4,
	0x55, 0xdb, 0xf5, 0xea, 0x82, 0x9a, 0x09, 0x6b, 0x39, 0x8d, 0x63, 0x85, 0x0d, 0xc5, 0x09, 0x13,
	0x0c, 0xf1, 0xc2, 0x1a, 0xd8, 0xc4, 0xc7, 0x09, 0x1b, 0x8e, 0x13, 0x26, 0x18, 0x62, 0x84, 0x95,
	0xc0, 0xbc, 0x7f, 0x4d, 0xe4, 0x38, 0x51, 0x41, 0x89, 0x18, 0x41, 0x33, 0x82, 0xb8, 0xe8, 0x38,
	0x7d, 0x42, 0xfc, 0xeb, 0x0d, 0x08, 0x19, 0x89, 0x13, 0x22, 0x88, 0x07, 0x85, 0xf8, 0xd7, 0x1a,
	0x10, 0x32, 0x1a, 0x27, 0x44, 0x10, 0x47, 0x85, 0xe4, 0x1e, 0x8e, 0x82, 0xcc, 0x8e, 0x89, 0xbc,
	0x7d, 0x42, 0xad, 0x12, 0xb1, 0xf7, 0x8d, 0x26, 0xfc, 0x32, 0x98, 0xd7, 0x89, 0xed, 0x21, 0xc3,
	0xc6, 0x54, 0xa3, 0xb8, 0x69, 0xb8, 0x1e, 0xed, 0x68, 0x0e, 0xf2, 0x0e, 0x44, 0x40, 0xa9, 0xb3,
	0x5d, 0xb4, 0xea, 0x63, 0x77, 0x90, 0x77, 0x00, 0xaf, 0x82, 0xb9, 0x20, 0x70, 0xb4, 0xb6, 0xa5,
	0x19, 0x16, 0x6a, 0x62, 0xc1, 0xc6, 0x43, 0x4b, 0x9d, 0x0e, 0xb0, 0xbb, 0x56, 0x95, 0xe1, 0x38,
	0xd3, 0x65, 0x30, 0x65, 0x13, 0xcf, 0xd8, 0xef, 0x68, 0xba, 0x47, 0x4d, 0x0d, 0x35, 0x1a, 0xd4,
	0xe5, 0x1e, 0x49, 0xaa, 0x93, 0x02, 0x51, 0xf2, 0xa8, 0x59, 0x64, 0x60, 0x78, 0x01, 0x80, 0x36,
	0x6a, 0x99, 0x1e, 0xa7, 0xe2, 0xd6, 0x4e, 0xaa, 0x49, 0x0e, 0x61, 0x78, 0x98, 0x03, 0x13, 0x9e,
	0xe9, 0x6a, 0x3a, 0xa6, 0x9e, 0xb6, 0x6f, 0x98, 0x98, 0x9b, 0x32, 0xa9, 0xa6, 0x3c, 0xd3, 0x2d,
	0x61, 0xea, 0xad, 0x19, 0x26, 0x86, 0x37, 0xc0, 0x18, 0xb6, 0xdb, 0x5a, 0x1b, 0x51, 0x65, 0x74,
	0x71, 0xf8, 0x52, 0x6a, 0xf9, 0xb9, 0xa5, 0x6e, 0xf6, 0x58, 0x8a, 0xda, 0x61, 0xa9, 0x62, 0xb7,
	0x77, 0x11, 0xad, 0xd8, 0x1e, 0xed, 0xa8, 0xa3, 0x98, 0x6f, 0xe0, 0x33, 0x20, 0xed, 0xf8, 0x54,
	0x9a, 0x87, 0x9a, 0xca, 0xb8, 0x38, 0x22, 0x80, 0xd5, 0x51, 0x13, 0x9e, 0x03, 0x49, 0x0f, 0xbb,
	0x9e, 0x66, 0x91, 0x06, 0x56, 0x92, 0x8b, 0xd2, 0xa5, 0x71, 0x75, 0x9c, 0x01, 0x36, 0x49, 0x03,
	0x43, 0x08, 0x12, 0xae, 0x83, 0x6c, 0x05, 0x70, 0x3e, 0xbe, 0x66, 0x32, 0x75, 0x13, 0x23, 0xbb,
	0xe5, 0x08, 0x9e, 0x14, 0xe7, 0x49, 0xf9, 0x30, 0xce, 0x36, 0x07, 0x46, 0x99, 0x23, 0x88, 0xad,
	0xa4, 0x39, 0xa3, 0xbf, 0x83, 0x2f, 0x00, 0x99, 0xa5, 0x1a, 0x4c, 0x75, 0x03, 0x99, 0xfc, 0xe6,
	0xae, 0x32, 0xc1, 0xd9, 0x27, 0x7b, 0x70, 0x76, 0x79, 0x17, 0x3e, 0x0f, 0x26, 0x5b, 0x2e, 0xd6,
	0x84, 0x01, 0x05, 0x65, 0x86, 0x53, 0x4e, 0xb4, 0x5c, 0xbc, 0xcb, 0xa0, 0x82, 0x2e, 0x07, 0x26,
	0x42, 0x74, 0xc8, 0x55, 0x26, 0x85, 0x3a, 0x5d, 0x2a, 0xe4, 0xc2, 0x45, 0x90, 0x66, 0x21, 0xd7,
	0xb0, 0x5d, 0x8d, 0x12, 0xe2, 0x29, 0x32, 0x57, 0x0a, 0x20, 0xc7, 0x29, 0xdb, 0xae, 0x4a, 0x88,
	0x07, 0x2f, 0x01, 0x59, 0x3f, 0xc0, 0xfb, 0x9a, 0x8b, 0x69, 0x1b, 0x53, 0x11, 0x05, 0x53, 0x9c,
	0x2a, 0xc3, 0xe0, 0x35, 0x0e, 0xe6, 0x01, 0x70, 0x03, 0xcc, 0x70, 0x4a, 0xdd, 0x34, 0xb0, 0xed,
	0x69, 0x86, 0xed, 0x61, 0xda, 0x46, 0xa6, 0x02, 0x17, 0xa5, 0x4b, 0x23, 0x7d, 0x21, 0x0c, 0x19,
	0x65, 0x89, 0x13, 0x56, 0x7d, 0x3a, 0xf8, 0x1c, 0xc8, 0x34, 0xb0, 0x63, 0x92, 0x8e, 0xc5, 0xd8,
	0x99, 0x4f, 0xa6, 0xf9, 0x39, 0x13, 0x3d, 0x68, 0x1d, 0x35, 0xb3, 0x5f, 0x01, 0xa9, 0x90, 0x3f,
	0xa1, 0x0c, 0x86, 0xef, 0xe2, 0x8e, 0x1f, 0xcf, 0x6c, 0x09, 0x67, 0xc0, 0x48, 0x1b, 0x99, 0x2d,
	0x3f, 0x0f, 0xaa, 0x62, 0xb3, 0x32, 0x74, 0x4d, 0xca, 0xfd, 0x47, 0x02, 0x99, 0x20, 0xcb, 0xaa,
	0xd8, 0xdd, 0x44, 0x0e, 0x5c, 0xea, 0xb1, 0xa7, 0x96, 0xe7, 0x42, 0x21, 0x14, 0xca, 0xc6, 0xab,
	0x89, 0x47, 0x1f, 0x5e, 0x3c, 0x23, 0x84, 0xbf, 0x02, 0xc6, 0x2c, 0xe4, 0x38, 0x86, 0xdd, 0x54,
	0x86, 0x78, 0xd8, 0x3d, 0x1f, 0xc3, 0x23, 0x64, 0x2f, 0x6d, 0x0a, 0x42, 0x11, 0x77, 0x01, 0x5b,
	0x76, 0x05, 0xa4, 0xc3, 0x88, 0x93, 0x5c, 0x60, 0xe5, 0xc6, 0xeb, 0x47, 0x4a, 0x21, 0x78, 0x7c,
	0xd7, 0xd7, 0x71, 0x67, 0x69, 0x0b, 0x59, 0x38, 0x1f, 0x40, 0xae, 0x10, 0xda, 0xe4, 0xd0, 0xed,
	0x50, 0x59, 0xf8, 0xc3, 0x91, 0x32, 0xe6, 0x1f, 0x98, 0xdb, 0x03, 0xa9, 0xaa, 0xbd, 0x4f, 0x91,
	0x9f, 0x1f, 0x96, 0xc1, 0x2c, 0xbe, 0xef, 0x61, 0x6a, 0x23, 0x53, 0xb3, 0xb1, 0x77, 0x8f, 0xd0,
	0xbb, 0x1a, 0xaf, 0x20, 0x42, 0x99, 0xe9, 0x00, 0xb9, 0x25, 0x70, 0xec, 0x2c, 0x78, 0x11, 0xa4,
	0x44, 0x09, 0xd5, 0x7a, 0xb5, 0x46, 0x05, 0x02, 0xc4, 0x08, 0x72, 0xdf, 0x9f, 0x02, 0xe3, 0x81,
	0x21, 0x58, 0xb8, 0xef, 0x1b, 0xd8, 0x6c, 0xb8, 0x8a, 0xb4, 0x38, 0xcc, 0xc2, 0x5d, 0xec, 0x02,
	0xb3, 0x0f, 0x7d, 0x56, 0xb3, 0xbf, 0x0c, 0xc6, 0x4d, 0xa2, 0x8b, 0x5a, 0x38, 0xc2, 0x99, 0x2e,
	0x2c, 0x35, 0x58, 0xc2, 0x32, 0xf6, 0x5a, 0x1e, 0x6e, 0x68, 0xbc, 0xea, 0x6a, 0xa2, 0xea, 0x2e,
	0x6d, 0x10, 0xdd, 0xe7, 0xed, 0x32, 0xc1, 0xab, 0x00, 0x18, 0x8e, 0xe6, 0xb6, 0x1c, 0x87, 0x50,
	0x91, 0x55, 0x33, 0xcb, 0x33, 0xa1, 0x73, 0xab, 0x4e, 0x4d, 0xe0, 0xd4, 0xa4, 0x11, 0x2c, 0x59,
	0x9a, 0x72, 0x59, 0xe3, 0xa1, 0x6b, 0x86, 0xe3, 0x2a, 0x63, 0x22, 0x4d, 0x09, 0x48, 0xd5, 0xe1,
	0x0f, 0xd1, 0x6e, 0x59, 0x5a, 0xa3, 0x63, 0x23, 0xcb, 0xa7, 0x61, 0x59, 0x64, 0x44, 0x9d, 0xb0,
	0x5b, 0x56, 0x59, 0x40, 0x19, 0x5d, 0x05, 0xa4, 0x58, 0x3a, 0xd7, 0x4c, 0x5e, 0x5e, 0x79, 0x26,
	0x49, 0x2d, 0x2f, 0x84, 0x0e, 0x8f, 0x29, 0xc2, 0xfe, 0x05, 0x80, 0xd7, 0x2b, 0xcb, 0xcf, 0x81,
	0x51, 0x4c, 0x29, 0xa1, 0xae, 0x02, 0x98, 0x2d, 0x57, 0x27, 0xde, 0x3c, 0x54, 0xa4, 0x1f, 0xbf,
	0x73, 0x76, 0xc4, 0x26, 0xba, 0xe5, 0xa8, 0x3e, 0x12, 0xbe, 0x02, 0x46, 0x99, 0x8a, 0x2d, 0x97,
	0xa7, 0x9f, 0xd4, 0xf2, 0x6c, 0xe8, 0xa0, 0x1a, 0x47, 0x54, 0xed, 0x7d, 0xb2, 0x3a, 0x15, 0xe1,
	0xe6, 0x87, 0xf9, 0x7c, 0xf0, 0x25, 0x30, 0xc2, 0x56, 0x98, 0xa7, 0xa8, 0xcc, 0xf2, 0x7c, 0x48,
	0x40, 0x9d, 0x22, 0xfd, 0x2e, 0x6e, 0x30, 0x39, 0xb8, 0x5f, 0x01, 0xc1, 0x04, 0x6f, 0x81, 0xb4,
	0x4e, 0x2d, 0x8d, 0xb4, 0x31, 0xa5, 0x46, 0x03, 0xf3, 0x2c, 0x96, 0x89, 0xfa, 0x58, 0xdd, 0xdc,
	0xf6, 0xb1, 0xfd, 0x32, 0x52, 0x3a, 0xb5, 0x02, 0x1c, 0xbc, 0x06, 0xe4, 0x50, 0x42, 0x60, 0xae,
	0x34, 0x45, 0xa6, 0xeb, 0xe7, 0x9a, 0xec, 0x91, 0x6d, 0x30, 0x2a, 0xf8, 0x12, 0x98, 0xe8, 0x25,
	0xf7, 0x8e, 0x83, 0x79, 0xea, 0x8b, 0xde, 0x24, 0x28, 0x11, 0xf5, 0x8e, 0x83, 0xd5, 0x6e, 0x29,
	0x60, 0x3b, 0xf8, 0x25, 0xe0, 0x17, 0x2c, 0xcd, 0xa5, 0x6d, 0x51, 0xa2, 0x78, 0x5e, 0x5c, 0x4d,
	0xf6, 0x8e, 0x9c, 0x10, 0x14, 0x35, 0xda, 0xe6, 0x15, 0x6b, 0x19, 0x8c, 0x8a, 0x27, 0xc0, 0x73,
	0x63, 0x2a, 0x12, 0x5a, 0x6b, 0x1c, 0xd1, 0x0b, 0x68, 0x9f, 0x12, 0x3e, 0x0b, 0x26, 0x9c, 0x83,
	0x8e, 0x6b, 0xe8, 0xec, 0xf5, 0xb1, 0xb7, 0x04, 0x79, 0x80, 0xa5, 0x03, 0x20, 0x7f, 0x6e, 0xd7,
	0x7a, 0x65, 0x6e, 0x9a, 0xe7, 0x9b, 0x8b, 0x31, 0x8f, 0x25, 0xb6, 0xc0, 0x7d, 0x01, 0x4c, 0xf5,
	0x8a, 0x7f, 0x1b, 0x53, 0x97, 0xbd, 0x9d, 0x19, 0x7e, 0x84, 0xdc, 0x45, 0xec, 0x0a, 0x38, 0x2c,
	0x83, 0x51, 0x9d, 0xe7, 0x04, 0x65, 0x96, 0xeb, 0x7f, 0xf6, 0xd8, 0x62, 0x1a, 0x1b, 0x38, 0x82,
	0x17, 0xde, 0x02, 0x29, 0x8a, 0x5d, 0x96, 0xba, 0x35, 0x0b, 0x39, 0xca, 0x1c, 0x57, 0x38, 0x17,
	0xa7, 0xb0, 0x8a, 0xdd, 0x3a, 0x6a, 0x6e, 0x22, 0x87, 0xeb, 0xbc, 0x9a, 0x60, 0x32, 0xd5, 0x24,
	0x0d, 0xa0, 0xb0, 0x0c, 0x52, 0x48, 0xd7, 0xb1, 0xeb, 0xb2, 0x9b, 0xbb, 0xca, 0x3c, 0x97, 0xf4,
	0x6c, 0x9c, 0xa4, 0x22, 0x27, 0xdb, 0x45, 0xd4, 0x15, 0xd7, 0x07, 0xa8, 0x0b, 0x60, 0xb5, 0xab,
	0xdb, 0xbe, 0x04, 0x16, 0x50, 0x44, 0xed, 0x6a, 0x8b, 0xce, 0x25, 0xb8, 0xff, 0x0b, 0x00, 0xf4,
	0x62, 0x48, 0xc9, 0xf6, 0x7b, 0x3b, 0x84, 0x84, 0x25, 0x20, 0x1b, 0x2c, 0x87, 0x6a, 0xc8, 0x31,
	0x34, 0x71, 0x98, 0x72, 0x8e, 0x87, 0x57, 0xd8, 0x68, 0x3c, 0xcd, 0x16, 0x1d, 0x43, 0xa8, 0xa7,
	0x66, 0x8c, 0xc8, 0x1e, 0xbe, 0x0c, 0xd2, 0x42, 0x88, 0x6f, 0xf5, 0xf3, 0x03, 0x89, 0x30, 0x94,
	0xa7, 0xfd, 0xb8, 0x49, 0x19, 0xa1, 0xd4, 0x5d, 0x07, 0x93, 0xe1, 0x62, 0xcb, 0x92, 0xe9, 0x85,
	0x63, 0xeb, 0xd1, 0x52, 0xa9, 0x5b, 0x6d, 0xd7, 0x71, 0x27, 0x6c, 0xf2, 0x09, 0x3d, 0x8c, 0x81,
	0xb7, 0xc0, 0x94, 0x85, 0x58, 0xe1, 0xb6, 0x91, 0xad, 0x63, 0x4d, 0x64, 0x81, 0x05, 0x7e, 0xb9,
	0x73, 0x21, 0xb9, 0x9b, 0x3d, 0x1a, 0x9e, 0x09, 0x54, 0xd9, 0xea, 0x83, 0xc0, 0x2a, 0x78, 0x26,
	0xc8, 0x00, 0x9a, 0x43, 0x4c, 0x43, 0xef, 0x68, 0x83, 0xd1, 0x78, 0x91, 0x37, 0x24, 0x0b, 0x01,
	0xe1, 0x0e, 0xa7, 0x2b, 0xf5, 0xc7, 0xe6, 0x3c, 0x18, 0x6b, 0x5b, 0x9a, 0x43, 0x88, 0xa9, 0x2c,
	0x8a, 0x9e, 0xa9, 0x6d, 0xed, 0x10, 0x62, 0x7e, 0x8e, 0x4e, 0x20, 0x7b, 0x07, 0x64, 0xa2, 0x21,
	0x18, 0xc3, 0x5d, 0x08, 0x73, 0x47, 0x9f, 0x84, 0xe0, 0xad, 0xb3, 0x41, 0x71, 0x1d, 0x77, 0xc2,
	0x82, 0xaf, 0x83, 0xc9, 0xbe, 0x88, 0x3c, 0x91, 0x5e, 0xaf, 0x00, 0x38, 0xe8, 0xab, 0x13, 0xb5,
	0x08, 0x3f, 0x18, 0x62, 0x33, 0xde, 0x3f, 0x3f, 0x51, 0xa4, 0x6f, 0x1d, 0x2a, 0xd2, 0x0f, 0x0f,
	0x15, 0xe9, 0x67, 0x87, 0x8a, 0xf4, 0xf6, 0xa1, 0x22, 0x3d, 0x3a, 0x54, 0xa4, 0xf7, 0xd8, 0xdb,
	0x3d, 0x52, 0xde, 0x90, 0x36, 0xfc, 0xc2, 0xb8, 0x74, 0x8b, 0x50, 0xe3, 0x01, 0x33, 0xb9, 0x59,
	0xd4, 0xf5, 0x16, 0x45, 0x7a, 0x27, 0xdf, 0xc5, 0xed, 0x62, 0xea, 0xb1, 0x4c, 0x34, 0x88, 0x29,
	0x91, 0x16, 0x75, 0x71, 0x6f, 0x5f, 0x73, 0x30, 0x6e, 0xf4, 0xb6, 0xac, 0x8e, 0xb9, 0x1e, 0xb2,
	0x9c, 0xbc, 0xa8, 0x38, 0x79, 0x11, 0xb5, 0xf9, 0xad, 0x70, 0xd2, 0xcc, 0x47, 0x6e, 0xca, 0x29,
	0x71, 0xbe, 0xc2, 0x8b, 0xd8, 0x29, 0xda, 0x9c, 0x77, 0x9e, 0x28, 0xf2, 0x5d, 0xdc, 0xb9, 0x1e,
	0x86, 0xe5, 0xfe, 0x24, 0x81, 0x94, 0x48, 0xbf, 0x9b, 0xac, 0x41, 0x38, 0x71, 0xb7, 0xd7, 0xd7,
	0xec, 0x0c, 0xf7, 0x37, 0x3b, 0x2c, 0xc9, 0xa2, 0x36, 0x32, 0x4c, 0xb4, 0x67, 0x98, 0x86, 0xd7,
	0xd1, 0x1e, 0x10, 0x1b, 0xfb, 0xf3, 0x8c, 0x1c, 0x46, 0xbc, 0x46, 0x6c, 0xbc, 0x52, 0x79, 0xfd,
	0x48, 0x29, 0x9e, 0xf0, 0x5a, 0x79, 0x71, 0xd8, 0xf5, 0xb5, 0x5e, 0x83, 0xb5, 0x04, 0xe4, 0x40,
	0xdd, 0x4d, 0x64, 0x1b, 0xfb, 0xd8, 0xf5, 0x60, 0x16, 0x8c, 0x5b, 0xfe, 0xda, 0x0f, 0x89, 0xee,
	0x3e, 0xf7, 0x5b, 0x09, 0xa4, 0x77, 0x28, 0x71, 0x30, 0xf5, 0x3a, 0xac, 0xf4, 0xb3, 0xd1, 0x25,
	0xd4, 0xe5, 0xf1, 0x35, 0x5c, 0x04, 0xa9, 0x06, 0x76, 0x75, 0x6a, 0x38, 0xbc, 0xc7, 0x12, 0x32,
	0xc2, 0xa0, 0x5e, 0xc8, 0x0d, 0x87, 0x42, 0x8e, 0x35, 0x78, 0x2e, 0xd6, 0x29, 0x16, 0x33, 0xf3,
	0xb8, 0xea, 0xef, 0xe0, 0x79, 0x90, 0xb4, 0x90, 0xdd, 0x40, 0x1e, 0xa1, 0x1d, 0xde, 0xb1, 0x8d,
	0xab, 0x3d, 0x00, 0x53, 0x97, 0x8f, 0x07, 0x36, 0x32, 0x79, 0x2f, 0x36, 0xae, 0x76, 0xf7, 0xb9,
	0x7f, 0x48, 0x60, 0x22, 0xb8, 0x1f, 0x53, 0xdb, 0x1d, 0xac, 0xe6, 0xd2, 0x49, 0xaa, 0xf9, 0x2d,
	0x00, 0x1c, 0x71, 0x7b, 0x03, 0xbb, 0x7e, 0xd3, 0x7e, 0x29, 0xc6, 0xf5, 0xfc, 0xac, 0xa5, 0x9d,
	0x2e, 0xa9, 0x5f, 0x4e, 0x7a, 0xbc, 0xd9, 0x5d, 0x30, 0xd9, 0x87, 0x8e, 0x79, 0x99, 0x57, 0xa2,
	0x59, 0x23, 0xa2, 0x64, 0xc8, 0x09, 0xe1, 0xb1, 0xe4, 0x03, 0x09, 0x00, 0xe1, 0xdf, 0x63, 0xdd,
	0xc3, 0x8c, 0xaf, 0x3b, 0x2d, 0x97, 0x4b, 0x4d, 0xa8, 0x62, 0xc3, 0x4e, 0xa7, 0xc8, 0xe2, 0x0e,
	0x49, 0xa8, 0x6c, 0xc9, 0x78, 0x1b, 0x86, 0x7b, 0x97, 0x3b, 0x23, 0xa1, 0xf2, 0x35, 0x2c, 0x81,
	0x71, 0x76, 0x09, 0x5e, 0x92, 0x47, 0x06, 0x4a, 0x72, 0xef, 0x60, 0xae, 0x5f, 0x5f, 0x49, 0x1e,
	0x73, 0x04, 0x8c, 0x4d, 0x2d, 0x61, 0xf4, 0x89, 0xc6, 0xae, 0x17, 0xc1, 0xd8, 0x76, 0xad, 0xc8,
	0x9e, 0x40, 0xec, 0xdd, 0xe6, 0xba, 0x0d, 0xab, 0xe0, 0xf4, 0x77, 0x39, 0xca, 0xd8, 0x78, 0x95,
	0x8e, 0x65, 0x83, 0x20, 0xe1, 0xa1, 0x66, 0xc0, 0xc4, 0xd7, 0x70, 0x21, 0xe2, 0x6b, 0xff, 0xb9,
	0xf6, 0x20, 0xec, 0x3d, 0x33, 0x93, 0x68, 0x2c, 0x38, 0x90, 0xe7, 0x3f, 0x54, 0xc0, 0x40, 0x6b,
	0x1c, 0x92, 0xfb, 0xdd, 0x28, 0x48, 0x07, 0x01, 0xc1, 0x9d, 0xf1, 0xbf, 0x1a, 0x60, 0x96, 0x82,
	0x9e, 0x7a, 0x98, 0xc7, 0xae, 0x12, 0xc3, 0x21, 0x4a, 0xa9, 0xdf, 0x45, 0x3f, 0x0f, 0x92, 0x7e,
	0x0f, 0x6a, 0x34, 0xfc, 0xbf, 0xa3, 0x42, 0xfd, 0xc8, 0xb8, 0xc0, 0x55, 0x1b, 0xac, 0x71, 0x61,
	0x75, 0x95, 0x12, 0xd3, 0xc4, 0x54, 0xfc, 0x4f, 0x12, 0x69, 0x5c, 0x7a, 0x48, 0x78, 0x1e, 0x00,
	0xe2, 0x6a, 0x16, 0xba, 0xaf, 0xb1, 0xa0, 0x19, 0xe5, 0x11, 0x32, 0x4e, 0xdc, 0x4d, 0x74, 0x5f,
	0x45, 0x16, 0xcc, 0x81, 0x09, 0x1f, 0xdb, 0xd6, 0x09, 0xc5, 0x62, 0xdc, 0x49, 0xa8, 0x29, 0x4e,
	0xb0, 0xcb, 0x41, 0xf0, 0x99, 0x1e, 0x0d, 0x31, 0xb5, 0xe6, 0x1e, 0x1f, 0x77, 0x12, 0x2a, 0x10,
	0x34, 0xc4, 0xbc, 0xb9, 0xc7, 0xec, 0xe5, 0x0f, 0x29, 0x49, 0x61, 0x2f, 0x7f, 0x2a, 0x29, 0x80,
	0x31, 0x91, 0xc9, 0xc4, 0xf4, 0x12, 0x1d, 0x4b, 0x7a, 0x31, 0xa8, 0x06, 0x54, 0xf0, 0xea, 0x67,
	0x1b, 0x63, 0x12, 0x91, 0xc9, 0x25, 0xb6, 0xe7, 0x4d, 0x1f, 0xd3, 0xf3, 0x16, 0x01, 0x1c, 0xc8,
	0xdd, 0xae, 0x32, 0xc1, 0xb5, 0x83, 0xe1, 0xe9, 0x4c, 0xc4, 0xae, 0x3a, 0xd5, 0x9f, 0xd0, 0xd9,
	0xad, 0x92, 0xc4, 0x15, 0x0d, 0xa6, 0xab, 0x64, 0x62, 0x38, 0x79, 0xf8, 0x32, 0x2b, 0xf3, 0x85,
	0x0b, 0x57, 0xc0, 0xd9, 0x9e, 0x47, 0x34, 0x1d, 0xe9, 0x07, 0x58, 0xa3, 0x58, 0xc7, 0x46, 0x1b,
	0x37, 0xfc, 0xff, 0x67, 0xe6, 0x7b, 0x04, 0x25, 0x86, 0x57, 0x7d, 0x74, 0x7c, 0x73, 0x26, 0x9f,
	0xa2, 0x39, 0x5b, 0xb9, 0xd3, 0xdf, 0x22, 0x3c, 0xf4, 0x5b, 0x83, 0x8f, 0x0e, 0x15, 0xe9, 0x74,
	0xb5, 0x37, 0x61, 0x13, 0x1b, 0xe7, 0x9e, 0x05, 0x93, 0xdd, 0xd2, 0x84, 0x3d, 0x6a, 0xe8, 0x3c,
	0x47, 0xed, 0x13, 0xc2, 0x23, 0x33, 0xa1, 0xb2, 0xe5, 0xe5, 0xb7, 0x86, 0x40, 0x3a, 0x9c, 0xaf,
	0xe1, 0x1c, 0x80, 0x3b, 0x1b, 0xc5, 0xfa, 0xda, 0xb6, 0xba, 0xa9, 0xd5, 0x5f, 0xdd, 0xa9, 0x68,
	0x6b, 0xc5, 0xf5, 0x8a, 0x7c, 0x66, 0x10, 0x5e, 0xae, 0x6e, 0x95, 0x65, 0x09, 0x9e, 0x03, 0xf3,
	0x51, 0xf8, 0xf6, 0x4e, 0x65, 0xab, 0x56, 0x2f, 0x96, 0xd6, 0xe5, 0x21, 0x38, 0x0f, 0xa6, 0xa3,
	0xc8, 0xe2, 0x6b, 0xb7, 0xd5, 0x8a, 0x3c, 0x0c, 0x67, 0xc1, 0x54, 0x14, 0x71, 0xb3, 0xb4, 0x23,
	0x27, 0xe0, 0x59, 0x30, 0x1b, 0x05, 0x57, 0xca, 0x37, 0x2b, 0xab, 0xdb, 0x5f, 0x93, 0x47, 0x06,
	0xcf, 0x61, 0x7a, 0x55, 0xb7, 0xd6, 0xd4, 0xa2, 0x3c, 0x3a, 0xc8, 0xb7, 0x5b, 0xdb, 0xb9, 0x55,
	0x51, 0x2b, 0xf2, 0xd8, 0xe0, 0x49, 0xc5, 0x3b, 0x35, 0x79, 0x3c, 0x86, 0x63, 0x53, 0xdb, 0xd9,
	0xde, 0xde, 0x90, 0x93, 0x50, 0x01, 0x33, 0x03, 0x1c, 0xda, 0xee, 0xa6, 0x0c, 0x2e, 0xaf, 0x80,
	0x4c, 0x74, 0x94, 0x80, 0x53, 0x60, 0xa2, 0x5c, 0x55, 0x2b, 0xa5, 0xba, 0x56, 0x2c, 0x95, 0x2a,
	0xb5, 0x9a, 0x7c, 0x86, 0x1d, 0xa8, 0x56, 0x6a, 0x75, 0xb5, 0x5a, 0xaa, 0x57, 0xca, 0x01, 0x58,
	0xba, 0x1c, 0xae, 0xa4, 0xa2, 0x2b, 0xcf, 0x82, 0xb9, 0xd2, 0xc6, 0xf6, 0xed, 0xf2, 0x46, 0xa5,
	0xae, 0xd5, 0xea, 0xc5, 0x7a, 0x45, 0xbb, 0xbd, 0xb5, 0xbe, 0xb5, 0x7d, 0x67, 0x4b, 0x3e, 0xc3,
	0xd4, 0xeb, 0xc3, 0x55, 0x54, 0x75, 0x5b, 0xad, 0xc9, 0x12, 0x53, 0xaf, 0x0f, 0xa5, 0x56, 0x8a,
	0xe5, 0x57, 0xe5, 0xa1, 0x18, 0x81, 0xdb, 0x6b, 0x6b, 0x1b, 0xd5, 0x2d, 0x66, 0xf0, 0x05, 0x90,
	0xed, 0xc3, 0x6d, 0x6d, 0xd7, 0xb5, 0x1d, 0xb5, 0x52, 0xab, 0x6c, 0xd5, 0xe5, 0x04, 0xf3, 0x54,
	0x1f, 0xbe, 0xba, 0x55, 0xad, 0xcb, 0x23, 0x71, 0x5a, 0xee, 0xdc, 0x54, 0x8b, 0xe5, 0x8a, 0x3c,
	0x0a, 0xcf, 0x03, 0xa5, 0x5f, 0x68, 0xa5, 0x52, 0xd6, 0x6a, 0xaf, 0x6e, 0x95, 0xe4, 0xb1, 0xe5,
	0xbf, 0xa4, 0x7b, 0x9f, 0x51, 0x8a, 0x8e, 0x01, 0x3f, 0x90, 0x40, 0xa6, 0xe4, 0x7f, 0x99, 0xf0,
	0xff, 0x91, 0x9a, 0x8e, 0xc9, 0xbc, 0xd9, 0xa9, 0x68, 0x6f, 0xdf, 0x32, 0xbd, 0xdc, 0x43, 0xe9,
	0xe3, 0x43, 0xa5, 0xa0, 0x62, 0x97, 0xb4, 0xa8, 0xde, 0x65, 0x77, 0xf3, 0x45, 0x9d, 0x45, 0xfc,
	0x26, 0xb2, 0x51, 0x13, 0xe7, 0xfb, 0x1f, 0xc2, 0x9b, 0x47, 0x8a, 0xf4, 0xf8, 0x48, 0x59, 0xde,
	0x0a, 0xff, 0xff, 0xd3, 0x6b, 0x8b, 0x37, 0x90, 0x67, 0x78, 0xad, 0x46, 0xa8, 0x6f, 0xde, 0x20,
	0x76, 0x93, 0x83, 0xbe, 0xf7, 0x44, 0x91, 0xde, 0x7a, 0xa2, 0xc8, 0xfd, 0x12, 0xbf, 0xf3, 0xe7,
	0xbf, 0xfd, 0x64, 0x68, 0x36, 0x27, 0x17, 0xc4, 0xd7, 0x87, 0xee, 0xcb, 0x5c, 0x91, 0x2e, 0x7f,
	0x51, 0x82, 0x3f, 0x92, 0x40, 0xa6, 0xec, 0x7f, 0xdf, 0x38, 0xe1, 0xfd, 0x6e, 0x9f, 0xf2, 0x7a,
	0x4c, 0x51, 0xae, 0xd4, 0x4c, 0x6e, 0xb2, 0x20, 0x3e, 0x44, 0x08, 0xa5, 0x02, 0x9d, 0x7e, 0x3f,
	0x04, 0x32, 0xb7, 0xfd, 0x0f, 0x38, 0x27, 0xd4, 0xe9, 0xdb, 0x43, 0xa7, 0x54, 0xea, 0xfd, 0x23,
	0xe5, 0x37, 0x52, 0x38, 0xa7, 0xe4, 0xcb, 0xd1, 0x7f, 0x84, 0xf2, 0xa2, 0xc4, 0xe4, 0x77, 0x42,
	0xff, 0xad, 0xe4, 0xfb, 0x27, 0xcd, 0x7c, 0x77, 0x24, 0xcc, 0xef, 0x46, 0xfe, 0x1e, 0x08, 0x49,
	0xcb, 0x47, 0x5f, 0x63, 0x3e, 0x34, 0xa6, 0xe7, 0xb7, 0x9f, 0x3a, 0xc7, 0xe6, 0x77, 0xf9, 0xd4,
	0xda, 0xb5, 0x1f, 0x73, 0xaa, 0xf8, 0x1a, 0xd4, 0xe7, 0xd4, 0x07, 0x20, 0x5d, 0x3b, 0x20, 0xf7,
	0x9e, 0x6e, 0xbd, 0x38, 0x60, 0xee, 0xc6, 0xc7, 0x87, 0xca, 0x85, 0xe3, 0xcc, 0xb7, 0x6b, 0xe0,
	0x7b, 0xf9, 0xf7, 0x8e, 0xfc, 0xd3, 0xa7, 0x73, 0x99, 0x82, 0x7b, 0x40, 0xee, 0xf5, 0x9d, 0xfd,
	0x4b, 0x09, 0x4c, 0xdf, 0xc4, 0xde, 0xc0, 0x7c, 0x11, 0xab, 0xc3, 0xb9, 0x18, 0x60, 0xc0, 0x91,
	0xab, 0x9f, 0xc2, 0x95, 0x5c, 0xb3, 0x73, 0xb9, 0xb9, 0x42, 0x13, 0x7b, 0x5d, 0xc5, 0x0a, 0xc1,
	0x20, 0xb3, 0x22, 0x5d, 0x86, 0xbf, 0x96, 0x80, 0x1c, 0xd2, 0x4f, 0xcc, 0x07, 0xca, 0x71, 0xdd,
	0x7c, 0xf6, 0x58, 0x4c, 0xee, 0xeb, 0x9f, 0x6a, 0xaa, 0xf7, 0x8f, 0x14, 0xd0, 0x6b, 0xf7, 0x1f,
	0x1f, 0x29, 0x91, 0xa2, 0xc5, 0x55, 0x55, 0x72, 0xd3, 0x51, 0x55, 0x59, 0xab, 0xe9, 0x32, 0x3d,
	0x7f, 0x2e, 0x81, 0xd9, 0x62, 0xa3, 0x11, 0xfd, 0x20, 0xe0, 0x18, 0x76, 0x13, 0x9e, 0x3d, 0xf6,
	0x7b, 0x41, 0xdc, 0x8b, 0x50, 0x4f, 0x6b, 0xc5, 0xb3, 0xb9, 0x99, 0x02, 0x6a, 0x34, 0xfc, 0x8f,
	0x0e, 0x61, 0x2f, 0xc3, 0x5f, 0x48, 0x40, 0x51, 0xb1, 0x45, 0xda, 0xf8, 0x73, 0xab, 0xf7, 0xd5,
	0xd3, 0xaa, 0xc7, 0x2c, 0x47, 0xad, 0x38, 0xed, 0x7e, 0x2a, 0x81, 0xc9, 0x35, 0xc3, 0x6e, 0x84,
	0xc7, 0xf6, 0xb9, 0x81, 0x5e, 0x91, 0xc3, 0xb3, 0xc7, 0xc0, 0xb9, 0x5a, 0x57, 0x9e, 0xea, 0xdc,
	0x58, 0xa5, 0xb2, 0xb9, 0xd9, 0xc2, 0xbe, 0x61, 0xc7, 0x19, 0x6d, 0xf9, 0x57, 0xc3, 0xbd, 0xd6,
	0x86, 0x35, 0x9e, 0xac, 0xba, 0xbc, 0x21, 0x01, 0x39, 0xfc, 0x52, 0xf9, 0xc0, 0x30, 0x1f, 0x63,
	0x40, 0x86, 0xc8, 0x1e, 0x87, 0xc8, 0xed, 0x7e, 0x7c, 0xa8, 0xbc, 0xd8, 0xaf, 0x6d, 0xd1, 0x46,
	0x66, 0xc7, 0x33, 0xf4, 0x4f, 0xd7, 0x7a, 0x3e, 0x07, 0xa3, 0x2f, 0xd9, 0xb0, 0xf7, 0x89, 0x78,
	0xcd, 0x2d, 0x00, 0xab, 0xf6, 0x37, 0xb0, 0xee, 0x7d, 0x36, 0x0d, 0x63, 0x1c, 0x7c, 0xf5, 0x14,
	0x0e, 0x86, 0x1e, 0x98, 0xaa, 0xb4, 0x8d, 0xff, 0xf3, 0xa9, 0xcb, 0xdf, 0x95, 0x00, 0xec, 0x6b,
	0x3e, 0x99, 0x93, 0xbe, 0x09, 0xa6, 0xc3, 0x3e, 0x0a, 0xda, 0xd2, 0x6c, 0x5c, 0xee, 0x12, 0xb8,
	0xec, 0x53, 0x70, 0xb9, 0xc5, 0x6e, 0xa4, 0x44, 0x6c, 0x6e, 0x09, 0x34, 0x37, 0xfb, 0xaa, 0xfc,
	0xe8, 0xaf, 0x0b, 0x67, 0x1e, 0x3d, 0x5e, 0x90, 0xde, 0x7b, 0xbc, 0x20, 0x7d, 0xf4, 0x78, 0x41,
	0xda, 0x1b, 0xe5, 0xc2, 0xae, 0xfe, 0x37, 0x00, 0x00, 0xff, 0xff, 0x8b, 0xb2, 0xc7, 0xd1, 0xf1,
	0x22, 0x00, 0x00,
}
