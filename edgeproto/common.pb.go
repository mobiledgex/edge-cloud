// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: common.proto

package edgeproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"

import "errors"
import "strconv"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Liveness indicates if an object was created statically via an external API call, or dynamically via an internal algorithm.
type Liveness int32

const (
	// Unknown liveness
	Liveness_LivenessUnknown Liveness = 0
	// Object managed by external entity
	Liveness_LivenessStatic Liveness = 1
	// Object managed internally
	Liveness_LivenessDynamic Liveness = 2
)

var Liveness_name = map[int32]string{
	0: "LivenessUnknown",
	1: "LivenessStatic",
	2: "LivenessDynamic",
}
var Liveness_value = map[string]int32{
	"LivenessUnknown": 0,
	"LivenessStatic":  1,
	"LivenessDynamic": 2,
}

func (x Liveness) String() string {
	return proto.EnumName(Liveness_name, int32(x))
}
func (Liveness) EnumDescriptor() ([]byte, []int) { return fileDescriptorCommon, []int{0} }

// IpSupport indicates the type of public IP support provided by the Cloudlet. Static IP support indicates a set of static public IPs are available for use, and managed by the Controller. Dynamic indicates the Cloudlet uses a DHCP server to provide public IP addresses, and the controller has no control over which IPs are assigned.
type IpSupport int32

const (
	// Unknown IP support
	IpSupport_IpSupportUnknown IpSupport = 0
	// Static IP addresses are provided to and managed by Controller
	IpSupport_IpSupportStatic IpSupport = 1
	// IP addresses are dynamically provided by an Operator's DHCP server
	IpSupport_IpSupportDynamic IpSupport = 2
)

var IpSupport_name = map[int32]string{
	0: "IpSupportUnknown",
	1: "IpSupportStatic",
	2: "IpSupportDynamic",
}
var IpSupport_value = map[string]int32{
	"IpSupportUnknown": 0,
	"IpSupportStatic":  1,
	"IpSupportDynamic": 2,
}

func (x IpSupport) String() string {
	return proto.EnumName(IpSupport_name, int32(x))
}
func (IpSupport) EnumDescriptor() ([]byte, []int) { return fileDescriptorCommon, []int{1} }

type IpAccess int32

const (
	// Unknown IP access
	IpAccess_IpAccessUnknown IpAccess = 0
	// Dedicated IP access
	IpAccess_IpAccessDedicated IpAccess = 1
	// Dedicated or shared (prefers dedicated) access
	IpAccess_IpAccessDedicatedOrShared IpAccess = 2
	// Shared IP access
	IpAccess_IpAccessShared IpAccess = 3
)

var IpAccess_name = map[int32]string{
	0: "IpAccessUnknown",
	1: "IpAccessDedicated",
	2: "IpAccessDedicatedOrShared",
	3: "IpAccessShared",
}
var IpAccess_value = map[string]int32{
	"IpAccessUnknown":           0,
	"IpAccessDedicated":         1,
	"IpAccessDedicatedOrShared": 2,
	"IpAccessShared":            3,
}

func (x IpAccess) String() string {
	return proto.EnumName(IpAccess_name, int32(x))
}
func (IpAccess) EnumDescriptor() ([]byte, []int) { return fileDescriptorCommon, []int{2} }

// TrackedState is used to track the state of an object on a remote node,
// i.e. track the state of a ClusterInst object on the CRM (Cloudlet).
type TrackedState int32

const (
	// Unknown state
	TrackedState_TrackedStateUnknown TrackedState = 0
	// Not present (does not exist)
	TrackedState_NotPresent TrackedState = 1
	// Create requested
	TrackedState_CreateRequested TrackedState = 2
	// Creating
	TrackedState_Creating TrackedState = 3
	// Create error
	TrackedState_CreateError TrackedState = 4
	// Ready
	TrackedState_Ready TrackedState = 5
	// Update requested
	TrackedState_UpdateRequested TrackedState = 6
	// Updating
	TrackedState_Updating TrackedState = 7
	// Update error
	TrackedState_UpdateError TrackedState = 8
	// Delete requested
	TrackedState_DeleteRequested TrackedState = 9
	// Deleting
	TrackedState_Deleting TrackedState = 10
	// Delete error
	TrackedState_DeleteError TrackedState = 11
	// Delete prepare (extra state used by controller to block other changes)
	TrackedState_DeletePrepare TrackedState = 12
)

var TrackedState_name = map[int32]string{
	0:  "TrackedStateUnknown",
	1:  "NotPresent",
	2:  "CreateRequested",
	3:  "Creating",
	4:  "CreateError",
	5:  "Ready",
	6:  "UpdateRequested",
	7:  "Updating",
	8:  "UpdateError",
	9:  "DeleteRequested",
	10: "Deleting",
	11: "DeleteError",
	12: "DeletePrepare",
}
var TrackedState_value = map[string]int32{
	"TrackedStateUnknown": 0,
	"NotPresent":          1,
	"CreateRequested":     2,
	"Creating":            3,
	"CreateError":         4,
	"Ready":               5,
	"UpdateRequested":     6,
	"Updating":            7,
	"UpdateError":         8,
	"DeleteRequested":     9,
	"Deleting":            10,
	"DeleteError":         11,
	"DeletePrepare":       12,
}

func (x TrackedState) String() string {
	return proto.EnumName(TrackedState_name, int32(x))
}
func (TrackedState) EnumDescriptor() ([]byte, []int) { return fileDescriptorCommon, []int{3} }

// CRMOverride can be applied to commands that issue requests to the CRM.
// It should only be used by administrators when bugs have caused the
// Controller and CRM to get out of sync. It allows commands from the
// Controller to ignore errors from the CRM, or ignore the CRM completely
// (messages will not be sent to CRM).
type CRMOverride int32

const (
	// No override
	CRMOverride_NoOverride CRMOverride = 0
	// Ignore errors from CRM
	CRMOverride_IgnoreCRMErrors CRMOverride = 1
	// Ignore CRM completely (does not inform CRM of operation)
	CRMOverride_IgnoreCRM CRMOverride = 2
	// Ignore Transient State (only admin should use if CRM crashed)
	CRMOverride_IgnoreTransientState CRMOverride = 3
	// Ignore CRM and Transient State
	CRMOverride_IgnoreCRMandTransientState CRMOverride = 4
)

var CRMOverride_name = map[int32]string{
	0: "NoOverride",
	1: "IgnoreCRMErrors",
	2: "IgnoreCRM",
	3: "IgnoreTransientState",
	4: "IgnoreCRMandTransientState",
}
var CRMOverride_value = map[string]int32{
	"NoOverride":                 0,
	"IgnoreCRMErrors":            1,
	"IgnoreCRM":                  2,
	"IgnoreTransientState":       3,
	"IgnoreCRMandTransientState": 4,
}

func (x CRMOverride) String() string {
	return proto.EnumName(CRMOverride_name, int32(x))
}
func (CRMOverride) EnumDescriptor() ([]byte, []int) { return fileDescriptorCommon, []int{4} }

func init() {
	proto.RegisterEnum("edgeproto.Liveness", Liveness_name, Liveness_value)
	proto.RegisterEnum("edgeproto.IpSupport", IpSupport_name, IpSupport_value)
	proto.RegisterEnum("edgeproto.IpAccess", IpAccess_name, IpAccess_value)
	proto.RegisterEnum("edgeproto.TrackedState", TrackedState_name, TrackedState_value)
	proto.RegisterEnum("edgeproto.CRMOverride", CRMOverride_name, CRMOverride_value)
}

var LivenessStrings = []string{
	"LivenessUnknown",
	"LivenessStatic",
	"LivenessDynamic",
}

const (
	LivenessLivenessUnknown uint64 = 1 << 0
	LivenessLivenessStatic  uint64 = 1 << 1
	LivenessLivenessDynamic uint64 = 1 << 2
)

func (e *Liveness) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := Liveness_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = Liveness_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = Liveness(val)
	return nil
}

func (e Liveness) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

// custom JSON encoding/decoding
func (e *Liveness) UnmarshalText(text []byte) error {
	str := string(text)
	val, ok := Liveness_value[str]
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = Liveness(val)
	return nil
}

func (e Liveness) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

var IpSupportStrings = []string{
	"IpSupportUnknown",
	"IpSupportStatic",
	"IpSupportDynamic",
}

const (
	IpSupportIpSupportUnknown uint64 = 1 << 0
	IpSupportIpSupportStatic  uint64 = 1 << 1
	IpSupportIpSupportDynamic uint64 = 1 << 2
)

func (e *IpSupport) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := IpSupport_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = IpSupport_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = IpSupport(val)
	return nil
}

func (e IpSupport) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

// custom JSON encoding/decoding
func (e *IpSupport) UnmarshalText(text []byte) error {
	str := string(text)
	val, ok := IpSupport_value[str]
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = IpSupport(val)
	return nil
}

func (e IpSupport) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

var IpAccessStrings = []string{
	"IpAccessUnknown",
	"IpAccessDedicated",
	"IpAccessDedicatedOrShared",
	"IpAccessShared",
}

const (
	IpAccessIpAccessUnknown           uint64 = 1 << 0
	IpAccessIpAccessDedicated         uint64 = 1 << 1
	IpAccessIpAccessDedicatedOrShared uint64 = 1 << 2
	IpAccessIpAccessShared            uint64 = 1 << 3
)

func (e *IpAccess) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := IpAccess_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = IpAccess_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = IpAccess(val)
	return nil
}

func (e IpAccess) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

// custom JSON encoding/decoding
func (e *IpAccess) UnmarshalText(text []byte) error {
	str := string(text)
	val, ok := IpAccess_value[str]
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = IpAccess(val)
	return nil
}

func (e IpAccess) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

var TrackedStateStrings = []string{
	"TrackedStateUnknown",
	"NotPresent",
	"CreateRequested",
	"Creating",
	"CreateError",
	"Ready",
	"UpdateRequested",
	"Updating",
	"UpdateError",
	"DeleteRequested",
	"Deleting",
	"DeleteError",
	"DeletePrepare",
}

const (
	TrackedStateTrackedStateUnknown uint64 = 1 << 0
	TrackedStateNotPresent          uint64 = 1 << 1
	TrackedStateCreateRequested     uint64 = 1 << 2
	TrackedStateCreating            uint64 = 1 << 3
	TrackedStateCreateError         uint64 = 1 << 4
	TrackedStateReady               uint64 = 1 << 5
	TrackedStateUpdateRequested     uint64 = 1 << 6
	TrackedStateUpdating            uint64 = 1 << 7
	TrackedStateUpdateError         uint64 = 1 << 8
	TrackedStateDeleteRequested     uint64 = 1 << 9
	TrackedStateDeleting            uint64 = 1 << 10
	TrackedStateDeleteError         uint64 = 1 << 11
	TrackedStateDeletePrepare       uint64 = 1 << 12
)

func (e *TrackedState) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := TrackedState_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = TrackedState_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = TrackedState(val)
	return nil
}

func (e TrackedState) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

// custom JSON encoding/decoding
func (e *TrackedState) UnmarshalText(text []byte) error {
	str := string(text)
	val, ok := TrackedState_value[str]
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = TrackedState(val)
	return nil
}

func (e TrackedState) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

var CRMOverrideStrings = []string{
	"NoOverride",
	"IgnoreCRMErrors",
	"IgnoreCRM",
	"IgnoreTransientState",
	"IgnoreCRMandTransientState",
}

const (
	CRMOverrideNoOverride                 uint64 = 1 << 0
	CRMOverrideIgnoreCRMErrors            uint64 = 1 << 1
	CRMOverrideIgnoreCRM                  uint64 = 1 << 2
	CRMOverrideIgnoreTransientState       uint64 = 1 << 3
	CRMOverrideIgnoreCRMandTransientState uint64 = 1 << 4
)

func (e *CRMOverride) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := CRMOverride_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = CRMOverride_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = CRMOverride(val)
	return nil
}

func (e CRMOverride) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

// custom JSON encoding/decoding
func (e *CRMOverride) UnmarshalText(text []byte) error {
	str := string(text)
	val, ok := CRMOverride_value[str]
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = CRMOverride(val)
	return nil
}

func (e CRMOverride) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

func init() { proto.RegisterFile("common.proto", fileDescriptorCommon) }

var fileDescriptorCommon = []byte{
	// 412 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x92, 0x5f, 0x6e, 0x13, 0x31,
	0x10, 0x87, 0xbb, 0x49, 0x5b, 0xb2, 0x93, 0xb4, 0x71, 0x9d, 0x22, 0xa0, 0x82, 0x3d, 0xc0, 0x3e,
	0xd0, 0x07, 0x4e, 0x00, 0x09, 0x12, 0x95, 0x5a, 0x5a, 0x6d, 0xda, 0x03, 0x98, 0xf5, 0x68, 0xb1,
	0xda, 0xd8, 0x66, 0xd6, 0x2d, 0xaa, 0xb8, 0x60, 0x1e, 0x39, 0x02, 0xe4, 0x06, 0xdc, 0x00, 0xd9,
	0xce, 0xfe, 0x81, 0xbe, 0xcd, 0x7c, 0xfe, 0x7d, 0x63, 0x7b, 0xbd, 0x30, 0x29, 0xcd, 0x6a, 0x65,
	0xf4, 0x5b, 0x4b, 0xc6, 0x19, 0x9e, 0xa2, 0xac, 0x30, 0x94, 0x27, 0xaf, 0x2b, 0x63, 0xaa, 0x3b,
	0x3c, 0x15, 0x56, 0x9d, 0x0a, 0xad, 0x8d, 0x13, 0x4e, 0x19, 0x5d, 0xc7, 0x60, 0xfe, 0x09, 0x46,
	0xe7, 0xea, 0x01, 0x35, 0xd6, 0x35, 0x9f, 0xc1, 0xb4, 0xa9, 0x6f, 0xf4, 0xad, 0x36, 0xdf, 0x35,
	0xdb, 0xe1, 0x1c, 0x0e, 0x1b, 0xb8, 0xf4, 0x6a, 0xc9, 0x92, 0x7e, 0x70, 0xf1, 0xa8, 0xc5, 0x4a,
	0x95, 0x6c, 0x90, 0x9f, 0x43, 0x7a, 0x66, 0x97, 0xf7, 0xd6, 0x1a, 0x72, 0xfc, 0x18, 0x58, 0xdb,
	0x74, 0xb3, 0x66, 0x30, 0x6d, 0x69, 0x3b, 0xac, 0x1f, 0xed, 0xa6, 0x29, 0x18, 0x9d, 0xd9, 0xf7,
	0x65, 0xb9, 0x3d, 0x57, 0x53, 0x77, 0xb3, 0x9e, 0xc3, 0x51, 0x03, 0x17, 0x28, 0x55, 0x29, 0x1c,
	0x4a, 0x96, 0xf0, 0x37, 0xf0, 0xea, 0x09, 0xbe, 0xa4, 0xe5, 0x57, 0x41, 0x28, 0xd9, 0xc0, 0xdf,
	0xa6, 0x59, 0xde, 0xb2, 0x61, 0xfe, 0x27, 0x81, 0xc9, 0x35, 0x89, 0xf2, 0x16, 0xa5, 0x3f, 0x14,
	0xf2, 0x17, 0x30, 0xeb, 0xf7, 0xdd, 0x9e, 0x87, 0x00, 0x9f, 0x8d, 0xbb, 0x22, 0xac, 0x51, 0xbb,
	0xf8, 0x1d, 0xe6, 0x84, 0xc2, 0x61, 0x81, 0xdf, 0xee, 0xb1, 0x76, 0x61, 0x8b, 0x09, 0x8c, 0x02,
	0x54, 0xba, 0x62, 0x43, 0x3e, 0x85, 0x71, 0x8c, 0x7c, 0x24, 0x32, 0xc4, 0x76, 0x79, 0x0a, 0x7b,
	0x05, 0x0a, 0xf9, 0xc8, 0xf6, 0xbc, 0x7e, 0x63, 0xe5, 0x3f, 0xfa, 0xbe, 0xd7, 0x03, 0xf4, 0xfa,
	0x33, 0xaf, 0xc7, 0x48, 0xd4, 0x47, 0xde, 0x59, 0xe0, 0x1d, 0xf6, 0x9d, 0xd4, 0x3b, 0x01, 0x7a,
	0x07, 0xbc, 0x13, 0x23, 0xd1, 0x19, 0xf3, 0x23, 0x38, 0x88, 0xe0, 0x8a, 0xd0, 0x0a, 0x42, 0x36,
	0xc9, 0x7f, 0xc0, 0x78, 0x5e, 0x5c, 0x5c, 0x3e, 0x20, 0x91, 0x92, 0x18, 0x2f, 0xd6, 0x74, 0xdb,
	0x87, 0xaa, 0xb4, 0x21, 0x9c, 0x17, 0x17, 0x61, 0x4a, 0xcd, 0x12, 0x7e, 0x00, 0x69, 0x0b, 0xd9,
	0x80, 0xbf, 0x84, 0xe3, 0xd8, 0x5e, 0x93, 0xd0, 0xb5, 0x42, 0x1d, 0x9e, 0x14, 0xd9, 0x90, 0x67,
	0x70, 0xd2, 0x06, 0x85, 0x96, 0xff, 0xad, 0xef, 0x7e, 0x60, 0xeb, 0xdf, 0xd9, 0xce, 0x7a, 0x93,
	0x25, 0x3f, 0x37, 0x59, 0xf2, 0x6b, 0x93, 0x25, 0x5f, 0xf6, 0xc3, 0xcf, 0xf8, 0xee, 0x6f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x76, 0x0b, 0x0a, 0x93, 0xc5, 0x02, 0x00, 0x00,
}
