// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app_inst.proto

package edgeproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/mobiledgex/edge-cloud/protogen"
import _ "github.com/mobiledgex/edge-cloud/protoc-gen-cmd/protocmd"
import distributed_match_engine "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto"
import _ "github.com/gogo/protobuf/gogoproto"

import strings "strings"
import reflect "reflect"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import binary "encoding/binary"

import "encoding/json"
import "github.com/mobiledgex/edge-cloud/objstore"
import "github.com/mobiledgex/edge-cloud/util"
import "github.com/mobiledgex/edge-cloud/log"
import google_protobuf "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type AppInstKey struct {
	// App key
	AppKey AppKey `protobuf:"bytes,1,opt,name=app_key,json=appKey" json:"app_key"`
	// Cloudlet it's on
	CloudletKey CloudletKey `protobuf:"bytes,2,opt,name=cloudlet_key,json=cloudletKey" json:"cloudlet_key"`
	// inst id
	Id uint64 `protobuf:"fixed64,3,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *AppInstKey) Reset()                    { *m = AppInstKey{} }
func (m *AppInstKey) String() string            { return proto.CompactTextString(m) }
func (*AppInstKey) ProtoMessage()               {}
func (*AppInstKey) Descriptor() ([]byte, []int) { return fileDescriptorAppInst, []int{0} }

// AppInsts are instances of an application instantiated
// on a cloudlet, like a docker or VM instance.
type AppInst struct {
	Fields []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty"`
	// Unique identifier key
	Key AppInstKey `protobuf:"bytes,2,opt,name=key" json:"key"`
	// Cache the location of the cloudlet
	CloudletLoc distributed_match_engine.Loc `protobuf:"bytes,3,opt,name=cloudlet_loc,json=cloudletLoc" json:"cloudlet_loc"`
	// URI to connect to this instance
	Uri string `protobuf:"bytes,4,opt,name=uri,proto3" json:"uri,omitempty"`
	// cluster instance on which this is instatiated
	ClusterInstKey ClusterInstKey `protobuf:"bytes,5,opt,name=cluster_inst_key,json=clusterInstKey" json:"cluster_inst_key"`
	// type of instance
	Liveness Liveness `protobuf:"varint,6,opt,name=liveness,proto3,enum=edgeproto.Liveness" json:"liveness,omitempty"`
	// cache data from app
	// image path
	ImagePath string `protobuf:"bytes,7,opt,name=image_path,json=imagePath,proto3" json:"image_path,omitempty"`
	// image type
	ImageType ImageType `protobuf:"varint,8,opt,name=image_type,json=imageType,proto3,enum=edgeproto.ImageType" json:"image_type,omitempty"`
	// mapped ports that are publicly accessible; correspond to
	// ports on App. Only valid for L4 access types.
	MappedPorts string `protobuf:"bytes,9,opt,name=mapped_ports,json=mappedPorts,proto3" json:"mapped_ports,omitempty"`
	// mapped path to append to hostname for public access.
	// Only valid for L7 access types.
	MappedPath string `protobuf:"bytes,10,opt,name=mapped_path,json=mappedPath,proto3" json:"mapped_path,omitempty"`
	// initial config passed to docker
	ConfigMap string `protobuf:"bytes,11,opt,name=config_map,json=configMap,proto3" json:"config_map,omitempty"`
	// flavor defining resource requirements
	Flavor FlavorKey `protobuf:"bytes,12,opt,name=flavor" json:"flavor"`
}

func (m *AppInst) Reset()                    { *m = AppInst{} }
func (m *AppInst) String() string            { return proto.CompactTextString(m) }
func (*AppInst) ProtoMessage()               {}
func (*AppInst) Descriptor() ([]byte, []int) { return fileDescriptorAppInst, []int{1} }

// AppInstInfo contains static data collected by the CRM to be sent
// to the connected controller. It is put into etcd or equivalent.
type AppInstInfo struct {
	Fields []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty"`
	// Unique identifier key
	Key AppInstKey `protobuf:"bytes,2,opt,name=key" json:"key"`
	// Id of client assigned by server
	NotifyId int64 `protobuf:"varint,3,opt,name=notify_id,json=notifyId,proto3" json:"notify_id,omitempty"`
}

func (m *AppInstInfo) Reset()                    { *m = AppInstInfo{} }
func (m *AppInstInfo) String() string            { return proto.CompactTextString(m) }
func (*AppInstInfo) ProtoMessage()               {}
func (*AppInstInfo) Descriptor() ([]byte, []int) { return fileDescriptorAppInst, []int{2} }

// AppInstMetrics are metrics produced by the DME to pass up to
// an analytics or storage node (not the controller). These are not
// stored in etcd, but probably logged as time series to disk (TBD)
type AppInstMetrics struct {
	// what goes here?
	// Note that metrics for grpc calls can be done by a prometheus
	// interceptor in grpc, so adding call metrics here may be
	// redundant unless they're needed for billing.
	Something uint64 `protobuf:"varint,5,opt,name=something,proto3" json:"something,omitempty"`
}

func (m *AppInstMetrics) Reset()                    { *m = AppInstMetrics{} }
func (m *AppInstMetrics) String() string            { return proto.CompactTextString(m) }
func (*AppInstMetrics) ProtoMessage()               {}
func (*AppInstMetrics) Descriptor() ([]byte, []int) { return fileDescriptorAppInst, []int{3} }

func init() {
	proto.RegisterType((*AppInstKey)(nil), "edgeproto.AppInstKey")
	proto.RegisterType((*AppInst)(nil), "edgeproto.AppInst")
	proto.RegisterType((*AppInstInfo)(nil), "edgeproto.AppInstInfo")
	proto.RegisterType((*AppInstMetrics)(nil), "edgeproto.AppInstMetrics")
}
func (this *AppInstKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&edgeproto.AppInstKey{")
	s = append(s, "AppKey: "+strings.Replace(this.AppKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "CloudletKey: "+strings.Replace(this.CloudletKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAppInst(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AppInstApi service

type AppInstApiClient interface {
	CreateAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (*Result, error)
	DeleteAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (*Result, error)
	UpdateAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (*Result, error)
	ShowAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_ShowAppInstClient, error)
}

type appInstApiClient struct {
	cc *grpc.ClientConn
}

func NewAppInstApiClient(cc *grpc.ClientConn) AppInstApiClient {
	return &appInstApiClient{cc}
}

func (c *appInstApiClient) CreateAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.AppInstApi/CreateAppInst", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appInstApiClient) DeleteAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.AppInstApi/DeleteAppInst", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appInstApiClient) UpdateAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.AppInstApi/UpdateAppInst", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appInstApiClient) ShowAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_ShowAppInstClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AppInstApi_serviceDesc.Streams[0], c.cc, "/edgeproto.AppInstApi/ShowAppInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstApiShowAppInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstApi_ShowAppInstClient interface {
	Recv() (*AppInst, error)
	grpc.ClientStream
}

type appInstApiShowAppInstClient struct {
	grpc.ClientStream
}

func (x *appInstApiShowAppInstClient) Recv() (*AppInst, error) {
	m := new(AppInst)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AppInstApi service

type AppInstApiServer interface {
	CreateAppInst(context.Context, *AppInst) (*Result, error)
	DeleteAppInst(context.Context, *AppInst) (*Result, error)
	UpdateAppInst(context.Context, *AppInst) (*Result, error)
	ShowAppInst(*AppInst, AppInstApi_ShowAppInstServer) error
}

func RegisterAppInstApiServer(s *grpc.Server, srv AppInstApiServer) {
	s.RegisterService(&_AppInstApi_serviceDesc, srv)
}

func _AppInstApi_CreateAppInst_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInst)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppInstApiServer).CreateAppInst(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.AppInstApi/CreateAppInst",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppInstApiServer).CreateAppInst(ctx, req.(*AppInst))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppInstApi_DeleteAppInst_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInst)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppInstApiServer).DeleteAppInst(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.AppInstApi/DeleteAppInst",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppInstApiServer).DeleteAppInst(ctx, req.(*AppInst))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppInstApi_UpdateAppInst_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInst)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppInstApiServer).UpdateAppInst(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.AppInstApi/UpdateAppInst",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppInstApiServer).UpdateAppInst(ctx, req.(*AppInst))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppInstApi_ShowAppInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstApiServer).ShowAppInst(m, &appInstApiShowAppInstServer{stream})
}

type AppInstApi_ShowAppInstServer interface {
	Send(*AppInst) error
	grpc.ServerStream
}

type appInstApiShowAppInstServer struct {
	grpc.ServerStream
}

func (x *appInstApiShowAppInstServer) Send(m *AppInst) error {
	return x.ServerStream.SendMsg(m)
}

var _AppInstApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.AppInstApi",
	HandlerType: (*AppInstApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAppInst",
			Handler:    _AppInstApi_CreateAppInst_Handler,
		},
		{
			MethodName: "DeleteAppInst",
			Handler:    _AppInstApi_DeleteAppInst_Handler,
		},
		{
			MethodName: "UpdateAppInst",
			Handler:    _AppInstApi_UpdateAppInst_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowAppInst",
			Handler:       _AppInstApi_ShowAppInst_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "app_inst.proto",
}

// Client API for AppInstInfoApi service

type AppInstInfoApiClient interface {
	ShowAppInstInfo(ctx context.Context, in *AppInstInfo, opts ...grpc.CallOption) (AppInstInfoApi_ShowAppInstInfoClient, error)
}

type appInstInfoApiClient struct {
	cc *grpc.ClientConn
}

func NewAppInstInfoApiClient(cc *grpc.ClientConn) AppInstInfoApiClient {
	return &appInstInfoApiClient{cc}
}

func (c *appInstInfoApiClient) ShowAppInstInfo(ctx context.Context, in *AppInstInfo, opts ...grpc.CallOption) (AppInstInfoApi_ShowAppInstInfoClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AppInstInfoApi_serviceDesc.Streams[0], c.cc, "/edgeproto.AppInstInfoApi/ShowAppInstInfo", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstInfoApiShowAppInstInfoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstInfoApi_ShowAppInstInfoClient interface {
	Recv() (*AppInstInfo, error)
	grpc.ClientStream
}

type appInstInfoApiShowAppInstInfoClient struct {
	grpc.ClientStream
}

func (x *appInstInfoApiShowAppInstInfoClient) Recv() (*AppInstInfo, error) {
	m := new(AppInstInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AppInstInfoApi service

type AppInstInfoApiServer interface {
	ShowAppInstInfo(*AppInstInfo, AppInstInfoApi_ShowAppInstInfoServer) error
}

func RegisterAppInstInfoApiServer(s *grpc.Server, srv AppInstInfoApiServer) {
	s.RegisterService(&_AppInstInfoApi_serviceDesc, srv)
}

func _AppInstInfoApi_ShowAppInstInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInstInfo)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstInfoApiServer).ShowAppInstInfo(m, &appInstInfoApiShowAppInstInfoServer{stream})
}

type AppInstInfoApi_ShowAppInstInfoServer interface {
	Send(*AppInstInfo) error
	grpc.ServerStream
}

type appInstInfoApiShowAppInstInfoServer struct {
	grpc.ServerStream
}

func (x *appInstInfoApiShowAppInstInfoServer) Send(m *AppInstInfo) error {
	return x.ServerStream.SendMsg(m)
}

var _AppInstInfoApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.AppInstInfoApi",
	HandlerType: (*AppInstInfoApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowAppInstInfo",
			Handler:       _AppInstInfoApi_ShowAppInstInfo_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "app_inst.proto",
}

// Client API for AppInstMetricsApi service

type AppInstMetricsApiClient interface {
	ShowAppInstMetrics(ctx context.Context, in *AppInstMetrics, opts ...grpc.CallOption) (AppInstMetricsApi_ShowAppInstMetricsClient, error)
}

type appInstMetricsApiClient struct {
	cc *grpc.ClientConn
}

func NewAppInstMetricsApiClient(cc *grpc.ClientConn) AppInstMetricsApiClient {
	return &appInstMetricsApiClient{cc}
}

func (c *appInstMetricsApiClient) ShowAppInstMetrics(ctx context.Context, in *AppInstMetrics, opts ...grpc.CallOption) (AppInstMetricsApi_ShowAppInstMetricsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AppInstMetricsApi_serviceDesc.Streams[0], c.cc, "/edgeproto.AppInstMetricsApi/ShowAppInstMetrics", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstMetricsApiShowAppInstMetricsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstMetricsApi_ShowAppInstMetricsClient interface {
	Recv() (*AppInstMetrics, error)
	grpc.ClientStream
}

type appInstMetricsApiShowAppInstMetricsClient struct {
	grpc.ClientStream
}

func (x *appInstMetricsApiShowAppInstMetricsClient) Recv() (*AppInstMetrics, error) {
	m := new(AppInstMetrics)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AppInstMetricsApi service

type AppInstMetricsApiServer interface {
	ShowAppInstMetrics(*AppInstMetrics, AppInstMetricsApi_ShowAppInstMetricsServer) error
}

func RegisterAppInstMetricsApiServer(s *grpc.Server, srv AppInstMetricsApiServer) {
	s.RegisterService(&_AppInstMetricsApi_serviceDesc, srv)
}

func _AppInstMetricsApi_ShowAppInstMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInstMetrics)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstMetricsApiServer).ShowAppInstMetrics(m, &appInstMetricsApiShowAppInstMetricsServer{stream})
}

type AppInstMetricsApi_ShowAppInstMetricsServer interface {
	Send(*AppInstMetrics) error
	grpc.ServerStream
}

type appInstMetricsApiShowAppInstMetricsServer struct {
	grpc.ServerStream
}

func (x *appInstMetricsApiShowAppInstMetricsServer) Send(m *AppInstMetrics) error {
	return x.ServerStream.SendMsg(m)
}

var _AppInstMetricsApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.AppInstMetricsApi",
	HandlerType: (*AppInstMetricsApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowAppInstMetrics",
			Handler:       _AppInstMetricsApi_ShowAppInstMetrics_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "app_inst.proto",
}

func (m *AppInstKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAppInst(dAtA, i, uint64(m.AppKey.Size()))
	n1, err := m.AppKey.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintAppInst(dAtA, i, uint64(m.CloudletKey.Size()))
	n2, err := m.CloudletKey.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if m.Id != 0 {
		dAtA[i] = 0x19
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Id))
		i += 8
	}
	return i, nil
}

func (m *AppInst) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInst) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintAppInst(dAtA, i, uint64(m.Key.Size()))
	n3, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAppInst(dAtA, i, uint64(m.CloudletLoc.Size()))
	n4, err := m.CloudletLoc.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if len(m.Uri) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintAppInst(dAtA, i, uint64(m.ClusterInstKey.Size()))
	n5, err := m.ClusterInstKey.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if m.Liveness != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(m.Liveness))
	}
	if len(m.ImagePath) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(len(m.ImagePath)))
		i += copy(dAtA[i:], m.ImagePath)
	}
	if m.ImageType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(m.ImageType))
	}
	if len(m.MappedPorts) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(len(m.MappedPorts)))
		i += copy(dAtA[i:], m.MappedPorts)
	}
	if len(m.MappedPath) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(len(m.MappedPath)))
		i += copy(dAtA[i:], m.MappedPath)
	}
	if len(m.ConfigMap) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(len(m.ConfigMap)))
		i += copy(dAtA[i:], m.ConfigMap)
	}
	dAtA[i] = 0x62
	i++
	i = encodeVarintAppInst(dAtA, i, uint64(m.Flavor.Size()))
	n6, err := m.Flavor.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func (m *AppInstInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintAppInst(dAtA, i, uint64(m.Key.Size()))
	n7, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if m.NotifyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(m.NotifyId))
	}
	return i, nil
}

func (m *AppInstMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstMetrics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Something != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(m.Something))
	}
	return i, nil
}

func encodeVarintAppInst(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AppInstKey) Matches(filter *AppInstKey) bool {
	if filter == nil {
		return true
	}
	if !m.AppKey.Matches(&filter.AppKey) {
		return false
	}
	if !m.CloudletKey.Matches(&filter.CloudletKey) {
		return false
	}
	if filter.Id != 0 && filter.Id != m.Id {
		return false
	}
	return true
}

func (m *AppInstKey) MatchesIgnoreBackend(filter *AppInstKey) bool {
	if filter == nil {
		return true
	}
	if !m.AppKey.MatchesIgnoreBackend(&filter.AppKey) {
		return false
	}
	if !m.CloudletKey.MatchesIgnoreBackend(&filter.CloudletKey) {
		return false
	}
	if filter.Id != 0 && filter.Id != m.Id {
		return false
	}
	return true
}

func (m *AppInstKey) CopyInFields(src *AppInstKey) {
	m.AppKey.DeveloperKey.Name = src.AppKey.DeveloperKey.Name
	m.AppKey.Name = src.AppKey.Name
	m.AppKey.Version = src.AppKey.Version
	m.CloudletKey.OperatorKey.Name = src.CloudletKey.OperatorKey.Name
	m.CloudletKey.Name = src.CloudletKey.Name
	m.Id = src.Id
}

func (m *AppInstKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal AppInstKey key string", "obj", m)
	}
	return string(key)
}

func AppInstKeyStringParse(str string, key *AppInstKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal AppInstKey key string", "str", str)
	}
}

func (m *AppInst) Matches(filter *AppInst) bool {
	if filter == nil {
		return true
	}
	if !m.Key.Matches(&filter.Key) {
		return false
	}
	if filter.Uri != "" && filter.Uri != m.Uri {
		return false
	}
	if !m.ClusterInstKey.Matches(&filter.ClusterInstKey) {
		return false
	}
	if filter.Liveness != 0 && filter.Liveness != m.Liveness {
		return false
	}
	if filter.ImagePath != "" && filter.ImagePath != m.ImagePath {
		return false
	}
	if filter.ImageType != 0 && filter.ImageType != m.ImageType {
		return false
	}
	if filter.MappedPorts != "" && filter.MappedPorts != m.MappedPorts {
		return false
	}
	if filter.MappedPath != "" && filter.MappedPath != m.MappedPath {
		return false
	}
	if filter.ConfigMap != "" && filter.ConfigMap != m.ConfigMap {
		return false
	}
	if !m.Flavor.Matches(&filter.Flavor) {
		return false
	}
	return true
}

func (m *AppInst) MatchesIgnoreBackend(filter *AppInst) bool {
	if filter == nil {
		return true
	}
	if !m.Key.MatchesIgnoreBackend(&filter.Key) {
		return false
	}
	return true
}

const AppInstFieldKey = "2"
const AppInstFieldKeyAppKey = "2.1"
const AppInstFieldKeyAppKeyDeveloperKey = "2.1.1"
const AppInstFieldKeyAppKeyDeveloperKeyName = "2.1.1.2"
const AppInstFieldKeyAppKeyName = "2.1.2"
const AppInstFieldKeyAppKeyVersion = "2.1.3"
const AppInstFieldKeyCloudletKey = "2.2"
const AppInstFieldKeyCloudletKeyOperatorKey = "2.2.1"
const AppInstFieldKeyCloudletKeyOperatorKeyName = "2.2.1.1"
const AppInstFieldKeyCloudletKeyName = "2.2.2"
const AppInstFieldKeyId = "2.3"
const AppInstFieldCloudletLoc = "3"
const AppInstFieldCloudletLocLat = "3.1"
const AppInstFieldCloudletLocLong = "3.2"
const AppInstFieldCloudletLocHorizontalAccuracy = "3.3"
const AppInstFieldCloudletLocVerticalAccuracy = "3.4"
const AppInstFieldCloudletLocAltitude = "3.5"
const AppInstFieldCloudletLocCourse = "3.6"
const AppInstFieldCloudletLocSpeed = "3.7"
const AppInstFieldCloudletLocTimestamp = "3.8"
const AppInstFieldCloudletLocTimestampSeconds = "3.8.1"
const AppInstFieldCloudletLocTimestampNanos = "3.8.2"
const AppInstFieldUri = "4"
const AppInstFieldClusterInstKey = "5"
const AppInstFieldClusterInstKeyClusterKey = "5.1"
const AppInstFieldClusterInstKeyClusterKeyName = "5.1.1"
const AppInstFieldClusterInstKeyCloudletKey = "5.2"
const AppInstFieldClusterInstKeyCloudletKeyOperatorKey = "5.2.1"
const AppInstFieldClusterInstKeyCloudletKeyOperatorKeyName = "5.2.1.1"
const AppInstFieldClusterInstKeyCloudletKeyName = "5.2.2"
const AppInstFieldLiveness = "6"
const AppInstFieldImagePath = "7"
const AppInstFieldImageType = "8"
const AppInstFieldMappedPorts = "9"
const AppInstFieldMappedPath = "10"
const AppInstFieldConfigMap = "11"
const AppInstFieldFlavor = "12"
const AppInstFieldFlavorName = "12.1"

var AppInstAllFields = []string{
	AppInstFieldKeyAppKeyDeveloperKeyName,
	AppInstFieldKeyAppKeyName,
	AppInstFieldKeyAppKeyVersion,
	AppInstFieldKeyCloudletKeyOperatorKeyName,
	AppInstFieldKeyCloudletKeyName,
	AppInstFieldKeyId,
	AppInstFieldCloudletLocLat,
	AppInstFieldCloudletLocLong,
	AppInstFieldCloudletLocHorizontalAccuracy,
	AppInstFieldCloudletLocVerticalAccuracy,
	AppInstFieldCloudletLocAltitude,
	AppInstFieldCloudletLocCourse,
	AppInstFieldCloudletLocSpeed,
	AppInstFieldCloudletLocTimestampSeconds,
	AppInstFieldCloudletLocTimestampNanos,
	AppInstFieldUri,
	AppInstFieldClusterInstKeyClusterKeyName,
	AppInstFieldClusterInstKeyCloudletKeyOperatorKeyName,
	AppInstFieldClusterInstKeyCloudletKeyName,
	AppInstFieldLiveness,
	AppInstFieldImagePath,
	AppInstFieldImageType,
	AppInstFieldMappedPorts,
	AppInstFieldMappedPath,
	AppInstFieldConfigMap,
	AppInstFieldFlavorName,
}

var AppInstAllFieldsMap = map[string]struct{}{
	AppInstFieldKeyAppKeyDeveloperKeyName:                struct{}{},
	AppInstFieldKeyAppKeyName:                            struct{}{},
	AppInstFieldKeyAppKeyVersion:                         struct{}{},
	AppInstFieldKeyCloudletKeyOperatorKeyName:            struct{}{},
	AppInstFieldKeyCloudletKeyName:                       struct{}{},
	AppInstFieldKeyId:                                    struct{}{},
	AppInstFieldCloudletLocLat:                           struct{}{},
	AppInstFieldCloudletLocLong:                          struct{}{},
	AppInstFieldCloudletLocHorizontalAccuracy:            struct{}{},
	AppInstFieldCloudletLocVerticalAccuracy:              struct{}{},
	AppInstFieldCloudletLocAltitude:                      struct{}{},
	AppInstFieldCloudletLocCourse:                        struct{}{},
	AppInstFieldCloudletLocSpeed:                         struct{}{},
	AppInstFieldCloudletLocTimestampSeconds:              struct{}{},
	AppInstFieldCloudletLocTimestampNanos:                struct{}{},
	AppInstFieldUri:                                      struct{}{},
	AppInstFieldClusterInstKeyClusterKeyName:             struct{}{},
	AppInstFieldClusterInstKeyCloudletKeyOperatorKeyName: struct{}{},
	AppInstFieldClusterInstKeyCloudletKeyName:            struct{}{},
	AppInstFieldLiveness:                                 struct{}{},
	AppInstFieldImagePath:                                struct{}{},
	AppInstFieldImageType:                                struct{}{},
	AppInstFieldMappedPorts:                              struct{}{},
	AppInstFieldMappedPath:                               struct{}{},
	AppInstFieldConfigMap:                                struct{}{},
	AppInstFieldFlavorName:                               struct{}{},
}

func (m *AppInst) CopyInFields(src *AppInst) {
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if _, set := fmap["2.1.1"]; set {
				if _, set := fmap["2.1.1.2"]; set {
					m.Key.AppKey.DeveloperKey.Name = src.Key.AppKey.DeveloperKey.Name
				}
			}
			if _, set := fmap["2.1.2"]; set {
				m.Key.AppKey.Name = src.Key.AppKey.Name
			}
			if _, set := fmap["2.1.3"]; set {
				m.Key.AppKey.Version = src.Key.AppKey.Version
			}
		}
		if _, set := fmap["2.2"]; set {
			if _, set := fmap["2.2.1"]; set {
				if _, set := fmap["2.2.1.1"]; set {
					m.Key.CloudletKey.OperatorKey.Name = src.Key.CloudletKey.OperatorKey.Name
				}
			}
			if _, set := fmap["2.2.2"]; set {
				m.Key.CloudletKey.Name = src.Key.CloudletKey.Name
			}
		}
		if _, set := fmap["2.3"]; set {
			m.Key.Id = src.Key.Id
		}
	}
	if _, set := fmap["3"]; set {
		if _, set := fmap["3.1"]; set {
			m.CloudletLoc.Lat = src.CloudletLoc.Lat
		}
		if _, set := fmap["3.2"]; set {
			m.CloudletLoc.Long = src.CloudletLoc.Long
		}
		if _, set := fmap["3.3"]; set {
			m.CloudletLoc.HorizontalAccuracy = src.CloudletLoc.HorizontalAccuracy
		}
		if _, set := fmap["3.4"]; set {
			m.CloudletLoc.VerticalAccuracy = src.CloudletLoc.VerticalAccuracy
		}
		if _, set := fmap["3.5"]; set {
			m.CloudletLoc.Altitude = src.CloudletLoc.Altitude
		}
		if _, set := fmap["3.6"]; set {
			m.CloudletLoc.Course = src.CloudletLoc.Course
		}
		if _, set := fmap["3.7"]; set {
			m.CloudletLoc.Speed = src.CloudletLoc.Speed
		}
		if _, set := fmap["3.8"]; set && src.CloudletLoc.Timestamp != nil {
			m.CloudletLoc.Timestamp = &google_protobuf.Timestamp{}
			if _, set := fmap["3.8.1"]; set {
				m.CloudletLoc.Timestamp.Seconds = src.CloudletLoc.Timestamp.Seconds
			}
			if _, set := fmap["3.8.2"]; set {
				m.CloudletLoc.Timestamp.Nanos = src.CloudletLoc.Timestamp.Nanos
			}
		}
	}
	if _, set := fmap["4"]; set {
		m.Uri = src.Uri
	}
	if _, set := fmap["5"]; set {
		if _, set := fmap["5.1"]; set {
			if _, set := fmap["5.1.1"]; set {
				m.ClusterInstKey.ClusterKey.Name = src.ClusterInstKey.ClusterKey.Name
			}
		}
		if _, set := fmap["5.2"]; set {
			if _, set := fmap["5.2.1"]; set {
				if _, set := fmap["5.2.1.1"]; set {
					m.ClusterInstKey.CloudletKey.OperatorKey.Name = src.ClusterInstKey.CloudletKey.OperatorKey.Name
				}
			}
			if _, set := fmap["5.2.2"]; set {
				m.ClusterInstKey.CloudletKey.Name = src.ClusterInstKey.CloudletKey.Name
			}
		}
	}
	if _, set := fmap["6"]; set {
		m.Liveness = src.Liveness
	}
	if _, set := fmap["7"]; set {
		m.ImagePath = src.ImagePath
	}
	if _, set := fmap["8"]; set {
		m.ImageType = src.ImageType
	}
	if _, set := fmap["9"]; set {
		m.MappedPorts = src.MappedPorts
	}
	if _, set := fmap["10"]; set {
		m.MappedPath = src.MappedPath
	}
	if _, set := fmap["11"]; set {
		m.ConfigMap = src.ConfigMap
	}
	if _, set := fmap["12"]; set {
		if _, set := fmap["12.1"]; set {
			m.Flavor.Name = src.Flavor.Name
		}
	}
}

func (s *AppInst) HasFields() bool {
	return true
}

type AppInstStore struct {
	kvstore objstore.KVStore
}

func NewAppInstStore(kvstore objstore.KVStore) AppInstStore {
	return AppInstStore{kvstore: kvstore}
}

func (s *AppInstStore) Create(m *AppInst, wait func(int64)) (*Result, error) {
	err := m.Validate(AppInstAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInst", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstStore) Update(m *AppInst, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInst", m.GetKey())
	var vers int64 = 0
	curBytes, vers, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur AppInst
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstStore) Put(m *AppInst, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInst", m.GetKey())
	var val []byte
	curBytes, _, err := s.kvstore.Get(key)
	if err == nil {
		var cur AppInst
		err = json.Unmarshal(curBytes, &cur)
		if err != nil {
			return nil, err
		}
		cur.CopyInFields(m)
		// never save fields
		cur.Fields = nil
		val, err = json.Marshal(cur)
	} else {
		m.Fields = nil
		val, err = json.Marshal(m)
	}
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstStore) Delete(m *AppInst, wait func(int64)) (*Result, error) {
	err := m.GetKey().Validate()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInst", m.GetKey())
	rev, err := s.kvstore.Delete(key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstStore) LoadOne(key string) (*AppInst, int64, error) {
	val, rev, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj AppInst
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse AppInst data", "val", string(val))
		return nil, 0, err
	}
	return &obj, rev, nil
}

// AppInstCache caches AppInst objects in memory in a hash table
// and keeps them in sync with the database.
type AppInstCache struct {
	Objs      map[AppInstKey]*AppInst
	Mux       util.Mutex
	List      map[AppInstKey]struct{}
	NotifyCb  func(obj *AppInstKey)
	UpdatedCb func(old *AppInst, new *AppInst)
}

func NewAppInstCache() *AppInstCache {
	cache := AppInstCache{}
	InitAppInstCache(&cache)
	return &cache
}

func InitAppInstCache(cache *AppInstCache) {
	cache.Objs = make(map[AppInstKey]*AppInst)
}

func (c *AppInstCache) GetTypeString() string {
	return "AppInst"
}

func (c *AppInstCache) Get(key *AppInstKey, valbuf *AppInst) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		*valbuf = *inst
	}
	return found
}

func (c *AppInstCache) HasKey(key *AppInstKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *AppInstCache) GetAllKeys(keys map[AppInstKey]struct{}) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		keys[key] = struct{}{}
	}
}

func (c *AppInstCache) Update(in *AppInst, rev int64) {
	c.Mux.Lock()
	if c.UpdatedCb != nil {
		old := c.Objs[in.Key]
		new := &AppInst{}
		*new = *in
		defer c.UpdatedCb(old, new)
	}
	c.Objs[in.Key] = in
	log.DebugLog(log.DebugLevelApi, "SyncUpdate", "obj", in, "rev", rev)
	c.Mux.Unlock()
	if c.NotifyCb != nil {
		c.NotifyCb(&in.Key)
	}
}

func (c *AppInstCache) Delete(in *AppInst, rev int64) {
	c.Mux.Lock()
	delete(c.Objs, in.Key)
	log.DebugLog(log.DebugLevelApi, "SyncUpdate", "key", in.Key, "rev", rev)
	c.Mux.Unlock()
	if c.NotifyCb != nil {
		c.NotifyCb(&in.Key)
	}
}

func (c *AppInstCache) Prune(validKeys map[AppInstKey]struct{}) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			delete(c.Objs, key)
			if c.NotifyCb != nil {
				c.NotifyCb(&key)
			}
		}
	}
}

func (c *AppInstCache) Show(filter *AppInst, cb func(ret *AppInst) error) error {
	log.DebugLog(log.DebugLevelApi, "Show AppInst", "count", len(c.Objs))
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, obj := range c.Objs {
		if !obj.Matches(filter) {
			continue
		}
		log.DebugLog(log.DebugLevelApi, "Show AppInst", "obj", obj)
		err := cb(obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func (c *AppInstCache) SetNotifyCb(fn func(obj *AppInstKey)) {
	c.NotifyCb = fn
}

func (c *AppInstCache) SetUpdatedCb(fn func(old *AppInst, new *AppInst)) {
	c.UpdatedCb = fn
}
func (c *AppInstCache) SyncUpdate(key, val []byte, rev int64) {
	obj := AppInst{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse AppInst data", "val", string(val))
		return
	}
	c.Update(&obj, rev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.Key] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *AppInstCache) SyncDelete(key []byte, rev int64) {
	obj := AppInst{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	AppInstKeyStringParse(keystr, &obj.Key)
	c.Delete(&obj, rev)
}

func (c *AppInstCache) SyncListStart() {
	c.List = make(map[AppInstKey]struct{})
}

func (c *AppInstCache) SyncListEnd() {
	deleted := make(map[AppInstKey]struct{})
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, found := c.List[key]; !found {
			delete(c.Objs, key)
			deleted[key] = struct{}{}
		}
	}
	c.List = nil
	c.Mux.Unlock()
	if c.NotifyCb != nil {
		for key, _ := range deleted {
			c.NotifyCb(&key)
		}
	}
}
func (m *AppInst) GetKey() *AppInstKey {
	return &m.Key
}

func (m *AppInstInfo) Matches(filter *AppInstInfo) bool {
	if filter == nil {
		return true
	}
	if !m.Key.Matches(&filter.Key) {
		return false
	}
	if filter.NotifyId != 0 && filter.NotifyId != m.NotifyId {
		return false
	}
	return true
}

func (m *AppInstInfo) MatchesIgnoreBackend(filter *AppInstInfo) bool {
	if filter == nil {
		return true
	}
	if !m.Key.MatchesIgnoreBackend(&filter.Key) {
		return false
	}
	if filter.NotifyId != 0 && filter.NotifyId != m.NotifyId {
		return false
	}
	return true
}

const AppInstInfoFieldKey = "2"
const AppInstInfoFieldKeyAppKey = "2.1"
const AppInstInfoFieldKeyAppKeyDeveloperKey = "2.1.1"
const AppInstInfoFieldKeyAppKeyDeveloperKeyName = "2.1.1.2"
const AppInstInfoFieldKeyAppKeyName = "2.1.2"
const AppInstInfoFieldKeyAppKeyVersion = "2.1.3"
const AppInstInfoFieldKeyCloudletKey = "2.2"
const AppInstInfoFieldKeyCloudletKeyOperatorKey = "2.2.1"
const AppInstInfoFieldKeyCloudletKeyOperatorKeyName = "2.2.1.1"
const AppInstInfoFieldKeyCloudletKeyName = "2.2.2"
const AppInstInfoFieldKeyId = "2.3"
const AppInstInfoFieldNotifyId = "3"

var AppInstInfoAllFields = []string{
	AppInstInfoFieldKeyAppKeyDeveloperKeyName,
	AppInstInfoFieldKeyAppKeyName,
	AppInstInfoFieldKeyAppKeyVersion,
	AppInstInfoFieldKeyCloudletKeyOperatorKeyName,
	AppInstInfoFieldKeyCloudletKeyName,
	AppInstInfoFieldKeyId,
	AppInstInfoFieldNotifyId,
}

var AppInstInfoAllFieldsMap = map[string]struct{}{
	AppInstInfoFieldKeyAppKeyDeveloperKeyName:     struct{}{},
	AppInstInfoFieldKeyAppKeyName:                 struct{}{},
	AppInstInfoFieldKeyAppKeyVersion:              struct{}{},
	AppInstInfoFieldKeyCloudletKeyOperatorKeyName: struct{}{},
	AppInstInfoFieldKeyCloudletKeyName:            struct{}{},
	AppInstInfoFieldKeyId:                         struct{}{},
	AppInstInfoFieldNotifyId:                      struct{}{},
}

func (m *AppInstInfo) CopyInFields(src *AppInstInfo) {
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if _, set := fmap["2.1.1"]; set {
				if _, set := fmap["2.1.1.2"]; set {
					m.Key.AppKey.DeveloperKey.Name = src.Key.AppKey.DeveloperKey.Name
				}
			}
			if _, set := fmap["2.1.2"]; set {
				m.Key.AppKey.Name = src.Key.AppKey.Name
			}
			if _, set := fmap["2.1.3"]; set {
				m.Key.AppKey.Version = src.Key.AppKey.Version
			}
		}
		if _, set := fmap["2.2"]; set {
			if _, set := fmap["2.2.1"]; set {
				if _, set := fmap["2.2.1.1"]; set {
					m.Key.CloudletKey.OperatorKey.Name = src.Key.CloudletKey.OperatorKey.Name
				}
			}
			if _, set := fmap["2.2.2"]; set {
				m.Key.CloudletKey.Name = src.Key.CloudletKey.Name
			}
		}
		if _, set := fmap["2.3"]; set {
			m.Key.Id = src.Key.Id
		}
	}
	if _, set := fmap["3"]; set {
		m.NotifyId = src.NotifyId
	}
}

func (s *AppInstInfo) HasFields() bool {
	return true
}

type AppInstInfoStore struct {
	kvstore objstore.KVStore
}

func NewAppInstInfoStore(kvstore objstore.KVStore) AppInstInfoStore {
	return AppInstInfoStore{kvstore: kvstore}
}

func (s *AppInstInfoStore) Create(m *AppInstInfo, wait func(int64)) (*Result, error) {
	err := m.Validate(AppInstInfoAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstInfo", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstInfoStore) Update(m *AppInstInfo, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstInfo", m.GetKey())
	var vers int64 = 0
	curBytes, vers, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur AppInstInfo
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstInfoStore) Put(m *AppInstInfo, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstInfo", m.GetKey())
	var val []byte
	curBytes, _, err := s.kvstore.Get(key)
	if err == nil {
		var cur AppInstInfo
		err = json.Unmarshal(curBytes, &cur)
		if err != nil {
			return nil, err
		}
		cur.CopyInFields(m)
		// never save fields
		cur.Fields = nil
		val, err = json.Marshal(cur)
	} else {
		m.Fields = nil
		val, err = json.Marshal(m)
	}
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstInfoStore) Delete(m *AppInstInfo, wait func(int64)) (*Result, error) {
	err := m.GetKey().Validate()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstInfo", m.GetKey())
	rev, err := s.kvstore.Delete(key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstInfoStore) LoadOne(key string) (*AppInstInfo, int64, error) {
	val, rev, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj AppInstInfo
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse AppInstInfo data", "val", string(val))
		return nil, 0, err
	}
	return &obj, rev, nil
}

// AppInstInfoCache caches AppInstInfo objects in memory in a hash table
// and keeps them in sync with the database.
type AppInstInfoCache struct {
	Objs      map[AppInstKey]*AppInstInfo
	Mux       util.Mutex
	List      map[AppInstKey]struct{}
	NotifyCb  func(obj *AppInstKey)
	UpdatedCb func(old *AppInstInfo, new *AppInstInfo)
}

func NewAppInstInfoCache() *AppInstInfoCache {
	cache := AppInstInfoCache{}
	InitAppInstInfoCache(&cache)
	return &cache
}

func InitAppInstInfoCache(cache *AppInstInfoCache) {
	cache.Objs = make(map[AppInstKey]*AppInstInfo)
}

func (c *AppInstInfoCache) GetTypeString() string {
	return "AppInstInfo"
}

func (c *AppInstInfoCache) Get(key *AppInstKey, valbuf *AppInstInfo) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		*valbuf = *inst
	}
	return found
}

func (c *AppInstInfoCache) HasKey(key *AppInstKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *AppInstInfoCache) GetAllKeys(keys map[AppInstKey]struct{}) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		keys[key] = struct{}{}
	}
}

func (c *AppInstInfoCache) Update(in *AppInstInfo, rev int64) {
	c.Mux.Lock()
	if c.UpdatedCb != nil {
		old := c.Objs[in.Key]
		new := &AppInstInfo{}
		*new = *in
		defer c.UpdatedCb(old, new)
	}
	c.Objs[in.Key] = in
	log.DebugLog(log.DebugLevelApi, "SyncUpdate", "obj", in, "rev", rev)
	c.Mux.Unlock()
	if c.NotifyCb != nil {
		c.NotifyCb(&in.Key)
	}
}

func (c *AppInstInfoCache) Delete(in *AppInstInfo, rev int64) {
	c.Mux.Lock()
	delete(c.Objs, in.Key)
	log.DebugLog(log.DebugLevelApi, "SyncUpdate", "key", in.Key, "rev", rev)
	c.Mux.Unlock()
	if c.NotifyCb != nil {
		c.NotifyCb(&in.Key)
	}
}

func (c *AppInstInfoCache) Prune(validKeys map[AppInstKey]struct{}) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			delete(c.Objs, key)
			if c.NotifyCb != nil {
				c.NotifyCb(&key)
			}
		}
	}
}
func (c *AppInstInfoCache) Flush(notifyId int64) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, val := range c.Objs {
		if val.NotifyId != notifyId {
			continue
		}
		delete(c.Objs, key)
		if c.NotifyCb != nil {
			c.NotifyCb(&key)
		}
	}
}

func (c *AppInstInfoCache) Show(filter *AppInstInfo, cb func(ret *AppInstInfo) error) error {
	log.DebugLog(log.DebugLevelApi, "Show AppInstInfo", "count", len(c.Objs))
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, obj := range c.Objs {
		if !obj.Matches(filter) {
			continue
		}
		log.DebugLog(log.DebugLevelApi, "Show AppInstInfo", "obj", obj)
		err := cb(obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func (c *AppInstInfoCache) SetNotifyCb(fn func(obj *AppInstKey)) {
	c.NotifyCb = fn
}

func (c *AppInstInfoCache) SetUpdatedCb(fn func(old *AppInstInfo, new *AppInstInfo)) {
	c.UpdatedCb = fn
}
func (c *AppInstInfoCache) SyncUpdate(key, val []byte, rev int64) {
	obj := AppInstInfo{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse AppInstInfo data", "val", string(val))
		return
	}
	c.Update(&obj, rev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.Key] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *AppInstInfoCache) SyncDelete(key []byte, rev int64) {
	obj := AppInstInfo{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	AppInstKeyStringParse(keystr, &obj.Key)
	c.Delete(&obj, rev)
}

func (c *AppInstInfoCache) SyncListStart() {
	c.List = make(map[AppInstKey]struct{})
}

func (c *AppInstInfoCache) SyncListEnd() {
	deleted := make(map[AppInstKey]struct{})
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, found := c.List[key]; !found {
			delete(c.Objs, key)
			deleted[key] = struct{}{}
		}
	}
	c.List = nil
	c.Mux.Unlock()
	if c.NotifyCb != nil {
		for key, _ := range deleted {
			c.NotifyCb(&key)
		}
	}
}
func (m *AppInstInfo) GetKey() *AppInstKey {
	return &m.Key
}

func (m *AppInstMetrics) CopyInFields(src *AppInstMetrics) {
	m.Something = src.Something
}

func (m *AppInstKey) Size() (n int) {
	var l int
	_ = l
	l = m.AppKey.Size()
	n += 1 + l + sovAppInst(uint64(l))
	l = m.CloudletKey.Size()
	n += 1 + l + sovAppInst(uint64(l))
	if m.Id != 0 {
		n += 9
	}
	return n
}

func (m *AppInst) Size() (n int) {
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovAppInst(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovAppInst(uint64(l))
	l = m.CloudletLoc.Size()
	n += 1 + l + sovAppInst(uint64(l))
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovAppInst(uint64(l))
	}
	l = m.ClusterInstKey.Size()
	n += 1 + l + sovAppInst(uint64(l))
	if m.Liveness != 0 {
		n += 1 + sovAppInst(uint64(m.Liveness))
	}
	l = len(m.ImagePath)
	if l > 0 {
		n += 1 + l + sovAppInst(uint64(l))
	}
	if m.ImageType != 0 {
		n += 1 + sovAppInst(uint64(m.ImageType))
	}
	l = len(m.MappedPorts)
	if l > 0 {
		n += 1 + l + sovAppInst(uint64(l))
	}
	l = len(m.MappedPath)
	if l > 0 {
		n += 1 + l + sovAppInst(uint64(l))
	}
	l = len(m.ConfigMap)
	if l > 0 {
		n += 1 + l + sovAppInst(uint64(l))
	}
	l = m.Flavor.Size()
	n += 1 + l + sovAppInst(uint64(l))
	return n
}

func (m *AppInstInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovAppInst(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovAppInst(uint64(l))
	if m.NotifyId != 0 {
		n += 1 + sovAppInst(uint64(m.NotifyId))
	}
	return n
}

func (m *AppInstMetrics) Size() (n int) {
	var l int
	_ = l
	if m.Something != 0 {
		n += 1 + sovAppInst(uint64(m.Something))
	}
	return n
}

func sovAppInst(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAppInst(x uint64) (n int) {
	return sovAppInst(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AppInstKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppInst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AppKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CloudletKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipAppInst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppInst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInst) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppInst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInst: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInst: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletLoc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CloudletLoc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterInstKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterInstKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liveness", wireType)
			}
			m.Liveness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Liveness |= (Liveness(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageType", wireType)
			}
			m.ImageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImageType |= (ImageType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MappedPorts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MappedPorts = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MappedPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MappedPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigMap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigMap = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flavor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Flavor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppInst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppInst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppInst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyId", wireType)
			}
			m.NotifyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotifyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppInst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppInst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppInst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Something", wireType)
			}
			m.Something = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Something |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppInst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppInst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAppInst(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAppInst
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAppInst
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAppInst
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAppInst(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAppInst = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAppInst   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("app_inst.proto", fileDescriptorAppInst) }

var fileDescriptorAppInst = []byte{
	// 920 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0x4f, 0x6f, 0x23, 0x35,
	0x14, 0x5f, 0x27, 0x6d, 0xda, 0x71, 0xb2, 0xd9, 0xad, 0x29, 0xc5, 0x0d, 0xa5, 0x8d, 0x46, 0x2b,
	0x14, 0xa1, 0x24, 0xb3, 0x0a, 0x12, 0xa0, 0x5c, 0x50, 0x1b, 0xb4, 0x28, 0xda, 0x16, 0x2d, 0x81,
	0x3d, 0x47, 0x93, 0x19, 0x67, 0x62, 0x31, 0x33, 0xb6, 0x66, 0x9c, 0x5d, 0x72, 0x43, 0xbb, 0x07,
	0x24, 0x4e, 0x48, 0x5c, 0xb8, 0x20, 0xed, 0x47, 0x40, 0x7c, 0x8a, 0x1e, 0x11, 0x1c, 0x91, 0x10,
	0x54, 0x1c, 0xf6, 0x88, 0xd4, 0x1e, 0xe0, 0x86, 0xec, 0xf1, 0x24, 0x9e, 0x96, 0x05, 0xa4, 0x72,
	0x19, 0xd9, 0xef, 0xbd, 0xdf, 0x1f, 0x3f, 0x3f, 0x0f, 0xac, 0xbb, 0x9c, 0x8f, 0x69, 0x9c, 0x8a,
	0x2e, 0x4f, 0x98, 0x60, 0xc8, 0x22, 0x7e, 0x40, 0xd4, 0xb2, 0xb1, 0x17, 0x30, 0x16, 0x84, 0xc4,
	0x71, 0x39, 0x75, 0xdc, 0x38, 0x66, 0xc2, 0x15, 0x94, 0xc5, 0x69, 0x56, 0xd8, 0xa8, 0x25, 0x24,
	0x9d, 0x87, 0x1a, 0xd6, 0x78, 0x27, 0xa0, 0x62, 0x36, 0x9f, 0x74, 0x3d, 0x16, 0x39, 0x11, 0x9b,
	0xd0, 0x50, 0xd2, 0x7c, 0xea, 0xc8, 0x6f, 0xc7, 0x0b, 0xd9, 0xdc, 0x77, 0x54, 0x5d, 0x40, 0xe2,
	0xe5, 0x42, 0x23, 0xdf, 0xff, 0x6f, 0x48, 0xaf, 0x13, 0x90, 0xb8, 0xe3, 0x45, 0xf9, 0xd6, 0x58,
	0x68, 0x22, 0xcb, 0xe5, 0x5c, 0x2f, 0xeb, 0x0a, 0x18, 0x92, 0xdc, 0x5d, 0x6d, 0x1a, 0xba, 0x8f,
	0x58, 0xa2, 0x77, 0x5b, 0x5e, 0x38, 0x4f, 0x05, 0x49, 0x56, 0xa7, 0x6e, 0xd4, 0x3c, 0x16, 0x45,
	0x2c, 0xb7, 0x34, 0xf8, 0x57, 0x4b, 0x7e, 0x27, 0x72, 0x85, 0x37, 0xeb, 0x90, 0x38, 0xa0, 0x31,
	0x71, 0xfc, 0x88, 0x74, 0x14, 0xd4, 0x09, 0x99, 0xa7, 0x49, 0x3a, 0x06, 0x49, 0xc0, 0x02, 0x96,
	0xd9, 0x9d, 0xcc, 0xa7, 0x6a, 0x97, 0x55, 0xcb, 0x55, 0x56, 0x6e, 0x7f, 0x03, 0x20, 0x3c, 0xe4,
	0x7c, 0x18, 0xa7, 0xe2, 0x3e, 0x59, 0xa0, 0xbb, 0x70, 0x43, 0x5e, 0xcc, 0x27, 0x64, 0x81, 0x41,
	0x13, 0xb4, 0xaa, 0xbd, 0xad, 0xee, 0xf2, 0x62, 0xba, 0x87, 0x9c, 0xdf, 0x27, 0x8b, 0xa3, 0xb5,
	0xd3, 0x9f, 0x0f, 0x6e, 0x8c, 0x2a, 0xae, 0xda, 0xa1, 0x77, 0x61, 0x2d, 0x3f, 0xb5, 0x82, 0x95,
	0x14, 0x6c, 0xc7, 0x80, 0x0d, 0x74, 0x7a, 0x85, 0xad, 0x7a, 0xab, 0x10, 0xaa, 0xc3, 0x12, 0xf5,
	0x71, 0xb9, 0x09, 0x5a, 0x95, 0x51, 0x89, 0xfa, 0xfd, 0xda, 0xf3, 0x73, 0x0c, 0xfe, 0x38, 0xc7,
	0xe0, 0xdb, 0x67, 0x07, 0xc0, 0xfe, 0x61, 0x1d, 0x6e, 0x68, 0x7f, 0x68, 0x07, 0x56, 0xa6, 0x94,
	0x84, 0x7e, 0x8a, 0x41, 0xb3, 0xdc, 0xb2, 0x46, 0x7a, 0x87, 0x3a, 0xb0, 0xbc, 0x52, 0x7e, 0xb9,
	0x68, 0x58, 0x1f, 0x4c, 0x0b, 0xcb, 0x3a, 0x74, 0xcf, 0x70, 0x1c, 0x32, 0x4f, 0x49, 0x57, 0x7b,
	0xaf, 0x75, 0x7d, 0x9a, 0x8a, 0x84, 0x4e, 0xe6, 0x82, 0xf8, 0x63, 0xd5, 0xe6, 0x71, 0xd6, 0xe6,
	0xee, 0x31, 0xf3, 0x2e, 0x1b, 0x3f, 0x66, 0x1e, 0x7a, 0x05, 0x96, 0xe7, 0x09, 0xc5, 0x6b, 0x4d,
	0xd0, 0xb2, 0x8e, 0xd6, 0x9f, 0x3f, 0xfd, 0x13, 0x80, 0x91, 0x8c, 0xa0, 0x0f, 0xe0, 0x6d, 0x7d,
	0xd5, 0x6a, 0xc2, 0x55, 0x5b, 0xd6, 0x95, 0xc8, 0x6e, 0xa1, 0x2d, 0xaa, 0x24, 0x37, 0x68, 0x49,
	0x81, 0x8c, 0xa4, 0xee, 0x15, 0x52, 0xe8, 0x2d, 0xb8, 0x19, 0xd2, 0x47, 0x24, 0x26, 0x69, 0x8a,
	0x2b, 0x4d, 0xd0, 0xaa, 0xf7, 0x5e, 0x32, 0x78, 0x8e, 0x75, 0x2a, 0xb7, 0xb0, 0xac, 0x45, 0x77,
	0x20, 0xa4, 0x91, 0x1b, 0x90, 0x31, 0x77, 0xc5, 0x0c, 0x6f, 0x98, 0x3e, 0x2d, 0x95, 0x78, 0xe0,
	0x8a, 0x19, 0xea, 0xe7, 0x55, 0x62, 0xc1, 0x09, 0xde, 0x54, 0xfc, 0xdb, 0x06, 0xff, 0x50, 0x26,
	0x3f, 0x5e, 0x70, 0x52, 0xc4, 0xca, 0x08, 0x6a, 0xc1, 0x5a, 0xe4, 0x72, 0x4e, 0xfc, 0x31, 0x67,
	0x89, 0x48, 0xb1, 0x65, 0x6a, 0x54, 0xb3, 0xd4, 0x03, 0x99, 0x41, 0xaf, 0xc3, 0x6a, 0x5e, 0x29,
	0xcd, 0x40, 0xb3, 0x10, 0xea, 0x42, 0xe9, 0xe6, 0x0e, 0x84, 0x1e, 0x8b, 0xa7, 0x34, 0x18, 0x47,
	0x2e, 0xc7, 0xd5, 0x82, 0xe7, 0x2c, 0x71, 0xe2, 0x72, 0xf4, 0x36, 0xac, 0x64, 0x4f, 0x0b, 0xd7,
	0x54, 0x5f, 0x4d, 0xbf, 0xf7, 0x54, 0xe2, 0x52, 0x4b, 0x75, 0x79, 0xff, 0x29, 0x90, 0xd3, 0xf5,
	0xfb, 0x39, 0x06, 0x9f, 0x5d, 0x60, 0xf0, 0xf5, 0x05, 0x06, 0x5f, 0x7c, 0xb7, 0xcb, 0x06, 0xab,
	0x5b, 0x6d, 0x0f, 0xf3, 0xc6, 0xb4, 0x97, 0x07, 0x6f, 0x9f, 0xac, 0x0e, 0x92, 0xaf, 0x65, 0xc1,
	0x20, 0xf7, 0xd3, 0xce, 0x34, 0xdb, 0x0f, 0x13, 0xda, 0xce, 0xaf, 0xa3, 0x5d, 0xbc, 0x5f, 0xf3,
	0x15, 0xd8, 0x9f, 0x03, 0x58, 0xd5, 0xb3, 0x39, 0x8c, 0xa7, 0xec, 0xff, 0x1a, 0xec, 0x57, 0xa1,
	0x15, 0x33, 0x41, 0xa7, 0x8b, 0xb1, 0x7e, 0x50, 0xe5, 0xd1, 0x66, 0x16, 0x18, 0xfa, 0xfd, 0x6d,
	0xf3, 0xe0, 0x5f, 0x5e, 0x60, 0xf0, 0xec, 0x02, 0x03, 0xbb, 0x0b, 0xeb, 0x9a, 0xeb, 0x84, 0x88,
	0x84, 0x7a, 0x29, 0xda, 0x83, 0x56, 0xca, 0x22, 0x22, 0x66, 0x34, 0x0e, 0xd4, 0xd4, 0xae, 0x8d,
	0x56, 0x81, 0xde, 0x4f, 0xa5, 0xe5, 0xef, 0xe2, 0x90, 0x53, 0x34, 0x82, 0x37, 0x07, 0x09, 0x71,
	0x05, 0xc9, 0x9f, 0x28, 0xba, 0x6a, 0xb2, 0x61, 0xfe, 0x42, 0x46, 0xea, 0xe7, 0x6d, 0x37, 0x9e,
	0xfc, 0xf8, 0xdb, 0x57, 0xa5, 0x6d, 0xfb, 0x96, 0xe3, 0x29, 0xb8, 0xe3, 0x72, 0x2e, 0x9f, 0x4a,
	0x1f, 0xbc, 0x21, 0x39, 0xdf, 0x23, 0x21, 0xb9, 0x06, 0xa7, 0xaf, 0xe0, 0x97, 0x38, 0x1f, 0x72,
	0xff, 0x3a, 0x3e, 0xe7, 0x0a, 0x6e, 0x72, 0x7e, 0x08, 0xab, 0x1f, 0xcd, 0xd8, 0xe3, 0x7f, 0x62,
	0xfc, 0x9b, 0x98, 0x8d, 0x15, 0x25, 0xb2, 0x6f, 0x3a, 0xe9, 0x8c, 0x3d, 0x36, 0x08, 0xef, 0x82,
	0x5e, 0xba, 0xbc, 0x0d, 0x39, 0x16, 0xb2, 0xc1, 0x2e, 0xbc, 0x65, 0x88, 0x64, 0xc3, 0x72, 0x95,
	0x54, 0xc6, 0x1b, 0x2f, 0x88, 0xdb, 0x7b, 0x4a, 0x70, 0xc7, 0xde, 0x2a, 0x08, 0xd2, 0x78, 0xca,
	0x32, 0xd1, 0x27, 0x00, 0x6e, 0x15, 0x67, 0x40, 0x0a, 0x47, 0x10, 0x19, 0xc2, 0xf9, 0x70, 0xec,
	0x5e, 0xd5, 0xd0, 0xa9, 0xc6, 0x8b, 0x53, 0xf6, 0x81, 0x72, 0xb0, 0x6b, 0x6f, 0x17, 0x1c, 0x44,
	0x59, 0x56, 0x99, 0x38, 0xba, 0x7d, 0xfa, 0xeb, 0xfe, 0x8d, 0xd3, 0xb3, 0x7d, 0xf0, 0xfd, 0xd9,
	0x3e, 0xf8, 0xe5, 0x6c, 0x1f, 0x4c, 0x2a, 0x8a, 0xea, 0xcd, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff,
	0x38, 0x66, 0x7f, 0x95, 0x29, 0x08, 0x00, 0x00,
}
