// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app_inst.proto

package edgeproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/mobiledgex/edge-cloud/protogen"
import _ "github.com/mobiledgex/edge-cloud/protoc-gen-cmd/protocmd"
import distributed_match_engine "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto"
import _ "github.com/gogo/protobuf/gogoproto"

import strings "strings"
import reflect "reflect"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import binary "encoding/binary"

import "encoding/json"
import "github.com/mobiledgex/edge-cloud/objstore"
import "github.com/coreos/etcd/clientv3/concurrency"
import "github.com/mobiledgex/edge-cloud/util"
import "github.com/mobiledgex/edge-cloud/log"
import "errors"
import "strconv"
import "time"
import google_protobuf "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// AppState defines the state of the AppInst. This state is defined both by the state on the Controller, and the state on the Cloudlet where the AppInst is instantiated. Some of the states are intermediate states to denote a change in progress.
type AppState int32

const (
	// AppInst state unknown
	AppState_AppStateUnknown AppState = 0
	// AppInst state in the process of being created
	AppState_AppStateBuilding AppState = 1
	// AppInst state created and ready
	AppState_AppStateReady AppState = 2
	// AppInst change encountered errors, see Errors field of AppInstInfo
	AppState_AppStateErrors AppState = 3
	// AppInst in the process of being deleted
	AppState_AppStateDeleting AppState = 4
	// AppInst was deleted
	AppState_AppStateDeleted AppState = 5
	// AppInst in the process of being updated
	AppState_AppStateChanging AppState = 6
	// AppInst is not present
	AppState_AppStateNotPresent AppState = 7
)

var AppState_name = map[int32]string{
	0: "AppStateUnknown",
	1: "AppStateBuilding",
	2: "AppStateReady",
	3: "AppStateErrors",
	4: "AppStateDeleting",
	5: "AppStateDeleted",
	6: "AppStateChanging",
	7: "AppStateNotPresent",
}
var AppState_value = map[string]int32{
	"AppStateUnknown":    0,
	"AppStateBuilding":   1,
	"AppStateReady":      2,
	"AppStateErrors":     3,
	"AppStateDeleting":   4,
	"AppStateDeleted":    5,
	"AppStateChanging":   6,
	"AppStateNotPresent": 7,
}

func (x AppState) String() string {
	return proto.EnumName(AppState_name, int32(x))
}
func (AppState) EnumDescriptor() ([]byte, []int) { return fileDescriptorAppInst, []int{0} }

// AppInstKey uniquely identifies an Application Instance (AppInst) or Application Instance state (AppInstInfo).
type AppInstKey struct {
	// App key
	AppKey AppKey `protobuf:"bytes,1,opt,name=app_key,json=appKey" json:"app_key"`
	// Cloudlet on which the App is instantiated
	CloudletKey CloudletKey `protobuf:"bytes,2,opt,name=cloudlet_key,json=cloudletKey" json:"cloudlet_key"`
	// Instance id for defining multiple instances of the same App on the same Cloudlet (not supported yet)
	Id uint64 `protobuf:"fixed64,3,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *AppInstKey) Reset()                    { *m = AppInstKey{} }
func (m *AppInstKey) String() string            { return proto.CompactTextString(m) }
func (*AppInstKey) ProtoMessage()               {}
func (*AppInstKey) Descriptor() ([]byte, []int) { return fileDescriptorAppInst, []int{0} }

// AppPort describes an L4 public access port mapping. This is used to track external to internal mappings for access via a shared load balancer or reverse proxy.
type AppPort struct {
	// TCP or UDP protocol
	Proto L4Proto `protobuf:"varint,1,opt,name=proto,proto3,enum=edgeproto.L4Proto" json:"proto,omitempty"`
	// Container port
	InternalPort int32 `protobuf:"varint,2,opt,name=internal_port,json=internalPort,proto3" json:"internal_port,omitempty"`
	// Public facing port (may be mapped on shared LB reverse proxy)
	PublicPort int32 `protobuf:"varint,3,opt,name=public_port,json=publicPort,proto3" json:"public_port,omitempty"`
}

func (m *AppPort) Reset()                    { *m = AppPort{} }
func (m *AppPort) String() string            { return proto.CompactTextString(m) }
func (*AppPort) ProtoMessage()               {}
func (*AppPort) Descriptor() ([]byte, []int) { return fileDescriptorAppInst, []int{1} }

// AppInst is an instance of an App (application) on a Cloudlet. It is defined by an App plus a Cloudlet key. This separation of the definition of the App versus its instantiation is unique to Mobiledgex, and allows the Developer to provide the App defintion, while either the Developer may statically define the instances, or the Mobiledgex platform may dynamically create and destroy instances in response to demand.
// When an application is instantiated on a Cloudlet, the user may override the default Flavor of the application. This allows for an instance in one location to be provided more resources than an instance in other locations, in expectation of different demands in different locations.
// Many of the fields here are inherited from the App definition. Some are derived, like the mapped ports field, depending upon if the AppInst accessibility is via a shared or dedicated load balancer.
type AppInst struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty"`
	// Unique identifier key
	Key AppInstKey `protobuf:"bytes,2,opt,name=key" json:"key"`
	// Cached location of the cloudlet
	CloudletLoc distributed_match_engine.Loc `protobuf:"bytes,3,opt,name=cloudlet_loc,json=cloudletLoc" json:"cloudlet_loc"`
	// URI to connect to this instance
	Uri string `protobuf:"bytes,4,opt,name=uri,proto3" json:"uri,omitempty"`
	// Cluster instance on which this is instatiated (not specifiable by user)
	ClusterInstKey ClusterInstKey `protobuf:"bytes,5,opt,name=cluster_inst_key,json=clusterInstKey" json:"cluster_inst_key"`
	// Liveness of instance (see Liveness)
	Liveness Liveness `protobuf:"varint,6,opt,name=liveness,proto3,enum=edgeproto.Liveness" json:"liveness,omitempty"`
	// URI from which to download image
	ImagePath string `protobuf:"bytes,7,opt,name=image_path,json=imagePath,proto3" json:"image_path,omitempty"`
	// Image type (see ImageType)
	ImageType ImageType `protobuf:"varint,8,opt,name=image_type,json=imageType,proto3,enum=edgeproto.ImageType" json:"image_type,omitempty"`
	// For instances accessible via a shared load balancer, defines the external
	// ports on the shared load balancer that map to the internal ports
	// External ports should be appended to the Uri for L4 access.
	MappedPorts []AppPort `protobuf:"bytes,9,rep,name=mapped_ports,json=mappedPorts" json:"mapped_ports"`
	// Mapped path to append to Uri for public access.
	// Only valid for L7 access types.
	MappedPath string `protobuf:"bytes,10,opt,name=mapped_path,json=mappedPath,proto3" json:"mapped_path,omitempty"`
	// URI of resource to be used to establish config for App.
	Config string `protobuf:"bytes,11,opt,name=config,proto3" json:"config,omitempty"`
	// Flavor defining resource requirements
	Flavor FlavorKey `protobuf:"bytes,12,opt,name=flavor" json:"flavor"`
	// Access layer(s)
	AccessLayer AccessLayer `protobuf:"varint,13,opt,name=access_layer,json=accessLayer,proto3,enum=edgeproto.AccessLayer" json:"access_layer,omitempty"`
}

func (m *AppInst) Reset()                    { *m = AppInst{} }
func (m *AppInst) String() string            { return proto.CompactTextString(m) }
func (*AppInst) ProtoMessage()               {}
func (*AppInst) Descriptor() ([]byte, []int) { return fileDescriptorAppInst, []int{2} }

// AppInstInfo provides information from the Cloudlet Resource Manager about the state of the AppInst on the Cloudlet. Whereas the AppInst defines the intent of instantiating an App on a Cloudlet, the AppInstInfo defines the current state of trying to apply that intent on the physical resources of the Cloudlet.
type AppInstInfo struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty"`
	// Unique identifier key
	Key AppInstKey `protobuf:"bytes,2,opt,name=key" json:"key"`
	// Id of client assigned by server (internal use only)
	NotifyId int64 `protobuf:"varint,3,opt,name=notify_id,json=notifyId,proto3" json:"notify_id,omitempty"`
	// Current state of the AppInst on the Cloudlet
	State AppState `protobuf:"varint,4,opt,name=state,proto3,enum=edgeproto.AppState" json:"state,omitempty"`
	// Any errors trying to create, update, or delete the AppInst on the Cloudlet
	Errors []string `protobuf:"bytes,5,rep,name=errors" json:"errors,omitempty"`
}

func (m *AppInstInfo) Reset()                    { *m = AppInstInfo{} }
func (m *AppInstInfo) String() string            { return proto.CompactTextString(m) }
func (*AppInstInfo) ProtoMessage()               {}
func (*AppInstInfo) Descriptor() ([]byte, []int) { return fileDescriptorAppInst, []int{3} }

// (TODO) AppInstMetrics provide metrics collected about the application instance on the Cloudlet. They are sent to a metrics collector for analytics. They are not stored in the persistent distributed database, but are stored as a time series in some other database or files.
type AppInstMetrics struct {
	// what goes here?
	// Note that metrics for grpc calls can be done by a prometheus
	// interceptor in grpc, so adding call metrics here may be
	// redundant unless they're needed for billing.
	Something uint64 `protobuf:"varint,5,opt,name=something,proto3" json:"something,omitempty"`
}

func (m *AppInstMetrics) Reset()                    { *m = AppInstMetrics{} }
func (m *AppInstMetrics) String() string            { return proto.CompactTextString(m) }
func (*AppInstMetrics) ProtoMessage()               {}
func (*AppInstMetrics) Descriptor() ([]byte, []int) { return fileDescriptorAppInst, []int{4} }

func init() {
	proto.RegisterType((*AppInstKey)(nil), "edgeproto.AppInstKey")
	proto.RegisterType((*AppPort)(nil), "edgeproto.AppPort")
	proto.RegisterType((*AppInst)(nil), "edgeproto.AppInst")
	proto.RegisterType((*AppInstInfo)(nil), "edgeproto.AppInstInfo")
	proto.RegisterType((*AppInstMetrics)(nil), "edgeproto.AppInstMetrics")
	proto.RegisterEnum("edgeproto.AppState", AppState_name, AppState_value)
}
func (this *AppInstKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&edgeproto.AppInstKey{")
	s = append(s, "AppKey: "+strings.Replace(this.AppKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "CloudletKey: "+strings.Replace(this.CloudletKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAppInst(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AppInstApi service

type AppInstApiClient interface {
	// Create an application instance
	CreateAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_CreateAppInstClient, error)
	// Delete an application instance
	DeleteAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_DeleteAppInstClient, error)
	// Update an application instance
	UpdateAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_UpdateAppInstClient, error)
	// Show application instances. Any fields specified will be used to filter results.
	ShowAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_ShowAppInstClient, error)
}

type appInstApiClient struct {
	cc *grpc.ClientConn
}

func NewAppInstApiClient(cc *grpc.ClientConn) AppInstApiClient {
	return &appInstApiClient{cc}
}

func (c *appInstApiClient) CreateAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_CreateAppInstClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AppInstApi_serviceDesc.Streams[0], c.cc, "/edgeproto.AppInstApi/CreateAppInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstApiCreateAppInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstApi_CreateAppInstClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type appInstApiCreateAppInstClient struct {
	grpc.ClientStream
}

func (x *appInstApiCreateAppInstClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *appInstApiClient) DeleteAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_DeleteAppInstClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AppInstApi_serviceDesc.Streams[1], c.cc, "/edgeproto.AppInstApi/DeleteAppInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstApiDeleteAppInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstApi_DeleteAppInstClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type appInstApiDeleteAppInstClient struct {
	grpc.ClientStream
}

func (x *appInstApiDeleteAppInstClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *appInstApiClient) UpdateAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_UpdateAppInstClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AppInstApi_serviceDesc.Streams[2], c.cc, "/edgeproto.AppInstApi/UpdateAppInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstApiUpdateAppInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstApi_UpdateAppInstClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type appInstApiUpdateAppInstClient struct {
	grpc.ClientStream
}

func (x *appInstApiUpdateAppInstClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *appInstApiClient) ShowAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_ShowAppInstClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AppInstApi_serviceDesc.Streams[3], c.cc, "/edgeproto.AppInstApi/ShowAppInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstApiShowAppInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstApi_ShowAppInstClient interface {
	Recv() (*AppInst, error)
	grpc.ClientStream
}

type appInstApiShowAppInstClient struct {
	grpc.ClientStream
}

func (x *appInstApiShowAppInstClient) Recv() (*AppInst, error) {
	m := new(AppInst)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AppInstApi service

type AppInstApiServer interface {
	// Create an application instance
	CreateAppInst(*AppInst, AppInstApi_CreateAppInstServer) error
	// Delete an application instance
	DeleteAppInst(*AppInst, AppInstApi_DeleteAppInstServer) error
	// Update an application instance
	UpdateAppInst(*AppInst, AppInstApi_UpdateAppInstServer) error
	// Show application instances. Any fields specified will be used to filter results.
	ShowAppInst(*AppInst, AppInstApi_ShowAppInstServer) error
}

func RegisterAppInstApiServer(s *grpc.Server, srv AppInstApiServer) {
	s.RegisterService(&_AppInstApi_serviceDesc, srv)
}

func _AppInstApi_CreateAppInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstApiServer).CreateAppInst(m, &appInstApiCreateAppInstServer{stream})
}

type AppInstApi_CreateAppInstServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type appInstApiCreateAppInstServer struct {
	grpc.ServerStream
}

func (x *appInstApiCreateAppInstServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _AppInstApi_DeleteAppInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstApiServer).DeleteAppInst(m, &appInstApiDeleteAppInstServer{stream})
}

type AppInstApi_DeleteAppInstServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type appInstApiDeleteAppInstServer struct {
	grpc.ServerStream
}

func (x *appInstApiDeleteAppInstServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _AppInstApi_UpdateAppInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstApiServer).UpdateAppInst(m, &appInstApiUpdateAppInstServer{stream})
}

type AppInstApi_UpdateAppInstServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type appInstApiUpdateAppInstServer struct {
	grpc.ServerStream
}

func (x *appInstApiUpdateAppInstServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _AppInstApi_ShowAppInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstApiServer).ShowAppInst(m, &appInstApiShowAppInstServer{stream})
}

type AppInstApi_ShowAppInstServer interface {
	Send(*AppInst) error
	grpc.ServerStream
}

type appInstApiShowAppInstServer struct {
	grpc.ServerStream
}

func (x *appInstApiShowAppInstServer) Send(m *AppInst) error {
	return x.ServerStream.SendMsg(m)
}

var _AppInstApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.AppInstApi",
	HandlerType: (*AppInstApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreateAppInst",
			Handler:       _AppInstApi_CreateAppInst_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DeleteAppInst",
			Handler:       _AppInstApi_DeleteAppInst_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdateAppInst",
			Handler:       _AppInstApi_UpdateAppInst_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowAppInst",
			Handler:       _AppInstApi_ShowAppInst_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "app_inst.proto",
}

// Client API for AppInstInfoApi service

type AppInstInfoApiClient interface {
	// Show application instances state.
	ShowAppInstInfo(ctx context.Context, in *AppInstInfo, opts ...grpc.CallOption) (AppInstInfoApi_ShowAppInstInfoClient, error)
}

type appInstInfoApiClient struct {
	cc *grpc.ClientConn
}

func NewAppInstInfoApiClient(cc *grpc.ClientConn) AppInstInfoApiClient {
	return &appInstInfoApiClient{cc}
}

func (c *appInstInfoApiClient) ShowAppInstInfo(ctx context.Context, in *AppInstInfo, opts ...grpc.CallOption) (AppInstInfoApi_ShowAppInstInfoClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AppInstInfoApi_serviceDesc.Streams[0], c.cc, "/edgeproto.AppInstInfoApi/ShowAppInstInfo", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstInfoApiShowAppInstInfoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstInfoApi_ShowAppInstInfoClient interface {
	Recv() (*AppInstInfo, error)
	grpc.ClientStream
}

type appInstInfoApiShowAppInstInfoClient struct {
	grpc.ClientStream
}

func (x *appInstInfoApiShowAppInstInfoClient) Recv() (*AppInstInfo, error) {
	m := new(AppInstInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AppInstInfoApi service

type AppInstInfoApiServer interface {
	// Show application instances state.
	ShowAppInstInfo(*AppInstInfo, AppInstInfoApi_ShowAppInstInfoServer) error
}

func RegisterAppInstInfoApiServer(s *grpc.Server, srv AppInstInfoApiServer) {
	s.RegisterService(&_AppInstInfoApi_serviceDesc, srv)
}

func _AppInstInfoApi_ShowAppInstInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInstInfo)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstInfoApiServer).ShowAppInstInfo(m, &appInstInfoApiShowAppInstInfoServer{stream})
}

type AppInstInfoApi_ShowAppInstInfoServer interface {
	Send(*AppInstInfo) error
	grpc.ServerStream
}

type appInstInfoApiShowAppInstInfoServer struct {
	grpc.ServerStream
}

func (x *appInstInfoApiShowAppInstInfoServer) Send(m *AppInstInfo) error {
	return x.ServerStream.SendMsg(m)
}

var _AppInstInfoApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.AppInstInfoApi",
	HandlerType: (*AppInstInfoApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowAppInstInfo",
			Handler:       _AppInstInfoApi_ShowAppInstInfo_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "app_inst.proto",
}

// Client API for AppInstMetricsApi service

type AppInstMetricsApiClient interface {
	// Show application instance metrics.
	ShowAppInstMetrics(ctx context.Context, in *AppInstMetrics, opts ...grpc.CallOption) (AppInstMetricsApi_ShowAppInstMetricsClient, error)
}

type appInstMetricsApiClient struct {
	cc *grpc.ClientConn
}

func NewAppInstMetricsApiClient(cc *grpc.ClientConn) AppInstMetricsApiClient {
	return &appInstMetricsApiClient{cc}
}

func (c *appInstMetricsApiClient) ShowAppInstMetrics(ctx context.Context, in *AppInstMetrics, opts ...grpc.CallOption) (AppInstMetricsApi_ShowAppInstMetricsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AppInstMetricsApi_serviceDesc.Streams[0], c.cc, "/edgeproto.AppInstMetricsApi/ShowAppInstMetrics", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstMetricsApiShowAppInstMetricsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstMetricsApi_ShowAppInstMetricsClient interface {
	Recv() (*AppInstMetrics, error)
	grpc.ClientStream
}

type appInstMetricsApiShowAppInstMetricsClient struct {
	grpc.ClientStream
}

func (x *appInstMetricsApiShowAppInstMetricsClient) Recv() (*AppInstMetrics, error) {
	m := new(AppInstMetrics)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AppInstMetricsApi service

type AppInstMetricsApiServer interface {
	// Show application instance metrics.
	ShowAppInstMetrics(*AppInstMetrics, AppInstMetricsApi_ShowAppInstMetricsServer) error
}

func RegisterAppInstMetricsApiServer(s *grpc.Server, srv AppInstMetricsApiServer) {
	s.RegisterService(&_AppInstMetricsApi_serviceDesc, srv)
}

func _AppInstMetricsApi_ShowAppInstMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInstMetrics)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstMetricsApiServer).ShowAppInstMetrics(m, &appInstMetricsApiShowAppInstMetricsServer{stream})
}

type AppInstMetricsApi_ShowAppInstMetricsServer interface {
	Send(*AppInstMetrics) error
	grpc.ServerStream
}

type appInstMetricsApiShowAppInstMetricsServer struct {
	grpc.ServerStream
}

func (x *appInstMetricsApiShowAppInstMetricsServer) Send(m *AppInstMetrics) error {
	return x.ServerStream.SendMsg(m)
}

var _AppInstMetricsApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.AppInstMetricsApi",
	HandlerType: (*AppInstMetricsApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowAppInstMetrics",
			Handler:       _AppInstMetricsApi_ShowAppInstMetrics_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "app_inst.proto",
}

func (m *AppInstKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAppInst(dAtA, i, uint64(m.AppKey.Size()))
	n1, err := m.AppKey.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintAppInst(dAtA, i, uint64(m.CloudletKey.Size()))
	n2, err := m.CloudletKey.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if m.Id != 0 {
		dAtA[i] = 0x19
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Id))
		i += 8
	}
	return i, nil
}

func (m *AppPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppPort) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Proto != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(m.Proto))
	}
	if m.InternalPort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(m.InternalPort))
	}
	if m.PublicPort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(m.PublicPort))
	}
	return i, nil
}

func (m *AppInst) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInst) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintAppInst(dAtA, i, uint64(m.Key.Size()))
	n3, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAppInst(dAtA, i, uint64(m.CloudletLoc.Size()))
	n4, err := m.CloudletLoc.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if len(m.Uri) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintAppInst(dAtA, i, uint64(m.ClusterInstKey.Size()))
	n5, err := m.ClusterInstKey.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if m.Liveness != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(m.Liveness))
	}
	if len(m.ImagePath) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(len(m.ImagePath)))
		i += copy(dAtA[i:], m.ImagePath)
	}
	if m.ImageType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(m.ImageType))
	}
	if len(m.MappedPorts) > 0 {
		for _, msg := range m.MappedPorts {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintAppInst(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MappedPath) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(len(m.MappedPath)))
		i += copy(dAtA[i:], m.MappedPath)
	}
	if len(m.Config) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(len(m.Config)))
		i += copy(dAtA[i:], m.Config)
	}
	dAtA[i] = 0x62
	i++
	i = encodeVarintAppInst(dAtA, i, uint64(m.Flavor.Size()))
	n6, err := m.Flavor.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if m.AccessLayer != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(m.AccessLayer))
	}
	return i, nil
}

func (m *AppInstInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintAppInst(dAtA, i, uint64(m.Key.Size()))
	n7, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if m.NotifyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(m.NotifyId))
	}
	if m.State != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(m.State))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *AppInstMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstMetrics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Something != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAppInst(dAtA, i, uint64(m.Something))
	}
	return i, nil
}

func encodeVarintAppInst(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AppInstKey) Matches(o *AppInstKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.AppKey.Matches(&o.AppKey, fopts...) {
		return false
	}
	if !m.CloudletKey.Matches(&o.CloudletKey, fopts...) {
		return false
	}
	if !opts.Filter || o.Id != 0 {
		if o.Id != m.Id {
			return false
		}
	}
	return true
}

func (m *AppInstKey) CopyInFields(src *AppInstKey) {
	m.AppKey.DeveloperKey.Name = src.AppKey.DeveloperKey.Name
	m.AppKey.Name = src.AppKey.Name
	m.AppKey.Version = src.AppKey.Version
	m.CloudletKey.OperatorKey.Name = src.CloudletKey.OperatorKey.Name
	m.CloudletKey.Name = src.CloudletKey.Name
	m.Id = src.Id
}

func (m *AppInstKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal AppInstKey key string", "obj", m)
	}
	return string(key)
}

func AppInstKeyStringParse(str string, key *AppInstKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal AppInstKey key string", "str", str)
	}
}

func (m *AppPort) CopyInFields(src *AppPort) {
	m.Proto = src.Proto
	m.InternalPort = src.InternalPort
	m.PublicPort = src.PublicPort
}

func (m *AppInst) Matches(o *AppInst, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Uri != "" {
			if o.Uri != m.Uri {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !m.ClusterInstKey.Matches(&o.ClusterInstKey, fopts...) {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Liveness != 0 {
			if o.Liveness != m.Liveness {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.ImagePath != "" {
			if o.ImagePath != m.ImagePath {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.ImageType != 0 {
			if o.ImageType != m.ImageType {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.MappedPorts != nil {
			if m.MappedPorts == nil && o.MappedPorts != nil || m.MappedPorts != nil && o.MappedPorts == nil {
				return false
			} else if m.MappedPorts != nil && o.MappedPorts != nil {
				if len(m.MappedPorts) != len(o.MappedPorts) {
					return false
				}
				for i := 0; i < len(m.MappedPorts); i++ {
				}
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.MappedPath != "" {
			if o.MappedPath != m.MappedPath {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Config != "" {
			if o.Config != m.Config {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !m.Flavor.Matches(&o.Flavor, fopts...) {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.AccessLayer != 0 {
			if o.AccessLayer != m.AccessLayer {
				return false
			}
		}
	}
	return true
}

const AppInstFieldKey = "2"
const AppInstFieldKeyAppKey = "2.1"
const AppInstFieldKeyAppKeyDeveloperKey = "2.1.1"
const AppInstFieldKeyAppKeyDeveloperKeyName = "2.1.1.2"
const AppInstFieldKeyAppKeyName = "2.1.2"
const AppInstFieldKeyAppKeyVersion = "2.1.3"
const AppInstFieldKeyCloudletKey = "2.2"
const AppInstFieldKeyCloudletKeyOperatorKey = "2.2.1"
const AppInstFieldKeyCloudletKeyOperatorKeyName = "2.2.1.1"
const AppInstFieldKeyCloudletKeyName = "2.2.2"
const AppInstFieldKeyId = "2.3"
const AppInstFieldCloudletLoc = "3"
const AppInstFieldCloudletLocLat = "3.1"
const AppInstFieldCloudletLocLong = "3.2"
const AppInstFieldCloudletLocHorizontalAccuracy = "3.3"
const AppInstFieldCloudletLocVerticalAccuracy = "3.4"
const AppInstFieldCloudletLocAltitude = "3.5"
const AppInstFieldCloudletLocCourse = "3.6"
const AppInstFieldCloudletLocSpeed = "3.7"
const AppInstFieldCloudletLocTimestamp = "3.8"
const AppInstFieldCloudletLocTimestampSeconds = "3.8.1"
const AppInstFieldCloudletLocTimestampNanos = "3.8.2"
const AppInstFieldUri = "4"
const AppInstFieldClusterInstKey = "5"
const AppInstFieldClusterInstKeyClusterKey = "5.1"
const AppInstFieldClusterInstKeyClusterKeyName = "5.1.1"
const AppInstFieldClusterInstKeyCloudletKey = "5.2"
const AppInstFieldClusterInstKeyCloudletKeyOperatorKey = "5.2.1"
const AppInstFieldClusterInstKeyCloudletKeyOperatorKeyName = "5.2.1.1"
const AppInstFieldClusterInstKeyCloudletKeyName = "5.2.2"
const AppInstFieldLiveness = "6"
const AppInstFieldImagePath = "7"
const AppInstFieldImageType = "8"
const AppInstFieldMappedPorts = "9"
const AppInstFieldMappedPortsProto = "9.1"
const AppInstFieldMappedPortsInternalPort = "9.2"
const AppInstFieldMappedPortsPublicPort = "9.3"
const AppInstFieldMappedPath = "10"
const AppInstFieldConfig = "11"
const AppInstFieldFlavor = "12"
const AppInstFieldFlavorName = "12.1"
const AppInstFieldAccessLayer = "13"

var AppInstAllFields = []string{
	AppInstFieldKeyAppKeyDeveloperKeyName,
	AppInstFieldKeyAppKeyName,
	AppInstFieldKeyAppKeyVersion,
	AppInstFieldKeyCloudletKeyOperatorKeyName,
	AppInstFieldKeyCloudletKeyName,
	AppInstFieldKeyId,
	AppInstFieldCloudletLocLat,
	AppInstFieldCloudletLocLong,
	AppInstFieldCloudletLocHorizontalAccuracy,
	AppInstFieldCloudletLocVerticalAccuracy,
	AppInstFieldCloudletLocAltitude,
	AppInstFieldCloudletLocCourse,
	AppInstFieldCloudletLocSpeed,
	AppInstFieldCloudletLocTimestampSeconds,
	AppInstFieldCloudletLocTimestampNanos,
	AppInstFieldUri,
	AppInstFieldClusterInstKeyClusterKeyName,
	AppInstFieldClusterInstKeyCloudletKeyOperatorKeyName,
	AppInstFieldClusterInstKeyCloudletKeyName,
	AppInstFieldLiveness,
	AppInstFieldImagePath,
	AppInstFieldImageType,
	AppInstFieldMappedPortsProto,
	AppInstFieldMappedPortsInternalPort,
	AppInstFieldMappedPortsPublicPort,
	AppInstFieldMappedPath,
	AppInstFieldConfig,
	AppInstFieldFlavorName,
	AppInstFieldAccessLayer,
}

var AppInstAllFieldsMap = map[string]struct{}{
	AppInstFieldKeyAppKeyDeveloperKeyName:                struct{}{},
	AppInstFieldKeyAppKeyName:                            struct{}{},
	AppInstFieldKeyAppKeyVersion:                         struct{}{},
	AppInstFieldKeyCloudletKeyOperatorKeyName:            struct{}{},
	AppInstFieldKeyCloudletKeyName:                       struct{}{},
	AppInstFieldKeyId:                                    struct{}{},
	AppInstFieldCloudletLocLat:                           struct{}{},
	AppInstFieldCloudletLocLong:                          struct{}{},
	AppInstFieldCloudletLocHorizontalAccuracy:            struct{}{},
	AppInstFieldCloudletLocVerticalAccuracy:              struct{}{},
	AppInstFieldCloudletLocAltitude:                      struct{}{},
	AppInstFieldCloudletLocCourse:                        struct{}{},
	AppInstFieldCloudletLocSpeed:                         struct{}{},
	AppInstFieldCloudletLocTimestampSeconds:              struct{}{},
	AppInstFieldCloudletLocTimestampNanos:                struct{}{},
	AppInstFieldUri:                                      struct{}{},
	AppInstFieldClusterInstKeyClusterKeyName:             struct{}{},
	AppInstFieldClusterInstKeyCloudletKeyOperatorKeyName: struct{}{},
	AppInstFieldClusterInstKeyCloudletKeyName:            struct{}{},
	AppInstFieldLiveness:                                 struct{}{},
	AppInstFieldImagePath:                                struct{}{},
	AppInstFieldImageType:                                struct{}{},
	AppInstFieldMappedPortsProto:                         struct{}{},
	AppInstFieldMappedPortsInternalPort:                  struct{}{},
	AppInstFieldMappedPortsPublicPort:                    struct{}{},
	AppInstFieldMappedPath:                               struct{}{},
	AppInstFieldConfig:                                   struct{}{},
	AppInstFieldFlavorName:                               struct{}{},
	AppInstFieldAccessLayer:                              struct{}{},
}

func (m *AppInst) DiffFields(o *AppInst, fields map[string]struct{}) {
	if m.Key.AppKey.DeveloperKey.Name != o.Key.AppKey.DeveloperKey.Name {
		fields[AppInstFieldKeyAppKeyDeveloperKeyName] = struct{}{}
		fields[AppInstFieldKeyAppKeyDeveloperKey] = struct{}{}
		fields[AppInstFieldKeyAppKey] = struct{}{}
		fields[AppInstFieldKey] = struct{}{}
	}
	if m.Key.AppKey.Name != o.Key.AppKey.Name {
		fields[AppInstFieldKeyAppKeyName] = struct{}{}
		fields[AppInstFieldKeyAppKey] = struct{}{}
		fields[AppInstFieldKey] = struct{}{}
	}
	if m.Key.AppKey.Version != o.Key.AppKey.Version {
		fields[AppInstFieldKeyAppKeyVersion] = struct{}{}
		fields[AppInstFieldKeyAppKey] = struct{}{}
		fields[AppInstFieldKey] = struct{}{}
	}
	if m.Key.CloudletKey.OperatorKey.Name != o.Key.CloudletKey.OperatorKey.Name {
		fields[AppInstFieldKeyCloudletKeyOperatorKeyName] = struct{}{}
		fields[AppInstFieldKeyCloudletKeyOperatorKey] = struct{}{}
		fields[AppInstFieldKeyCloudletKey] = struct{}{}
		fields[AppInstFieldKey] = struct{}{}
	}
	if m.Key.CloudletKey.Name != o.Key.CloudletKey.Name {
		fields[AppInstFieldKeyCloudletKeyName] = struct{}{}
		fields[AppInstFieldKeyCloudletKey] = struct{}{}
		fields[AppInstFieldKey] = struct{}{}
	}
	if m.Key.Id != o.Key.Id {
		fields[AppInstFieldKeyId] = struct{}{}
		fields[AppInstFieldKey] = struct{}{}
	}
	if m.CloudletLoc.Lat != o.CloudletLoc.Lat {
		fields[AppInstFieldCloudletLocLat] = struct{}{}
		fields[AppInstFieldCloudletLoc] = struct{}{}
	}
	if m.CloudletLoc.Long != o.CloudletLoc.Long {
		fields[AppInstFieldCloudletLocLong] = struct{}{}
		fields[AppInstFieldCloudletLoc] = struct{}{}
	}
	if m.CloudletLoc.HorizontalAccuracy != o.CloudletLoc.HorizontalAccuracy {
		fields[AppInstFieldCloudletLocHorizontalAccuracy] = struct{}{}
		fields[AppInstFieldCloudletLoc] = struct{}{}
	}
	if m.CloudletLoc.VerticalAccuracy != o.CloudletLoc.VerticalAccuracy {
		fields[AppInstFieldCloudletLocVerticalAccuracy] = struct{}{}
		fields[AppInstFieldCloudletLoc] = struct{}{}
	}
	if m.CloudletLoc.Altitude != o.CloudletLoc.Altitude {
		fields[AppInstFieldCloudletLocAltitude] = struct{}{}
		fields[AppInstFieldCloudletLoc] = struct{}{}
	}
	if m.CloudletLoc.Course != o.CloudletLoc.Course {
		fields[AppInstFieldCloudletLocCourse] = struct{}{}
		fields[AppInstFieldCloudletLoc] = struct{}{}
	}
	if m.CloudletLoc.Speed != o.CloudletLoc.Speed {
		fields[AppInstFieldCloudletLocSpeed] = struct{}{}
		fields[AppInstFieldCloudletLoc] = struct{}{}
	}
	if m.CloudletLoc.Timestamp.Seconds != o.CloudletLoc.Timestamp.Seconds {
		fields[AppInstFieldCloudletLocTimestampSeconds] = struct{}{}
		fields[AppInstFieldCloudletLocTimestamp] = struct{}{}
		fields[AppInstFieldCloudletLoc] = struct{}{}
	}
	if m.CloudletLoc.Timestamp.Nanos != o.CloudletLoc.Timestamp.Nanos {
		fields[AppInstFieldCloudletLocTimestampNanos] = struct{}{}
		fields[AppInstFieldCloudletLocTimestamp] = struct{}{}
		fields[AppInstFieldCloudletLoc] = struct{}{}
	}
	if m.Uri != o.Uri {
		fields[AppInstFieldUri] = struct{}{}
	}
	if m.ClusterInstKey.ClusterKey.Name != o.ClusterInstKey.ClusterKey.Name {
		fields[AppInstFieldClusterInstKeyClusterKeyName] = struct{}{}
		fields[AppInstFieldClusterInstKeyClusterKey] = struct{}{}
		fields[AppInstFieldClusterInstKey] = struct{}{}
	}
	if m.ClusterInstKey.CloudletKey.OperatorKey.Name != o.ClusterInstKey.CloudletKey.OperatorKey.Name {
		fields[AppInstFieldClusterInstKeyCloudletKeyOperatorKeyName] = struct{}{}
		fields[AppInstFieldClusterInstKeyCloudletKeyOperatorKey] = struct{}{}
		fields[AppInstFieldClusterInstKeyCloudletKey] = struct{}{}
		fields[AppInstFieldClusterInstKey] = struct{}{}
	}
	if m.ClusterInstKey.CloudletKey.Name != o.ClusterInstKey.CloudletKey.Name {
		fields[AppInstFieldClusterInstKeyCloudletKeyName] = struct{}{}
		fields[AppInstFieldClusterInstKeyCloudletKey] = struct{}{}
		fields[AppInstFieldClusterInstKey] = struct{}{}
	}
	if m.Liveness != o.Liveness {
		fields[AppInstFieldLiveness] = struct{}{}
	}
	if m.ImagePath != o.ImagePath {
		fields[AppInstFieldImagePath] = struct{}{}
	}
	if m.ImageType != o.ImageType {
		fields[AppInstFieldImageType] = struct{}{}
	}
	if len(m.MappedPorts) != len(o.MappedPorts) {
		fields[AppInstFieldMappedPorts] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.MappedPorts); i0++ {
			if m.MappedPorts[i0].Proto != o.MappedPorts[i0].Proto {
				fields[AppInstFieldMappedPortsProto] = struct{}{}
				fields[AppInstFieldMappedPorts] = struct{}{}
			}
			if m.MappedPorts[i0].InternalPort != o.MappedPorts[i0].InternalPort {
				fields[AppInstFieldMappedPortsInternalPort] = struct{}{}
				fields[AppInstFieldMappedPorts] = struct{}{}
			}
			if m.MappedPorts[i0].PublicPort != o.MappedPorts[i0].PublicPort {
				fields[AppInstFieldMappedPortsPublicPort] = struct{}{}
				fields[AppInstFieldMappedPorts] = struct{}{}
			}
		}
	}
	if m.MappedPath != o.MappedPath {
		fields[AppInstFieldMappedPath] = struct{}{}
	}
	if m.Config != o.Config {
		fields[AppInstFieldConfig] = struct{}{}
	}
	if m.Flavor.Name != o.Flavor.Name {
		fields[AppInstFieldFlavorName] = struct{}{}
		fields[AppInstFieldFlavor] = struct{}{}
	}
	if m.AccessLayer != o.AccessLayer {
		fields[AppInstFieldAccessLayer] = struct{}{}
	}
}

func (m *AppInst) CopyInFields(src *AppInst) {
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if _, set := fmap["2.1.1"]; set {
				if _, set := fmap["2.1.1.2"]; set {
					m.Key.AppKey.DeveloperKey.Name = src.Key.AppKey.DeveloperKey.Name
				}
			}
			if _, set := fmap["2.1.2"]; set {
				m.Key.AppKey.Name = src.Key.AppKey.Name
			}
			if _, set := fmap["2.1.3"]; set {
				m.Key.AppKey.Version = src.Key.AppKey.Version
			}
		}
		if _, set := fmap["2.2"]; set {
			if _, set := fmap["2.2.1"]; set {
				if _, set := fmap["2.2.1.1"]; set {
					m.Key.CloudletKey.OperatorKey.Name = src.Key.CloudletKey.OperatorKey.Name
				}
			}
			if _, set := fmap["2.2.2"]; set {
				m.Key.CloudletKey.Name = src.Key.CloudletKey.Name
			}
		}
		if _, set := fmap["2.3"]; set {
			m.Key.Id = src.Key.Id
		}
	}
	if _, set := fmap["3"]; set {
		if _, set := fmap["3.1"]; set {
			m.CloudletLoc.Lat = src.CloudletLoc.Lat
		}
		if _, set := fmap["3.2"]; set {
			m.CloudletLoc.Long = src.CloudletLoc.Long
		}
		if _, set := fmap["3.3"]; set {
			m.CloudletLoc.HorizontalAccuracy = src.CloudletLoc.HorizontalAccuracy
		}
		if _, set := fmap["3.4"]; set {
			m.CloudletLoc.VerticalAccuracy = src.CloudletLoc.VerticalAccuracy
		}
		if _, set := fmap["3.5"]; set {
			m.CloudletLoc.Altitude = src.CloudletLoc.Altitude
		}
		if _, set := fmap["3.6"]; set {
			m.CloudletLoc.Course = src.CloudletLoc.Course
		}
		if _, set := fmap["3.7"]; set {
			m.CloudletLoc.Speed = src.CloudletLoc.Speed
		}
		if _, set := fmap["3.8"]; set && src.CloudletLoc.Timestamp != nil {
			m.CloudletLoc.Timestamp = &google_protobuf.Timestamp{}
			if _, set := fmap["3.8.1"]; set {
				m.CloudletLoc.Timestamp.Seconds = src.CloudletLoc.Timestamp.Seconds
			}
			if _, set := fmap["3.8.2"]; set {
				m.CloudletLoc.Timestamp.Nanos = src.CloudletLoc.Timestamp.Nanos
			}
		}
	}
	if _, set := fmap["4"]; set {
		m.Uri = src.Uri
	}
	if _, set := fmap["5"]; set {
		if _, set := fmap["5.1"]; set {
			if _, set := fmap["5.1.1"]; set {
				m.ClusterInstKey.ClusterKey.Name = src.ClusterInstKey.ClusterKey.Name
			}
		}
		if _, set := fmap["5.2"]; set {
			if _, set := fmap["5.2.1"]; set {
				if _, set := fmap["5.2.1.1"]; set {
					m.ClusterInstKey.CloudletKey.OperatorKey.Name = src.ClusterInstKey.CloudletKey.OperatorKey.Name
				}
			}
			if _, set := fmap["5.2.2"]; set {
				m.ClusterInstKey.CloudletKey.Name = src.ClusterInstKey.CloudletKey.Name
			}
		}
	}
	if _, set := fmap["6"]; set {
		m.Liveness = src.Liveness
	}
	if _, set := fmap["7"]; set {
		m.ImagePath = src.ImagePath
	}
	if _, set := fmap["8"]; set {
		m.ImageType = src.ImageType
	}
	if _, set := fmap["9"]; set {
		if m.MappedPorts == nil || len(m.MappedPorts) != len(src.MappedPorts) {
			m.MappedPorts = make([]AppPort, len(src.MappedPorts))
		}
		for i0 := 0; i0 < len(src.MappedPorts); i0++ {
			if _, set := fmap["9.1"]; set {
				m.MappedPorts[i0].Proto = src.MappedPorts[i0].Proto
			}
			if _, set := fmap["9.2"]; set {
				m.MappedPorts[i0].InternalPort = src.MappedPorts[i0].InternalPort
			}
			if _, set := fmap["9.3"]; set {
				m.MappedPorts[i0].PublicPort = src.MappedPorts[i0].PublicPort
			}
		}
	}
	if _, set := fmap["10"]; set {
		m.MappedPath = src.MappedPath
	}
	if _, set := fmap["11"]; set {
		m.Config = src.Config
	}
	if _, set := fmap["12"]; set {
		if _, set := fmap["12.1"]; set {
			m.Flavor.Name = src.Flavor.Name
		}
	}
	if _, set := fmap["13"]; set {
		m.AccessLayer = src.AccessLayer
	}
}

func (s *AppInst) HasFields() bool {
	return true
}

type AppInstStore struct {
	kvstore objstore.KVStore
}

func NewAppInstStore(kvstore objstore.KVStore) AppInstStore {
	return AppInstStore{kvstore: kvstore}
}

func (s *AppInstStore) Create(m *AppInst, wait func(int64)) (*Result, error) {
	err := m.Validate(AppInstAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInst", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstStore) Update(m *AppInst, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInst", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur AppInst
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstStore) Put(m *AppInst, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInst", m.GetKey())
	var val []byte
	curBytes, _, _, err := s.kvstore.Get(key)
	if err == nil {
		var cur AppInst
		err = json.Unmarshal(curBytes, &cur)
		if err != nil {
			return nil, err
		}
		cur.CopyInFields(m)
		// never save fields
		cur.Fields = nil
		val, err = json.Marshal(cur)
	} else {
		m.Fields = nil
		val, err = json.Marshal(m)
	}
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstStore) Delete(m *AppInst, wait func(int64)) (*Result, error) {
	err := m.GetKey().Validate()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInst", m.GetKey())
	rev, err := s.kvstore.Delete(key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstStore) LoadOne(key string) (*AppInst, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj AppInst
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse AppInst data", "val", string(val))
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *AppInstStore) STMGet(stm concurrency.STM, key *AppInstKey, buf *AppInst) bool {
	keystr := objstore.DbKeyString("AppInst", key)
	valstr := stm.Get(keystr)
	if valstr == "" {
		return false
	}
	if buf != nil {
		err := json.Unmarshal([]byte(valstr), buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *AppInstStore) STMPut(stm concurrency.STM, obj *AppInst) {
	keystr := objstore.DbKeyString("AppInst", obj.GetKey())
	val, _ := json.Marshal(obj)
	stm.Put(keystr, string(val))
}

func (s *AppInstStore) STMDel(stm concurrency.STM, key *AppInstKey) {
	keystr := objstore.DbKeyString("AppInst", key)
	stm.Del(keystr)
}

type AppInstKeyWatcher struct {
	cb func()
}

// AppInstCache caches AppInst objects in memory in a hash table
// and keeps them in sync with the database.
type AppInstCache struct {
	Objs        map[AppInstKey]*AppInst
	Mux         util.Mutex
	List        map[AppInstKey]struct{}
	NotifyCb    func(obj *AppInstKey, old *AppInst)
	UpdatedCb   func(old *AppInst, new *AppInst)
	KeyWatchers map[AppInstKey][]*AppInstKeyWatcher
}

func NewAppInstCache() *AppInstCache {
	cache := AppInstCache{}
	InitAppInstCache(&cache)
	return &cache
}

func InitAppInstCache(cache *AppInstCache) {
	cache.Objs = make(map[AppInstKey]*AppInst)
	cache.KeyWatchers = make(map[AppInstKey][]*AppInstKeyWatcher)
}

func (c *AppInstCache) GetTypeString() string {
	return "AppInst"
}

func (c *AppInstCache) Get(key *AppInstKey, valbuf *AppInst) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		*valbuf = *inst
	}
	return found
}

func (c *AppInstCache) HasKey(key *AppInstKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *AppInstCache) GetAllKeys(keys map[AppInstKey]struct{}) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		keys[key] = struct{}{}
	}
}

func (c *AppInstCache) Update(in *AppInst, rev int64) {
	c.Mux.Lock()
	if c.UpdatedCb != nil || c.NotifyCb != nil {
		old := c.Objs[in.Key]
		if c.UpdatedCb != nil {
			new := &AppInst{}
			*new = *in
			defer c.UpdatedCb(old, new)
		}
		if c.NotifyCb != nil {
			defer c.NotifyCb(&in.Key, old)
		}
	}
	c.Objs[in.Key] = in
	log.DebugLog(log.DebugLevelApi, "SyncUpdate AppInst", "obj", in, "rev", rev)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(&in.Key)
}

func (c *AppInstCache) Delete(in *AppInst, rev int64) {
	c.Mux.Lock()
	old := c.Objs[in.Key]
	delete(c.Objs, in.Key)
	log.DebugLog(log.DebugLevelApi, "SyncDelete AppInst", "key", in.Key, "rev", rev)
	c.Mux.Unlock()
	if c.NotifyCb != nil {
		c.NotifyCb(&in.Key, old)
	}
	c.TriggerKeyWatchers(&in.Key)
}

func (c *AppInstCache) Prune(validKeys map[AppInstKey]struct{}) {
	notify := make(map[AppInstKey]*AppInst)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if c.NotifyCb != nil {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		if c.NotifyCb != nil {
			c.NotifyCb(&key, old)
		}
		c.TriggerKeyWatchers(&key)
	}
}

func (c *AppInstCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *AppInstCache) Show(filter *AppInst, cb func(ret *AppInst) error) error {
	log.DebugLog(log.DebugLevelApi, "Show AppInst", "count", len(c.Objs))
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, obj := range c.Objs {
		if !obj.Matches(filter, MatchFilter()) {
			continue
		}
		log.DebugLog(log.DebugLevelApi, "Show AppInst", "obj", obj)
		err := cb(obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func AppInstGenericNotifyCb(fn func(key *AppInstKey, old *AppInst)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*AppInstKey), obj.(*AppInst))
	}
}

func (c *AppInstCache) SetNotifyCb(fn func(obj *AppInstKey, old *AppInst)) {
	c.NotifyCb = fn
}

func (c *AppInstCache) SetUpdatedCb(fn func(old *AppInst, new *AppInst)) {
	c.UpdatedCb = fn
}

func (c *AppInstCache) WatchKey(key *AppInstKey, cb func()) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*AppInstKeyWatcher, 0)
	}
	watcher := AppInstKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching AppInst", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *AppInstCache) TriggerKeyWatchers(key *AppInstKey) {
	watchers := make([]*AppInstKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb()
	}
}
func (c *AppInstCache) SyncUpdate(key, val []byte, rev int64) {
	obj := AppInst{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse AppInst data", "val", string(val))
		return
	}
	c.Update(&obj, rev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.Key] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *AppInstCache) SyncDelete(key []byte, rev int64) {
	obj := AppInst{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	AppInstKeyStringParse(keystr, &obj.Key)
	c.Delete(&obj, rev)
}

func (c *AppInstCache) SyncListStart() {
	c.List = make(map[AppInstKey]struct{})
}

func (c *AppInstCache) SyncListEnd() {
	deleted := make(map[AppInstKey]*AppInst)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	if c.NotifyCb != nil {
		for key, val := range deleted {
			c.NotifyCb(&key, val)
			c.TriggerKeyWatchers(&key)
		}
	}
}

func (m *AppInst) GetKey() objstore.ObjKey {
	return &m.Key
}

func (m *AppInstInfo) Matches(o *AppInstInfo, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.NotifyId != 0 {
		if o.NotifyId != m.NotifyId {
			return false
		}
	}
	if !opts.Filter || o.State != 0 {
		if o.State != m.State {
			return false
		}
	}
	if !opts.Filter || o.Errors != nil {
		if m.Errors == nil && o.Errors != nil || m.Errors != nil && o.Errors == nil {
			return false
		} else if m.Errors != nil && o.Errors != nil {
			if len(m.Errors) != len(o.Errors) {
				return false
			}
			for i := 0; i < len(m.Errors); i++ {
				if o.Errors[i] != m.Errors[i] {
					return false
				}
			}
		}
	}
	return true
}

const AppInstInfoFieldKey = "2"
const AppInstInfoFieldKeyAppKey = "2.1"
const AppInstInfoFieldKeyAppKeyDeveloperKey = "2.1.1"
const AppInstInfoFieldKeyAppKeyDeveloperKeyName = "2.1.1.2"
const AppInstInfoFieldKeyAppKeyName = "2.1.2"
const AppInstInfoFieldKeyAppKeyVersion = "2.1.3"
const AppInstInfoFieldKeyCloudletKey = "2.2"
const AppInstInfoFieldKeyCloudletKeyOperatorKey = "2.2.1"
const AppInstInfoFieldKeyCloudletKeyOperatorKeyName = "2.2.1.1"
const AppInstInfoFieldKeyCloudletKeyName = "2.2.2"
const AppInstInfoFieldKeyId = "2.3"
const AppInstInfoFieldNotifyId = "3"
const AppInstInfoFieldState = "4"
const AppInstInfoFieldErrors = "5"

var AppInstInfoAllFields = []string{
	AppInstInfoFieldKeyAppKeyDeveloperKeyName,
	AppInstInfoFieldKeyAppKeyName,
	AppInstInfoFieldKeyAppKeyVersion,
	AppInstInfoFieldKeyCloudletKeyOperatorKeyName,
	AppInstInfoFieldKeyCloudletKeyName,
	AppInstInfoFieldKeyId,
	AppInstInfoFieldNotifyId,
	AppInstInfoFieldState,
	AppInstInfoFieldErrors,
}

var AppInstInfoAllFieldsMap = map[string]struct{}{
	AppInstInfoFieldKeyAppKeyDeveloperKeyName:     struct{}{},
	AppInstInfoFieldKeyAppKeyName:                 struct{}{},
	AppInstInfoFieldKeyAppKeyVersion:              struct{}{},
	AppInstInfoFieldKeyCloudletKeyOperatorKeyName: struct{}{},
	AppInstInfoFieldKeyCloudletKeyName:            struct{}{},
	AppInstInfoFieldKeyId:                         struct{}{},
	AppInstInfoFieldNotifyId:                      struct{}{},
	AppInstInfoFieldState:                         struct{}{},
	AppInstInfoFieldErrors:                        struct{}{},
}

func (m *AppInstInfo) DiffFields(o *AppInstInfo, fields map[string]struct{}) {
	if m.Key.AppKey.DeveloperKey.Name != o.Key.AppKey.DeveloperKey.Name {
		fields[AppInstInfoFieldKeyAppKeyDeveloperKeyName] = struct{}{}
		fields[AppInstInfoFieldKeyAppKeyDeveloperKey] = struct{}{}
		fields[AppInstInfoFieldKeyAppKey] = struct{}{}
		fields[AppInstInfoFieldKey] = struct{}{}
	}
	if m.Key.AppKey.Name != o.Key.AppKey.Name {
		fields[AppInstInfoFieldKeyAppKeyName] = struct{}{}
		fields[AppInstInfoFieldKeyAppKey] = struct{}{}
		fields[AppInstInfoFieldKey] = struct{}{}
	}
	if m.Key.AppKey.Version != o.Key.AppKey.Version {
		fields[AppInstInfoFieldKeyAppKeyVersion] = struct{}{}
		fields[AppInstInfoFieldKeyAppKey] = struct{}{}
		fields[AppInstInfoFieldKey] = struct{}{}
	}
	if m.Key.CloudletKey.OperatorKey.Name != o.Key.CloudletKey.OperatorKey.Name {
		fields[AppInstInfoFieldKeyCloudletKeyOperatorKeyName] = struct{}{}
		fields[AppInstInfoFieldKeyCloudletKeyOperatorKey] = struct{}{}
		fields[AppInstInfoFieldKeyCloudletKey] = struct{}{}
		fields[AppInstInfoFieldKey] = struct{}{}
	}
	if m.Key.CloudletKey.Name != o.Key.CloudletKey.Name {
		fields[AppInstInfoFieldKeyCloudletKeyName] = struct{}{}
		fields[AppInstInfoFieldKeyCloudletKey] = struct{}{}
		fields[AppInstInfoFieldKey] = struct{}{}
	}
	if m.Key.Id != o.Key.Id {
		fields[AppInstInfoFieldKeyId] = struct{}{}
		fields[AppInstInfoFieldKey] = struct{}{}
	}
	if m.NotifyId != o.NotifyId {
		fields[AppInstInfoFieldNotifyId] = struct{}{}
	}
	if m.State != o.State {
		fields[AppInstInfoFieldState] = struct{}{}
	}
	if len(m.Errors) != len(o.Errors) {
		fields[AppInstInfoFieldErrors] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.Errors); i0++ {
			if m.Errors[i0] != o.Errors[i0] {
				fields[AppInstInfoFieldErrors] = struct{}{}
				break
			}
		}
	}
}

func (m *AppInstInfo) CopyInFields(src *AppInstInfo) {
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if _, set := fmap["2.1.1"]; set {
				if _, set := fmap["2.1.1.2"]; set {
					m.Key.AppKey.DeveloperKey.Name = src.Key.AppKey.DeveloperKey.Name
				}
			}
			if _, set := fmap["2.1.2"]; set {
				m.Key.AppKey.Name = src.Key.AppKey.Name
			}
			if _, set := fmap["2.1.3"]; set {
				m.Key.AppKey.Version = src.Key.AppKey.Version
			}
		}
		if _, set := fmap["2.2"]; set {
			if _, set := fmap["2.2.1"]; set {
				if _, set := fmap["2.2.1.1"]; set {
					m.Key.CloudletKey.OperatorKey.Name = src.Key.CloudletKey.OperatorKey.Name
				}
			}
			if _, set := fmap["2.2.2"]; set {
				m.Key.CloudletKey.Name = src.Key.CloudletKey.Name
			}
		}
		if _, set := fmap["2.3"]; set {
			m.Key.Id = src.Key.Id
		}
	}
	if _, set := fmap["3"]; set {
		m.NotifyId = src.NotifyId
	}
	if _, set := fmap["4"]; set {
		m.State = src.State
	}
	if _, set := fmap["5"]; set {
		if m.Errors == nil || len(m.Errors) != len(src.Errors) {
			m.Errors = make([]string, len(src.Errors))
		}
		copy(m.Errors, src.Errors)
	}
}

func (s *AppInstInfo) HasFields() bool {
	return true
}

type AppInstInfoStore struct {
	kvstore objstore.KVStore
}

func NewAppInstInfoStore(kvstore objstore.KVStore) AppInstInfoStore {
	return AppInstInfoStore{kvstore: kvstore}
}

func (s *AppInstInfoStore) Create(m *AppInstInfo, wait func(int64)) (*Result, error) {
	err := m.Validate(AppInstInfoAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstInfo", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstInfoStore) Update(m *AppInstInfo, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstInfo", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur AppInstInfo
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstInfoStore) Put(m *AppInstInfo, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstInfo", m.GetKey())
	var val []byte
	curBytes, _, _, err := s.kvstore.Get(key)
	if err == nil {
		var cur AppInstInfo
		err = json.Unmarshal(curBytes, &cur)
		if err != nil {
			return nil, err
		}
		cur.CopyInFields(m)
		// never save fields
		cur.Fields = nil
		val, err = json.Marshal(cur)
	} else {
		m.Fields = nil
		val, err = json.Marshal(m)
	}
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstInfoStore) Delete(m *AppInstInfo, wait func(int64)) (*Result, error) {
	err := m.GetKey().Validate()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstInfo", m.GetKey())
	rev, err := s.kvstore.Delete(key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstInfoStore) LoadOne(key string) (*AppInstInfo, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj AppInstInfo
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse AppInstInfo data", "val", string(val))
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *AppInstInfoStore) STMGet(stm concurrency.STM, key *AppInstKey, buf *AppInstInfo) bool {
	keystr := objstore.DbKeyString("AppInstInfo", key)
	valstr := stm.Get(keystr)
	if valstr == "" {
		return false
	}
	if buf != nil {
		err := json.Unmarshal([]byte(valstr), buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *AppInstInfoStore) STMPut(stm concurrency.STM, obj *AppInstInfo) {
	keystr := objstore.DbKeyString("AppInstInfo", obj.GetKey())
	val, _ := json.Marshal(obj)
	stm.Put(keystr, string(val))
}

func (s *AppInstInfoStore) STMDel(stm concurrency.STM, key *AppInstKey) {
	keystr := objstore.DbKeyString("AppInstInfo", key)
	stm.Del(keystr)
}

type AppInstInfoKeyWatcher struct {
	cb func()
}

// AppInstInfoCache caches AppInstInfo objects in memory in a hash table
// and keeps them in sync with the database.
type AppInstInfoCache struct {
	Objs        map[AppInstKey]*AppInstInfo
	Mux         util.Mutex
	List        map[AppInstKey]struct{}
	NotifyCb    func(obj *AppInstKey, old *AppInstInfo)
	UpdatedCb   func(old *AppInstInfo, new *AppInstInfo)
	KeyWatchers map[AppInstKey][]*AppInstInfoKeyWatcher
}

func NewAppInstInfoCache() *AppInstInfoCache {
	cache := AppInstInfoCache{}
	InitAppInstInfoCache(&cache)
	return &cache
}

func InitAppInstInfoCache(cache *AppInstInfoCache) {
	cache.Objs = make(map[AppInstKey]*AppInstInfo)
	cache.KeyWatchers = make(map[AppInstKey][]*AppInstInfoKeyWatcher)
}

func (c *AppInstInfoCache) GetTypeString() string {
	return "AppInstInfo"
}

func (c *AppInstInfoCache) Get(key *AppInstKey, valbuf *AppInstInfo) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		*valbuf = *inst
	}
	return found
}

func (c *AppInstInfoCache) HasKey(key *AppInstKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *AppInstInfoCache) GetAllKeys(keys map[AppInstKey]struct{}) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		keys[key] = struct{}{}
	}
}

func (c *AppInstInfoCache) Update(in *AppInstInfo, rev int64) {
	c.Mux.Lock()
	if c.UpdatedCb != nil || c.NotifyCb != nil {
		old := c.Objs[in.Key]
		if c.UpdatedCb != nil {
			new := &AppInstInfo{}
			*new = *in
			defer c.UpdatedCb(old, new)
		}
		if c.NotifyCb != nil {
			defer c.NotifyCb(&in.Key, old)
		}
	}
	c.Objs[in.Key] = in
	log.DebugLog(log.DebugLevelApi, "SyncUpdate AppInstInfo", "obj", in, "rev", rev)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(&in.Key)
}

func (c *AppInstInfoCache) Delete(in *AppInstInfo, rev int64) {
	c.Mux.Lock()
	old := c.Objs[in.Key]
	delete(c.Objs, in.Key)
	log.DebugLog(log.DebugLevelApi, "SyncDelete AppInstInfo", "key", in.Key, "rev", rev)
	c.Mux.Unlock()
	if c.NotifyCb != nil {
		c.NotifyCb(&in.Key, old)
	}
	c.TriggerKeyWatchers(&in.Key)
}

func (c *AppInstInfoCache) Prune(validKeys map[AppInstKey]struct{}) {
	notify := make(map[AppInstKey]*AppInstInfo)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if c.NotifyCb != nil {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		if c.NotifyCb != nil {
			c.NotifyCb(&key, old)
		}
		c.TriggerKeyWatchers(&key)
	}
}

func (c *AppInstInfoCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}
func (c *AppInstInfoCache) Flush(notifyId int64) {
	flushed := make(map[AppInstKey]*AppInstInfo)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if val.NotifyId != notifyId {
			continue
		}
		flushed[key] = c.Objs[key]
		delete(c.Objs, key)
	}
	c.Mux.Unlock()
	if len(flushed) > 0 {
		for key, old := range flushed {
			if c.NotifyCb != nil {
				c.NotifyCb(&key, old)
			}
			c.TriggerKeyWatchers(&key)
		}
	}
}

func (c *AppInstInfoCache) Show(filter *AppInstInfo, cb func(ret *AppInstInfo) error) error {
	log.DebugLog(log.DebugLevelApi, "Show AppInstInfo", "count", len(c.Objs))
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, obj := range c.Objs {
		if !obj.Matches(filter, MatchFilter()) {
			continue
		}
		log.DebugLog(log.DebugLevelApi, "Show AppInstInfo", "obj", obj)
		err := cb(obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func AppInstInfoGenericNotifyCb(fn func(key *AppInstKey, old *AppInstInfo)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*AppInstKey), obj.(*AppInstInfo))
	}
}

func (c *AppInstInfoCache) SetNotifyCb(fn func(obj *AppInstKey, old *AppInstInfo)) {
	c.NotifyCb = fn
}

func (c *AppInstInfoCache) SetUpdatedCb(fn func(old *AppInstInfo, new *AppInstInfo)) {
	c.UpdatedCb = fn
}

func (c *AppInstInfoCache) WatchKey(key *AppInstKey, cb func()) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*AppInstInfoKeyWatcher, 0)
	}
	watcher := AppInstInfoKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching AppInstInfo", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *AppInstInfoCache) TriggerKeyWatchers(key *AppInstKey) {
	watchers := make([]*AppInstInfoKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb()
	}
}
func (c *AppInstInfoCache) SyncUpdate(key, val []byte, rev int64) {
	obj := AppInstInfo{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse AppInstInfo data", "val", string(val))
		return
	}
	c.Update(&obj, rev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.Key] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *AppInstInfoCache) SyncDelete(key []byte, rev int64) {
	obj := AppInstInfo{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	AppInstKeyStringParse(keystr, &obj.Key)
	c.Delete(&obj, rev)
}

func (c *AppInstInfoCache) SyncListStart() {
	c.List = make(map[AppInstKey]struct{})
}

func (c *AppInstInfoCache) SyncListEnd() {
	deleted := make(map[AppInstKey]*AppInstInfo)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	if c.NotifyCb != nil {
		for key, val := range deleted {
			c.NotifyCb(&key, val)
			c.TriggerKeyWatchers(&key)
		}
	}
}

func (c *AppInstInfoCache) WaitForState(ctx context.Context, key *AppInstKey, targetState AppState, transitionStates map[AppState]struct{}, timeout time.Duration, successMsg string, send func(*Result) error) error {
	curState := AppState_AppStateUnknown
	done := make(chan bool, 1)
	failed := make(chan bool, 1)
	var err error

	cancel := c.WatchKey(key, func() {
		info := AppInstInfo{}
		if c.Get(key, &info) {
			curState = info.State
		} else {
			curState = AppState_AppStateNotPresent
		}
		if send != nil {
			msg := AppState_name[int32(curState)]
			send(&Result{Message: msg})
		}
		log.DebugLog(log.DebugLevelApi, "Watch event for AppInstInfo", "key", key, "state", AppState_name[int32(curState)])
		if curState == AppState_AppStateErrors {
			failed <- true
		} else if curState == targetState {
			done <- true
		}
	})
	// After setting up watch, check current state,
	// as it may have already changed to target state
	info := AppInstInfo{}
	if c.Get(key, &info) {
		curState = info.State
	} else {
		curState = AppState_AppStateNotPresent
	}
	if curState == targetState {
		done <- true
	}

	select {
	case <-done:
		err = nil
		if successMsg != "" {
			send(&Result{Message: successMsg})
		}
	case <-ctx.Done():
		log.DebugLog(log.DebugLevelApi, "Watch for AppInstInfo cancelled by user", "key", key)
		err = nil // caller cancelled
	case <-failed:
		if c.Get(key, &info) {
			err = fmt.Errorf("Encountered failures: %v", info.Errors)
		} else {
			// this shouldn't happen, since only way to get here
			// is if info state is set to Error
			err = errors.New("Unknown failure")
		}
	case <-time.After(timeout):
		hasInfo := c.Get(key, &info)
		if hasInfo && info.State == AppState_AppStateErrors {
			// error may have been sent back before watch started
			err = fmt.Errorf("Encountered failures: %v", info.Errors)
		} else if _, found := transitionStates[info.State]; hasInfo && found {
			// no success response, but state is a valid transition
			// state. That means work is still in progress.
			// Notify user that this is not an error.
			// Do not undo since CRM is still busy.
			msg := fmt.Sprintf("Timed out while work still in progress state %s. Please use ShowAppInstInfoInfo to check current status", AppState_name[int32(info.State)])
			send(&Result{Message: msg})
			err = nil
		} else {
			err = fmt.Errorf("Timed out; expected state %s but is %s",
				AppState_name[int32(targetState)],
				AppState_name[int32(curState)])
		}
	}
	cancel()
	// note: do not close done/failed, garbage collector will deal with it.
	return err
}

func (m *AppInstInfo) GetKey() objstore.ObjKey {
	return &m.Key
}

func (m *AppInstMetrics) CopyInFields(src *AppInstMetrics) {
	m.Something = src.Something
}

var AppStateStrings = []string{
	"AppStateUnknown",
	"AppStateBuilding",
	"AppStateReady",
	"AppStateErrors",
	"AppStateDeleting",
	"AppStateDeleted",
	"AppStateChanging",
	"AppStateNotPresent",
}

const (
	AppStateAppStateUnknown    uint64 = 1 << 0
	AppStateAppStateBuilding   uint64 = 1 << 1
	AppStateAppStateReady      uint64 = 1 << 2
	AppStateAppStateErrors     uint64 = 1 << 3
	AppStateAppStateDeleting   uint64 = 1 << 4
	AppStateAppStateDeleted    uint64 = 1 << 5
	AppStateAppStateChanging   uint64 = 1 << 6
	AppStateAppStateNotPresent uint64 = 1 << 7
)

func (e *AppState) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := AppState_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = AppState_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = AppState(val)
	return nil
}

func (e AppState) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

func (m *AppInstKey) Size() (n int) {
	var l int
	_ = l
	l = m.AppKey.Size()
	n += 1 + l + sovAppInst(uint64(l))
	l = m.CloudletKey.Size()
	n += 1 + l + sovAppInst(uint64(l))
	if m.Id != 0 {
		n += 9
	}
	return n
}

func (m *AppPort) Size() (n int) {
	var l int
	_ = l
	if m.Proto != 0 {
		n += 1 + sovAppInst(uint64(m.Proto))
	}
	if m.InternalPort != 0 {
		n += 1 + sovAppInst(uint64(m.InternalPort))
	}
	if m.PublicPort != 0 {
		n += 1 + sovAppInst(uint64(m.PublicPort))
	}
	return n
}

func (m *AppInst) Size() (n int) {
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovAppInst(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovAppInst(uint64(l))
	l = m.CloudletLoc.Size()
	n += 1 + l + sovAppInst(uint64(l))
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovAppInst(uint64(l))
	}
	l = m.ClusterInstKey.Size()
	n += 1 + l + sovAppInst(uint64(l))
	if m.Liveness != 0 {
		n += 1 + sovAppInst(uint64(m.Liveness))
	}
	l = len(m.ImagePath)
	if l > 0 {
		n += 1 + l + sovAppInst(uint64(l))
	}
	if m.ImageType != 0 {
		n += 1 + sovAppInst(uint64(m.ImageType))
	}
	if len(m.MappedPorts) > 0 {
		for _, e := range m.MappedPorts {
			l = e.Size()
			n += 1 + l + sovAppInst(uint64(l))
		}
	}
	l = len(m.MappedPath)
	if l > 0 {
		n += 1 + l + sovAppInst(uint64(l))
	}
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovAppInst(uint64(l))
	}
	l = m.Flavor.Size()
	n += 1 + l + sovAppInst(uint64(l))
	if m.AccessLayer != 0 {
		n += 1 + sovAppInst(uint64(m.AccessLayer))
	}
	return n
}

func (m *AppInstInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovAppInst(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovAppInst(uint64(l))
	if m.NotifyId != 0 {
		n += 1 + sovAppInst(uint64(m.NotifyId))
	}
	if m.State != 0 {
		n += 1 + sovAppInst(uint64(m.State))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovAppInst(uint64(l))
		}
	}
	return n
}

func (m *AppInstMetrics) Size() (n int) {
	var l int
	_ = l
	if m.Something != 0 {
		n += 1 + sovAppInst(uint64(m.Something))
	}
	return n
}

func sovAppInst(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAppInst(x uint64) (n int) {
	return sovAppInst(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AppInstKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppInst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AppKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CloudletKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipAppInst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppInst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppInst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto", wireType)
			}
			m.Proto = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proto |= (L4Proto(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalPort", wireType)
			}
			m.InternalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InternalPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicPort", wireType)
			}
			m.PublicPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PublicPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppInst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppInst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInst) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppInst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInst: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInst: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletLoc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CloudletLoc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterInstKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterInstKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liveness", wireType)
			}
			m.Liveness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Liveness |= (Liveness(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageType", wireType)
			}
			m.ImageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImageType |= (ImageType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MappedPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MappedPorts = append(m.MappedPorts, AppPort{})
			if err := m.MappedPorts[len(m.MappedPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MappedPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MappedPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flavor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Flavor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessLayer", wireType)
			}
			m.AccessLayer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessLayer |= (AccessLayer(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppInst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppInst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppInst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyId", wireType)
			}
			m.NotifyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotifyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (AppState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppInst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppInst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppInst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppInst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Something", wireType)
			}
			m.Something = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Something |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppInst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppInst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAppInst(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAppInst
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppInst
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAppInst
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAppInst
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAppInst(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAppInst = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAppInst   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("app_inst.proto", fileDescriptorAppInst) }

var fileDescriptorAppInst = []byte{
	// 1162 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xcd, 0x6f, 0x1b, 0xc5,
	0x1b, 0xee, 0xd8, 0xb1, 0x13, 0x8f, 0x3f, 0xea, 0x4c, 0xf3, 0x8b, 0xd6, 0x56, 0x7e, 0x89, 0xb5,
	0x15, 0xc8, 0x54, 0xfe, 0xa8, 0xc2, 0x87, 0x20, 0x17, 0x64, 0x1b, 0x8a, 0xac, 0x26, 0x28, 0xb8,
	0x54, 0xe2, 0x66, 0xad, 0x77, 0xc7, 0xeb, 0x51, 0x77, 0x77, 0x46, 0xbb, 0xe3, 0x16, 0x1f, 0x90,
	0x50, 0x8f, 0x9c, 0x10, 0x5c, 0x7a, 0xa9, 0xd4, 0x23, 0xc7, 0xaa, 0x12, 0x17, 0xfe, 0x82, 0x1c,
	0x91, 0xb8, 0x23, 0x1a, 0x71, 0xe0, 0x82, 0x84, 0x14, 0x1f, 0x38, 0xa2, 0x79, 0x77, 0xd7, 0xde,
	0x25, 0x14, 0x90, 0xca, 0x25, 0x99, 0x79, 0xdf, 0xe7, 0x7d, 0xde, 0x67, 0xde, 0x8f, 0x35, 0xae,
	0x18, 0x42, 0x8c, 0x99, 0x17, 0xc8, 0x8e, 0xf0, 0xb9, 0xe4, 0xa4, 0x40, 0x2d, 0x9b, 0xc2, 0xb1,
	0xbe, 0x67, 0x73, 0x6e, 0x3b, 0xb4, 0x6b, 0x08, 0xd6, 0x35, 0x3c, 0x8f, 0x4b, 0x43, 0x32, 0xee,
	0x05, 0x21, 0xb0, 0x5e, 0xf2, 0x69, 0x30, 0x77, 0xa2, 0xb0, 0xfa, 0xdb, 0x36, 0x93, 0xb3, 0xf9,
	0xa4, 0x63, 0x72, 0xb7, 0xeb, 0xf2, 0x09, 0x73, 0x14, 0xcd, 0xa7, 0x5d, 0xf5, 0xb7, 0x6d, 0x3a,
	0x7c, 0x6e, 0x75, 0x01, 0x67, 0x53, 0x6f, 0x75, 0x88, 0x22, 0x3f, 0xf8, 0x77, 0x91, 0x66, 0xdb,
	0xa6, 0x5e, 0xdb, 0x74, 0xe3, 0x6b, 0xe2, 0x10, 0x11, 0x15, 0x0c, 0x21, 0xa2, 0x63, 0x05, 0x02,
	0x1d, 0x1a, 0xab, 0x2b, 0x4d, 0x1d, 0xe3, 0x3e, 0xf7, 0xa3, 0xdb, 0xb6, 0xe9, 0xcc, 0x03, 0x49,
	0xfd, 0xf5, 0xab, 0xeb, 0x25, 0x93, 0xbb, 0x2e, 0x8f, 0x25, 0x0d, 0xfe, 0x51, 0x92, 0xd5, 0x76,
	0x0d, 0x69, 0xce, 0xda, 0xd4, 0xb3, 0x99, 0x47, 0xbb, 0x96, 0x4b, 0xdb, 0x10, 0xda, 0x75, 0xb8,
	0x19, 0x91, 0xb4, 0x13, 0x24, 0x36, 0xb7, 0x79, 0x28, 0x77, 0x32, 0x9f, 0xc2, 0x2d, 0x44, 0xab,
	0x53, 0x08, 0xd7, 0x1f, 0x23, 0x8c, 0x7b, 0x42, 0x0c, 0xbd, 0x40, 0xde, 0xa6, 0x0b, 0x72, 0x13,
	0x6f, 0xaa, 0xc6, 0xdc, 0xa3, 0x0b, 0x0d, 0x35, 0x50, 0xb3, 0x78, 0xb8, 0xdd, 0x59, 0x35, 0xa6,
	0xd3, 0x13, 0xe2, 0x36, 0x5d, 0xf4, 0x37, 0xce, 0x7e, 0x3c, 0xb8, 0x32, 0xca, 0x1b, 0x70, 0x23,
	0xef, 0xe2, 0x52, 0xfc, 0x6a, 0x08, 0xcb, 0x40, 0xd8, 0x6e, 0x22, 0x6c, 0x10, 0xb9, 0xd7, 0xb1,
	0x45, 0x73, 0x6d, 0x22, 0x15, 0x9c, 0x61, 0x96, 0x96, 0x6d, 0xa0, 0x66, 0x7e, 0x94, 0x61, 0xd6,
	0x51, 0xe9, 0x97, 0x0b, 0x0d, 0xfd, 0x7e, 0xa1, 0xa1, 0xa7, 0x4f, 0x0e, 0x90, 0xbe, 0xc0, 0x9b,
	0x3d, 0x21, 0x4e, 0xb9, 0x2f, 0x49, 0x13, 0xe7, 0x80, 0x10, 0x94, 0x55, 0x0e, 0x49, 0x22, 0xc5,
	0xf1, 0x1b, 0xa7, 0xea, 0xff, 0x28, 0x04, 0x90, 0xeb, 0xb8, 0xcc, 0x3c, 0x49, 0x7d, 0xcf, 0x70,
	0xc6, 0x82, 0xfb, 0x12, 0x44, 0xe5, 0x46, 0xa5, 0xd8, 0x08, 0x74, 0x07, 0xb8, 0x28, 0xe6, 0x13,
	0x87, 0x99, 0x21, 0x24, 0x0b, 0x10, 0x1c, 0x9a, 0x14, 0x40, 0x7f, 0x9c, 0x87, 0xdc, 0xaa, 0x34,
	0x64, 0x17, 0xe7, 0xa7, 0x8c, 0x3a, 0x56, 0xa0, 0xa1, 0x46, 0xb6, 0x59, 0x18, 0x45, 0x37, 0xd2,
	0xc6, 0xd9, 0xf5, 0xa3, 0xff, 0x97, 0xae, 0x55, 0x54, 0xd3, 0xe8, 0xcd, 0x0a, 0x47, 0x6e, 0x25,
	0x8a, 0xe5, 0x70, 0x13, 0x92, 0x16, 0x0f, 0xff, 0xdf, 0xb1, 0x58, 0x20, 0x7d, 0x36, 0x99, 0x4b,
	0x6a, 0x8d, 0xa1, 0xc3, 0xe3, 0xb0, 0xc3, 0x9d, 0x63, 0x6e, 0xfe, 0xb9, 0x66, 0xc7, 0xdc, 0x24,
	0x07, 0x38, 0x3b, 0xf7, 0x99, 0xb6, 0xd1, 0x40, 0xcd, 0x42, 0xbf, 0xfc, 0xcd, 0x52, 0x43, 0x5f,
	0x3d, 0xab, 0xe5, 0x3c, 0x6e, 0xba, 0x62, 0xa4, 0x3c, 0xe4, 0x04, 0x57, 0xa3, 0x69, 0x83, 0x25,
	0x83, 0xce, 0xe4, 0x20, 0x59, 0x2d, 0xd5, 0x19, 0x80, 0xc4, 0x42, 0xb7, 0x14, 0x11, 0x24, 0xab,
	0x98, 0x29, 0x0f, 0x79, 0x13, 0x6f, 0x39, 0xec, 0x3e, 0xf5, 0x68, 0x10, 0x68, 0x79, 0xa8, 0xfe,
	0xb5, 0x64, 0xf5, 0x23, 0x57, 0x7f, 0x43, 0x11, 0x8c, 0x56, 0x50, 0x72, 0x1d, 0x63, 0xe6, 0x1a,
	0x36, 0x1d, 0x0b, 0x43, 0xce, 0xb4, 0x4d, 0x50, 0x1b, 0x62, 0x0a, 0x60, 0x3f, 0x35, 0xe4, 0x8c,
	0xbc, 0x13, 0x83, 0xe4, 0x42, 0x50, 0x6d, 0x0b, 0xd8, 0x77, 0x12, 0xec, 0x43, 0xe5, 0xfc, 0x78,
	0x21, 0x68, 0x2a, 0x54, 0x19, 0xd4, 0xec, 0xb9, 0x86, 0x10, 0xd4, 0x82, 0x16, 0x06, 0x5a, 0xa1,
	0x91, 0x6d, 0x16, 0x53, 0x83, 0x11, 0xcd, 0x4e, 0xe2, 0x69, 0xc5, 0x30, 0x42, 0x59, 0x03, 0xf2,
	0x0a, 0x2e, 0xc6, 0x04, 0x4a, 0x21, 0x4e, 0x28, 0xc4, 0x11, 0x4e, 0x49, 0xdc, 0xc3, 0x79, 0x93,
	0x7b, 0x53, 0x66, 0x6b, 0xc5, 0x04, 0x22, 0xb2, 0x91, 0xb7, 0x70, 0x3e, 0xdc, 0x73, 0xad, 0x04,
	0x15, 0x4e, 0x8a, 0xbf, 0x05, 0x8e, 0x74, 0x71, 0x23, 0xb4, 0x52, 0x6f, 0x98, 0x26, 0x0d, 0x82,
	0xb1, 0x63, 0x2c, 0xa8, 0xaf, 0x95, 0xe1, 0xe9, 0xc9, 0xcd, 0xe9, 0x81, 0xfb, 0x58, 0x79, 0xa3,
	0x9c, 0x45, 0x63, 0x6d, 0x3a, 0xfa, 0x4c, 0x6d, 0xca, 0x6f, 0x17, 0x1a, 0xfa, 0x7c, 0xa9, 0xa1,
	0x47, 0x4b, 0x0d, 0x3d, 0x5d, 0x6a, 0xe8, 0x8b, 0x67, 0x35, 0x3a, 0x58, 0x8f, 0x4a, 0x6b, 0x18,
	0x17, 0xba, 0xb5, 0x2a, 0x64, 0xeb, 0x64, 0x5d, 0x82, 0xf8, 0xac, 0x00, 0x03, 0x78, 0xcf, 0x89,
	0x21, 0x5a, 0x77, 0x7d, 0xd6, 0x8a, 0xbb, 0xda, 0x4a, 0x4f, 0x49, 0xeb, 0x14, 0x36, 0x64, 0x28,
	0xf4, 0xe7, 0x08, 0x17, 0xa3, 0x31, 0x1f, 0x7a, 0x53, 0xfe, 0x5f, 0xed, 0xc8, 0xab, 0xb8, 0xe0,
	0x71, 0xc9, 0xa6, 0x8b, 0x71, 0xf4, 0x59, 0xc8, 0xf6, 0x0b, 0xeb, 0xe9, 0xde, 0x0a, 0x7d, 0x43,
	0x8b, 0xbc, 0x86, 0x73, 0x81, 0x34, 0x24, 0x85, 0x2d, 0x48, 0x0f, 0x64, 0x4f, 0x88, 0x3b, 0xca,
	0x35, 0x0a, 0x11, 0x4a, 0x19, 0xf5, 0x7d, 0xee, 0x07, 0x5a, 0x2e, 0x54, 0x16, 0xde, 0x8e, 0x1a,
	0xc9, 0x02, 0x7e, 0xb9, 0xd4, 0xd0, 0x93, 0xa5, 0x86, 0xbe, 0x5b, 0x6a, 0x5b, 0x31, 0x81, 0xde,
	0xc1, 0x95, 0x48, 0xe5, 0x09, 0x95, 0x3e, 0x33, 0x03, 0xb2, 0x87, 0x0b, 0x01, 0x77, 0xa9, 0x9c,
	0x31, 0xcf, 0x86, 0x95, 0xda, 0x18, 0xad, 0x0d, 0x37, 0xbe, 0x45, 0x78, 0x15, 0x4c, 0xae, 0xe1,
	0xab, 0xf1, 0xf9, 0xae, 0x77, 0xcf, 0xe3, 0x0f, 0xbc, 0xea, 0x15, 0xb2, 0x83, 0xab, 0xb1, 0xb1,
	0x3f, 0x67, 0x8e, 0xc5, 0x3c, 0xbb, 0x8a, 0xc8, 0x36, 0x2e, 0xaf, 0x44, 0x53, 0xc3, 0x5a, 0x54,
	0x33, 0x84, 0x40, 0x6a, 0x30, 0xbd, 0x0f, 0x72, 0xab, 0xd9, 0x64, 0xf0, 0x7b, 0xd4, 0xa1, 0x52,
	0x05, 0x6f, 0x24, 0xf3, 0x80, 0x95, 0x5a, 0xd5, 0x5c, 0x12, 0x3a, 0x98, 0x19, 0xea, 0x6b, 0x62,
	0x57, 0xf3, 0x64, 0x17, 0x93, 0xd8, 0xfa, 0x21, 0x97, 0xa7, 0x3e, 0x0d, 0xa8, 0x27, 0xab, 0x9b,
	0x87, 0xbf, 0x66, 0x56, 0x3f, 0x03, 0x3d, 0xc1, 0xc8, 0x27, 0xb8, 0x3c, 0xf0, 0xa9, 0x21, 0x69,
	0xfc, 0xfd, 0x23, 0x97, 0xdb, 0x56, 0x4f, 0xfe, 0x34, 0x8c, 0xe0, 0x47, 0x59, 0xdf, 0x7f, 0xf4,
	0xac, 0x86, 0x1e, 0xfe, 0xf0, 0xf3, 0xd7, 0x99, 0x1d, 0xfd, 0x6a, 0xd7, 0x04, 0x8a, 0xae, 0x21,
	0x84, 0xfa, 0x06, 0x1d, 0xa1, 0x1b, 0x37, 0x91, 0x62, 0x0e, 0x35, 0xbe, 0x14, 0xb3, 0x05, 0x14,
	0x97, 0x98, 0xef, 0x0a, 0xeb, 0x65, 0x35, 0xcf, 0x81, 0x22, 0xcd, 0xfc, 0x11, 0x2e, 0xde, 0x99,
	0xf1, 0x07, 0x7f, 0xc7, 0xfb, 0x17, 0x36, 0x5d, 0x03, 0x52, 0xa2, 0x97, 0xbb, 0xc1, 0x8c, 0x3f,
	0x48, 0x51, 0x1e, 0x06, 0xab, 0xb9, 0x52, 0xab, 0xa3, 0x4a, 0x6e, 0xe0, 0xab, 0x89, 0x24, 0xe1,
	0x42, 0x5d, 0x26, 0x55, 0xf6, 0xfa, 0x0b, 0xec, 0xfa, 0x1e, 0x24, 0xdc, 0xd5, 0xb7, 0x53, 0x09,
	0x99, 0x37, 0xe5, 0x61, 0xd2, 0x87, 0x08, 0x6f, 0xa7, 0xa7, 0x59, 0x25, 0x76, 0x31, 0x49, 0x24,
	0x8e, 0xc7, 0xbc, 0x76, 0x39, 0x47, 0xe4, 0xaa, 0xbf, 0xd8, 0xa5, 0x1f, 0x80, 0x82, 0x9a, 0xbe,
	0x93, 0x52, 0xe0, 0x86, 0x5e, 0x10, 0xd1, 0xaf, 0x9e, 0x3d, 0xdf, 0xbf, 0x72, 0x76, 0xbe, 0x8f,
	0xbe, 0x3f, 0xdf, 0x47, 0x3f, 0x9d, 0xef, 0xa3, 0x49, 0x1e, 0xa8, 0x5e, 0xff, 0x23, 0x00, 0x00,
	0xff, 0xff, 0x86, 0xf2, 0x86, 0x3c, 0x13, 0x0a, 0x00, 0x00,
}
