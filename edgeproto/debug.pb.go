// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: debug.proto

package edgeproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/mobiledgex/edge-cloud/protogen"
import _ "github.com/gogo/protobuf/gogoproto"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import strings "strings"
import "github.com/google/go-cmp/cmp"
import "github.com/google/go-cmp/cmp/cmpopts"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// DebugRequest. Keep everything in one struct to make it easy to send commands without having to change the code.
type DebugRequest struct {
	// Service node identifier (see NodeShow)
	Node NodeKey `protobuf:"bytes,1,opt,name=node" json:"node"`
	// Comma separated list of debug level names: etcd,api,notify,dmereq,locapi,mexos,metrics,upgrade,info,sampled
	Levels string `protobuf:"bytes,2,opt,name=levels,proto3" json:"levels,omitempty"`
	// Debug command
	Cmd string `protobuf:"bytes,3,opt,name=cmd,proto3" json:"cmd,omitempty"`
	// if possible, make output pretty
	Pretty bool `protobuf:"varint,4,opt,name=pretty,proto3" json:"pretty,omitempty"`
	// Id used internally
	Id uint64 `protobuf:"varint,5,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *DebugRequest) Reset()                    { *m = DebugRequest{} }
func (m *DebugRequest) String() string            { return proto.CompactTextString(m) }
func (*DebugRequest) ProtoMessage()               {}
func (*DebugRequest) Descriptor() ([]byte, []int) { return fileDescriptorDebug, []int{0} }

type DebugReply struct {
	// Service node identifier (see NodeShow)
	Node NodeKey `protobuf:"bytes,1,opt,name=node" json:"node"`
	// Debug output, if any
	Output string `protobuf:"bytes,2,opt,name=output,proto3" json:"output,omitempty"`
	// Id used internally
	Id uint64 `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *DebugReply) Reset()                    { *m = DebugReply{} }
func (m *DebugReply) String() string            { return proto.CompactTextString(m) }
func (*DebugReply) ProtoMessage()               {}
func (*DebugReply) Descriptor() ([]byte, []int) { return fileDescriptorDebug, []int{1} }

func init() {
	proto.RegisterType((*DebugRequest)(nil), "edgeproto.DebugRequest")
	proto.RegisterType((*DebugReply)(nil), "edgeproto.DebugReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DebugApi service

type DebugApiClient interface {
	EnableDebugLevels(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (DebugApi_EnableDebugLevelsClient, error)
	DisableDebugLevels(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (DebugApi_DisableDebugLevelsClient, error)
	ShowDebugLevels(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (DebugApi_ShowDebugLevelsClient, error)
	RunDebug(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (DebugApi_RunDebugClient, error)
}

type debugApiClient struct {
	cc *grpc.ClientConn
}

func NewDebugApiClient(cc *grpc.ClientConn) DebugApiClient {
	return &debugApiClient{cc}
}

func (c *debugApiClient) EnableDebugLevels(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (DebugApi_EnableDebugLevelsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DebugApi_serviceDesc.Streams[0], c.cc, "/edgeproto.DebugApi/EnableDebugLevels", opts...)
	if err != nil {
		return nil, err
	}
	x := &debugApiEnableDebugLevelsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DebugApi_EnableDebugLevelsClient interface {
	Recv() (*DebugReply, error)
	grpc.ClientStream
}

type debugApiEnableDebugLevelsClient struct {
	grpc.ClientStream
}

func (x *debugApiEnableDebugLevelsClient) Recv() (*DebugReply, error) {
	m := new(DebugReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *debugApiClient) DisableDebugLevels(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (DebugApi_DisableDebugLevelsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DebugApi_serviceDesc.Streams[1], c.cc, "/edgeproto.DebugApi/DisableDebugLevels", opts...)
	if err != nil {
		return nil, err
	}
	x := &debugApiDisableDebugLevelsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DebugApi_DisableDebugLevelsClient interface {
	Recv() (*DebugReply, error)
	grpc.ClientStream
}

type debugApiDisableDebugLevelsClient struct {
	grpc.ClientStream
}

func (x *debugApiDisableDebugLevelsClient) Recv() (*DebugReply, error) {
	m := new(DebugReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *debugApiClient) ShowDebugLevels(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (DebugApi_ShowDebugLevelsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DebugApi_serviceDesc.Streams[2], c.cc, "/edgeproto.DebugApi/ShowDebugLevels", opts...)
	if err != nil {
		return nil, err
	}
	x := &debugApiShowDebugLevelsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DebugApi_ShowDebugLevelsClient interface {
	Recv() (*DebugReply, error)
	grpc.ClientStream
}

type debugApiShowDebugLevelsClient struct {
	grpc.ClientStream
}

func (x *debugApiShowDebugLevelsClient) Recv() (*DebugReply, error) {
	m := new(DebugReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *debugApiClient) RunDebug(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (DebugApi_RunDebugClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DebugApi_serviceDesc.Streams[3], c.cc, "/edgeproto.DebugApi/RunDebug", opts...)
	if err != nil {
		return nil, err
	}
	x := &debugApiRunDebugClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DebugApi_RunDebugClient interface {
	Recv() (*DebugReply, error)
	grpc.ClientStream
}

type debugApiRunDebugClient struct {
	grpc.ClientStream
}

func (x *debugApiRunDebugClient) Recv() (*DebugReply, error) {
	m := new(DebugReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for DebugApi service

type DebugApiServer interface {
	EnableDebugLevels(*DebugRequest, DebugApi_EnableDebugLevelsServer) error
	DisableDebugLevels(*DebugRequest, DebugApi_DisableDebugLevelsServer) error
	ShowDebugLevels(*DebugRequest, DebugApi_ShowDebugLevelsServer) error
	RunDebug(*DebugRequest, DebugApi_RunDebugServer) error
}

func RegisterDebugApiServer(s *grpc.Server, srv DebugApiServer) {
	s.RegisterService(&_DebugApi_serviceDesc, srv)
}

func _DebugApi_EnableDebugLevels_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DebugRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DebugApiServer).EnableDebugLevels(m, &debugApiEnableDebugLevelsServer{stream})
}

type DebugApi_EnableDebugLevelsServer interface {
	Send(*DebugReply) error
	grpc.ServerStream
}

type debugApiEnableDebugLevelsServer struct {
	grpc.ServerStream
}

func (x *debugApiEnableDebugLevelsServer) Send(m *DebugReply) error {
	return x.ServerStream.SendMsg(m)
}

func _DebugApi_DisableDebugLevels_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DebugRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DebugApiServer).DisableDebugLevels(m, &debugApiDisableDebugLevelsServer{stream})
}

type DebugApi_DisableDebugLevelsServer interface {
	Send(*DebugReply) error
	grpc.ServerStream
}

type debugApiDisableDebugLevelsServer struct {
	grpc.ServerStream
}

func (x *debugApiDisableDebugLevelsServer) Send(m *DebugReply) error {
	return x.ServerStream.SendMsg(m)
}

func _DebugApi_ShowDebugLevels_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DebugRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DebugApiServer).ShowDebugLevels(m, &debugApiShowDebugLevelsServer{stream})
}

type DebugApi_ShowDebugLevelsServer interface {
	Send(*DebugReply) error
	grpc.ServerStream
}

type debugApiShowDebugLevelsServer struct {
	grpc.ServerStream
}

func (x *debugApiShowDebugLevelsServer) Send(m *DebugReply) error {
	return x.ServerStream.SendMsg(m)
}

func _DebugApi_RunDebug_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DebugRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DebugApiServer).RunDebug(m, &debugApiRunDebugServer{stream})
}

type DebugApi_RunDebugServer interface {
	Send(*DebugReply) error
	grpc.ServerStream
}

type debugApiRunDebugServer struct {
	grpc.ServerStream
}

func (x *debugApiRunDebugServer) Send(m *DebugReply) error {
	return x.ServerStream.SendMsg(m)
}

var _DebugApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.DebugApi",
	HandlerType: (*DebugApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "EnableDebugLevels",
			Handler:       _DebugApi_EnableDebugLevels_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DisableDebugLevels",
			Handler:       _DebugApi_DisableDebugLevels_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowDebugLevels",
			Handler:       _DebugApi_ShowDebugLevels_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RunDebug",
			Handler:       _DebugApi_RunDebug_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "debug.proto",
}

func (m *DebugRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintDebug(dAtA, i, uint64(m.Node.Size()))
	n1, err := m.Node.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if len(m.Levels) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDebug(dAtA, i, uint64(len(m.Levels)))
		i += copy(dAtA[i:], m.Levels)
	}
	if len(m.Cmd) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDebug(dAtA, i, uint64(len(m.Cmd)))
		i += copy(dAtA[i:], m.Cmd)
	}
	if m.Pretty {
		dAtA[i] = 0x20
		i++
		if m.Pretty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Id != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDebug(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *DebugReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintDebug(dAtA, i, uint64(m.Node.Size()))
	n2, err := m.Node.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if len(m.Output) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDebug(dAtA, i, uint64(len(m.Output)))
		i += copy(dAtA[i:], m.Output)
	}
	if m.Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDebug(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func encodeVarintDebug(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DebugRequest) CopyInFields(src *DebugRequest) int {
	changed := 0
	if m.Node.Name != src.Node.Name {
		m.Node.Name = src.Node.Name
		changed++
	}
	if m.Node.CloudletKey.OperatorKey.Name != src.Node.CloudletKey.OperatorKey.Name {
		m.Node.CloudletKey.OperatorKey.Name = src.Node.CloudletKey.OperatorKey.Name
		changed++
	}
	if m.Node.CloudletKey.Name != src.Node.CloudletKey.Name {
		m.Node.CloudletKey.Name = src.Node.CloudletKey.Name
		changed++
	}
	if m.Node.Type != src.Node.Type {
		m.Node.Type = src.Node.Type
		changed++
	}
	if m.Node.Region != src.Node.Region {
		m.Node.Region = src.Node.Region
		changed++
	}
	if m.Levels != src.Levels {
		m.Levels = src.Levels
		changed++
	}
	if m.Cmd != src.Cmd {
		m.Cmd = src.Cmd
		changed++
	}
	if m.Pretty != src.Pretty {
		m.Pretty = src.Pretty
		changed++
	}
	if m.Id != src.Id {
		m.Id = src.Id
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *DebugRequest) ValidateEnums() error {
	if err := m.Node.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func IgnoreDebugRequestFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Node.Name")
	}
	return cmpopts.IgnoreFields(DebugRequest{}, names...)
}

func (m *DebugReply) CopyInFields(src *DebugReply) int {
	changed := 0
	if m.Node.Name != src.Node.Name {
		m.Node.Name = src.Node.Name
		changed++
	}
	if m.Node.CloudletKey.OperatorKey.Name != src.Node.CloudletKey.OperatorKey.Name {
		m.Node.CloudletKey.OperatorKey.Name = src.Node.CloudletKey.OperatorKey.Name
		changed++
	}
	if m.Node.CloudletKey.Name != src.Node.CloudletKey.Name {
		m.Node.CloudletKey.Name = src.Node.CloudletKey.Name
		changed++
	}
	if m.Node.Type != src.Node.Type {
		m.Node.Type = src.Node.Type
		changed++
	}
	if m.Node.Region != src.Node.Region {
		m.Node.Region = src.Node.Region
		changed++
	}
	if m.Output != src.Output {
		m.Output = src.Output
		changed++
	}
	if m.Id != src.Id {
		m.Id = src.Id
		changed++
	}
	return changed
}

// Helper method to check that enums have valid values
func (m *DebugReply) ValidateEnums() error {
	if err := m.Node.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func IgnoreDebugReplyFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Node.Name")
	}
	return cmpopts.IgnoreFields(DebugReply{}, names...)
}

func (m *DebugRequest) Size() (n int) {
	var l int
	_ = l
	l = m.Node.Size()
	n += 1 + l + sovDebug(uint64(l))
	l = len(m.Levels)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	l = len(m.Cmd)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Pretty {
		n += 2
	}
	if m.Id != 0 {
		n += 1 + sovDebug(uint64(m.Id))
	}
	return n
}

func (m *DebugReply) Size() (n int) {
	var l int
	_ = l
	l = m.Node.Size()
	n += 1 + l + sovDebug(uint64(l))
	l = len(m.Output)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovDebug(uint64(m.Id))
	}
	return n
}

func sovDebug(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDebug(x uint64) (n int) {
	return sovDebug(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DebugRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Levels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Levels = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pretty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pretty = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebugReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDebug(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDebug
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDebug
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDebug(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDebug = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDebug   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("debug.proto", fileDescriptorDebug) }

var fileDescriptorDebug = []byte{
	// 559 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x92, 0xbf, 0x6f, 0xd3, 0x40,
	0x14, 0xc7, 0x7b, 0x89, 0xa9, 0xda, 0x2b, 0x52, 0x5b, 0x13, 0xca, 0x11, 0x55, 0x21, 0xf2, 0x14,
	0x21, 0x13, 0xa3, 0xb2, 0xa0, 0x4a, 0x0c, 0x4d, 0xca, 0xd4, 0x52, 0x24, 0xb7, 0x62, 0x77, 0xe2,
	0x87, 0x73, 0x92, 0x7d, 0x67, 0xec, 0x33, 0xc1, 0x6c, 0xf4, 0x2f, 0x00, 0x31, 0x51, 0xf1, 0x07,
	0xf0, 0x67, 0x30, 0x66, 0x44, 0x62, 0x63, 0xa8, 0x20, 0x62, 0xea, 0x9c, 0x30, 0xa3, 0xfb, 0x41,
	0x14, 0xb5, 0x0c, 0x94, 0x2e, 0xd6, 0xf7, 0xbd, 0xf7, 0x3d, 0xbf, 0xcf, 0x7b, 0x77, 0x78, 0x25,
	0x84, 0x5e, 0x11, 0xb5, 0xd3, 0x8c, 0x0b, 0x6e, 0x2f, 0x43, 0x18, 0x81, 0x92, 0xf5, 0xcd, 0x88,
	0xf3, 0x28, 0x06, 0x2f, 0x48, 0xa9, 0x17, 0x30, 0xc6, 0x45, 0x20, 0x28, 0x67, 0xb9, 0x36, 0xd6,
	0x1f, 0x46, 0x54, 0x0c, 0x8a, 0x5e, 0xbb, 0xcf, 0x13, 0x2f, 0xe1, 0x3d, 0x1a, 0xcb, 0x83, 0xaf,
	0x3c, 0xf9, 0xbd, 0xd7, 0x8f, 0x79, 0x11, 0x7a, 0xca, 0x17, 0x01, 0x9b, 0x09, 0x73, 0xb2, 0x16,
	0xf1, 0x88, 0x2b, 0xe9, 0x49, 0x65, 0xb2, 0x98, 0xf1, 0x10, 0xb4, 0x76, 0x3e, 0x54, 0xf0, 0xf5,
	0x5d, 0x09, 0xe5, 0xc3, 0x8b, 0x02, 0x72, 0x61, 0xbb, 0xd8, 0x92, 0x65, 0x82, 0x9a, 0xa8, 0xb5,
	0xb2, 0x65, 0xb7, 0x67, 0x90, 0xed, 0x03, 0x1e, 0xc2, 0x1e, 0x94, 0x1d, 0x6b, 0x74, 0x7a, 0x67,
	0xc1, 0x57, 0x2e, 0x7b, 0x03, 0x2f, 0xc6, 0xf0, 0x12, 0xe2, 0x9c, 0x54, 0x9a, 0xa8, 0xb5, 0xec,
	0x9b, 0xc8, 0x5e, 0xc3, 0xd5, 0x7e, 0x12, 0x92, 0xaa, 0x4a, 0x4a, 0x29, 0x9d, 0x69, 0x06, 0x42,
	0x94, 0xc4, 0x6a, 0xa2, 0xd6, 0x92, 0x6f, 0x22, 0xbb, 0x86, 0x2b, 0x34, 0x24, 0xd7, 0x9a, 0xa8,
	0x65, 0x75, 0xac, 0x4f, 0x13, 0x82, 0xfc, 0x0a, 0x0d, 0xb7, 0x8f, 0xd1, 0xe7, 0x09, 0x41, 0x27,
	0x53, 0xf2, 0x9a, 0x05, 0x09, 0x3c, 0x92, 0xad, 0xdb, 0x07, 0x41, 0x02, 0xae, 0x28, 0x53, 0x13,
	0x1e, 0x95, 0x29, 0xb8, 0x6a, 0xfc, 0x18, 0x84, 0x4e, 0x75, 0x4d, 0xb4, 0x07, 0xa5, 0x76, 0xf3,
	0x14, 0xb2, 0x40, 0xf0, 0xec, 0x62, 0xf9, 0xa9, 0xa9, 0xcc, 0xac, 0x19, 0x44, 0x94, 0x33, 0x6d,
	0xf4, 0x95, 0x76, 0x18, 0xc6, 0x66, 0x35, 0x69, 0x5c, 0x5e, 0x7e, 0x31, 0xbc, 0x10, 0x69, 0x21,
	0xfe, 0x2c, 0x46, 0x47, 0x66, 0xdc, 0xea, 0xb9, 0x71, 0x2d, 0x39, 0xed, 0xd6, 0xa9, 0x85, 0x97,
	0x54, 0xc3, 0x9d, 0x94, 0xda, 0x27, 0x08, 0xaf, 0x3f, 0x66, 0x41, 0x2f, 0x06, 0x95, 0xda, 0xd7,
	0x7b, 0xbd, 0x35, 0xd7, 0x76, 0xfe, 0xda, 0xea, 0x37, 0x2f, 0x16, 0xd2, 0xb8, 0x74, 0x0e, 0xcf,
	0x26, 0x64, 0xd3, 0x87, 0x9c, 0x17, 0x59, 0x1f, 0xba, 0x9c, 0x3d, 0xa7, 0x91, 0xbb, 0xd3, 0x97,
	0x8f, 0xeb, 0x49, 0xc0, 0x82, 0x08, 0xdc, 0x6f, 0x53, 0x52, 0xed, 0x26, 0xe1, 0x78, 0x4a, 0x16,
	0x75, 0x8b, 0xb7, 0xbf, 0x08, 0x3a, 0xfe, 0xfa, 0xf3, 0x7d, 0x85, 0x38, 0x37, 0x3c, 0xf5, 0x5c,
	0x3d, 0x50, 0x18, 0xfa, 0x66, 0xb7, 0xd1, 0xdd, 0xfb, 0xc8, 0xfe, 0x88, 0xb0, 0xbd, 0x4b, 0xf3,
	0xab, 0xd2, 0x1d, 0xfd, 0x3f, 0xdd, 0x6d, 0xa7, 0x66, 0xe8, 0x42, 0xcd, 0x31, 0x8f, 0xf7, 0x0e,
	0xe1, 0xd5, 0xc3, 0x01, 0x1f, 0x5e, 0x85, 0x6d, 0xff, 0x6c, 0x42, 0xea, 0x7f, 0x65, 0x7b, 0x46,
	0x61, 0x28, 0xc9, 0xb0, 0xfe, 0xb3, 0xdb, 0x4d, 0xc2, 0x19, 0xd6, 0x86, 0xb3, 0x6e, 0xb0, 0xf2,
	0x01, 0x1f, 0xce, 0x33, 0xbd, 0x41, 0x78, 0xc9, 0x2f, 0x98, 0xea, 0x70, 0x69, 0x98, 0xee, 0x3f,
	0x2c, 0xea, 0xfc, 0x86, 0x56, 0x1d, 0x6c, 0x50, 0xb2, 0x82, 0x29, 0x86, 0xce, 0xda, 0xe8, 0x47,
	0x63, 0x61, 0x34, 0x6e, 0xa0, 0x2f, 0xe3, 0x06, 0xfa, 0x3e, 0x6e, 0xa0, 0xde, 0xa2, 0x6a, 0xf5,
	0xe0, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x42, 0x83, 0xaf, 0x55, 0x99, 0x04, 0x00, 0x00,
}
