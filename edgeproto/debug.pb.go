// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: debug.proto

package edgeproto

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	_ "github.com/mobiledgex/edge-cloud/protogen"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// DebugRequest. Keep everything in one struct to make it easy to send commands without having to change the code.
type DebugRequest struct {
	// Service node identifier (see NodeShow)
	Node NodeKey `protobuf:"bytes,1,opt,name=node,proto3" json:"node"`
	// Comma separated list of debug level names: etcd,api,notify,dmereq,locapi,infra,metrics,upgrade,info,sampled
	Levels string `protobuf:"bytes,2,opt,name=levels,proto3" json:"levels,omitempty"`
	// Debug command (use "help" to see available commands)
	Cmd string `protobuf:"bytes,3,opt,name=cmd,proto3" json:"cmd,omitempty"`
	// if possible, make output pretty
	Pretty bool `protobuf:"varint,4,opt,name=pretty,proto3" json:"pretty,omitempty"`
	// Id used internally
	Id uint64 `protobuf:"varint,5,opt,name=id,proto3" json:"id,omitempty"`
	// Additional arguments for cmd
	Args string `protobuf:"bytes,6,opt,name=args,proto3" json:"args,omitempty"`
	// custom timeout (duration, defaults to 10s)
	Timeout Duration `protobuf:"varint,7,opt,name=timeout,proto3,casttype=Duration" json:"timeout,omitempty"`
}

func (m *DebugRequest) Reset()         { *m = DebugRequest{} }
func (m *DebugRequest) String() string { return proto.CompactTextString(m) }
func (*DebugRequest) ProtoMessage()    {}
func (*DebugRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{0}
}
func (m *DebugRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DebugRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DebugRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugRequest.Merge(m, src)
}
func (m *DebugRequest) XXX_Size() int {
	return m.Size()
}
func (m *DebugRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DebugRequest proto.InternalMessageInfo

type DebugReply struct {
	// Service node identifier (see NodeShow)
	Node NodeKey `protobuf:"bytes,1,opt,name=node,proto3" json:"node"`
	// Debug output, if any
	Output string `protobuf:"bytes,2,opt,name=output,proto3" json:"output,omitempty"`
	// Id used internally
	Id uint64 `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *DebugReply) Reset()         { *m = DebugReply{} }
func (m *DebugReply) String() string { return proto.CompactTextString(m) }
func (*DebugReply) ProtoMessage()    {}
func (*DebugReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{1}
}
func (m *DebugReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DebugReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DebugReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugReply.Merge(m, src)
}
func (m *DebugReply) XXX_Size() int {
	return m.Size()
}
func (m *DebugReply) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugReply.DiscardUnknown(m)
}

var xxx_messageInfo_DebugReply proto.InternalMessageInfo

type DebugData struct {
	Requests []DebugRequest `protobuf:"bytes,1,rep,name=requests,proto3" json:"requests"`
}

func (m *DebugData) Reset()         { *m = DebugData{} }
func (m *DebugData) String() string { return proto.CompactTextString(m) }
func (*DebugData) ProtoMessage()    {}
func (*DebugData) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{2}
}
func (m *DebugData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DebugData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DebugData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugData.Merge(m, src)
}
func (m *DebugData) XXX_Size() int {
	return m.Size()
}
func (m *DebugData) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugData.DiscardUnknown(m)
}

var xxx_messageInfo_DebugData proto.InternalMessageInfo

func init() {
	proto.RegisterType((*DebugRequest)(nil), "edgeproto.DebugRequest")
	proto.RegisterType((*DebugReply)(nil), "edgeproto.DebugReply")
	proto.RegisterType((*DebugData)(nil), "edgeproto.DebugData")
}

func init() { proto.RegisterFile("debug.proto", fileDescriptor_8d9d361be58531fb) }

var fileDescriptor_8d9d361be58531fb = []byte{
	// 676 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x93, 0xb1, 0x6f, 0xd3, 0x4c,
	0x18, 0xc6, 0x7d, 0x89, 0xbf, 0xd4, 0xb9, 0xf6, 0x53, 0xa9, 0x29, 0xe5, 0x88, 0x2a, 0x37, 0xf2,
	0x80, 0x22, 0x64, 0x62, 0x54, 0x16, 0x88, 0xd4, 0xa1, 0x49, 0x18, 0x50, 0x69, 0x41, 0x2e, 0x2a,
	0xb3, 0x93, 0x3b, 0x5c, 0x4b, 0xb6, 0xcf, 0xd8, 0x67, 0x8a, 0x99, 0x50, 0xd7, 0x2e, 0x95, 0x58,
	0x2a, 0x24, 0x04, 0x23, 0x7f, 0x06, 0x63, 0xc7, 0x4a, 0x2c, 0x88, 0xa1, 0x82, 0x94, 0xa9, 0x13,
	0x43, 0x92, 0x81, 0x09, 0xf9, 0x7c, 0x8d, 0x82, 0x0a, 0x12, 0x55, 0x96, 0xe8, 0x79, 0xef, 0x7d,
	0xee, 0x7d, 0x7f, 0x79, 0x2e, 0x81, 0xd3, 0x98, 0x74, 0x12, 0xa7, 0x1e, 0x46, 0x94, 0x51, 0xb5,
	0x4c, 0xb0, 0x43, 0xb8, 0xac, 0x2c, 0x3a, 0x94, 0x3a, 0x1e, 0x31, 0xed, 0xd0, 0x35, 0xed, 0x20,
	0xa0, 0xcc, 0x66, 0x2e, 0x0d, 0xe2, 0xdc, 0x58, 0xb9, 0xe3, 0xb8, 0x6c, 0x3b, 0xe9, 0xd4, 0xbb,
	0xd4, 0x37, 0x7d, 0xda, 0x71, 0xbd, 0xec, 0xe2, 0x0b, 0x33, 0xfb, 0xbc, 0xd9, 0xf5, 0x68, 0x82,
	0x4d, 0xee, 0x73, 0x48, 0x30, 0x12, 0xe2, 0xe6, 0xbc, 0x43, 0x1d, 0xca, 0xa5, 0x99, 0x29, 0x71,
	0x0a, 0x03, 0x8a, 0x49, 0xae, 0xf5, 0xe3, 0x02, 0x9c, 0x69, 0x67, 0x50, 0x16, 0x79, 0x96, 0x90,
	0x98, 0xa9, 0x06, 0x94, 0xb3, 0x36, 0x02, 0x55, 0x50, 0x9b, 0x5e, 0x56, 0xeb, 0x23, 0xc8, 0xfa,
	0x06, 0xc5, 0x64, 0x8d, 0xa4, 0x4d, 0xf9, 0xf0, 0x78, 0x49, 0xb2, 0xb8, 0x4b, 0x5d, 0x80, 0x25,
	0x8f, 0x3c, 0x27, 0x5e, 0x8c, 0x0a, 0x55, 0x50, 0x2b, 0x5b, 0xa2, 0x52, 0x2f, 0xc1, 0x62, 0xd7,
	0xc7, 0xa8, 0xc8, 0x0f, 0x33, 0x99, 0x39, 0xc3, 0x88, 0x30, 0x96, 0x22, 0xb9, 0x0a, 0x6a, 0x8a,
	0x25, 0x2a, 0x75, 0x1e, 0x16, 0x5c, 0x8c, 0xfe, 0xab, 0x82, 0x9a, 0xdc, 0x94, 0x3f, 0xf4, 0x11,
	0xb0, 0x0a, 0x2e, 0x56, 0x55, 0x28, 0xdb, 0x91, 0x13, 0xa3, 0x12, 0x1f, 0xc0, 0xb5, 0x7a, 0x1d,
	0x4e, 0x31, 0xd7, 0x27, 0x34, 0x61, 0x68, 0xaa, 0x0a, 0x6a, 0xc5, 0xe6, 0xcc, 0xcf, 0xe3, 0x25,
	0xa5, 0x9d, 0x44, 0x3c, 0x2c, 0xeb, 0xac, 0xd9, 0xd8, 0x03, 0x1f, 0xfb, 0x08, 0xbc, 0x19, 0xa0,
	0x5d, 0x10, 0xd8, 0x3e, 0x59, 0xc9, 0xb8, 0xeb, 0x1b, 0xb6, 0x4f, 0x0c, 0x96, 0x86, 0xa2, 0x7c,
	0x9c, 0x86, 0xc4, 0xe0, 0xd9, 0x79, 0x84, 0xe5, 0x47, 0x2d, 0x51, 0xad, 0x91, 0x34, 0x77, 0xd3,
	0xc8, 0xb1, 0x03, 0xf7, 0x25, 0x9f, 0x7e, 0xde, 0xf2, 0x70, 0xac, 0x6b, 0x44, 0xc4, 0x19, 0x99,
	0x2c, 0xae, 0x8d, 0xae, 0x8f, 0x57, 0x5a, 0x3e, 0xd6, 0x23, 0x08, 0x45, 0xbe, 0xa1, 0x97, 0x5e,
	0x3c, 0x5d, 0x9a, 0xb0, 0x30, 0x61, 0x67, 0xe9, 0xe6, 0x95, 0xc8, 0xac, 0xf8, 0x7b, 0x66, 0x0d,
	0x25, 0xfb, 0xda, 0x3f, 0xfa, 0x48, 0xd2, 0x1f, 0xc1, 0x32, 0xdf, 0xd9, 0xb6, 0x99, 0xad, 0xde,
	0x85, 0x4a, 0x94, 0xbf, 0x6d, 0x8c, 0x40, 0xb5, 0x58, 0x9b, 0x5e, 0xbe, 0x3a, 0xb6, 0x76, 0xfc,
	0xed, 0xc5, 0xee, 0x91, 0xbd, 0xa1, 0x1c, 0x0c, 0x11, 0x78, 0x3f, 0x44, 0xd2, 0xf2, 0x40, 0x86,
	0x0a, 0xb7, 0xae, 0x86, 0xae, 0xfa, 0x16, 0xc0, 0xb9, 0x7b, 0x81, 0xdd, 0xf1, 0x08, 0x3f, 0x7a,
	0x90, 0x3f, 0xf9, 0xdf, 0xa6, 0x56, 0xae, 0x9c, 0x6f, 0x84, 0x5e, 0xaa, 0x6f, 0x9d, 0xf6, 0xd1,
	0xa2, 0x45, 0x62, 0x9a, 0x44, 0x5d, 0xd2, 0xa2, 0xc1, 0x53, 0xd7, 0x31, 0x56, 0xbb, 0x59, 0x9c,
	0xeb, 0x76, 0x60, 0x3b, 0xc4, 0xf8, 0x32, 0x40, 0xa5, 0x96, 0x8f, 0x8d, 0xfb, 0xb8, 0x37, 0x40,
	0xa5, 0x7c, 0xcb, 0xfe, 0x10, 0x81, 0xdd, 0x4f, 0xdf, 0x5f, 0x17, 0x90, 0x7e, 0xd9, 0xe4, 0x7f,
	0x26, 0x93, 0x70, 0x92, 0xfc, 0x77, 0xd7, 0x00, 0x37, 0x6e, 0x01, 0xf5, 0x1d, 0x80, 0x6a, 0xdb,
	0x8d, 0x27, 0x05, 0x7c, 0x32, 0x11, 0xe0, 0x35, 0x7d, 0x5e, 0x00, 0xe2, 0x1c, 0x65, 0x9c, 0xf0,
	0x00, 0xc0, 0xd9, 0xcd, 0x6d, 0xba, 0x33, 0x09, 0xde, 0xe6, 0x69, 0x1f, 0x55, 0xfe, 0x88, 0xb7,
	0xe5, 0x92, 0x9d, 0x0c, 0xee, 0xff, 0x7c, 0xb2, 0x91, 0x33, 0xbe, 0x1a, 0x22, 0x30, 0xa2, 0x5b,
	0xd0, 0xe7, 0x04, 0x5d, 0xbc, 0x4d, 0x77, 0xc6, 0xd1, 0xf6, 0x00, 0x54, 0xac, 0x24, 0xe0, 0x8b,
	0x2e, 0xcc, 0xb4, 0xfe, 0x0f, 0x91, 0x95, 0x05, 0x15, 0x4f, 0xad, 0xd8, 0xf2, 0xf1, 0x08, 0x6a,
	0x56, 0x87, 0x02, 0x2a, 0x4a, 0x02, 0x4e, 0xd3, 0x5c, 0x3c, 0xfc, 0xa6, 0x49, 0x87, 0x3d, 0x0d,
	0x1c, 0xf5, 0x34, 0xf0, 0xb5, 0xa7, 0x81, 0xfd, 0x13, 0x4d, 0x3a, 0x3a, 0xd1, 0xa4, 0xcf, 0x27,
	0x9a, 0xd4, 0x29, 0x71, 0x80, 0xdb, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0xf7, 0x41, 0x5c, 0x20,
	0x57, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DebugApiClient is the client API for DebugApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DebugApiClient interface {
	// Enable debug log levels
	EnableDebugLevels(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (DebugApi_EnableDebugLevelsClient, error)
	// Disable debug log levels
	DisableDebugLevels(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (DebugApi_DisableDebugLevelsClient, error)
	// Show debug log levels
	ShowDebugLevels(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (DebugApi_ShowDebugLevelsClient, error)
	// Run debug command
	RunDebug(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (DebugApi_RunDebugClient, error)
}

type debugApiClient struct {
	cc *grpc.ClientConn
}

func NewDebugApiClient(cc *grpc.ClientConn) DebugApiClient {
	return &debugApiClient{cc}
}

func (c *debugApiClient) EnableDebugLevels(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (DebugApi_EnableDebugLevelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DebugApi_serviceDesc.Streams[0], "/edgeproto.DebugApi/EnableDebugLevels", opts...)
	if err != nil {
		return nil, err
	}
	x := &debugApiEnableDebugLevelsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DebugApi_EnableDebugLevelsClient interface {
	Recv() (*DebugReply, error)
	grpc.ClientStream
}

type debugApiEnableDebugLevelsClient struct {
	grpc.ClientStream
}

func (x *debugApiEnableDebugLevelsClient) Recv() (*DebugReply, error) {
	m := new(DebugReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *debugApiClient) DisableDebugLevels(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (DebugApi_DisableDebugLevelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DebugApi_serviceDesc.Streams[1], "/edgeproto.DebugApi/DisableDebugLevels", opts...)
	if err != nil {
		return nil, err
	}
	x := &debugApiDisableDebugLevelsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DebugApi_DisableDebugLevelsClient interface {
	Recv() (*DebugReply, error)
	grpc.ClientStream
}

type debugApiDisableDebugLevelsClient struct {
	grpc.ClientStream
}

func (x *debugApiDisableDebugLevelsClient) Recv() (*DebugReply, error) {
	m := new(DebugReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *debugApiClient) ShowDebugLevels(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (DebugApi_ShowDebugLevelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DebugApi_serviceDesc.Streams[2], "/edgeproto.DebugApi/ShowDebugLevels", opts...)
	if err != nil {
		return nil, err
	}
	x := &debugApiShowDebugLevelsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DebugApi_ShowDebugLevelsClient interface {
	Recv() (*DebugReply, error)
	grpc.ClientStream
}

type debugApiShowDebugLevelsClient struct {
	grpc.ClientStream
}

func (x *debugApiShowDebugLevelsClient) Recv() (*DebugReply, error) {
	m := new(DebugReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *debugApiClient) RunDebug(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (DebugApi_RunDebugClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DebugApi_serviceDesc.Streams[3], "/edgeproto.DebugApi/RunDebug", opts...)
	if err != nil {
		return nil, err
	}
	x := &debugApiRunDebugClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DebugApi_RunDebugClient interface {
	Recv() (*DebugReply, error)
	grpc.ClientStream
}

type debugApiRunDebugClient struct {
	grpc.ClientStream
}

func (x *debugApiRunDebugClient) Recv() (*DebugReply, error) {
	m := new(DebugReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DebugApiServer is the server API for DebugApi service.
type DebugApiServer interface {
	// Enable debug log levels
	EnableDebugLevels(*DebugRequest, DebugApi_EnableDebugLevelsServer) error
	// Disable debug log levels
	DisableDebugLevels(*DebugRequest, DebugApi_DisableDebugLevelsServer) error
	// Show debug log levels
	ShowDebugLevels(*DebugRequest, DebugApi_ShowDebugLevelsServer) error
	// Run debug command
	RunDebug(*DebugRequest, DebugApi_RunDebugServer) error
}

// UnimplementedDebugApiServer can be embedded to have forward compatible implementations.
type UnimplementedDebugApiServer struct {
}

func (*UnimplementedDebugApiServer) EnableDebugLevels(req *DebugRequest, srv DebugApi_EnableDebugLevelsServer) error {
	return status.Errorf(codes.Unimplemented, "method EnableDebugLevels not implemented")
}
func (*UnimplementedDebugApiServer) DisableDebugLevels(req *DebugRequest, srv DebugApi_DisableDebugLevelsServer) error {
	return status.Errorf(codes.Unimplemented, "method DisableDebugLevels not implemented")
}
func (*UnimplementedDebugApiServer) ShowDebugLevels(req *DebugRequest, srv DebugApi_ShowDebugLevelsServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowDebugLevels not implemented")
}
func (*UnimplementedDebugApiServer) RunDebug(req *DebugRequest, srv DebugApi_RunDebugServer) error {
	return status.Errorf(codes.Unimplemented, "method RunDebug not implemented")
}

func RegisterDebugApiServer(s *grpc.Server, srv DebugApiServer) {
	s.RegisterService(&_DebugApi_serviceDesc, srv)
}

func _DebugApi_EnableDebugLevels_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DebugRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DebugApiServer).EnableDebugLevels(m, &debugApiEnableDebugLevelsServer{stream})
}

type DebugApi_EnableDebugLevelsServer interface {
	Send(*DebugReply) error
	grpc.ServerStream
}

type debugApiEnableDebugLevelsServer struct {
	grpc.ServerStream
}

func (x *debugApiEnableDebugLevelsServer) Send(m *DebugReply) error {
	return x.ServerStream.SendMsg(m)
}

func _DebugApi_DisableDebugLevels_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DebugRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DebugApiServer).DisableDebugLevels(m, &debugApiDisableDebugLevelsServer{stream})
}

type DebugApi_DisableDebugLevelsServer interface {
	Send(*DebugReply) error
	grpc.ServerStream
}

type debugApiDisableDebugLevelsServer struct {
	grpc.ServerStream
}

func (x *debugApiDisableDebugLevelsServer) Send(m *DebugReply) error {
	return x.ServerStream.SendMsg(m)
}

func _DebugApi_ShowDebugLevels_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DebugRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DebugApiServer).ShowDebugLevels(m, &debugApiShowDebugLevelsServer{stream})
}

type DebugApi_ShowDebugLevelsServer interface {
	Send(*DebugReply) error
	grpc.ServerStream
}

type debugApiShowDebugLevelsServer struct {
	grpc.ServerStream
}

func (x *debugApiShowDebugLevelsServer) Send(m *DebugReply) error {
	return x.ServerStream.SendMsg(m)
}

func _DebugApi_RunDebug_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DebugRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DebugApiServer).RunDebug(m, &debugApiRunDebugServer{stream})
}

type DebugApi_RunDebugServer interface {
	Send(*DebugReply) error
	grpc.ServerStream
}

type debugApiRunDebugServer struct {
	grpc.ServerStream
}

func (x *debugApiRunDebugServer) Send(m *DebugReply) error {
	return x.ServerStream.SendMsg(m)
}

var _DebugApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.DebugApi",
	HandlerType: (*DebugApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "EnableDebugLevels",
			Handler:       _DebugApi_EnableDebugLevels_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DisableDebugLevels",
			Handler:       _DebugApi_DisableDebugLevels_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowDebugLevels",
			Handler:       _DebugApi_ShowDebugLevels_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RunDebug",
			Handler:       _DebugApi_RunDebug_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "debug.proto",
}

func (m *DebugRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timeout != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Args) > 0 {
		i -= len(m.Args)
		copy(dAtA[i:], m.Args)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.Args)))
		i--
		dAtA[i] = 0x32
	}
	if m.Id != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x28
	}
	if m.Pretty {
		i--
		if m.Pretty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Cmd) > 0 {
		i -= len(m.Cmd)
		copy(dAtA[i:], m.Cmd)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.Cmd)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Levels) > 0 {
		i -= len(m.Levels)
		copy(dAtA[i:], m.Levels)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.Levels)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintDebug(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DebugReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Output) > 0 {
		i -= len(m.Output)
		copy(dAtA[i:], m.Output)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.Output)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintDebug(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DebugData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for iNdEx := len(m.Requests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Requests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintDebug(dAtA []byte, offset int, v uint64) int {
	offset -= sovDebug(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DebugRequest) CopyInFields(src *DebugRequest) int {
	changed := 0
	if m.Node.Name != src.Node.Name {
		m.Node.Name = src.Node.Name
		changed++
	}
	if m.Node.CloudletKey.Organization != src.Node.CloudletKey.Organization {
		m.Node.CloudletKey.Organization = src.Node.CloudletKey.Organization
		changed++
	}
	if m.Node.CloudletKey.Name != src.Node.CloudletKey.Name {
		m.Node.CloudletKey.Name = src.Node.CloudletKey.Name
		changed++
	}
	if m.Node.CloudletKey.FederatedOrganization != src.Node.CloudletKey.FederatedOrganization {
		m.Node.CloudletKey.FederatedOrganization = src.Node.CloudletKey.FederatedOrganization
		changed++
	}
	if m.Node.Type != src.Node.Type {
		m.Node.Type = src.Node.Type
		changed++
	}
	if m.Node.Region != src.Node.Region {
		m.Node.Region = src.Node.Region
		changed++
	}
	if m.Levels != src.Levels {
		m.Levels = src.Levels
		changed++
	}
	if m.Cmd != src.Cmd {
		m.Cmd = src.Cmd
		changed++
	}
	if m.Pretty != src.Pretty {
		m.Pretty = src.Pretty
		changed++
	}
	if m.Id != src.Id {
		m.Id = src.Id
		changed++
	}
	if m.Args != src.Args {
		m.Args = src.Args
		changed++
	}
	if m.Timeout != src.Timeout {
		m.Timeout = src.Timeout
		changed++
	}
	return changed
}

func (m *DebugRequest) DeepCopyIn(src *DebugRequest) {
	m.Node.DeepCopyIn(&src.Node)
	m.Levels = src.Levels
	m.Cmd = src.Cmd
	m.Pretty = src.Pretty
	m.Id = src.Id
	m.Args = src.Args
	m.Timeout = src.Timeout
}

// Helper method to check that enums have valid values
func (m *DebugRequest) ValidateEnums() error {
	if err := m.Node.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *DebugRequest) ClearTagged(tags map[string]struct{}) {
	s.Node.ClearTagged(tags)
}

func (s *DebugRequest) ClearRedisOnlyFields() {
	// Clear fields so that they are not stored in DB, as they are cached in Redis
}

func IgnoreDebugRequestFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Node.Name")
	}
	return cmpopts.IgnoreFields(DebugRequest{}, names...)
}

func (m *DebugReply) CopyInFields(src *DebugReply) int {
	changed := 0
	if m.Node.Name != src.Node.Name {
		m.Node.Name = src.Node.Name
		changed++
	}
	if m.Node.CloudletKey.Organization != src.Node.CloudletKey.Organization {
		m.Node.CloudletKey.Organization = src.Node.CloudletKey.Organization
		changed++
	}
	if m.Node.CloudletKey.Name != src.Node.CloudletKey.Name {
		m.Node.CloudletKey.Name = src.Node.CloudletKey.Name
		changed++
	}
	if m.Node.CloudletKey.FederatedOrganization != src.Node.CloudletKey.FederatedOrganization {
		m.Node.CloudletKey.FederatedOrganization = src.Node.CloudletKey.FederatedOrganization
		changed++
	}
	if m.Node.Type != src.Node.Type {
		m.Node.Type = src.Node.Type
		changed++
	}
	if m.Node.Region != src.Node.Region {
		m.Node.Region = src.Node.Region
		changed++
	}
	if m.Output != src.Output {
		m.Output = src.Output
		changed++
	}
	if m.Id != src.Id {
		m.Id = src.Id
		changed++
	}
	return changed
}

func (m *DebugReply) DeepCopyIn(src *DebugReply) {
	m.Node.DeepCopyIn(&src.Node)
	m.Output = src.Output
	m.Id = src.Id
}

// Helper method to check that enums have valid values
func (m *DebugReply) ValidateEnums() error {
	if err := m.Node.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *DebugReply) ClearTagged(tags map[string]struct{}) {
	s.Node.ClearTagged(tags)
}

func (s *DebugReply) ClearRedisOnlyFields() {
	// Clear fields so that they are not stored in DB, as they are cached in Redis
}

func IgnoreDebugReplyFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Node.Name")
	}
	return cmpopts.IgnoreFields(DebugReply{}, names...)
}

func (m *DebugData) DeepCopyIn(src *DebugData) {
	if src.Requests != nil {
		m.Requests = make([]DebugRequest, len(src.Requests), len(src.Requests))
		for ii, s := range src.Requests {
			m.Requests[ii].DeepCopyIn(&s)
		}
	} else {
		m.Requests = nil
	}
}

// Helper method to check that enums have valid values
func (m *DebugData) ValidateEnums() error {
	for _, e := range m.Requests {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *DebugData) ClearTagged(tags map[string]struct{}) {
	if s.Requests != nil {
		for ii := 0; ii < len(s.Requests); ii++ {
			s.Requests[ii].ClearTagged(tags)
		}
	}
}

func (s *DebugData) ClearRedisOnlyFields() {
	// Clear fields so that they are not stored in DB, as they are cached in Redis
}

func IgnoreDebugDataFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Requests.Node.Name")
	}
	return cmpopts.IgnoreFields(DebugData{}, names...)
}

func (m *DebugRequest) IsValidArgsForEnableDebugLevels() error {
	if m.Cmd != "" {
		return fmt.Errorf("Invalid field specified: Cmd, this field is only for internal use")
	}
	if m.Id != 0 {
		return fmt.Errorf("Invalid field specified: Id, this field is only for internal use")
	}
	return nil
}

func (m *DebugRequest) IsValidArgsForDisableDebugLevels() error {
	if m.Cmd != "" {
		return fmt.Errorf("Invalid field specified: Cmd, this field is only for internal use")
	}
	if m.Id != 0 {
		return fmt.Errorf("Invalid field specified: Id, this field is only for internal use")
	}
	return nil
}

func (m *DebugRequest) IsValidArgsForShowDebugLevels() error {
	if m.Levels != "" {
		return fmt.Errorf("Invalid field specified: Levels, this field is only for internal use")
	}
	if m.Cmd != "" {
		return fmt.Errorf("Invalid field specified: Cmd, this field is only for internal use")
	}
	if m.Id != 0 {
		return fmt.Errorf("Invalid field specified: Id, this field is only for internal use")
	}
	return nil
}

func (m *DebugRequest) IsValidArgsForRunDebug() error {
	if m.Levels != "" {
		return fmt.Errorf("Invalid field specified: Levels, this field is only for internal use")
	}
	if m.Id != 0 {
		return fmt.Errorf("Invalid field specified: Id, this field is only for internal use")
	}
	return nil
}

func (m *DebugRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Node.Size()
	n += 1 + l + sovDebug(uint64(l))
	l = len(m.Levels)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	l = len(m.Cmd)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Pretty {
		n += 2
	}
	if m.Id != 0 {
		n += 1 + sovDebug(uint64(m.Id))
	}
	l = len(m.Args)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovDebug(uint64(m.Timeout))
	}
	return n
}

func (m *DebugReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Node.Size()
	n += 1 + l + sovDebug(uint64(l))
	l = len(m.Output)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovDebug(uint64(m.Id))
	}
	return n
}

func (m *DebugData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	return n
}

func sovDebug(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDebug(x uint64) (n int) {
	return sovDebug(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DebugRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Levels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Levels = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pretty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pretty = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebugReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebugData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, DebugRequest{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDebug(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDebug
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDebug
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDebug
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDebug        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDebug          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDebug = fmt.Errorf("proto: unexpected end of group")
)
