// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: clusterinst.proto

package edgeproto

import (
	context "context"
	"encoding/json"
	"errors"
	fmt "fmt"
	"github.com/coreos/etcd/clientv3/concurrency"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	dme_proto "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto"
	"github.com/mobiledgex/edge-cloud/log"
	"github.com/mobiledgex/edge-cloud/objstore"
	_ "github.com/mobiledgex/edge-cloud/protogen"
	"github.com/mobiledgex/edge-cloud/util"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
	"time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Cluster Instance unique key
//
// ClusterInstKey uniquely identifies a Cluster Instance (ClusterInst) or Cluster Instance state (ClusterInstInfo).
type ClusterInstKey struct {
	// Name of Cluster
	ClusterKey ClusterKey `protobuf:"bytes,1,opt,name=cluster_key,json=clusterKey,proto3" json:"cluster_key"`
	// Name of Cloudlet on which the Cluster is instantiated
	CloudletKey CloudletKey `protobuf:"bytes,2,opt,name=cloudlet_key,json=cloudletKey,proto3" json:"cloudlet_key"`
	// Name of Developer organization that this cluster belongs to
	Organization string `protobuf:"bytes,3,opt,name=organization,proto3" json:"organization,omitempty"`
}

func (m *ClusterInstKey) Reset()         { *m = ClusterInstKey{} }
func (m *ClusterInstKey) String() string { return proto.CompactTextString(m) }
func (*ClusterInstKey) ProtoMessage()    {}
func (*ClusterInstKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d2ba73d39f00460, []int{0}
}
func (m *ClusterInstKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterInstKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterInstKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterInstKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterInstKey.Merge(m, src)
}
func (m *ClusterInstKey) XXX_Size() int {
	return m.Size()
}
func (m *ClusterInstKey) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterInstKey.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterInstKey proto.InternalMessageInfo

// Cluster Instance
//
// ClusterInst is an instance of a Cluster on a Cloudlet.
// It is defined by a Cluster, Cloudlet, and Developer key.
type ClusterInst struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// required: true
	// Unique key
	Key ClusterInstKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// Flavor of the k8s node
	Flavor FlavorKey `protobuf:"bytes,3,opt,name=flavor,proto3" json:"flavor"`
	// Liveness of instance (see Liveness)
	Liveness Liveness `protobuf:"varint,9,opt,name=liveness,proto3,enum=edgeproto.Liveness" json:"liveness,omitempty"`
	// Auto is set to true when automatically created by back-end (internal use only)
	Auto bool `protobuf:"varint,10,opt,name=auto,proto3" json:"auto,omitempty"`
	// State of the cluster instance
	State TrackedState `protobuf:"varint,4,opt,name=state,proto3,enum=edgeproto.TrackedState" json:"state,omitempty"`
	// Any errors trying to create, update, or delete the ClusterInst on the Cloudlet.
	Errors []string `protobuf:"bytes,5,rep,name=errors,proto3" json:"errors,omitempty"`
	// Override actions to CRM
	CrmOverride CRMOverride `protobuf:"varint,6,opt,name=crm_override,json=crmOverride,proto3,enum=edgeproto.CRMOverride" json:"crm_override,omitempty"`
	// IP access type (RootLB Type)
	IpAccess IpAccess `protobuf:"varint,7,opt,name=ip_access,json=ipAccess,proto3,enum=edgeproto.IpAccess" json:"ip_access,omitempty"`
	// Allocated IP for dedicated access
	AllocatedIp string `protobuf:"bytes,8,opt,name=allocated_ip,json=allocatedIp,proto3" json:"allocated_ip,omitempty"`
	// Cloudlet specific node flavor
	NodeFlavor string `protobuf:"bytes,11,opt,name=node_flavor,json=nodeFlavor,proto3" json:"node_flavor,omitempty"`
	// Deployment type (kubernetes or docker)
	Deployment string `protobuf:"bytes,15,opt,name=deployment,proto3" json:"deployment,omitempty"`
	// Number of k8s masters (In case of docker deployment, this field is not required)
	NumMasters uint32 `protobuf:"varint,13,opt,name=num_masters,json=numMasters,proto3" json:"num_masters,omitempty"`
	// Number of k8s nodes (In case of docker deployment, this field is not required)
	NumNodes uint32 `protobuf:"varint,14,opt,name=num_nodes,json=numNodes,proto3" json:"num_nodes,omitempty"`
	// status is used to reflect progress of creation or other events
	Status StatusInfo `protobuf:"bytes,16,opt,name=status,proto3" json:"status"`
	// Size of external volume to be attached to nodes.  This is for the root partition
	ExternalVolumeSize uint64 `protobuf:"varint,17,opt,name=external_volume_size,json=externalVolumeSize,proto3" json:"external_volume_size,omitempty"`
	// Auto scale policy name
	AutoScalePolicy string `protobuf:"bytes,18,opt,name=auto_scale_policy,json=autoScalePolicy,proto3" json:"auto_scale_policy,omitempty"`
	// Optional Resource AZ if any
	AvailabilityZone string `protobuf:"bytes,19,opt,name=availability_zone,json=availabilityZone,proto3" json:"availability_zone,omitempty"`
	// Optional resource specific image to launch
	ImageName string `protobuf:"bytes,20,opt,name=image_name,json=imageName,proto3" json:"image_name,omitempty"`
	// If ClusterInst is reservable
	Reservable bool `protobuf:"varint,21,opt,name=reservable,proto3" json:"reservable,omitempty"`
	// For reservable MobiledgeX ClusterInsts, the current developer tenant
	ReservedBy string `protobuf:"bytes,22,opt,name=reserved_by,json=reservedBy,proto3" json:"reserved_by,omitempty"`
	// Size of an optional shared volume to be mounted on the master
	SharedVolumeSize uint64 `protobuf:"varint,23,opt,name=shared_volume_size,json=sharedVolumeSize,proto3" json:"shared_volume_size,omitempty"`
	// Generic flavor for k8s master VM when worker nodes > 0
	MasterNodeFlavor string `protobuf:"bytes,25,opt,name=master_node_flavor,json=masterNodeFlavor,proto3" json:"master_node_flavor,omitempty"`
	// Prevents cleanup of resources on failure within CRM, used for diagnostic purposes
	SkipCrmCleanupOnFailure bool `protobuf:"varint,26,opt,name=skip_crm_cleanup_on_failure,json=skipCrmCleanupOnFailure,proto3" json:"skip_crm_cleanup_on_failure,omitempty"`
	// Optional Resources required by OS flavor if any
	OptRes string `protobuf:"bytes,27,opt,name=opt_res,json=optRes,proto3" json:"opt_res,omitempty"`
	// Resources used by cluster
	Resources InfraResources `protobuf:"bytes,28,opt,name=resources,proto3" json:"resources"`
	// Created at time
	CreatedAt dme_proto.Timestamp `protobuf:"bytes,29,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	// Updated at time
	UpdatedAt dme_proto.Timestamp `protobuf:"bytes,30,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	// For reservable ClusterInsts, when the last reservation ended
	ReservationEndedAt dme_proto.Timestamp `protobuf:"bytes,31,opt,name=reservation_ended_at,json=reservationEndedAt,proto3" json:"reservation_ended_at"`
	// Multi-tenant kubernetes cluster
	MultiTenant bool `protobuf:"varint,32,opt,name=multi_tenant,json=multiTenant,proto3" json:"multi_tenant,omitempty"`
}

func (m *ClusterInst) Reset()         { *m = ClusterInst{} }
func (m *ClusterInst) String() string { return proto.CompactTextString(m) }
func (*ClusterInst) ProtoMessage()    {}
func (*ClusterInst) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d2ba73d39f00460, []int{1}
}
func (m *ClusterInst) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterInst) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterInst.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterInst) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterInst.Merge(m, src)
}
func (m *ClusterInst) XXX_Size() int {
	return m.Size()
}
func (m *ClusterInst) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterInst.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterInst proto.InternalMessageInfo

// Parameters for selecting reservable ClusterInsts to delete
type IdleReservableClusterInsts struct {
	// Idle time (duration)
	IdleTime Duration `protobuf:"varint,1,opt,name=idle_time,json=idleTime,proto3,casttype=Duration" json:"idle_time,omitempty"`
}

func (m *IdleReservableClusterInsts) Reset()         { *m = IdleReservableClusterInsts{} }
func (m *IdleReservableClusterInsts) String() string { return proto.CompactTextString(m) }
func (*IdleReservableClusterInsts) ProtoMessage()    {}
func (*IdleReservableClusterInsts) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d2ba73d39f00460, []int{2}
}
func (m *IdleReservableClusterInsts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IdleReservableClusterInsts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IdleReservableClusterInsts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IdleReservableClusterInsts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdleReservableClusterInsts.Merge(m, src)
}
func (m *IdleReservableClusterInsts) XXX_Size() int {
	return m.Size()
}
func (m *IdleReservableClusterInsts) XXX_DiscardUnknown() {
	xxx_messageInfo_IdleReservableClusterInsts.DiscardUnknown(m)
}

var xxx_messageInfo_IdleReservableClusterInsts proto.InternalMessageInfo

// ClusterInstInfo provides information from the Cloudlet Resource Manager about the state of the ClusterInst on the Cloudlet. Whereas the ClusterInst defines the intent of instantiating a Cluster on a Cloudlet, the ClusterInstInfo defines the current state of trying to apply that intent on the physical resources of the Cloudlet.
type ClusterInstInfo struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique identifier key
	Key ClusterInstKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// Id of client assigned by server (internal use only)
	NotifyId int64 `protobuf:"varint,3,opt,name=notify_id,json=notifyId,proto3" json:"notify_id,omitempty"`
	// State of the cluster instance
	State TrackedState `protobuf:"varint,4,opt,name=state,proto3,enum=edgeproto.TrackedState" json:"state,omitempty"`
	// Any errors trying to create, update, or delete the ClusterInst on the Cloudlet.
	Errors []string `protobuf:"bytes,5,rep,name=errors,proto3" json:"errors,omitempty"`
	// status is used to reflect progress of creation or other events
	Status StatusInfo `protobuf:"bytes,6,opt,name=status,proto3" json:"status"`
	// Resources allocated to this cluster
	Resources InfraResources `protobuf:"bytes,7,opt,name=resources,proto3" json:"resources"`
}

func (m *ClusterInstInfo) Reset()         { *m = ClusterInstInfo{} }
func (m *ClusterInstInfo) String() string { return proto.CompactTextString(m) }
func (*ClusterInstInfo) ProtoMessage()    {}
func (*ClusterInstInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d2ba73d39f00460, []int{3}
}
func (m *ClusterInstInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterInstInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterInstInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterInstInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterInstInfo.Merge(m, src)
}
func (m *ClusterInstInfo) XXX_Size() int {
	return m.Size()
}
func (m *ClusterInstInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterInstInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterInstInfo proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ClusterInstKey)(nil), "edgeproto.ClusterInstKey")
	proto.RegisterType((*ClusterInst)(nil), "edgeproto.ClusterInst")
	proto.RegisterType((*IdleReservableClusterInsts)(nil), "edgeproto.IdleReservableClusterInsts")
	proto.RegisterType((*ClusterInstInfo)(nil), "edgeproto.ClusterInstInfo")
}

func init() { proto.RegisterFile("clusterinst.proto", fileDescriptor_2d2ba73d39f00460) }

var fileDescriptor_2d2ba73d39f00460 = []byte{
	// 1651 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcd, 0x6f, 0x1c, 0x49,
	0x15, 0x77, 0xc5, 0xce, 0x78, 0xa6, 0x66, 0xfc, 0x31, 0xe5, 0x8f, 0x54, 0x26, 0x61, 0x3c, 0x0c,
	0x64, 0x31, 0xa1, 0x3d, 0x13, 0x8c, 0x58, 0x90, 0xd9, 0xd5, 0x32, 0x63, 0x67, 0xd1, 0x10, 0x1c,
	0xa3, 0xb6, 0x77, 0x05, 0x68, 0xa5, 0x56, 0xbb, 0xbb, 0x3c, 0x2e, 0xa5, 0xbb, 0xaa, 0xe9, 0x0f,
	0x67, 0xc7, 0x27, 0xc4, 0x65, 0xaf, 0x2b, 0xf6, 0x02, 0x2b, 0x40, 0x39, 0xe6, 0x18, 0x72, 0x42,
	0xf9, 0x0b, 0x7c, 0x0c, 0x82, 0x43, 0x94, 0x43, 0x14, 0x12, 0x0e, 0x90, 0x13, 0x52, 0xc6, 0x51,
	0x04, 0x17, 0x54, 0xd5, 0x1f, 0xd3, 0xf3, 0x11, 0x27, 0x72, 0xb8, 0x8c, 0xba, 0xde, 0xfb, 0xbd,
	0x57, 0xef, 0xbd, 0x7a, 0x5f, 0x03, 0x8b, 0x86, 0x15, 0x78, 0x3e, 0x71, 0x29, 0xf3, 0xfc, 0x9a,
	0xe3, 0x72, 0x9f, 0xa3, 0x1c, 0x31, 0xdb, 0x44, 0x7e, 0x96, 0x2e, 0xb6, 0x39, 0x6f, 0x5b, 0xa4,
	0xae, 0x3b, 0xb4, 0xae, 0x33, 0xc6, 0x7d, 0xdd, 0xa7, 0x9c, 0x79, 0x21, 0xb0, 0xf4, 0xfd, 0x36,
	0xf5, 0xf7, 0x83, 0xdd, 0x9a, 0xc1, 0xed, 0xba, 0xcd, 0x77, 0xa9, 0x25, 0x04, 0x3f, 0xad, 0x8b,
	0xdf, 0x15, 0xc3, 0xe2, 0x81, 0x59, 0x97, 0xb8, 0x36, 0x61, 0xc9, 0x47, 0x24, 0x59, 0x70, 0x89,
	0x17, 0x58, 0x7e, 0x7c, 0xda, 0xb3, 0xf4, 0x03, 0xee, 0x46, 0xa7, 0xa9, 0xc8, 0xa2, 0xe8, 0x38,
	0x2d, 0x35, 0x59, 0x24, 0x01, 0x1b, 0xdc, 0xb6, 0x79, 0xac, 0x68, 0x9e, 0xb2, 0x3d, 0x57, 0x77,
	0x89, 0xc7, 0x03, 0xd7, 0x20, 0xb1, 0x61, 0xf3, 0x6d, 0xde, 0xe6, 0xf2, 0xb3, 0x2e, 0xbe, 0x22,
	0xea, 0xfa, 0x6b, 0xcd, 0x35, 0x57, 0x6c, 0xdd, 0x37, 0xf6, 0x57, 0x08, 0x6b, 0x53, 0x46, 0xea,
	0xa6, 0x4d, 0x56, 0x42, 0x2d, 0x16, 0x37, 0x42, 0x25, 0xd5, 0xbf, 0x00, 0x38, 0xbd, 0x1e, 0x1a,
	0xd8, 0x62, 0x9e, 0x7f, 0x8d, 0x74, 0xd0, 0x7b, 0x30, 0x1f, 0x99, 0xac, 0xdd, 0x20, 0x1d, 0x0c,
	0x2a, 0x60, 0x39, 0xbf, 0xba, 0x50, 0x4b, 0xa2, 0x58, 0x8b, 0xf0, 0xd7, 0x48, 0xa7, 0x39, 0x71,
	0xf4, 0x68, 0x69, 0x4c, 0x85, 0x46, 0x42, 0x41, 0x1f, 0xc0, 0x42, 0xec, 0xa1, 0x14, 0x3f, 0x23,
	0xc5, 0x17, 0xfb, 0xc4, 0x43, 0x76, 0x4f, 0x3e, 0x6f, 0xf4, 0x48, 0x68, 0x15, 0x16, 0xb8, 0xdb,
	0xd6, 0x19, 0x3d, 0x94, 0x8f, 0x83, 0xc7, 0x2b, 0x60, 0x39, 0xd7, 0x9c, 0xbe, 0xf7, 0x02, 0xc7,
	0xd7, 0x70, 0xb7, 0xad, 0xf6, 0x61, 0xd6, 0x0a, 0xff, 0x7c, 0x8e, 0xc1, 0xcb, 0xe7, 0x18, 0xdc,
	0xb9, 0xb5, 0x04, 0xaa, 0x7f, 0x9b, 0x81, 0xf9, 0x94, 0x4f, 0x68, 0x11, 0x66, 0xf6, 0x28, 0xb1,
	0x4c, 0x0f, 0x83, 0xca, 0xf8, 0x72, 0x4e, 0x8d, 0x4e, 0xe8, 0xdb, 0x70, 0xbc, 0x67, 0xe1, 0xf9,
	0x61, 0x07, 0xa3, 0x80, 0x44, 0x46, 0x0a, 0x2c, 0x7a, 0x17, 0x66, 0xc2, 0xc7, 0x95, 0x66, 0xe5,
	0x57, 0xe7, 0x53, 0x52, 0x1f, 0x4a, 0x86, 0x10, 0xc8, 0xde, 0xee, 0x62, 0x20, 0x85, 0x22, 0x34,
	0xfa, 0x2e, 0xcc, 0x5a, 0xf4, 0x80, 0x30, 0xe2, 0x79, 0x38, 0x57, 0x01, 0xcb, 0xd3, 0xab, 0x73,
	0x29, 0xc9, 0x9f, 0x44, 0xac, 0xe6, 0x84, 0x10, 0x54, 0x13, 0x28, 0xc2, 0x70, 0x42, 0x0f, 0x7c,
	0x8e, 0x61, 0x05, 0x2c, 0x67, 0x23, 0xae, 0xa4, 0xa0, 0xf7, 0xe0, 0x59, 0xcf, 0xd7, 0x7d, 0x82,
	0x27, 0xa4, 0xb6, 0x73, 0x29, 0x6d, 0x3b, 0xae, 0x6e, 0xdc, 0x20, 0xe6, 0xb6, 0x60, 0x37, 0xa7,
	0x84, 0xcc, 0x6f, 0xee, 0x9e, 0x3f, 0xcb, 0xb8, 0x61, 0x3b, 0x6a, 0x28, 0x84, 0x2e, 0xc1, 0x0c,
	0x71, 0x5d, 0xee, 0x7a, 0xf8, 0xac, 0x88, 0xc8, 0x20, 0x2a, 0x62, 0xa2, 0x0d, 0x58, 0x30, 0x5c,
	0x5b, 0xe3, 0x07, 0xc4, 0x75, 0xa9, 0x49, 0x70, 0x46, 0xde, 0xd5, 0xf7, 0x96, 0xea, 0xe6, 0x56,
	0xc4, 0x6d, 0xe6, 0x7a, 0x0a, 0xf2, 0x86, 0x6b, 0xc7, 0x74, 0xf4, 0x2e, 0xcc, 0x51, 0x47, 0xd3,
	0x0d, 0x43, 0x38, 0x3f, 0x39, 0xe4, 0x7c, 0xcb, 0x69, 0x48, 0x56, 0xec, 0x3c, 0x8d, 0xce, 0xe8,
	0x0a, 0x2c, 0xe8, 0x96, 0xc5, 0x0d, 0xdd, 0x27, 0xa6, 0x46, 0x1d, 0x9c, 0x95, 0x89, 0x30, 0x60,
	0x6a, 0x3e, 0x81, 0xb4, 0x1c, 0x54, 0x83, 0x79, 0xc6, 0x4d, 0xa2, 0x45, 0x4f, 0x94, 0x1f, 0x25,
	0x00, 0x05, 0x22, 0x7c, 0x2a, 0xf4, 0x75, 0x08, 0x4d, 0xe2, 0x58, 0xbc, 0x63, 0x13, 0xe6, 0xe3,
	0x19, 0x09, 0x0f, 0xad, 0x48, 0xd1, 0xd1, 0x12, 0xcc, 0xb3, 0xc0, 0xd6, 0x6c, 0x5d, 0xe4, 0x84,
	0x87, 0xa7, 0x2a, 0x60, 0x79, 0x4a, 0x85, 0x2c, 0xb0, 0x37, 0x43, 0x0a, 0xba, 0x00, 0x73, 0x02,
	0x20, 0x14, 0x7b, 0x78, 0x5a, 0xb2, 0xb3, 0x2c, 0xb0, 0xaf, 0x8b, 0x33, 0xfa, 0x21, 0xcc, 0x88,
	0x98, 0x07, 0x1e, 0x9e, 0x1d, 0x2a, 0xa4, 0x6d, 0xc9, 0x68, 0xb1, 0x3d, 0xde, 0x2c, 0xf6, 0x59,
	0x19, 0xe6, 0x4e, 0x28, 0x87, 0x3e, 0x80, 0xf3, 0xe4, 0x53, 0x9f, 0xb8, 0x4c, 0xb7, 0xb4, 0x03,
	0x6e, 0x05, 0x36, 0xd1, 0x3c, 0x7a, 0x48, 0x70, 0xb1, 0x02, 0x96, 0x27, 0x06, 0xdd, 0x43, 0x31,
	0xf4, 0x63, 0x89, 0xdc, 0xa6, 0x87, 0x04, 0x5d, 0x86, 0x45, 0x91, 0x33, 0x9a, 0x67, 0xe8, 0x16,
	0xd1, 0x1c, 0x6e, 0x51, 0xa3, 0x83, 0x91, 0xf0, 0x56, 0x9d, 0x11, 0x8c, 0x6d, 0x41, 0xff, 0xa9,
	0x24, 0xa3, 0x6f, 0xc1, 0xa2, 0x7e, 0xa0, 0x53, 0x4b, 0xdf, 0xa5, 0x16, 0xf5, 0x3b, 0xda, 0x21,
	0x67, 0x04, 0xcf, 0x49, 0xec, 0x6c, 0x9a, 0xf1, 0x0b, 0xce, 0x08, 0x52, 0x20, 0xa4, 0xb6, 0xde,
	0x26, 0x1a, 0xd3, 0x6d, 0x82, 0xe7, 0x47, 0x85, 0x3b, 0x27, 0x01, 0xd7, 0x75, 0x9b, 0xa0, 0x32,
	0x84, 0x2e, 0xf1, 0x88, 0x7b, 0xa0, 0xef, 0x5a, 0x04, 0x2f, 0x88, 0x94, 0x56, 0x53, 0x14, 0x74,
	0x09, 0xe6, 0xc3, 0x13, 0x31, 0xb5, 0xdd, 0x0e, 0x5e, 0x4c, 0x3f, 0x47, 0xcc, 0x68, 0x76, 0x90,
	0x02, 0x91, 0xb7, 0xaf, 0xbb, 0xc4, 0xec, 0x0b, 0xc6, 0x39, 0x11, 0x0c, 0x75, 0x36, 0xe4, 0xa4,
	0x7c, 0xff, 0x01, 0x44, 0xe1, 0xc3, 0x69, 0xe9, 0xcc, 0x38, 0x3f, 0xca, 0xd4, 0xd9, 0x10, 0x78,
	0xbd, 0x97, 0x1f, 0x3f, 0x82, 0x17, 0xbc, 0x1b, 0xd4, 0xd1, 0x44, 0x11, 0x18, 0x16, 0xd1, 0x59,
	0xe0, 0x68, 0x9c, 0x69, 0x7b, 0x3a, 0xb5, 0x02, 0x97, 0xe0, 0x92, 0xac, 0xca, 0x54, 0xda, 0x9f,
	0x13, 0xe8, 0x75, 0xd7, 0x5e, 0x0f, 0xb1, 0x5b, 0xec, 0xc3, 0x10, 0x89, 0xde, 0x81, 0x93, 0xdc,
	0xf1, 0x35, 0x97, 0x78, 0xf8, 0xc2, 0xa8, 0xab, 0x33, 0xdc, 0xf1, 0x55, 0xe2, 0xa1, 0x1f, 0xc3,
	0x5c, 0xd2, 0xfb, 0xf1, 0xc5, 0xa1, 0xbe, 0xd4, 0x12, 0xc3, 0x41, 0x8d, 0x01, 0xa3, 0x72, 0xa6,
	0x27, 0x8e, 0x7e, 0x0e, 0xa1, 0xe1, 0x12, 0x59, 0x3c, 0xba, 0x8f, 0xbf, 0x22, 0x95, 0x7d, 0xad,
	0x66, 0x52, 0xcf, 0x77, 0xe9, 0x6e, 0x20, 0xc8, 0x72, 0x38, 0x68, 0xe1, 0x70, 0xa8, 0xed, 0x50,
	0x9b, 0x78, 0xbe, 0x6e, 0x3b, 0xcd, 0x85, 0x48, 0x6d, 0xce, 0x8f, 0x49, 0xa1, 0xea, 0x48, 0x5b,
	0xc3, 0x17, 0xaa, 0x03, 0xc7, 0x8c, 0x55, 0x97, 0xdf, 0x5e, 0x75, 0xa4, 0xad, 0xe1, 0x23, 0x0b,
	0xce, 0x47, 0x29, 0x21, 0x1a, 0xbb, 0x46, 0x98, 0x19, 0x5e, 0xb2, 0xf4, 0xd6, 0x97, 0xa0, 0x94,
	0xde, 0xab, 0x42, 0x6d, 0xc3, 0x47, 0x5f, 0x85, 0x05, 0x3b, 0xb0, 0x7c, 0xaa, 0xf9, 0x84, 0xe9,
	0xcc, 0xc7, 0x15, 0x99, 0x94, 0x79, 0x49, 0xdb, 0x91, 0xa4, 0xb5, 0xcf, 0xc6, 0xc5, 0x6c, 0xf9,
	0xf7, 0x73, 0x0c, 0x7e, 0xd5, 0xc5, 0xe0, 0xf3, 0x2e, 0x06, 0xbf, 0xed, 0x62, 0x70, 0xa7, 0x8b,
	0xc1, 0xbd, 0x2e, 0x2e, 0xa4, 0x7b, 0xed, 0x51, 0x17, 0x83, 0x07, 0xe2, 0xea, 0x63, 0xfc, 0x07,
	0x10, 0xb7, 0x74, 0xa5, 0x11, 0xf8, 0x5c, 0xd9, 0x1c, 0xc8, 0x2c, 0x25, 0xf5, 0x79, 0x75, 0xa8,
	0x60, 0x95, 0x46, 0xaf, 0xa7, 0x29, 0x61, 0x8f, 0x50, 0xd4, 0xa4, 0x00, 0x24, 0x85, 0x28, 0x57,
	0x65, 0x8b, 0x56, 0x92, 0x6c, 0x50, 0x1a, 0x03, 0xd5, 0xa9, 0xac, 0xc7, 0xef, 0xa5, 0x7c, 0x14,
	0x87, 0x57, 0xd9, 0x92, 0x79, 0xf6, 0xe5, 0x31, 0xfe, 0x02, 0x44, 0xc3, 0xf4, 0xfd, 0x6b, 0xa4,
	0x93, 0x9a, 0xe8, 0x35, 0x51, 0xaa, 0x4a, 0x3c, 0x8f, 0x23, 0x66, 0x32, 0x9c, 0xfb, 0xb9, 0x2b,
	0xdc, 0x6d, 0x0f, 0x21, 0xb6, 0x52, 0x73, 0x59, 0x89, 0xee, 0x48, 0x80, 0x7d, 0xcc, 0xb0, 0x16,
	0xdf, 0x0f, 0xc3, 0x20, 0x35, 0x3f, 0x3c, 0xc6, 0x33, 0x03, 0xfa, 0xee, 0xbe, 0xc0, 0x19, 0x23,
	0xf0, 0x7c, 0x6e, 0x57, 0x3f, 0x82, 0xa5, 0x96, 0x69, 0x11, 0x35, 0xe9, 0x18, 0xa9, 0x31, 0xed,
	0xa1, 0x6f, 0xc2, 0x1c, 0x35, 0x2d, 0xa2, 0x89, 0x47, 0x97, 0x3b, 0xcb, 0x78, 0xb3, 0xf0, 0x9f,
	0x47, 0x4b, 0xd9, 0x8d, 0xc0, 0x95, 0xd7, 0xa9, 0x59, 0xc1, 0x16, 0x59, 0xb2, 0x56, 0x78, 0x79,
	0x8c, 0xc1, 0xdd, 0x17, 0x78, 0x82, 0x71, 0x46, 0xaa, 0xff, 0x3a, 0x03, 0x67, 0x52, 0x9a, 0x44,
	0x37, 0xfe, 0x7f, 0x6e, 0x0c, 0xef, 0xc0, 0x1c, 0xe3, 0x3e, 0xdd, 0xeb, 0x68, 0xd4, 0x94, 0x4b,
	0xc3, 0x78, 0xba, 0x63, 0x64, 0x43, 0x5e, 0xcb, 0x44, 0x2b, 0x6f, 0x36, 0xd0, 0xe3, 0x09, 0xbe,
	0xd8, 0x3f, 0xc1, 0x93, 0x91, 0xfd, 0xbd, 0x64, 0xdc, 0x64, 0x4e, 0x1a, 0x37, 0xa9, 0x0d, 0x25,
	0x9a, 0x32, 0x8d, 0x74, 0xeb, 0x99, 0x7c, 0x5d, 0xeb, 0xe9, 0xc9, 0xf7, 0xa4, 0xd6, 0x2a, 0x83,
	0x95, 0x72, 0xab, 0x8b, 0xc1, 0xe3, 0x6e, 0x2f, 0xd6, 0xab, 0xbf, 0x9f, 0xec, 0xdb, 0x36, 0x1b,
	0x0e, 0x45, 0x7f, 0x04, 0xb0, 0x18, 0x66, 0x6a, 0xdf, 0xca, 0x36, 0x3a, 0xb6, 0xa5, 0x62, 0x8a,
	0xae, 0xca, 0x9d, 0xbb, 0xfa, 0xc9, 0xb3, 0x2e, 0x5e, 0x8d, 0x2d, 0x4b, 0xa7, 0x84, 0xd2, 0x30,
	0xc4, 0xc3, 0x6f, 0xea, 0x4c, 0x6f, 0x13, 0x65, 0x30, 0xfd, 0x6e, 0x1f, 0x63, 0x70, 0xff, 0x18,
	0x83, 0x5f, 0xff, 0xf5, 0x1f, 0x5f, 0x9c, 0xc1, 0xd5, 0xb9, 0x7a, 0xd8, 0xde, 0xea, 0xa9, 0xff,
	0x0f, 0x6b, 0xe0, 0xf2, 0x15, 0x80, 0xbe, 0x04, 0xb0, 0xb8, 0x41, 0x2c, 0x72, 0x6a, 0x03, 0x7f,
	0x76, 0x7a, 0x03, 0x13, 0xe3, 0x4c, 0x69, 0xc0, 0xb0, 0x71, 0xff, 0x05, 0xb0, 0x18, 0x56, 0xf7,
	0x29, 0x8d, 0xfb, 0x33, 0x38, 0xbd, 0x75, 0x0f, 0x8f, 0xf1, 0x27, 0x71, 0x3f, 0x4b, 0xb6, 0xa1,
	0xe1, 0x3e, 0xd4, 0x2b, 0x58, 0x65, 0x7b, 0x60, 0x3c, 0x2b, 0xf1, 0xf2, 0xa7, 0x6c, 0x24, 0xfb,
	0x96, 0xd2, 0x8a, 0x37, 0x86, 0xc4, 0xfb, 0x70, 0x3c, 0x0c, 0x7b, 0xff, 0x3b, 0x00, 0x67, 0xb6,
	0xf7, 0xf9, 0xcd, 0x37, 0xf1, 0xfd, 0x15, 0xf4, 0xea, 0xce, 0xb3, 0x2e, 0xbe, 0x72, 0x82, 0xff,
	0x1f, 0x53, 0x72, 0x73, 0xc8, 0xfb, 0x24, 0x71, 0x16, 0xab, 0xc5, 0xba, 0xb7, 0xcf, 0x6f, 0x0e,
	0xdb, 0xf6, 0x27, 0x00, 0x2b, 0x61, 0xda, 0x9c, 0xd0, 0xb4, 0x2e, 0xa5, 0x2b, 0xec, 0x95, 0xb0,
	0x51, 0xef, 0xb6, 0xfd, 0xac, 0x8b, 0xab, 0xaf, 0x7f, 0x36, 0x69, 0xe4, 0x37, 0xaa, 0xd5, 0x38,
	0x81, 0x44, 0x0f, 0xec, 0xad, 0x5c, 0x29, 0xa3, 0xbd, 0x35, 0x70, 0x79, 0xf5, 0x33, 0x00, 0xd1,
	0x40, 0x2b, 0x14, 0x25, 0xfa, 0x4b, 0x38, 0x37, 0x10, 0x65, 0xd9, 0x24, 0x4b, 0xa3, 0x23, 0x2a,
	0x78, 0xa5, 0x13, 0x78, 0xd5, 0x8a, 0x34, 0xaa, 0x54, 0x5d, 0x18, 0x8a, 0x1c, 0x65, 0x7b, 0x5c,
	0x46, 0xaf, 0x79, 0xf1, 0xe8, 0xef, 0xe5, 0xb1, 0xa3, 0x27, 0x65, 0x70, 0xff, 0x49, 0x19, 0x3c,
	0x7e, 0x52, 0x06, 0x9f, 0x3f, 0x2d, 0x8f, 0xdd, 0x7f, 0x5a, 0x1e, 0x7b, 0xf0, 0xb4, 0x3c, 0xb6,
	0x9b, 0x91, 0x8a, 0xbf, 0xf3, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xab, 0x90, 0xfc, 0x87, 0xed,
	0x0f, 0x00, 0x00,
}

func (this *ClusterInstKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&edgeproto.ClusterInstKey{")
	s = append(s, "ClusterKey: "+strings.Replace(this.ClusterKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "CloudletKey: "+strings.Replace(this.CloudletKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Organization: "+fmt.Sprintf("%#v", this.Organization)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringClusterinst(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ClusterInstApiClient is the client API for ClusterInstApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ClusterInstApiClient interface {
	// Create Cluster Instance. Creates an instance of a Cluster on a Cloudlet,
	// defined by a Cluster Key and a Cloudlet Key. ClusterInst is a collection of
	// compute resources on a Cloudlet on which AppInsts are deployed.
	CreateClusterInst(ctx context.Context, in *ClusterInst, opts ...grpc.CallOption) (ClusterInstApi_CreateClusterInstClient, error)
	// Delete Cluster Instance. Deletes an instance of a Cluster deployed on a Cloudlet.
	DeleteClusterInst(ctx context.Context, in *ClusterInst, opts ...grpc.CallOption) (ClusterInstApi_DeleteClusterInstClient, error)
	// Update Cluster Instance. Updates an instance of a Cluster deployed on a Cloudlet.
	UpdateClusterInst(ctx context.Context, in *ClusterInst, opts ...grpc.CallOption) (ClusterInstApi_UpdateClusterInstClient, error)
	// Show Cluster Instances. Lists all the cluster instances managed by Edge Controller.
	ShowClusterInst(ctx context.Context, in *ClusterInst, opts ...grpc.CallOption) (ClusterInstApi_ShowClusterInstClient, error)
	// Cleanup Reservable Cluster Instances. Deletes reservable cluster instances that are not in use.
	DeleteIdleReservableClusterInsts(ctx context.Context, in *IdleReservableClusterInsts, opts ...grpc.CallOption) (*Result, error)
}

type clusterInstApiClient struct {
	cc *grpc.ClientConn
}

func NewClusterInstApiClient(cc *grpc.ClientConn) ClusterInstApiClient {
	return &clusterInstApiClient{cc}
}

func (c *clusterInstApiClient) CreateClusterInst(ctx context.Context, in *ClusterInst, opts ...grpc.CallOption) (ClusterInstApi_CreateClusterInstClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ClusterInstApi_serviceDesc.Streams[0], "/edgeproto.ClusterInstApi/CreateClusterInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterInstApiCreateClusterInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ClusterInstApi_CreateClusterInstClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type clusterInstApiCreateClusterInstClient struct {
	grpc.ClientStream
}

func (x *clusterInstApiCreateClusterInstClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *clusterInstApiClient) DeleteClusterInst(ctx context.Context, in *ClusterInst, opts ...grpc.CallOption) (ClusterInstApi_DeleteClusterInstClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ClusterInstApi_serviceDesc.Streams[1], "/edgeproto.ClusterInstApi/DeleteClusterInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterInstApiDeleteClusterInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ClusterInstApi_DeleteClusterInstClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type clusterInstApiDeleteClusterInstClient struct {
	grpc.ClientStream
}

func (x *clusterInstApiDeleteClusterInstClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *clusterInstApiClient) UpdateClusterInst(ctx context.Context, in *ClusterInst, opts ...grpc.CallOption) (ClusterInstApi_UpdateClusterInstClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ClusterInstApi_serviceDesc.Streams[2], "/edgeproto.ClusterInstApi/UpdateClusterInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterInstApiUpdateClusterInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ClusterInstApi_UpdateClusterInstClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type clusterInstApiUpdateClusterInstClient struct {
	grpc.ClientStream
}

func (x *clusterInstApiUpdateClusterInstClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *clusterInstApiClient) ShowClusterInst(ctx context.Context, in *ClusterInst, opts ...grpc.CallOption) (ClusterInstApi_ShowClusterInstClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ClusterInstApi_serviceDesc.Streams[3], "/edgeproto.ClusterInstApi/ShowClusterInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterInstApiShowClusterInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ClusterInstApi_ShowClusterInstClient interface {
	Recv() (*ClusterInst, error)
	grpc.ClientStream
}

type clusterInstApiShowClusterInstClient struct {
	grpc.ClientStream
}

func (x *clusterInstApiShowClusterInstClient) Recv() (*ClusterInst, error) {
	m := new(ClusterInst)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *clusterInstApiClient) DeleteIdleReservableClusterInsts(ctx context.Context, in *IdleReservableClusterInsts, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.ClusterInstApi/DeleteIdleReservableClusterInsts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClusterInstApiServer is the server API for ClusterInstApi service.
type ClusterInstApiServer interface {
	// Create Cluster Instance. Creates an instance of a Cluster on a Cloudlet,
	// defined by a Cluster Key and a Cloudlet Key. ClusterInst is a collection of
	// compute resources on a Cloudlet on which AppInsts are deployed.
	CreateClusterInst(*ClusterInst, ClusterInstApi_CreateClusterInstServer) error
	// Delete Cluster Instance. Deletes an instance of a Cluster deployed on a Cloudlet.
	DeleteClusterInst(*ClusterInst, ClusterInstApi_DeleteClusterInstServer) error
	// Update Cluster Instance. Updates an instance of a Cluster deployed on a Cloudlet.
	UpdateClusterInst(*ClusterInst, ClusterInstApi_UpdateClusterInstServer) error
	// Show Cluster Instances. Lists all the cluster instances managed by Edge Controller.
	ShowClusterInst(*ClusterInst, ClusterInstApi_ShowClusterInstServer) error
	// Cleanup Reservable Cluster Instances. Deletes reservable cluster instances that are not in use.
	DeleteIdleReservableClusterInsts(context.Context, *IdleReservableClusterInsts) (*Result, error)
}

// UnimplementedClusterInstApiServer can be embedded to have forward compatible implementations.
type UnimplementedClusterInstApiServer struct {
}

func (*UnimplementedClusterInstApiServer) CreateClusterInst(req *ClusterInst, srv ClusterInstApi_CreateClusterInstServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateClusterInst not implemented")
}
func (*UnimplementedClusterInstApiServer) DeleteClusterInst(req *ClusterInst, srv ClusterInstApi_DeleteClusterInstServer) error {
	return status.Errorf(codes.Unimplemented, "method DeleteClusterInst not implemented")
}
func (*UnimplementedClusterInstApiServer) UpdateClusterInst(req *ClusterInst, srv ClusterInstApi_UpdateClusterInstServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateClusterInst not implemented")
}
func (*UnimplementedClusterInstApiServer) ShowClusterInst(req *ClusterInst, srv ClusterInstApi_ShowClusterInstServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowClusterInst not implemented")
}
func (*UnimplementedClusterInstApiServer) DeleteIdleReservableClusterInsts(ctx context.Context, req *IdleReservableClusterInsts) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteIdleReservableClusterInsts not implemented")
}

func RegisterClusterInstApiServer(s *grpc.Server, srv ClusterInstApiServer) {
	s.RegisterService(&_ClusterInstApi_serviceDesc, srv)
}

func _ClusterInstApi_CreateClusterInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ClusterInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClusterInstApiServer).CreateClusterInst(m, &clusterInstApiCreateClusterInstServer{stream})
}

type ClusterInstApi_CreateClusterInstServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type clusterInstApiCreateClusterInstServer struct {
	grpc.ServerStream
}

func (x *clusterInstApiCreateClusterInstServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _ClusterInstApi_DeleteClusterInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ClusterInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClusterInstApiServer).DeleteClusterInst(m, &clusterInstApiDeleteClusterInstServer{stream})
}

type ClusterInstApi_DeleteClusterInstServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type clusterInstApiDeleteClusterInstServer struct {
	grpc.ServerStream
}

func (x *clusterInstApiDeleteClusterInstServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _ClusterInstApi_UpdateClusterInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ClusterInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClusterInstApiServer).UpdateClusterInst(m, &clusterInstApiUpdateClusterInstServer{stream})
}

type ClusterInstApi_UpdateClusterInstServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type clusterInstApiUpdateClusterInstServer struct {
	grpc.ServerStream
}

func (x *clusterInstApiUpdateClusterInstServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _ClusterInstApi_ShowClusterInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ClusterInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClusterInstApiServer).ShowClusterInst(m, &clusterInstApiShowClusterInstServer{stream})
}

type ClusterInstApi_ShowClusterInstServer interface {
	Send(*ClusterInst) error
	grpc.ServerStream
}

type clusterInstApiShowClusterInstServer struct {
	grpc.ServerStream
}

func (x *clusterInstApiShowClusterInstServer) Send(m *ClusterInst) error {
	return x.ServerStream.SendMsg(m)
}

func _ClusterInstApi_DeleteIdleReservableClusterInsts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdleReservableClusterInsts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterInstApiServer).DeleteIdleReservableClusterInsts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.ClusterInstApi/DeleteIdleReservableClusterInsts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterInstApiServer).DeleteIdleReservableClusterInsts(ctx, req.(*IdleReservableClusterInsts))
	}
	return interceptor(ctx, in, info, handler)
}

var _ClusterInstApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.ClusterInstApi",
	HandlerType: (*ClusterInstApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeleteIdleReservableClusterInsts",
			Handler:    _ClusterInstApi_DeleteIdleReservableClusterInsts_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreateClusterInst",
			Handler:       _ClusterInstApi_CreateClusterInst_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DeleteClusterInst",
			Handler:       _ClusterInstApi_DeleteClusterInst_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdateClusterInst",
			Handler:       _ClusterInstApi_UpdateClusterInst_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowClusterInst",
			Handler:       _ClusterInstApi_ShowClusterInst_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "clusterinst.proto",
}

// ClusterInstInfoApiClient is the client API for ClusterInstInfoApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ClusterInstInfoApiClient interface {
	// Show Cluster instances state.
	ShowClusterInstInfo(ctx context.Context, in *ClusterInstInfo, opts ...grpc.CallOption) (ClusterInstInfoApi_ShowClusterInstInfoClient, error)
}

type clusterInstInfoApiClient struct {
	cc *grpc.ClientConn
}

func NewClusterInstInfoApiClient(cc *grpc.ClientConn) ClusterInstInfoApiClient {
	return &clusterInstInfoApiClient{cc}
}

func (c *clusterInstInfoApiClient) ShowClusterInstInfo(ctx context.Context, in *ClusterInstInfo, opts ...grpc.CallOption) (ClusterInstInfoApi_ShowClusterInstInfoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ClusterInstInfoApi_serviceDesc.Streams[0], "/edgeproto.ClusterInstInfoApi/ShowClusterInstInfo", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterInstInfoApiShowClusterInstInfoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ClusterInstInfoApi_ShowClusterInstInfoClient interface {
	Recv() (*ClusterInstInfo, error)
	grpc.ClientStream
}

type clusterInstInfoApiShowClusterInstInfoClient struct {
	grpc.ClientStream
}

func (x *clusterInstInfoApiShowClusterInstInfoClient) Recv() (*ClusterInstInfo, error) {
	m := new(ClusterInstInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ClusterInstInfoApiServer is the server API for ClusterInstInfoApi service.
type ClusterInstInfoApiServer interface {
	// Show Cluster instances state.
	ShowClusterInstInfo(*ClusterInstInfo, ClusterInstInfoApi_ShowClusterInstInfoServer) error
}

// UnimplementedClusterInstInfoApiServer can be embedded to have forward compatible implementations.
type UnimplementedClusterInstInfoApiServer struct {
}

func (*UnimplementedClusterInstInfoApiServer) ShowClusterInstInfo(req *ClusterInstInfo, srv ClusterInstInfoApi_ShowClusterInstInfoServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowClusterInstInfo not implemented")
}

func RegisterClusterInstInfoApiServer(s *grpc.Server, srv ClusterInstInfoApiServer) {
	s.RegisterService(&_ClusterInstInfoApi_serviceDesc, srv)
}

func _ClusterInstInfoApi_ShowClusterInstInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ClusterInstInfo)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClusterInstInfoApiServer).ShowClusterInstInfo(m, &clusterInstInfoApiShowClusterInstInfoServer{stream})
}

type ClusterInstInfoApi_ShowClusterInstInfoServer interface {
	Send(*ClusterInstInfo) error
	grpc.ServerStream
}

type clusterInstInfoApiShowClusterInstInfoServer struct {
	grpc.ServerStream
}

func (x *clusterInstInfoApiShowClusterInstInfoServer) Send(m *ClusterInstInfo) error {
	return x.ServerStream.SendMsg(m)
}

var _ClusterInstInfoApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.ClusterInstInfoApi",
	HandlerType: (*ClusterInstInfoApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowClusterInstInfo",
			Handler:       _ClusterInstInfoApi_ShowClusterInstInfo_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "clusterinst.proto",
}

func (m *ClusterInstKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterInstKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterInstKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.CloudletKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ClusterKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ClusterInst) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterInst) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterInst) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MultiTenant {
		i--
		if m.MultiTenant {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	{
		size, err := m.ReservationEndedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xfa
	{
		size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xf2
	{
		size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xea
	{
		size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xe2
	if len(m.OptRes) > 0 {
		i -= len(m.OptRes)
		copy(dAtA[i:], m.OptRes)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.OptRes)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.SkipCrmCleanupOnFailure {
		i--
		if m.SkipCrmCleanupOnFailure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if len(m.MasterNodeFlavor) > 0 {
		i -= len(m.MasterNodeFlavor)
		copy(dAtA[i:], m.MasterNodeFlavor)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.MasterNodeFlavor)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.SharedVolumeSize != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.SharedVolumeSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.ReservedBy) > 0 {
		i -= len(m.ReservedBy)
		copy(dAtA[i:], m.ReservedBy)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.ReservedBy)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.Reservable {
		i--
		if m.Reservable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.ImageName) > 0 {
		i -= len(m.ImageName)
		copy(dAtA[i:], m.ImageName)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.ImageName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.AvailabilityZone) > 0 {
		i -= len(m.AvailabilityZone)
		copy(dAtA[i:], m.AvailabilityZone)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.AvailabilityZone)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.AutoScalePolicy) > 0 {
		i -= len(m.AutoScalePolicy)
		copy(dAtA[i:], m.AutoScalePolicy)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.AutoScalePolicy)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.ExternalVolumeSize != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.ExternalVolumeSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	if len(m.Deployment) > 0 {
		i -= len(m.Deployment)
		copy(dAtA[i:], m.Deployment)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.Deployment)))
		i--
		dAtA[i] = 0x7a
	}
	if m.NumNodes != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.NumNodes))
		i--
		dAtA[i] = 0x70
	}
	if m.NumMasters != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.NumMasters))
		i--
		dAtA[i] = 0x68
	}
	if len(m.NodeFlavor) > 0 {
		i -= len(m.NodeFlavor)
		copy(dAtA[i:], m.NodeFlavor)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.NodeFlavor)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Auto {
		i--
		if m.Auto {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Liveness != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.Liveness))
		i--
		dAtA[i] = 0x48
	}
	if len(m.AllocatedIp) > 0 {
		i -= len(m.AllocatedIp)
		copy(dAtA[i:], m.AllocatedIp)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.AllocatedIp)))
		i--
		dAtA[i] = 0x42
	}
	if m.IpAccess != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.IpAccess))
		i--
		dAtA[i] = 0x38
	}
	if m.CrmOverride != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.CrmOverride))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Errors[iNdEx])
			copy(dAtA[i:], m.Errors[iNdEx])
			i = encodeVarintClusterinst(dAtA, i, uint64(len(m.Errors[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.State != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Flavor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintClusterinst(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IdleReservableClusterInsts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdleReservableClusterInsts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IdleReservableClusterInsts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IdleTime != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.IdleTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClusterInstInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterInstInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterInstInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Errors[iNdEx])
			copy(dAtA[i:], m.Errors[iNdEx])
			i = encodeVarintClusterinst(dAtA, i, uint64(len(m.Errors[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.State != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if m.NotifyId != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.NotifyId))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintClusterinst(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintClusterinst(dAtA []byte, offset int, v uint64) int {
	offset -= sovClusterinst(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ClusterInstKey) Matches(o *ClusterInstKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.ClusterKey.Matches(&o.ClusterKey, fopts...) {
		return false
	}
	if !m.CloudletKey.Matches(&o.CloudletKey, fopts...) {
		return false
	}
	if !opts.Filter || o.Organization != "" {
		if o.Organization != m.Organization {
			return false
		}
	}
	return true
}

func (m *ClusterInstKey) CopyInFields(src *ClusterInstKey) int {
	changed := 0
	if m.ClusterKey.Name != src.ClusterKey.Name {
		m.ClusterKey.Name = src.ClusterKey.Name
		changed++
	}
	if m.CloudletKey.Organization != src.CloudletKey.Organization {
		m.CloudletKey.Organization = src.CloudletKey.Organization
		changed++
	}
	if m.CloudletKey.Name != src.CloudletKey.Name {
		m.CloudletKey.Name = src.CloudletKey.Name
		changed++
	}
	if m.Organization != src.Organization {
		m.Organization = src.Organization
		changed++
	}
	return changed
}

func (m *ClusterInstKey) DeepCopyIn(src *ClusterInstKey) {
	m.ClusterKey.DeepCopyIn(&src.ClusterKey)
	m.CloudletKey.DeepCopyIn(&src.CloudletKey)
	m.Organization = src.Organization
}

func (m *ClusterInstKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal ClusterInstKey key string", "obj", m)
	}
	return string(key)
}

func ClusterInstKeyStringParse(str string, key *ClusterInstKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal ClusterInstKey key string", "str", str)
	}
}

func (m *ClusterInstKey) NotFoundError() error {
	return fmt.Errorf("ClusterInst key %s not found", m.GetKeyString())
}

func (m *ClusterInstKey) ExistsError() error {
	return fmt.Errorf("ClusterInst key %s already exists", m.GetKeyString())
}

var ClusterInstKeyTagOrganization = "clusterorg"

func (m *ClusterInstKey) GetTags() map[string]string {
	tags := make(map[string]string)
	tags["cluster"] = m.ClusterKey.Name
	tags["cloudletorg"] = m.CloudletKey.Organization
	tags["cloudlet"] = m.CloudletKey.Name
	tags["clusterorg"] = m.Organization
	return tags
}

// Helper method to check that enums have valid values
func (m *ClusterInstKey) ValidateEnums() error {
	if err := m.ClusterKey.ValidateEnums(); err != nil {
		return err
	}
	if err := m.CloudletKey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *ClusterInst) Matches(o *ClusterInst, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.IgnoreBackend {
		if !m.Flavor.Matches(&o.Flavor, fopts...) {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.State != 0 {
			if o.State != m.State {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Errors != nil {
			if len(m.Errors) == 0 && len(o.Errors) > 0 || len(m.Errors) > 0 && len(o.Errors) == 0 {
				return false
			} else if m.Errors != nil && o.Errors != nil {
				if !opts.Filter && len(m.Errors) != len(o.Errors) {
					return false
				}
				found := 0
				for oIndex, _ := range o.Errors {
					for mIndex, _ := range m.Errors {
						if o.Errors[oIndex] == m.Errors[mIndex] {
							found++
							break
						}
					}
				}
				if found != len(o.Errors) {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.CrmOverride != 0 {
		if o.CrmOverride != m.CrmOverride {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.IpAccess != 0 {
			if o.IpAccess != m.IpAccess {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.AllocatedIp != "" {
			if o.AllocatedIp != m.AllocatedIp {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Liveness != 0 {
			if o.Liveness != m.Liveness {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Auto != false {
			if o.Auto != m.Auto {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.NodeFlavor != "" {
			if o.NodeFlavor != m.NodeFlavor {
				return false
			}
		}
	}
	if !opts.Filter || o.NumMasters != 0 {
		if o.NumMasters != m.NumMasters {
			return false
		}
	}
	if !opts.Filter || o.NumNodes != 0 {
		if o.NumNodes != m.NumNodes {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Deployment != "" {
			if o.Deployment != m.Deployment {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.ExternalVolumeSize != 0 {
			if o.ExternalVolumeSize != m.ExternalVolumeSize {
				return false
			}
		}
	}
	if !opts.Filter || o.AutoScalePolicy != "" {
		if o.AutoScalePolicy != m.AutoScalePolicy {
			return false
		}
	}
	if !opts.Filter || o.AvailabilityZone != "" {
		if o.AvailabilityZone != m.AvailabilityZone {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.ImageName != "" {
			if o.ImageName != m.ImageName {
				return false
			}
		}
	}
	if !opts.Filter || o.Reservable != false {
		if o.Reservable != m.Reservable {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.ReservedBy != "" {
			if o.ReservedBy != m.ReservedBy {
				return false
			}
		}
	}
	if !opts.Filter || o.SharedVolumeSize != 0 {
		if o.SharedVolumeSize != m.SharedVolumeSize {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.MasterNodeFlavor != "" {
			if o.MasterNodeFlavor != m.MasterNodeFlavor {
				return false
			}
		}
	}
	if !opts.Filter || o.SkipCrmCleanupOnFailure != false {
		if o.SkipCrmCleanupOnFailure != m.SkipCrmCleanupOnFailure {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.OptRes != "" {
			if o.OptRes != m.OptRes {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
	}
	if !opts.Filter || o.MultiTenant != false {
		if o.MultiTenant != m.MultiTenant {
			return false
		}
	}
	return true
}

const ClusterInstFieldKey = "2"
const ClusterInstFieldKeyClusterKey = "2.1"
const ClusterInstFieldKeyClusterKeyName = "2.1.1"
const ClusterInstFieldKeyCloudletKey = "2.2"
const ClusterInstFieldKeyCloudletKeyOrganization = "2.2.1"
const ClusterInstFieldKeyCloudletKeyName = "2.2.2"
const ClusterInstFieldKeyOrganization = "2.3"
const ClusterInstFieldFlavor = "3"
const ClusterInstFieldFlavorName = "3.1"
const ClusterInstFieldState = "4"
const ClusterInstFieldErrors = "5"
const ClusterInstFieldCrmOverride = "6"
const ClusterInstFieldIpAccess = "7"
const ClusterInstFieldAllocatedIp = "8"
const ClusterInstFieldLiveness = "9"
const ClusterInstFieldAuto = "10"
const ClusterInstFieldNodeFlavor = "11"
const ClusterInstFieldNumMasters = "13"
const ClusterInstFieldNumNodes = "14"
const ClusterInstFieldDeployment = "15"
const ClusterInstFieldStatus = "16"
const ClusterInstFieldStatusTaskNumber = "16.1"
const ClusterInstFieldStatusMaxTasks = "16.2"
const ClusterInstFieldStatusTaskName = "16.3"
const ClusterInstFieldStatusStepName = "16.4"
const ClusterInstFieldStatusMsgCount = "16.5"
const ClusterInstFieldStatusMsgs = "16.6"
const ClusterInstFieldExternalVolumeSize = "17"
const ClusterInstFieldAutoScalePolicy = "18"
const ClusterInstFieldAvailabilityZone = "19"
const ClusterInstFieldImageName = "20"
const ClusterInstFieldReservable = "21"
const ClusterInstFieldReservedBy = "22"
const ClusterInstFieldSharedVolumeSize = "23"
const ClusterInstFieldMasterNodeFlavor = "25"
const ClusterInstFieldSkipCrmCleanupOnFailure = "26"
const ClusterInstFieldOptRes = "27"
const ClusterInstFieldResources = "28"
const ClusterInstFieldResourcesVms = "28.1"
const ClusterInstFieldResourcesVmsName = "28.1.1"
const ClusterInstFieldResourcesVmsType = "28.1.2"
const ClusterInstFieldResourcesVmsStatus = "28.1.3"
const ClusterInstFieldResourcesVmsInfraFlavor = "28.1.4"
const ClusterInstFieldResourcesVmsIpaddresses = "28.1.5"
const ClusterInstFieldResourcesVmsIpaddressesExternalIp = "28.1.5.1"
const ClusterInstFieldResourcesVmsIpaddressesInternalIp = "28.1.5.2"
const ClusterInstFieldResourcesVmsContainers = "28.1.6"
const ClusterInstFieldResourcesVmsContainersName = "28.1.6.1"
const ClusterInstFieldResourcesVmsContainersType = "28.1.6.2"
const ClusterInstFieldResourcesVmsContainersStatus = "28.1.6.3"
const ClusterInstFieldResourcesVmsContainersClusterip = "28.1.6.4"
const ClusterInstFieldResourcesVmsContainersRestarts = "28.1.6.5"
const ClusterInstFieldCreatedAt = "29"
const ClusterInstFieldCreatedAtSeconds = "29.1"
const ClusterInstFieldCreatedAtNanos = "29.2"
const ClusterInstFieldUpdatedAt = "30"
const ClusterInstFieldUpdatedAtSeconds = "30.1"
const ClusterInstFieldUpdatedAtNanos = "30.2"
const ClusterInstFieldReservationEndedAt = "31"
const ClusterInstFieldReservationEndedAtSeconds = "31.1"
const ClusterInstFieldReservationEndedAtNanos = "31.2"
const ClusterInstFieldMultiTenant = "32"

var ClusterInstAllFields = []string{
	ClusterInstFieldKeyClusterKeyName,
	ClusterInstFieldKeyCloudletKeyOrganization,
	ClusterInstFieldKeyCloudletKeyName,
	ClusterInstFieldKeyOrganization,
	ClusterInstFieldFlavorName,
	ClusterInstFieldState,
	ClusterInstFieldErrors,
	ClusterInstFieldCrmOverride,
	ClusterInstFieldIpAccess,
	ClusterInstFieldAllocatedIp,
	ClusterInstFieldLiveness,
	ClusterInstFieldAuto,
	ClusterInstFieldNodeFlavor,
	ClusterInstFieldNumMasters,
	ClusterInstFieldNumNodes,
	ClusterInstFieldDeployment,
	ClusterInstFieldStatusTaskNumber,
	ClusterInstFieldStatusMaxTasks,
	ClusterInstFieldStatusTaskName,
	ClusterInstFieldStatusStepName,
	ClusterInstFieldStatusMsgCount,
	ClusterInstFieldStatusMsgs,
	ClusterInstFieldExternalVolumeSize,
	ClusterInstFieldAutoScalePolicy,
	ClusterInstFieldAvailabilityZone,
	ClusterInstFieldImageName,
	ClusterInstFieldReservable,
	ClusterInstFieldReservedBy,
	ClusterInstFieldSharedVolumeSize,
	ClusterInstFieldMasterNodeFlavor,
	ClusterInstFieldSkipCrmCleanupOnFailure,
	ClusterInstFieldOptRes,
	ClusterInstFieldResourcesVmsName,
	ClusterInstFieldResourcesVmsType,
	ClusterInstFieldResourcesVmsStatus,
	ClusterInstFieldResourcesVmsInfraFlavor,
	ClusterInstFieldResourcesVmsIpaddressesExternalIp,
	ClusterInstFieldResourcesVmsIpaddressesInternalIp,
	ClusterInstFieldResourcesVmsContainersName,
	ClusterInstFieldResourcesVmsContainersType,
	ClusterInstFieldResourcesVmsContainersStatus,
	ClusterInstFieldResourcesVmsContainersClusterip,
	ClusterInstFieldResourcesVmsContainersRestarts,
	ClusterInstFieldCreatedAtSeconds,
	ClusterInstFieldCreatedAtNanos,
	ClusterInstFieldUpdatedAtSeconds,
	ClusterInstFieldUpdatedAtNanos,
	ClusterInstFieldReservationEndedAtSeconds,
	ClusterInstFieldReservationEndedAtNanos,
	ClusterInstFieldMultiTenant,
}

var ClusterInstAllFieldsMap = map[string]struct{}{
	ClusterInstFieldKeyClusterKeyName:                 struct{}{},
	ClusterInstFieldKeyCloudletKeyOrganization:        struct{}{},
	ClusterInstFieldKeyCloudletKeyName:                struct{}{},
	ClusterInstFieldKeyOrganization:                   struct{}{},
	ClusterInstFieldFlavorName:                        struct{}{},
	ClusterInstFieldState:                             struct{}{},
	ClusterInstFieldErrors:                            struct{}{},
	ClusterInstFieldCrmOverride:                       struct{}{},
	ClusterInstFieldIpAccess:                          struct{}{},
	ClusterInstFieldAllocatedIp:                       struct{}{},
	ClusterInstFieldLiveness:                          struct{}{},
	ClusterInstFieldAuto:                              struct{}{},
	ClusterInstFieldNodeFlavor:                        struct{}{},
	ClusterInstFieldNumMasters:                        struct{}{},
	ClusterInstFieldNumNodes:                          struct{}{},
	ClusterInstFieldDeployment:                        struct{}{},
	ClusterInstFieldStatusTaskNumber:                  struct{}{},
	ClusterInstFieldStatusMaxTasks:                    struct{}{},
	ClusterInstFieldStatusTaskName:                    struct{}{},
	ClusterInstFieldStatusStepName:                    struct{}{},
	ClusterInstFieldStatusMsgCount:                    struct{}{},
	ClusterInstFieldStatusMsgs:                        struct{}{},
	ClusterInstFieldExternalVolumeSize:                struct{}{},
	ClusterInstFieldAutoScalePolicy:                   struct{}{},
	ClusterInstFieldAvailabilityZone:                  struct{}{},
	ClusterInstFieldImageName:                         struct{}{},
	ClusterInstFieldReservable:                        struct{}{},
	ClusterInstFieldReservedBy:                        struct{}{},
	ClusterInstFieldSharedVolumeSize:                  struct{}{},
	ClusterInstFieldMasterNodeFlavor:                  struct{}{},
	ClusterInstFieldSkipCrmCleanupOnFailure:           struct{}{},
	ClusterInstFieldOptRes:                            struct{}{},
	ClusterInstFieldResourcesVmsName:                  struct{}{},
	ClusterInstFieldResourcesVmsType:                  struct{}{},
	ClusterInstFieldResourcesVmsStatus:                struct{}{},
	ClusterInstFieldResourcesVmsInfraFlavor:           struct{}{},
	ClusterInstFieldResourcesVmsIpaddressesExternalIp: struct{}{},
	ClusterInstFieldResourcesVmsIpaddressesInternalIp: struct{}{},
	ClusterInstFieldResourcesVmsContainersName:        struct{}{},
	ClusterInstFieldResourcesVmsContainersType:        struct{}{},
	ClusterInstFieldResourcesVmsContainersStatus:      struct{}{},
	ClusterInstFieldResourcesVmsContainersClusterip:   struct{}{},
	ClusterInstFieldResourcesVmsContainersRestarts:    struct{}{},
	ClusterInstFieldCreatedAtSeconds:                  struct{}{},
	ClusterInstFieldCreatedAtNanos:                    struct{}{},
	ClusterInstFieldUpdatedAtSeconds:                  struct{}{},
	ClusterInstFieldUpdatedAtNanos:                    struct{}{},
	ClusterInstFieldReservationEndedAtSeconds:         struct{}{},
	ClusterInstFieldReservationEndedAtNanos:           struct{}{},
	ClusterInstFieldMultiTenant:                       struct{}{},
}

var ClusterInstAllFieldsStringMap = map[string]string{
	ClusterInstFieldKeyClusterKeyName:                 "Key Cluster Key Name",
	ClusterInstFieldKeyCloudletKeyOrganization:        "Key Cloudlet Key Organization",
	ClusterInstFieldKeyCloudletKeyName:                "Key Cloudlet Key Name",
	ClusterInstFieldKeyOrganization:                   "Key Organization",
	ClusterInstFieldFlavorName:                        "Flavor Name",
	ClusterInstFieldState:                             "State",
	ClusterInstFieldErrors:                            "Errors",
	ClusterInstFieldCrmOverride:                       "Crm Override",
	ClusterInstFieldIpAccess:                          "Ip Access",
	ClusterInstFieldAllocatedIp:                       "Allocated Ip",
	ClusterInstFieldLiveness:                          "Liveness",
	ClusterInstFieldAuto:                              "Auto",
	ClusterInstFieldNodeFlavor:                        "Node Flavor",
	ClusterInstFieldNumMasters:                        "Num Masters",
	ClusterInstFieldNumNodes:                          "Num Nodes",
	ClusterInstFieldDeployment:                        "Deployment",
	ClusterInstFieldStatusTaskNumber:                  "Status Task Number",
	ClusterInstFieldStatusMaxTasks:                    "Status Max Tasks",
	ClusterInstFieldStatusTaskName:                    "Status Task Name",
	ClusterInstFieldStatusStepName:                    "Status Step Name",
	ClusterInstFieldStatusMsgCount:                    "Status Msg Count",
	ClusterInstFieldStatusMsgs:                        "Status Msgs",
	ClusterInstFieldExternalVolumeSize:                "External Volume Size",
	ClusterInstFieldAutoScalePolicy:                   "Auto Scale Policy",
	ClusterInstFieldAvailabilityZone:                  "Availability Zone",
	ClusterInstFieldImageName:                         "Image Name",
	ClusterInstFieldReservable:                        "Reservable",
	ClusterInstFieldReservedBy:                        "Reserved By",
	ClusterInstFieldSharedVolumeSize:                  "Shared Volume Size",
	ClusterInstFieldMasterNodeFlavor:                  "Master Node Flavor",
	ClusterInstFieldSkipCrmCleanupOnFailure:           "Skip Crm Cleanup On Failure",
	ClusterInstFieldOptRes:                            "Opt Res",
	ClusterInstFieldResourcesVmsName:                  "Resources Vms Name",
	ClusterInstFieldResourcesVmsType:                  "Resources Vms Type",
	ClusterInstFieldResourcesVmsStatus:                "Resources Vms Status",
	ClusterInstFieldResourcesVmsInfraFlavor:           "Resources Vms Infra Flavor",
	ClusterInstFieldResourcesVmsIpaddressesExternalIp: "Resources Vms Ipaddresses External Ip",
	ClusterInstFieldResourcesVmsIpaddressesInternalIp: "Resources Vms Ipaddresses Internal Ip",
	ClusterInstFieldResourcesVmsContainersName:        "Resources Vms Containers Name",
	ClusterInstFieldResourcesVmsContainersType:        "Resources Vms Containers Type",
	ClusterInstFieldResourcesVmsContainersStatus:      "Resources Vms Containers Status",
	ClusterInstFieldResourcesVmsContainersClusterip:   "Resources Vms Containers Clusterip",
	ClusterInstFieldResourcesVmsContainersRestarts:    "Resources Vms Containers Restarts",
	ClusterInstFieldCreatedAtSeconds:                  "Created At Seconds",
	ClusterInstFieldCreatedAtNanos:                    "Created At Nanos",
	ClusterInstFieldUpdatedAtSeconds:                  "Updated At Seconds",
	ClusterInstFieldUpdatedAtNanos:                    "Updated At Nanos",
	ClusterInstFieldReservationEndedAtSeconds:         "Reservation Ended At Seconds",
	ClusterInstFieldReservationEndedAtNanos:           "Reservation Ended At Nanos",
	ClusterInstFieldMultiTenant:                       "Multi Tenant",
}

func (m *ClusterInst) IsKeyField(s string) bool {
	return strings.HasPrefix(s, ClusterInstFieldKey+".") || s == ClusterInstFieldKey
}

func (m *ClusterInst) DiffFields(o *ClusterInst, fields map[string]struct{}) {
	if m.Key.ClusterKey.Name != o.Key.ClusterKey.Name {
		fields[ClusterInstFieldKeyClusterKeyName] = struct{}{}
		fields[ClusterInstFieldKeyClusterKey] = struct{}{}
		fields[ClusterInstFieldKey] = struct{}{}
	}
	if m.Key.CloudletKey.Organization != o.Key.CloudletKey.Organization {
		fields[ClusterInstFieldKeyCloudletKeyOrganization] = struct{}{}
		fields[ClusterInstFieldKeyCloudletKey] = struct{}{}
		fields[ClusterInstFieldKey] = struct{}{}
	}
	if m.Key.CloudletKey.Name != o.Key.CloudletKey.Name {
		fields[ClusterInstFieldKeyCloudletKeyName] = struct{}{}
		fields[ClusterInstFieldKeyCloudletKey] = struct{}{}
		fields[ClusterInstFieldKey] = struct{}{}
	}
	if m.Key.Organization != o.Key.Organization {
		fields[ClusterInstFieldKeyOrganization] = struct{}{}
		fields[ClusterInstFieldKey] = struct{}{}
	}
	if m.Flavor.Name != o.Flavor.Name {
		fields[ClusterInstFieldFlavorName] = struct{}{}
		fields[ClusterInstFieldFlavor] = struct{}{}
	}
	if m.State != o.State {
		fields[ClusterInstFieldState] = struct{}{}
	}
	if len(m.Errors) != len(o.Errors) {
		fields[ClusterInstFieldErrors] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.Errors); i0++ {
			if m.Errors[i0] != o.Errors[i0] {
				fields[ClusterInstFieldErrors] = struct{}{}
				break
			}
		}
	}
	if m.CrmOverride != o.CrmOverride {
		fields[ClusterInstFieldCrmOverride] = struct{}{}
	}
	if m.IpAccess != o.IpAccess {
		fields[ClusterInstFieldIpAccess] = struct{}{}
	}
	if m.AllocatedIp != o.AllocatedIp {
		fields[ClusterInstFieldAllocatedIp] = struct{}{}
	}
	if m.Liveness != o.Liveness {
		fields[ClusterInstFieldLiveness] = struct{}{}
	}
	if m.Auto != o.Auto {
		fields[ClusterInstFieldAuto] = struct{}{}
	}
	if m.NodeFlavor != o.NodeFlavor {
		fields[ClusterInstFieldNodeFlavor] = struct{}{}
	}
	if m.NumMasters != o.NumMasters {
		fields[ClusterInstFieldNumMasters] = struct{}{}
	}
	if m.NumNodes != o.NumNodes {
		fields[ClusterInstFieldNumNodes] = struct{}{}
	}
	if m.Deployment != o.Deployment {
		fields[ClusterInstFieldDeployment] = struct{}{}
	}
	if m.Status.TaskNumber != o.Status.TaskNumber {
		fields[ClusterInstFieldStatusTaskNumber] = struct{}{}
		fields[ClusterInstFieldStatus] = struct{}{}
	}
	if m.Status.MaxTasks != o.Status.MaxTasks {
		fields[ClusterInstFieldStatusMaxTasks] = struct{}{}
		fields[ClusterInstFieldStatus] = struct{}{}
	}
	if m.Status.TaskName != o.Status.TaskName {
		fields[ClusterInstFieldStatusTaskName] = struct{}{}
		fields[ClusterInstFieldStatus] = struct{}{}
	}
	if m.Status.StepName != o.Status.StepName {
		fields[ClusterInstFieldStatusStepName] = struct{}{}
		fields[ClusterInstFieldStatus] = struct{}{}
	}
	if m.Status.MsgCount != o.Status.MsgCount {
		fields[ClusterInstFieldStatusMsgCount] = struct{}{}
		fields[ClusterInstFieldStatus] = struct{}{}
	}
	if len(m.Status.Msgs) != len(o.Status.Msgs) {
		fields[ClusterInstFieldStatusMsgs] = struct{}{}
		fields[ClusterInstFieldStatus] = struct{}{}
	} else {
		for i1 := 0; i1 < len(m.Status.Msgs); i1++ {
			if m.Status.Msgs[i1] != o.Status.Msgs[i1] {
				fields[ClusterInstFieldStatusMsgs] = struct{}{}
				fields[ClusterInstFieldStatus] = struct{}{}
				break
			}
		}
	}
	if m.ExternalVolumeSize != o.ExternalVolumeSize {
		fields[ClusterInstFieldExternalVolumeSize] = struct{}{}
	}
	if m.AutoScalePolicy != o.AutoScalePolicy {
		fields[ClusterInstFieldAutoScalePolicy] = struct{}{}
	}
	if m.AvailabilityZone != o.AvailabilityZone {
		fields[ClusterInstFieldAvailabilityZone] = struct{}{}
	}
	if m.ImageName != o.ImageName {
		fields[ClusterInstFieldImageName] = struct{}{}
	}
	if m.Reservable != o.Reservable {
		fields[ClusterInstFieldReservable] = struct{}{}
	}
	if m.ReservedBy != o.ReservedBy {
		fields[ClusterInstFieldReservedBy] = struct{}{}
	}
	if m.SharedVolumeSize != o.SharedVolumeSize {
		fields[ClusterInstFieldSharedVolumeSize] = struct{}{}
	}
	if m.MasterNodeFlavor != o.MasterNodeFlavor {
		fields[ClusterInstFieldMasterNodeFlavor] = struct{}{}
	}
	if m.SkipCrmCleanupOnFailure != o.SkipCrmCleanupOnFailure {
		fields[ClusterInstFieldSkipCrmCleanupOnFailure] = struct{}{}
	}
	if m.OptRes != o.OptRes {
		fields[ClusterInstFieldOptRes] = struct{}{}
	}
	if len(m.Resources.Vms) != len(o.Resources.Vms) {
		fields[ClusterInstFieldResourcesVms] = struct{}{}
		fields[ClusterInstFieldResources] = struct{}{}
	} else {
		for i1 := 0; i1 < len(m.Resources.Vms); i1++ {
			if m.Resources.Vms[i1].Name != o.Resources.Vms[i1].Name {
				fields[ClusterInstFieldResourcesVmsName] = struct{}{}
				fields[ClusterInstFieldResourcesVms] = struct{}{}
				fields[ClusterInstFieldResources] = struct{}{}
			}
			if m.Resources.Vms[i1].Type != o.Resources.Vms[i1].Type {
				fields[ClusterInstFieldResourcesVmsType] = struct{}{}
				fields[ClusterInstFieldResourcesVms] = struct{}{}
				fields[ClusterInstFieldResources] = struct{}{}
			}
			if m.Resources.Vms[i1].Status != o.Resources.Vms[i1].Status {
				fields[ClusterInstFieldResourcesVmsStatus] = struct{}{}
				fields[ClusterInstFieldResourcesVms] = struct{}{}
				fields[ClusterInstFieldResources] = struct{}{}
			}
			if m.Resources.Vms[i1].InfraFlavor != o.Resources.Vms[i1].InfraFlavor {
				fields[ClusterInstFieldResourcesVmsInfraFlavor] = struct{}{}
				fields[ClusterInstFieldResourcesVms] = struct{}{}
				fields[ClusterInstFieldResources] = struct{}{}
			}
			if len(m.Resources.Vms[i1].Ipaddresses) != len(o.Resources.Vms[i1].Ipaddresses) {
				fields[ClusterInstFieldResourcesVmsIpaddresses] = struct{}{}
				fields[ClusterInstFieldResourcesVms] = struct{}{}
				fields[ClusterInstFieldResources] = struct{}{}
			} else {
				for i2 := 0; i2 < len(m.Resources.Vms[i1].Ipaddresses); i2++ {
					if m.Resources.Vms[i1].Ipaddresses[i2].ExternalIp != o.Resources.Vms[i1].Ipaddresses[i2].ExternalIp {
						fields[ClusterInstFieldResourcesVmsIpaddressesExternalIp] = struct{}{}
						fields[ClusterInstFieldResourcesVmsIpaddresses] = struct{}{}
						fields[ClusterInstFieldResourcesVms] = struct{}{}
						fields[ClusterInstFieldResources] = struct{}{}
					}
					if m.Resources.Vms[i1].Ipaddresses[i2].InternalIp != o.Resources.Vms[i1].Ipaddresses[i2].InternalIp {
						fields[ClusterInstFieldResourcesVmsIpaddressesInternalIp] = struct{}{}
						fields[ClusterInstFieldResourcesVmsIpaddresses] = struct{}{}
						fields[ClusterInstFieldResourcesVms] = struct{}{}
						fields[ClusterInstFieldResources] = struct{}{}
					}
				}
			}
			if m.Resources.Vms[i1].Containers != nil && o.Resources.Vms[i1].Containers != nil {
				if len(m.Resources.Vms[i1].Containers) != len(o.Resources.Vms[i1].Containers) {
					fields[ClusterInstFieldResourcesVmsContainers] = struct{}{}
					fields[ClusterInstFieldResourcesVms] = struct{}{}
					fields[ClusterInstFieldResources] = struct{}{}
				} else {
					for i2 := 0; i2 < len(m.Resources.Vms[i1].Containers); i2++ {
						if m.Resources.Vms[i1].Containers[i2].Name != o.Resources.Vms[i1].Containers[i2].Name {
							fields[ClusterInstFieldResourcesVmsContainersName] = struct{}{}
							fields[ClusterInstFieldResourcesVmsContainers] = struct{}{}
							fields[ClusterInstFieldResourcesVms] = struct{}{}
							fields[ClusterInstFieldResources] = struct{}{}
						}
						if m.Resources.Vms[i1].Containers[i2].Type != o.Resources.Vms[i1].Containers[i2].Type {
							fields[ClusterInstFieldResourcesVmsContainersType] = struct{}{}
							fields[ClusterInstFieldResourcesVmsContainers] = struct{}{}
							fields[ClusterInstFieldResourcesVms] = struct{}{}
							fields[ClusterInstFieldResources] = struct{}{}
						}
						if m.Resources.Vms[i1].Containers[i2].Status != o.Resources.Vms[i1].Containers[i2].Status {
							fields[ClusterInstFieldResourcesVmsContainersStatus] = struct{}{}
							fields[ClusterInstFieldResourcesVmsContainers] = struct{}{}
							fields[ClusterInstFieldResourcesVms] = struct{}{}
							fields[ClusterInstFieldResources] = struct{}{}
						}
						if m.Resources.Vms[i1].Containers[i2].Clusterip != o.Resources.Vms[i1].Containers[i2].Clusterip {
							fields[ClusterInstFieldResourcesVmsContainersClusterip] = struct{}{}
							fields[ClusterInstFieldResourcesVmsContainers] = struct{}{}
							fields[ClusterInstFieldResourcesVms] = struct{}{}
							fields[ClusterInstFieldResources] = struct{}{}
						}
						if m.Resources.Vms[i1].Containers[i2].Restarts != o.Resources.Vms[i1].Containers[i2].Restarts {
							fields[ClusterInstFieldResourcesVmsContainersRestarts] = struct{}{}
							fields[ClusterInstFieldResourcesVmsContainers] = struct{}{}
							fields[ClusterInstFieldResourcesVms] = struct{}{}
							fields[ClusterInstFieldResources] = struct{}{}
						}
					}
				}
			} else if (m.Resources.Vms[i1].Containers != nil && o.Resources.Vms[i1].Containers == nil) || (m.Resources.Vms[i1].Containers == nil && o.Resources.Vms[i1].Containers != nil) {
				fields[ClusterInstFieldResourcesVmsContainers] = struct{}{}
				fields[ClusterInstFieldResourcesVms] = struct{}{}
				fields[ClusterInstFieldResources] = struct{}{}
			}
		}
	}
	if m.CreatedAt.Seconds != o.CreatedAt.Seconds {
		fields[ClusterInstFieldCreatedAtSeconds] = struct{}{}
		fields[ClusterInstFieldCreatedAt] = struct{}{}
	}
	if m.CreatedAt.Nanos != o.CreatedAt.Nanos {
		fields[ClusterInstFieldCreatedAtNanos] = struct{}{}
		fields[ClusterInstFieldCreatedAt] = struct{}{}
	}
	if m.UpdatedAt.Seconds != o.UpdatedAt.Seconds {
		fields[ClusterInstFieldUpdatedAtSeconds] = struct{}{}
		fields[ClusterInstFieldUpdatedAt] = struct{}{}
	}
	if m.UpdatedAt.Nanos != o.UpdatedAt.Nanos {
		fields[ClusterInstFieldUpdatedAtNanos] = struct{}{}
		fields[ClusterInstFieldUpdatedAt] = struct{}{}
	}
	if m.ReservationEndedAt.Seconds != o.ReservationEndedAt.Seconds {
		fields[ClusterInstFieldReservationEndedAtSeconds] = struct{}{}
		fields[ClusterInstFieldReservationEndedAt] = struct{}{}
	}
	if m.ReservationEndedAt.Nanos != o.ReservationEndedAt.Nanos {
		fields[ClusterInstFieldReservationEndedAtNanos] = struct{}{}
		fields[ClusterInstFieldReservationEndedAt] = struct{}{}
	}
	if m.MultiTenant != o.MultiTenant {
		fields[ClusterInstFieldMultiTenant] = struct{}{}
	}
}

var UpdateClusterInstFieldsMap = map[string]struct{}{
	ClusterInstFieldCrmOverride:               struct{}{},
	ClusterInstFieldNumNodes:                  struct{}{},
	ClusterInstFieldAutoScalePolicy:           struct{}{},
	ClusterInstFieldSkipCrmCleanupOnFailure:   struct{}{},
	ClusterInstFieldReservationEndedAt:        struct{}{},
	ClusterInstFieldReservationEndedAtSeconds: struct{}{},
	ClusterInstFieldReservationEndedAtNanos:   struct{}{},
	ClusterInstFieldMultiTenant:               struct{}{},
}

func (m *ClusterInst) ValidateUpdateFields() error {
	if m.Fields == nil {
		return fmt.Errorf("nothing specified to update")
	}
	fmap := MakeFieldMap(m.Fields)
	badFieldStrs := []string{}
	for field, _ := range fmap {
		if m.IsKeyField(field) {
			continue
		}
		if _, ok := UpdateClusterInstFieldsMap[field]; !ok {
			if _, ok := ClusterInstAllFieldsStringMap[field]; !ok {
				continue
			}
			badFieldStrs = append(badFieldStrs, ClusterInstAllFieldsStringMap[field])
		}
	}
	if len(badFieldStrs) > 0 {
		return fmt.Errorf("specified field(s) %s cannot be modified", strings.Join(badFieldStrs, ","))
	}
	return nil
}

func (m *ClusterInst) CopyInFields(src *ClusterInst) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if _, set := fmap["2.1.1"]; set {
				if m.Key.ClusterKey.Name != src.Key.ClusterKey.Name {
					m.Key.ClusterKey.Name = src.Key.ClusterKey.Name
					changed++
				}
			}
		}
		if _, set := fmap["2.2"]; set {
			if _, set := fmap["2.2.1"]; set {
				if m.Key.CloudletKey.Organization != src.Key.CloudletKey.Organization {
					m.Key.CloudletKey.Organization = src.Key.CloudletKey.Organization
					changed++
				}
			}
			if _, set := fmap["2.2.2"]; set {
				if m.Key.CloudletKey.Name != src.Key.CloudletKey.Name {
					m.Key.CloudletKey.Name = src.Key.CloudletKey.Name
					changed++
				}
			}
		}
		if _, set := fmap["2.3"]; set {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
	}
	if _, set := fmap["3"]; set {
		if _, set := fmap["3.1"]; set {
			if m.Flavor.Name != src.Flavor.Name {
				m.Flavor.Name = src.Flavor.Name
				changed++
			}
		}
	}
	if _, set := fmap["4"]; set {
		if m.State != src.State {
			m.State = src.State
			changed++
		}
	}
	if _, set := fmap["5"]; set {
		if src.Errors != nil {
			m.Errors = src.Errors
			changed++
		} else if m.Errors != nil {
			m.Errors = nil
			changed++
		}
	}
	if _, set := fmap["6"]; set {
		if m.CrmOverride != src.CrmOverride {
			m.CrmOverride = src.CrmOverride
			changed++
		}
	}
	if _, set := fmap["7"]; set {
		if m.IpAccess != src.IpAccess {
			m.IpAccess = src.IpAccess
			changed++
		}
	}
	if _, set := fmap["8"]; set {
		if m.AllocatedIp != src.AllocatedIp {
			m.AllocatedIp = src.AllocatedIp
			changed++
		}
	}
	if _, set := fmap["9"]; set {
		if m.Liveness != src.Liveness {
			m.Liveness = src.Liveness
			changed++
		}
	}
	if _, set := fmap["10"]; set {
		if m.Auto != src.Auto {
			m.Auto = src.Auto
			changed++
		}
	}
	if _, set := fmap["11"]; set {
		if m.NodeFlavor != src.NodeFlavor {
			m.NodeFlavor = src.NodeFlavor
			changed++
		}
	}
	if _, set := fmap["13"]; set {
		if m.NumMasters != src.NumMasters {
			m.NumMasters = src.NumMasters
			changed++
		}
	}
	if _, set := fmap["14"]; set {
		if m.NumNodes != src.NumNodes {
			m.NumNodes = src.NumNodes
			changed++
		}
	}
	if _, set := fmap["15"]; set {
		if m.Deployment != src.Deployment {
			m.Deployment = src.Deployment
			changed++
		}
	}
	if _, set := fmap["16"]; set {
		if _, set := fmap["16.1"]; set {
			if m.Status.TaskNumber != src.Status.TaskNumber {
				m.Status.TaskNumber = src.Status.TaskNumber
				changed++
			}
		}
		if _, set := fmap["16.2"]; set {
			if m.Status.MaxTasks != src.Status.MaxTasks {
				m.Status.MaxTasks = src.Status.MaxTasks
				changed++
			}
		}
		if _, set := fmap["16.3"]; set {
			if m.Status.TaskName != src.Status.TaskName {
				m.Status.TaskName = src.Status.TaskName
				changed++
			}
		}
		if _, set := fmap["16.4"]; set {
			if m.Status.StepName != src.Status.StepName {
				m.Status.StepName = src.Status.StepName
				changed++
			}
		}
		if _, set := fmap["16.5"]; set {
			if m.Status.MsgCount != src.Status.MsgCount {
				m.Status.MsgCount = src.Status.MsgCount
				changed++
			}
		}
		if _, set := fmap["16.6"]; set {
			if src.Status.Msgs != nil {
				m.Status.Msgs = src.Status.Msgs
				changed++
			} else if m.Status.Msgs != nil {
				m.Status.Msgs = nil
				changed++
			}
		}
	}
	if _, set := fmap["17"]; set {
		if m.ExternalVolumeSize != src.ExternalVolumeSize {
			m.ExternalVolumeSize = src.ExternalVolumeSize
			changed++
		}
	}
	if _, set := fmap["18"]; set {
		if m.AutoScalePolicy != src.AutoScalePolicy {
			m.AutoScalePolicy = src.AutoScalePolicy
			changed++
		}
	}
	if _, set := fmap["19"]; set {
		if m.AvailabilityZone != src.AvailabilityZone {
			m.AvailabilityZone = src.AvailabilityZone
			changed++
		}
	}
	if _, set := fmap["20"]; set {
		if m.ImageName != src.ImageName {
			m.ImageName = src.ImageName
			changed++
		}
	}
	if _, set := fmap["21"]; set {
		if m.Reservable != src.Reservable {
			m.Reservable = src.Reservable
			changed++
		}
	}
	if _, set := fmap["22"]; set {
		if m.ReservedBy != src.ReservedBy {
			m.ReservedBy = src.ReservedBy
			changed++
		}
	}
	if _, set := fmap["23"]; set {
		if m.SharedVolumeSize != src.SharedVolumeSize {
			m.SharedVolumeSize = src.SharedVolumeSize
			changed++
		}
	}
	if _, set := fmap["25"]; set {
		if m.MasterNodeFlavor != src.MasterNodeFlavor {
			m.MasterNodeFlavor = src.MasterNodeFlavor
			changed++
		}
	}
	if _, set := fmap["26"]; set {
		if m.SkipCrmCleanupOnFailure != src.SkipCrmCleanupOnFailure {
			m.SkipCrmCleanupOnFailure = src.SkipCrmCleanupOnFailure
			changed++
		}
	}
	if _, set := fmap["27"]; set {
		if m.OptRes != src.OptRes {
			m.OptRes = src.OptRes
			changed++
		}
	}
	if _, set := fmap["28"]; set {
		if _, set := fmap["28.1"]; set {
			if src.Resources.Vms != nil {
				m.Resources.Vms = src.Resources.Vms
				changed++
			} else if m.Resources.Vms != nil {
				m.Resources.Vms = nil
				changed++
			}
		}
	}
	if _, set := fmap["29"]; set {
		if _, set := fmap["29.1"]; set {
			if m.CreatedAt.Seconds != src.CreatedAt.Seconds {
				m.CreatedAt.Seconds = src.CreatedAt.Seconds
				changed++
			}
		}
		if _, set := fmap["29.2"]; set {
			if m.CreatedAt.Nanos != src.CreatedAt.Nanos {
				m.CreatedAt.Nanos = src.CreatedAt.Nanos
				changed++
			}
		}
	}
	if _, set := fmap["30"]; set {
		if _, set := fmap["30.1"]; set {
			if m.UpdatedAt.Seconds != src.UpdatedAt.Seconds {
				m.UpdatedAt.Seconds = src.UpdatedAt.Seconds
				changed++
			}
		}
		if _, set := fmap["30.2"]; set {
			if m.UpdatedAt.Nanos != src.UpdatedAt.Nanos {
				m.UpdatedAt.Nanos = src.UpdatedAt.Nanos
				changed++
			}
		}
	}
	if _, set := fmap["31"]; set {
		if _, set := fmap["31.1"]; set {
			if m.ReservationEndedAt.Seconds != src.ReservationEndedAt.Seconds {
				m.ReservationEndedAt.Seconds = src.ReservationEndedAt.Seconds
				changed++
			}
		}
		if _, set := fmap["31.2"]; set {
			if m.ReservationEndedAt.Nanos != src.ReservationEndedAt.Nanos {
				m.ReservationEndedAt.Nanos = src.ReservationEndedAt.Nanos
				changed++
			}
		}
	}
	if _, set := fmap["32"]; set {
		if m.MultiTenant != src.MultiTenant {
			m.MultiTenant = src.MultiTenant
			changed++
		}
	}
	return changed
}

func (m *ClusterInst) DeepCopyIn(src *ClusterInst) {
	m.Key.DeepCopyIn(&src.Key)
	m.Flavor.DeepCopyIn(&src.Flavor)
	m.State = src.State
	if src.Errors != nil {
		m.Errors = make([]string, len(src.Errors), len(src.Errors))
		for ii, s := range src.Errors {
			m.Errors[ii] = s
		}
	} else {
		m.Errors = nil
	}
	m.CrmOverride = src.CrmOverride
	m.IpAccess = src.IpAccess
	m.AllocatedIp = src.AllocatedIp
	m.Liveness = src.Liveness
	m.Auto = src.Auto
	m.NodeFlavor = src.NodeFlavor
	m.NumMasters = src.NumMasters
	m.NumNodes = src.NumNodes
	m.Deployment = src.Deployment
	m.Status.DeepCopyIn(&src.Status)
	m.ExternalVolumeSize = src.ExternalVolumeSize
	m.AutoScalePolicy = src.AutoScalePolicy
	m.AvailabilityZone = src.AvailabilityZone
	m.ImageName = src.ImageName
	m.Reservable = src.Reservable
	m.ReservedBy = src.ReservedBy
	m.SharedVolumeSize = src.SharedVolumeSize
	m.MasterNodeFlavor = src.MasterNodeFlavor
	m.SkipCrmCleanupOnFailure = src.SkipCrmCleanupOnFailure
	m.OptRes = src.OptRes
	m.Resources.DeepCopyIn(&src.Resources)
	m.CreatedAt = src.CreatedAt
	m.UpdatedAt = src.UpdatedAt
	m.ReservationEndedAt = src.ReservationEndedAt
	m.MultiTenant = src.MultiTenant
}

func (s *ClusterInst) HasFields() bool {
	return true
}

type ClusterInstStore struct {
	kvstore objstore.KVStore
}

func NewClusterInstStore(kvstore objstore.KVStore) ClusterInstStore {
	return ClusterInstStore{kvstore: kvstore}
}

func (s *ClusterInstStore) Create(ctx context.Context, m *ClusterInst, wait func(int64)) (*Result, error) {
	err := m.Validate(ClusterInstAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("ClusterInst", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *ClusterInstStore) Update(ctx context.Context, m *ClusterInst, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("ClusterInst", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur ClusterInst
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *ClusterInstStore) Put(ctx context.Context, m *ClusterInst, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(ClusterInstAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("ClusterInst", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *ClusterInstStore) Delete(ctx context.Context, m *ClusterInst, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("ClusterInst", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *ClusterInstStore) LoadOne(key string) (*ClusterInst, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj ClusterInst
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse ClusterInst data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *ClusterInstStore) STMGet(stm concurrency.STM, key *ClusterInstKey, buf *ClusterInst) bool {
	keystr := objstore.DbKeyString("ClusterInst", key)
	valstr := stm.Get(keystr)
	if valstr == "" {
		return false
	}
	if buf != nil {
		err := json.Unmarshal([]byte(valstr), buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *ClusterInstStore) STMPut(stm concurrency.STM, obj *ClusterInst, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("ClusterInst", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("ClusterInst json marsahal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *ClusterInstStore) STMDel(stm concurrency.STM, key *ClusterInstKey) {
	keystr := objstore.DbKeyString("ClusterInst", key)
	stm.Del(keystr)
}

type ClusterInstKeyWatcher struct {
	cb func(ctx context.Context)
}

type ClusterInstCacheData struct {
	Obj    *ClusterInst
	ModRev int64
}

// ClusterInstCache caches ClusterInst objects in memory in a hash table
// and keeps them in sync with the database.
type ClusterInstCache struct {
	Objs          map[ClusterInstKey]*ClusterInstCacheData
	Mux           util.Mutex
	List          map[ClusterInstKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *ClusterInstKey, old *ClusterInst, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *ClusterInst, new *ClusterInst)
	DeletedCbs    []func(ctx context.Context, old *ClusterInst)
	KeyWatchers   map[ClusterInstKey][]*ClusterInstKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *ClusterInstKey)
	DeletedKeyCbs []func(ctx context.Context, key *ClusterInstKey)
}

func NewClusterInstCache() *ClusterInstCache {
	cache := ClusterInstCache{}
	InitClusterInstCache(&cache)
	return &cache
}

func InitClusterInstCache(cache *ClusterInstCache) {
	cache.Objs = make(map[ClusterInstKey]*ClusterInstCacheData)
	cache.KeyWatchers = make(map[ClusterInstKey][]*ClusterInstKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *ClusterInstCache) GetTypeString() string {
	return "ClusterInst"
}

func (c *ClusterInstCache) Get(key *ClusterInstKey, valbuf *ClusterInst) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *ClusterInstCache) GetWithRev(key *ClusterInstKey, valbuf *ClusterInst, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *ClusterInstCache) HasKey(key *ClusterInstKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *ClusterInstCache) GetAllKeys(ctx context.Context, cb func(key *ClusterInstKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *ClusterInstCache) Update(ctx context.Context, in *ClusterInst, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *ClusterInst) (*ClusterInst, bool) {
		return in, true
	})
}

func (c *ClusterInstCache) UpdateModFunc(ctx context.Context, key *ClusterInstKey, modRev int64, modFunc func(old *ClusterInst) (new *ClusterInst, changed bool)) {
	c.Mux.Lock()
	var old *ClusterInst
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	for _, cb := range c.UpdatedCbs {
		newCopy := &ClusterInst{}
		newCopy.DeepCopyIn(new)
		defer cb(ctx, old, newCopy)
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			defer cb(ctx, new.GetKey(), old, modRev)
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &ClusterInst{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &ClusterInstCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *ClusterInstCache) Delete(ctx context.Context, in *ClusterInst, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *ClusterInst) bool {
		return true
	})
}

func (c *ClusterInstCache) DeleteCondFunc(ctx context.Context, in *ClusterInst, modRev int64, condFunc func(old *ClusterInst) bool) {
	c.Mux.Lock()
	var old *ClusterInst
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	c.Mux.Unlock()
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, in.GetKey(), old, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *ClusterInstCache) Prune(ctx context.Context, validKeys map[ClusterInstKey]struct{}) {
	notify := make(map[ClusterInstKey]*ClusterInstCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, old.Obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *ClusterInstCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *ClusterInstCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *ClusterInstCache) Show(filter *ClusterInst, cb func(ret *ClusterInst) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func ClusterInstGenericNotifyCb(fn func(key *ClusterInstKey, old *ClusterInst)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*ClusterInstKey), obj.(*ClusterInst))
	}
}

func (c *ClusterInstCache) SetNotifyCb(fn func(ctx context.Context, obj *ClusterInstKey, old *ClusterInst, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *ClusterInstKey, old *ClusterInst, modRev int64){fn}
}

func (c *ClusterInstCache) SetUpdatedCb(fn func(ctx context.Context, old *ClusterInst, new *ClusterInst)) {
	c.UpdatedCbs = []func(ctx context.Context, old *ClusterInst, new *ClusterInst){fn}
}

func (c *ClusterInstCache) SetDeletedCb(fn func(ctx context.Context, old *ClusterInst)) {
	c.DeletedCbs = []func(ctx context.Context, old *ClusterInst){fn}
}

func (c *ClusterInstCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *ClusterInstKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *ClusterInstKey){fn}
}

func (c *ClusterInstCache) SetDeletedKeyCb(fn func(ctx context.Context, key *ClusterInstKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *ClusterInstKey){fn}
}

func (c *ClusterInstCache) AddUpdatedCb(fn func(ctx context.Context, old *ClusterInst, new *ClusterInst)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *ClusterInstCache) AddDeletedCb(fn func(ctx context.Context, old *ClusterInst)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *ClusterInstCache) AddNotifyCb(fn func(ctx context.Context, obj *ClusterInstKey, old *ClusterInst, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *ClusterInstCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *ClusterInstKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *ClusterInstCache) AddDeletedKeyCb(fn func(ctx context.Context, key *ClusterInstKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *ClusterInstCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *ClusterInstCache) WatchKey(key *ClusterInstKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*ClusterInstKeyWatcher, 0)
	}
	watcher := ClusterInstKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching ClusterInst", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *ClusterInstCache) TriggerKeyWatchers(ctx context.Context, key *ClusterInstKey) {
	watchers := make([]*ClusterInstKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *ClusterInstCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := ClusterInst{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse ClusterInst data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *ClusterInstCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := ClusterInst{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	ClusterInstKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *ClusterInstCache) SyncListStart(ctx context.Context) {
	c.List = make(map[ClusterInstKey]struct{})
}

func (c *ClusterInstCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[ClusterInstKey]*ClusterInstCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, val.Obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *ClusterInstCache) WaitForState(ctx context.Context, key *ClusterInstKey, targetState TrackedState, transitionStates map[TrackedState]struct{}, errorState TrackedState, timeout time.Duration, successMsg string, send func(*Result) error, opts ...WaitStateOps) error {
	curState := TrackedState_TRACKED_STATE_UNKNOWN
	done := make(chan string, 1)
	failed := make(chan bool, 1)
	var lastMsgCnt int
	var err error

	var wSpec WaitStateSpec
	for _, op := range opts {
		if err := op(&wSpec); err != nil {
			return err
		}
	}

	var streamCancel context.CancelFunc
	if wSpec.StreamCache != nil {
		checkStreamMsg := func() {
			streamObj := StreamObj{}
			if !wSpec.StreamCache.Get(wSpec.StreamKey, &streamObj) {
				return
			}
			if len(streamObj.Status.Msgs) > 0 || streamObj.Status.MsgCount > 0 {
				if lastMsgCnt < int(streamObj.Status.MsgCount) {
					for ii := 0; ii < len(streamObj.Status.Msgs); ii++ {
						send(&Result{Message: streamObj.Status.Msgs[ii]})
						lastMsgCnt++
					}
				}
			}
		}

		streamCancel = wSpec.StreamCache.WatchKey(wSpec.StreamKey, func(ctx context.Context) {
			checkStreamMsg()
		})

		// After setting up watch, check if any status messages were received in the meantime
		checkStreamMsg()
	}

	cancel := c.WatchKey(key, func(ctx context.Context) {
		info := ClusterInst{}
		if c.Get(key, &info) {
			curState = info.State
		} else {
			curState = TrackedState_NOT_PRESENT
		}
		log.SpanLog(ctx, log.DebugLevelApi, "Watch event for ClusterInst", "key", key, "state", TrackedState_CamelName[int32(curState)])
		if curState == errorState {
			failed <- true
		} else if curState == targetState {
			msg := ""
			if curState == TrackedState_NOT_PRESENT {
				msg = TrackedState_CamelName[int32(curState)]
			}
			done <- msg
		}
	})
	// After setting up watch, check current state,
	// as it may have already changed to target state
	info := ClusterInst{}
	if c.Get(key, &info) {
		curState = info.State
	} else {
		curState = TrackedState_NOT_PRESENT
	}
	if curState == targetState {
		msg := ""
		if curState == TrackedState_NOT_PRESENT {
			msg = TrackedState_CamelName[int32(curState)]
		}
		done <- msg
	}

	select {
	case doneMsg := <-done:
		if doneMsg != "" {
			send(&Result{Message: doneMsg})
		}
		err = nil
		if successMsg != "" && send != nil {
			send(&Result{Message: successMsg})
		}
	case <-failed:
		if c.Get(key, &info) {
			errs := strings.Join(info.Errors, ", ")
			err = fmt.Errorf("Encountered failures: %s", errs)
		} else {
			// this shouldn't happen, since only way to get here
			// is if info state is set to Error
			err = errors.New("Unknown failure")
		}
	case <-time.After(timeout):
		hasInfo := c.Get(key, &info)
		if hasInfo && info.State == errorState {
			// error may have been sent back before watch started
			errs := strings.Join(info.Errors, ", ")
			err = fmt.Errorf("Encountered failures: %s", errs)
		} else if _, found := transitionStates[info.State]; hasInfo && found {
			// no success response, but state is a valid transition
			// state. That means work is still in progress.
			// Notify user that this is not an error.
			// Do not undo since CRM is still busy.
			if send != nil {
				msg := fmt.Sprintf("Timed out while work still in progress state %s. Please use ShowClusterInst to check current status", TrackedState_CamelName[int32(info.State)])
				send(&Result{Message: msg})
			}
			err = nil
		} else {
			err = fmt.Errorf("Timed out; expected state %s but is %s",
				TrackedState_CamelName[int32(targetState)],
				TrackedState_CamelName[int32(curState)])
		}
	}
	cancel()
	if streamCancel != nil {
		streamCancel()
	}
	// note: do not close done/failed, garbage collector will deal with it.
	return err
}

func (m *ClusterInst) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *ClusterInst) GetKey() *ClusterInstKey {
	return &m.Key
}

func (m *ClusterInst) GetKeyVal() ClusterInstKey {
	return m.Key
}

func (m *ClusterInst) SetKey(key *ClusterInstKey) {
	m.Key = *key
}

func CmpSortClusterInst(a ClusterInst, b ClusterInst) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *ClusterInst) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if err := m.Flavor.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := TrackedState_name[int32(m.State)]; !ok {
		return errors.New("invalid State")
	}
	if _, ok := CRMOverride_name[int32(m.CrmOverride)]; !ok {
		return errors.New("invalid CrmOverride")
	}
	if _, ok := IpAccess_name[int32(m.IpAccess)]; !ok {
		return errors.New("invalid IpAccess")
	}
	if _, ok := Liveness_name[int32(m.Liveness)]; !ok {
		return errors.New("invalid Liveness")
	}
	if err := m.Status.ValidateEnums(); err != nil {
		return err
	}
	if err := m.Resources.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func IgnoreClusterInstFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "State")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Errors")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "CrmOverride")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "AllocatedIp")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "NodeFlavor")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Status")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "ExternalVolumeSize")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "ImageName")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "MasterNodeFlavor")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "SkipCrmCleanupOnFailure")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "OptRes")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Resources")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "CreatedAt")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "UpdatedAt")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "ReservationEndedAt")
	}
	return cmpopts.IgnoreFields(ClusterInst{}, names...)
}

func (m *IdleReservableClusterInsts) CopyInFields(src *IdleReservableClusterInsts) int {
	changed := 0
	if m.IdleTime != src.IdleTime {
		m.IdleTime = src.IdleTime
		changed++
	}
	return changed
}

func (m *IdleReservableClusterInsts) DeepCopyIn(src *IdleReservableClusterInsts) {
	m.IdleTime = src.IdleTime
}

// Helper method to check that enums have valid values
func (m *IdleReservableClusterInsts) ValidateEnums() error {
	return nil
}

func (m *ClusterInstInfo) Matches(o *ClusterInstInfo, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.NotifyId != 0 {
		if o.NotifyId != m.NotifyId {
			return false
		}
	}
	if !opts.Filter || o.State != 0 {
		if o.State != m.State {
			return false
		}
	}
	if !opts.Filter || o.Errors != nil {
		if len(m.Errors) == 0 && len(o.Errors) > 0 || len(m.Errors) > 0 && len(o.Errors) == 0 {
			return false
		} else if m.Errors != nil && o.Errors != nil {
			if !opts.Filter && len(m.Errors) != len(o.Errors) {
				return false
			}
			found := 0
			for oIndex, _ := range o.Errors {
				for mIndex, _ := range m.Errors {
					if o.Errors[oIndex] == m.Errors[mIndex] {
						found++
						break
					}
				}
			}
			if found != len(o.Errors) {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
	}
	return true
}

const ClusterInstInfoFieldKey = "2"
const ClusterInstInfoFieldKeyClusterKey = "2.1"
const ClusterInstInfoFieldKeyClusterKeyName = "2.1.1"
const ClusterInstInfoFieldKeyCloudletKey = "2.2"
const ClusterInstInfoFieldKeyCloudletKeyOrganization = "2.2.1"
const ClusterInstInfoFieldKeyCloudletKeyName = "2.2.2"
const ClusterInstInfoFieldKeyOrganization = "2.3"
const ClusterInstInfoFieldNotifyId = "3"
const ClusterInstInfoFieldState = "4"
const ClusterInstInfoFieldErrors = "5"
const ClusterInstInfoFieldStatus = "6"
const ClusterInstInfoFieldStatusTaskNumber = "6.1"
const ClusterInstInfoFieldStatusMaxTasks = "6.2"
const ClusterInstInfoFieldStatusTaskName = "6.3"
const ClusterInstInfoFieldStatusStepName = "6.4"
const ClusterInstInfoFieldStatusMsgCount = "6.5"
const ClusterInstInfoFieldStatusMsgs = "6.6"
const ClusterInstInfoFieldResources = "7"
const ClusterInstInfoFieldResourcesVms = "7.1"
const ClusterInstInfoFieldResourcesVmsName = "7.1.1"
const ClusterInstInfoFieldResourcesVmsType = "7.1.2"
const ClusterInstInfoFieldResourcesVmsStatus = "7.1.3"
const ClusterInstInfoFieldResourcesVmsInfraFlavor = "7.1.4"
const ClusterInstInfoFieldResourcesVmsIpaddresses = "7.1.5"
const ClusterInstInfoFieldResourcesVmsIpaddressesExternalIp = "7.1.5.1"
const ClusterInstInfoFieldResourcesVmsIpaddressesInternalIp = "7.1.5.2"
const ClusterInstInfoFieldResourcesVmsContainers = "7.1.6"
const ClusterInstInfoFieldResourcesVmsContainersName = "7.1.6.1"
const ClusterInstInfoFieldResourcesVmsContainersType = "7.1.6.2"
const ClusterInstInfoFieldResourcesVmsContainersStatus = "7.1.6.3"
const ClusterInstInfoFieldResourcesVmsContainersClusterip = "7.1.6.4"
const ClusterInstInfoFieldResourcesVmsContainersRestarts = "7.1.6.5"

var ClusterInstInfoAllFields = []string{
	ClusterInstInfoFieldKeyClusterKeyName,
	ClusterInstInfoFieldKeyCloudletKeyOrganization,
	ClusterInstInfoFieldKeyCloudletKeyName,
	ClusterInstInfoFieldKeyOrganization,
	ClusterInstInfoFieldNotifyId,
	ClusterInstInfoFieldState,
	ClusterInstInfoFieldErrors,
	ClusterInstInfoFieldStatusTaskNumber,
	ClusterInstInfoFieldStatusMaxTasks,
	ClusterInstInfoFieldStatusTaskName,
	ClusterInstInfoFieldStatusStepName,
	ClusterInstInfoFieldStatusMsgCount,
	ClusterInstInfoFieldStatusMsgs,
	ClusterInstInfoFieldResourcesVmsName,
	ClusterInstInfoFieldResourcesVmsType,
	ClusterInstInfoFieldResourcesVmsStatus,
	ClusterInstInfoFieldResourcesVmsInfraFlavor,
	ClusterInstInfoFieldResourcesVmsIpaddressesExternalIp,
	ClusterInstInfoFieldResourcesVmsIpaddressesInternalIp,
	ClusterInstInfoFieldResourcesVmsContainersName,
	ClusterInstInfoFieldResourcesVmsContainersType,
	ClusterInstInfoFieldResourcesVmsContainersStatus,
	ClusterInstInfoFieldResourcesVmsContainersClusterip,
	ClusterInstInfoFieldResourcesVmsContainersRestarts,
}

var ClusterInstInfoAllFieldsMap = map[string]struct{}{
	ClusterInstInfoFieldKeyClusterKeyName:                 struct{}{},
	ClusterInstInfoFieldKeyCloudletKeyOrganization:        struct{}{},
	ClusterInstInfoFieldKeyCloudletKeyName:                struct{}{},
	ClusterInstInfoFieldKeyOrganization:                   struct{}{},
	ClusterInstInfoFieldNotifyId:                          struct{}{},
	ClusterInstInfoFieldState:                             struct{}{},
	ClusterInstInfoFieldErrors:                            struct{}{},
	ClusterInstInfoFieldStatusTaskNumber:                  struct{}{},
	ClusterInstInfoFieldStatusMaxTasks:                    struct{}{},
	ClusterInstInfoFieldStatusTaskName:                    struct{}{},
	ClusterInstInfoFieldStatusStepName:                    struct{}{},
	ClusterInstInfoFieldStatusMsgCount:                    struct{}{},
	ClusterInstInfoFieldStatusMsgs:                        struct{}{},
	ClusterInstInfoFieldResourcesVmsName:                  struct{}{},
	ClusterInstInfoFieldResourcesVmsType:                  struct{}{},
	ClusterInstInfoFieldResourcesVmsStatus:                struct{}{},
	ClusterInstInfoFieldResourcesVmsInfraFlavor:           struct{}{},
	ClusterInstInfoFieldResourcesVmsIpaddressesExternalIp: struct{}{},
	ClusterInstInfoFieldResourcesVmsIpaddressesInternalIp: struct{}{},
	ClusterInstInfoFieldResourcesVmsContainersName:        struct{}{},
	ClusterInstInfoFieldResourcesVmsContainersType:        struct{}{},
	ClusterInstInfoFieldResourcesVmsContainersStatus:      struct{}{},
	ClusterInstInfoFieldResourcesVmsContainersClusterip:   struct{}{},
	ClusterInstInfoFieldResourcesVmsContainersRestarts:    struct{}{},
}

var ClusterInstInfoAllFieldsStringMap = map[string]string{
	ClusterInstInfoFieldKeyClusterKeyName:                 "Key Cluster Key Name",
	ClusterInstInfoFieldKeyCloudletKeyOrganization:        "Key Cloudlet Key Organization",
	ClusterInstInfoFieldKeyCloudletKeyName:                "Key Cloudlet Key Name",
	ClusterInstInfoFieldKeyOrganization:                   "Key Organization",
	ClusterInstInfoFieldNotifyId:                          "Notify Id",
	ClusterInstInfoFieldState:                             "State",
	ClusterInstInfoFieldErrors:                            "Errors",
	ClusterInstInfoFieldStatusTaskNumber:                  "Status Task Number",
	ClusterInstInfoFieldStatusMaxTasks:                    "Status Max Tasks",
	ClusterInstInfoFieldStatusTaskName:                    "Status Task Name",
	ClusterInstInfoFieldStatusStepName:                    "Status Step Name",
	ClusterInstInfoFieldStatusMsgCount:                    "Status Msg Count",
	ClusterInstInfoFieldStatusMsgs:                        "Status Msgs",
	ClusterInstInfoFieldResourcesVmsName:                  "Resources Vms Name",
	ClusterInstInfoFieldResourcesVmsType:                  "Resources Vms Type",
	ClusterInstInfoFieldResourcesVmsStatus:                "Resources Vms Status",
	ClusterInstInfoFieldResourcesVmsInfraFlavor:           "Resources Vms Infra Flavor",
	ClusterInstInfoFieldResourcesVmsIpaddressesExternalIp: "Resources Vms Ipaddresses External Ip",
	ClusterInstInfoFieldResourcesVmsIpaddressesInternalIp: "Resources Vms Ipaddresses Internal Ip",
	ClusterInstInfoFieldResourcesVmsContainersName:        "Resources Vms Containers Name",
	ClusterInstInfoFieldResourcesVmsContainersType:        "Resources Vms Containers Type",
	ClusterInstInfoFieldResourcesVmsContainersStatus:      "Resources Vms Containers Status",
	ClusterInstInfoFieldResourcesVmsContainersClusterip:   "Resources Vms Containers Clusterip",
	ClusterInstInfoFieldResourcesVmsContainersRestarts:    "Resources Vms Containers Restarts",
}

func (m *ClusterInstInfo) IsKeyField(s string) bool {
	return strings.HasPrefix(s, ClusterInstInfoFieldKey+".") || s == ClusterInstInfoFieldKey
}

func (m *ClusterInstInfo) DiffFields(o *ClusterInstInfo, fields map[string]struct{}) {
	if m.Key.ClusterKey.Name != o.Key.ClusterKey.Name {
		fields[ClusterInstInfoFieldKeyClusterKeyName] = struct{}{}
		fields[ClusterInstInfoFieldKeyClusterKey] = struct{}{}
		fields[ClusterInstInfoFieldKey] = struct{}{}
	}
	if m.Key.CloudletKey.Organization != o.Key.CloudletKey.Organization {
		fields[ClusterInstInfoFieldKeyCloudletKeyOrganization] = struct{}{}
		fields[ClusterInstInfoFieldKeyCloudletKey] = struct{}{}
		fields[ClusterInstInfoFieldKey] = struct{}{}
	}
	if m.Key.CloudletKey.Name != o.Key.CloudletKey.Name {
		fields[ClusterInstInfoFieldKeyCloudletKeyName] = struct{}{}
		fields[ClusterInstInfoFieldKeyCloudletKey] = struct{}{}
		fields[ClusterInstInfoFieldKey] = struct{}{}
	}
	if m.Key.Organization != o.Key.Organization {
		fields[ClusterInstInfoFieldKeyOrganization] = struct{}{}
		fields[ClusterInstInfoFieldKey] = struct{}{}
	}
	if m.NotifyId != o.NotifyId {
		fields[ClusterInstInfoFieldNotifyId] = struct{}{}
	}
	if m.State != o.State {
		fields[ClusterInstInfoFieldState] = struct{}{}
	}
	if len(m.Errors) != len(o.Errors) {
		fields[ClusterInstInfoFieldErrors] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.Errors); i0++ {
			if m.Errors[i0] != o.Errors[i0] {
				fields[ClusterInstInfoFieldErrors] = struct{}{}
				break
			}
		}
	}
	if m.Status.TaskNumber != o.Status.TaskNumber {
		fields[ClusterInstInfoFieldStatusTaskNumber] = struct{}{}
		fields[ClusterInstInfoFieldStatus] = struct{}{}
	}
	if m.Status.MaxTasks != o.Status.MaxTasks {
		fields[ClusterInstInfoFieldStatusMaxTasks] = struct{}{}
		fields[ClusterInstInfoFieldStatus] = struct{}{}
	}
	if m.Status.TaskName != o.Status.TaskName {
		fields[ClusterInstInfoFieldStatusTaskName] = struct{}{}
		fields[ClusterInstInfoFieldStatus] = struct{}{}
	}
	if m.Status.StepName != o.Status.StepName {
		fields[ClusterInstInfoFieldStatusStepName] = struct{}{}
		fields[ClusterInstInfoFieldStatus] = struct{}{}
	}
	if m.Status.MsgCount != o.Status.MsgCount {
		fields[ClusterInstInfoFieldStatusMsgCount] = struct{}{}
		fields[ClusterInstInfoFieldStatus] = struct{}{}
	}
	if len(m.Status.Msgs) != len(o.Status.Msgs) {
		fields[ClusterInstInfoFieldStatusMsgs] = struct{}{}
		fields[ClusterInstInfoFieldStatus] = struct{}{}
	} else {
		for i1 := 0; i1 < len(m.Status.Msgs); i1++ {
			if m.Status.Msgs[i1] != o.Status.Msgs[i1] {
				fields[ClusterInstInfoFieldStatusMsgs] = struct{}{}
				fields[ClusterInstInfoFieldStatus] = struct{}{}
				break
			}
		}
	}
	if len(m.Resources.Vms) != len(o.Resources.Vms) {
		fields[ClusterInstInfoFieldResourcesVms] = struct{}{}
		fields[ClusterInstInfoFieldResources] = struct{}{}
	} else {
		for i1 := 0; i1 < len(m.Resources.Vms); i1++ {
			if m.Resources.Vms[i1].Name != o.Resources.Vms[i1].Name {
				fields[ClusterInstInfoFieldResourcesVmsName] = struct{}{}
				fields[ClusterInstInfoFieldResourcesVms] = struct{}{}
				fields[ClusterInstInfoFieldResources] = struct{}{}
			}
			if m.Resources.Vms[i1].Type != o.Resources.Vms[i1].Type {
				fields[ClusterInstInfoFieldResourcesVmsType] = struct{}{}
				fields[ClusterInstInfoFieldResourcesVms] = struct{}{}
				fields[ClusterInstInfoFieldResources] = struct{}{}
			}
			if m.Resources.Vms[i1].Status != o.Resources.Vms[i1].Status {
				fields[ClusterInstInfoFieldResourcesVmsStatus] = struct{}{}
				fields[ClusterInstInfoFieldResourcesVms] = struct{}{}
				fields[ClusterInstInfoFieldResources] = struct{}{}
			}
			if m.Resources.Vms[i1].InfraFlavor != o.Resources.Vms[i1].InfraFlavor {
				fields[ClusterInstInfoFieldResourcesVmsInfraFlavor] = struct{}{}
				fields[ClusterInstInfoFieldResourcesVms] = struct{}{}
				fields[ClusterInstInfoFieldResources] = struct{}{}
			}
			if len(m.Resources.Vms[i1].Ipaddresses) != len(o.Resources.Vms[i1].Ipaddresses) {
				fields[ClusterInstInfoFieldResourcesVmsIpaddresses] = struct{}{}
				fields[ClusterInstInfoFieldResourcesVms] = struct{}{}
				fields[ClusterInstInfoFieldResources] = struct{}{}
			} else {
				for i2 := 0; i2 < len(m.Resources.Vms[i1].Ipaddresses); i2++ {
					if m.Resources.Vms[i1].Ipaddresses[i2].ExternalIp != o.Resources.Vms[i1].Ipaddresses[i2].ExternalIp {
						fields[ClusterInstInfoFieldResourcesVmsIpaddressesExternalIp] = struct{}{}
						fields[ClusterInstInfoFieldResourcesVmsIpaddresses] = struct{}{}
						fields[ClusterInstInfoFieldResourcesVms] = struct{}{}
						fields[ClusterInstInfoFieldResources] = struct{}{}
					}
					if m.Resources.Vms[i1].Ipaddresses[i2].InternalIp != o.Resources.Vms[i1].Ipaddresses[i2].InternalIp {
						fields[ClusterInstInfoFieldResourcesVmsIpaddressesInternalIp] = struct{}{}
						fields[ClusterInstInfoFieldResourcesVmsIpaddresses] = struct{}{}
						fields[ClusterInstInfoFieldResourcesVms] = struct{}{}
						fields[ClusterInstInfoFieldResources] = struct{}{}
					}
				}
			}
			if m.Resources.Vms[i1].Containers != nil && o.Resources.Vms[i1].Containers != nil {
				if len(m.Resources.Vms[i1].Containers) != len(o.Resources.Vms[i1].Containers) {
					fields[ClusterInstInfoFieldResourcesVmsContainers] = struct{}{}
					fields[ClusterInstInfoFieldResourcesVms] = struct{}{}
					fields[ClusterInstInfoFieldResources] = struct{}{}
				} else {
					for i2 := 0; i2 < len(m.Resources.Vms[i1].Containers); i2++ {
						if m.Resources.Vms[i1].Containers[i2].Name != o.Resources.Vms[i1].Containers[i2].Name {
							fields[ClusterInstInfoFieldResourcesVmsContainersName] = struct{}{}
							fields[ClusterInstInfoFieldResourcesVmsContainers] = struct{}{}
							fields[ClusterInstInfoFieldResourcesVms] = struct{}{}
							fields[ClusterInstInfoFieldResources] = struct{}{}
						}
						if m.Resources.Vms[i1].Containers[i2].Type != o.Resources.Vms[i1].Containers[i2].Type {
							fields[ClusterInstInfoFieldResourcesVmsContainersType] = struct{}{}
							fields[ClusterInstInfoFieldResourcesVmsContainers] = struct{}{}
							fields[ClusterInstInfoFieldResourcesVms] = struct{}{}
							fields[ClusterInstInfoFieldResources] = struct{}{}
						}
						if m.Resources.Vms[i1].Containers[i2].Status != o.Resources.Vms[i1].Containers[i2].Status {
							fields[ClusterInstInfoFieldResourcesVmsContainersStatus] = struct{}{}
							fields[ClusterInstInfoFieldResourcesVmsContainers] = struct{}{}
							fields[ClusterInstInfoFieldResourcesVms] = struct{}{}
							fields[ClusterInstInfoFieldResources] = struct{}{}
						}
						if m.Resources.Vms[i1].Containers[i2].Clusterip != o.Resources.Vms[i1].Containers[i2].Clusterip {
							fields[ClusterInstInfoFieldResourcesVmsContainersClusterip] = struct{}{}
							fields[ClusterInstInfoFieldResourcesVmsContainers] = struct{}{}
							fields[ClusterInstInfoFieldResourcesVms] = struct{}{}
							fields[ClusterInstInfoFieldResources] = struct{}{}
						}
						if m.Resources.Vms[i1].Containers[i2].Restarts != o.Resources.Vms[i1].Containers[i2].Restarts {
							fields[ClusterInstInfoFieldResourcesVmsContainersRestarts] = struct{}{}
							fields[ClusterInstInfoFieldResourcesVmsContainers] = struct{}{}
							fields[ClusterInstInfoFieldResourcesVms] = struct{}{}
							fields[ClusterInstInfoFieldResources] = struct{}{}
						}
					}
				}
			} else if (m.Resources.Vms[i1].Containers != nil && o.Resources.Vms[i1].Containers == nil) || (m.Resources.Vms[i1].Containers == nil && o.Resources.Vms[i1].Containers != nil) {
				fields[ClusterInstInfoFieldResourcesVmsContainers] = struct{}{}
				fields[ClusterInstInfoFieldResourcesVms] = struct{}{}
				fields[ClusterInstInfoFieldResources] = struct{}{}
			}
		}
	}
}

func (m *ClusterInstInfo) CopyInFields(src *ClusterInstInfo) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if _, set := fmap["2.1.1"]; set {
				if m.Key.ClusterKey.Name != src.Key.ClusterKey.Name {
					m.Key.ClusterKey.Name = src.Key.ClusterKey.Name
					changed++
				}
			}
		}
		if _, set := fmap["2.2"]; set {
			if _, set := fmap["2.2.1"]; set {
				if m.Key.CloudletKey.Organization != src.Key.CloudletKey.Organization {
					m.Key.CloudletKey.Organization = src.Key.CloudletKey.Organization
					changed++
				}
			}
			if _, set := fmap["2.2.2"]; set {
				if m.Key.CloudletKey.Name != src.Key.CloudletKey.Name {
					m.Key.CloudletKey.Name = src.Key.CloudletKey.Name
					changed++
				}
			}
		}
		if _, set := fmap["2.3"]; set {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
	}
	if _, set := fmap["3"]; set {
		if m.NotifyId != src.NotifyId {
			m.NotifyId = src.NotifyId
			changed++
		}
	}
	if _, set := fmap["4"]; set {
		if m.State != src.State {
			m.State = src.State
			changed++
		}
	}
	if _, set := fmap["5"]; set {
		if src.Errors != nil {
			m.Errors = src.Errors
			changed++
		} else if m.Errors != nil {
			m.Errors = nil
			changed++
		}
	}
	if _, set := fmap["6"]; set {
		if _, set := fmap["6.1"]; set {
			if m.Status.TaskNumber != src.Status.TaskNumber {
				m.Status.TaskNumber = src.Status.TaskNumber
				changed++
			}
		}
		if _, set := fmap["6.2"]; set {
			if m.Status.MaxTasks != src.Status.MaxTasks {
				m.Status.MaxTasks = src.Status.MaxTasks
				changed++
			}
		}
		if _, set := fmap["6.3"]; set {
			if m.Status.TaskName != src.Status.TaskName {
				m.Status.TaskName = src.Status.TaskName
				changed++
			}
		}
		if _, set := fmap["6.4"]; set {
			if m.Status.StepName != src.Status.StepName {
				m.Status.StepName = src.Status.StepName
				changed++
			}
		}
		if _, set := fmap["6.5"]; set {
			if m.Status.MsgCount != src.Status.MsgCount {
				m.Status.MsgCount = src.Status.MsgCount
				changed++
			}
		}
		if _, set := fmap["6.6"]; set {
			if src.Status.Msgs != nil {
				m.Status.Msgs = src.Status.Msgs
				changed++
			} else if m.Status.Msgs != nil {
				m.Status.Msgs = nil
				changed++
			}
		}
	}
	if _, set := fmap["7"]; set {
		if _, set := fmap["7.1"]; set {
			if src.Resources.Vms != nil {
				m.Resources.Vms = src.Resources.Vms
				changed++
			} else if m.Resources.Vms != nil {
				m.Resources.Vms = nil
				changed++
			}
		}
	}
	return changed
}

func (m *ClusterInstInfo) DeepCopyIn(src *ClusterInstInfo) {
	m.Key.DeepCopyIn(&src.Key)
	m.NotifyId = src.NotifyId
	m.State = src.State
	if src.Errors != nil {
		m.Errors = make([]string, len(src.Errors), len(src.Errors))
		for ii, s := range src.Errors {
			m.Errors[ii] = s
		}
	} else {
		m.Errors = nil
	}
	m.Status.DeepCopyIn(&src.Status)
	m.Resources.DeepCopyIn(&src.Resources)
}

func (s *ClusterInstInfo) HasFields() bool {
	return true
}

type ClusterInstInfoStore struct {
	kvstore objstore.KVStore
}

func NewClusterInstInfoStore(kvstore objstore.KVStore) ClusterInstInfoStore {
	return ClusterInstInfoStore{kvstore: kvstore}
}

func (s *ClusterInstInfoStore) Create(ctx context.Context, m *ClusterInstInfo, wait func(int64)) (*Result, error) {
	err := m.Validate(ClusterInstInfoAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("ClusterInstInfo", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *ClusterInstInfoStore) Update(ctx context.Context, m *ClusterInstInfo, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("ClusterInstInfo", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur ClusterInstInfo
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *ClusterInstInfoStore) Put(ctx context.Context, m *ClusterInstInfo, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(ClusterInstInfoAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("ClusterInstInfo", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *ClusterInstInfoStore) Delete(ctx context.Context, m *ClusterInstInfo, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("ClusterInstInfo", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *ClusterInstInfoStore) LoadOne(key string) (*ClusterInstInfo, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj ClusterInstInfo
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse ClusterInstInfo data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *ClusterInstInfoStore) STMGet(stm concurrency.STM, key *ClusterInstKey, buf *ClusterInstInfo) bool {
	keystr := objstore.DbKeyString("ClusterInstInfo", key)
	valstr := stm.Get(keystr)
	if valstr == "" {
		return false
	}
	if buf != nil {
		err := json.Unmarshal([]byte(valstr), buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *ClusterInstInfoStore) STMPut(stm concurrency.STM, obj *ClusterInstInfo, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("ClusterInstInfo", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("ClusterInstInfo json marsahal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *ClusterInstInfoStore) STMDel(stm concurrency.STM, key *ClusterInstKey) {
	keystr := objstore.DbKeyString("ClusterInstInfo", key)
	stm.Del(keystr)
}

type ClusterInstInfoKeyWatcher struct {
	cb func(ctx context.Context)
}

type ClusterInstInfoCacheData struct {
	Obj    *ClusterInstInfo
	ModRev int64
}

// ClusterInstInfoCache caches ClusterInstInfo objects in memory in a hash table
// and keeps them in sync with the database.
type ClusterInstInfoCache struct {
	Objs          map[ClusterInstKey]*ClusterInstInfoCacheData
	Mux           util.Mutex
	List          map[ClusterInstKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *ClusterInstKey, old *ClusterInstInfo, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *ClusterInstInfo, new *ClusterInstInfo)
	DeletedCbs    []func(ctx context.Context, old *ClusterInstInfo)
	KeyWatchers   map[ClusterInstKey][]*ClusterInstInfoKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *ClusterInstKey)
	DeletedKeyCbs []func(ctx context.Context, key *ClusterInstKey)
}

func NewClusterInstInfoCache() *ClusterInstInfoCache {
	cache := ClusterInstInfoCache{}
	InitClusterInstInfoCache(&cache)
	return &cache
}

func InitClusterInstInfoCache(cache *ClusterInstInfoCache) {
	cache.Objs = make(map[ClusterInstKey]*ClusterInstInfoCacheData)
	cache.KeyWatchers = make(map[ClusterInstKey][]*ClusterInstInfoKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *ClusterInstInfoCache) GetTypeString() string {
	return "ClusterInstInfo"
}

func (c *ClusterInstInfoCache) Get(key *ClusterInstKey, valbuf *ClusterInstInfo) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *ClusterInstInfoCache) GetWithRev(key *ClusterInstKey, valbuf *ClusterInstInfo, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *ClusterInstInfoCache) HasKey(key *ClusterInstKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *ClusterInstInfoCache) GetAllKeys(ctx context.Context, cb func(key *ClusterInstKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *ClusterInstInfoCache) Update(ctx context.Context, in *ClusterInstInfo, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *ClusterInstInfo) (*ClusterInstInfo, bool) {
		return in, true
	})
}

func (c *ClusterInstInfoCache) UpdateModFunc(ctx context.Context, key *ClusterInstKey, modRev int64, modFunc func(old *ClusterInstInfo) (new *ClusterInstInfo, changed bool)) {
	c.Mux.Lock()
	var old *ClusterInstInfo
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	for _, cb := range c.UpdatedCbs {
		newCopy := &ClusterInstInfo{}
		newCopy.DeepCopyIn(new)
		defer cb(ctx, old, newCopy)
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			defer cb(ctx, new.GetKey(), old, modRev)
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &ClusterInstInfo{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &ClusterInstInfoCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *ClusterInstInfoCache) Delete(ctx context.Context, in *ClusterInstInfo, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *ClusterInstInfo) bool {
		return true
	})
}

func (c *ClusterInstInfoCache) DeleteCondFunc(ctx context.Context, in *ClusterInstInfo, modRev int64, condFunc func(old *ClusterInstInfo) bool) {
	c.Mux.Lock()
	var old *ClusterInstInfo
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	c.Mux.Unlock()
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, in.GetKey(), old, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *ClusterInstInfoCache) Prune(ctx context.Context, validKeys map[ClusterInstKey]struct{}) {
	notify := make(map[ClusterInstKey]*ClusterInstInfoCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, old.Obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *ClusterInstInfoCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *ClusterInstInfoCache) Flush(ctx context.Context, notifyId int64) {
	log.SpanLog(ctx, log.DebugLevelApi, "CacheFlush ClusterInstInfo", "notifyId", notifyId, "FlushAll", c.FlushAll)
	flushed := make(map[ClusterInstKey]*ClusterInstInfoCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if !c.FlushAll && val.Obj.NotifyId != notifyId {
			continue
		}
		flushed[key] = c.Objs[key]
		log.SpanLog(ctx, log.DebugLevelApi, "CacheFlush ClusterInstInfo delete", "key", key)
		delete(c.Objs, key)
	}
	c.Mux.Unlock()
	if len(flushed) > 0 {
		for key, old := range flushed {
			for _, cb := range c.NotifyCbs {
				if cb != nil {
					cb(ctx, &key, old.Obj, old.ModRev)
				}
			}
			for _, cb := range c.DeletedKeyCbs {
				cb(ctx, &key)
			}
			if old.Obj != nil {
				for _, cb := range c.DeletedCbs {
					cb(ctx, old.Obj)
				}
			}
			c.TriggerKeyWatchers(ctx, &key)
		}
	}
}

func (c *ClusterInstInfoCache) Show(filter *ClusterInstInfo, cb func(ret *ClusterInstInfo) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func ClusterInstInfoGenericNotifyCb(fn func(key *ClusterInstKey, old *ClusterInstInfo)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*ClusterInstKey), obj.(*ClusterInstInfo))
	}
}

func (c *ClusterInstInfoCache) SetNotifyCb(fn func(ctx context.Context, obj *ClusterInstKey, old *ClusterInstInfo, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *ClusterInstKey, old *ClusterInstInfo, modRev int64){fn}
}

func (c *ClusterInstInfoCache) SetUpdatedCb(fn func(ctx context.Context, old *ClusterInstInfo, new *ClusterInstInfo)) {
	c.UpdatedCbs = []func(ctx context.Context, old *ClusterInstInfo, new *ClusterInstInfo){fn}
}

func (c *ClusterInstInfoCache) SetDeletedCb(fn func(ctx context.Context, old *ClusterInstInfo)) {
	c.DeletedCbs = []func(ctx context.Context, old *ClusterInstInfo){fn}
}

func (c *ClusterInstInfoCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *ClusterInstKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *ClusterInstKey){fn}
}

func (c *ClusterInstInfoCache) SetDeletedKeyCb(fn func(ctx context.Context, key *ClusterInstKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *ClusterInstKey){fn}
}

func (c *ClusterInstInfoCache) AddUpdatedCb(fn func(ctx context.Context, old *ClusterInstInfo, new *ClusterInstInfo)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *ClusterInstInfoCache) AddDeletedCb(fn func(ctx context.Context, old *ClusterInstInfo)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *ClusterInstInfoCache) AddNotifyCb(fn func(ctx context.Context, obj *ClusterInstKey, old *ClusterInstInfo, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *ClusterInstInfoCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *ClusterInstKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *ClusterInstInfoCache) AddDeletedKeyCb(fn func(ctx context.Context, key *ClusterInstKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *ClusterInstInfoCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *ClusterInstInfoCache) WatchKey(key *ClusterInstKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*ClusterInstInfoKeyWatcher, 0)
	}
	watcher := ClusterInstInfoKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching ClusterInstInfo", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *ClusterInstInfoCache) TriggerKeyWatchers(ctx context.Context, key *ClusterInstKey) {
	watchers := make([]*ClusterInstInfoKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *ClusterInstInfoCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := ClusterInstInfo{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse ClusterInstInfo data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *ClusterInstInfoCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := ClusterInstInfo{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	ClusterInstKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *ClusterInstInfoCache) SyncListStart(ctx context.Context) {
	c.List = make(map[ClusterInstKey]struct{})
}

func (c *ClusterInstInfoCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[ClusterInstKey]*ClusterInstInfoCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, val.Obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *ClusterInstInfoCache) UsesOrg(org string) bool {
	return false
}

func (m *ClusterInstInfo) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *ClusterInstInfo) GetKey() *ClusterInstKey {
	return &m.Key
}

func (m *ClusterInstInfo) GetKeyVal() ClusterInstKey {
	return m.Key
}

func (m *ClusterInstInfo) SetKey(key *ClusterInstKey) {
	m.Key = *key
}

func CmpSortClusterInstInfo(a ClusterInstInfo, b ClusterInstInfo) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *ClusterInstInfo) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := TrackedState_name[int32(m.State)]; !ok {
		return errors.New("invalid State")
	}
	if err := m.Status.ValidateEnums(); err != nil {
		return err
	}
	if err := m.Resources.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func IgnoreClusterInstInfoFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "NotifyId")
	}
	return cmpopts.IgnoreFields(ClusterInstInfo{}, names...)
}

func (m *ClusterInst) IsValidArgsForCreateClusterInst() error {
	if m.State != 0 {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.Errors != nil {
		return fmt.Errorf("Invalid field specified: Errors, this field is only for internal use")
	}
	if m.AllocatedIp != "" {
		return fmt.Errorf("Invalid field specified: AllocatedIp, this field is only for internal use")
	}
	if m.Liveness != 0 {
		return fmt.Errorf("Invalid field specified: Liveness, this field is only for internal use")
	}
	if m.Auto != false {
		return fmt.Errorf("Invalid field specified: Auto, this field is only for internal use")
	}
	if m.NodeFlavor != "" {
		return fmt.Errorf("Invalid field specified: NodeFlavor, this field is only for internal use")
	}
	if m.Status.TaskNumber != 0 {
		return fmt.Errorf("Invalid field specified: Status.TaskNumber, this field is only for internal use")
	}
	if m.Status.MaxTasks != 0 {
		return fmt.Errorf("Invalid field specified: Status.MaxTasks, this field is only for internal use")
	}
	if m.Status.TaskName != "" {
		return fmt.Errorf("Invalid field specified: Status.TaskName, this field is only for internal use")
	}
	if m.Status.StepName != "" {
		return fmt.Errorf("Invalid field specified: Status.StepName, this field is only for internal use")
	}
	if m.Status.MsgCount != 0 {
		return fmt.Errorf("Invalid field specified: Status.MsgCount, this field is only for internal use")
	}
	if m.Status.Msgs != nil {
		return fmt.Errorf("Invalid field specified: Status.Msgs, this field is only for internal use")
	}
	if m.ExternalVolumeSize != 0 {
		return fmt.Errorf("Invalid field specified: ExternalVolumeSize, this field is only for internal use")
	}
	if m.AvailabilityZone != "" {
		return fmt.Errorf("Invalid field specified: AvailabilityZone, this field is only for internal use")
	}
	if m.ReservedBy != "" {
		return fmt.Errorf("Invalid field specified: ReservedBy, this field is only for internal use")
	}
	if m.MasterNodeFlavor != "" {
		return fmt.Errorf("Invalid field specified: MasterNodeFlavor, this field is only for internal use")
	}
	if m.OptRes != "" {
		return fmt.Errorf("Invalid field specified: OptRes, this field is only for internal use")
	}
	if m.Resources.Vms != nil {
		return fmt.Errorf("Invalid field specified: Resources.Vms, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	return nil
}

func (m *ClusterInst) IsValidArgsForDeleteClusterInst() error {
	if m.State != 0 {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.Errors != nil {
		return fmt.Errorf("Invalid field specified: Errors, this field is only for internal use")
	}
	if m.AllocatedIp != "" {
		return fmt.Errorf("Invalid field specified: AllocatedIp, this field is only for internal use")
	}
	if m.Liveness != 0 {
		return fmt.Errorf("Invalid field specified: Liveness, this field is only for internal use")
	}
	if m.Auto != false {
		return fmt.Errorf("Invalid field specified: Auto, this field is only for internal use")
	}
	if m.NodeFlavor != "" {
		return fmt.Errorf("Invalid field specified: NodeFlavor, this field is only for internal use")
	}
	if m.Status.TaskNumber != 0 {
		return fmt.Errorf("Invalid field specified: Status.TaskNumber, this field is only for internal use")
	}
	if m.Status.MaxTasks != 0 {
		return fmt.Errorf("Invalid field specified: Status.MaxTasks, this field is only for internal use")
	}
	if m.Status.TaskName != "" {
		return fmt.Errorf("Invalid field specified: Status.TaskName, this field is only for internal use")
	}
	if m.Status.StepName != "" {
		return fmt.Errorf("Invalid field specified: Status.StepName, this field is only for internal use")
	}
	if m.Status.MsgCount != 0 {
		return fmt.Errorf("Invalid field specified: Status.MsgCount, this field is only for internal use")
	}
	if m.Status.Msgs != nil {
		return fmt.Errorf("Invalid field specified: Status.Msgs, this field is only for internal use")
	}
	if m.ExternalVolumeSize != 0 {
		return fmt.Errorf("Invalid field specified: ExternalVolumeSize, this field is only for internal use")
	}
	if m.AvailabilityZone != "" {
		return fmt.Errorf("Invalid field specified: AvailabilityZone, this field is only for internal use")
	}
	if m.ReservedBy != "" {
		return fmt.Errorf("Invalid field specified: ReservedBy, this field is only for internal use")
	}
	if m.MasterNodeFlavor != "" {
		return fmt.Errorf("Invalid field specified: MasterNodeFlavor, this field is only for internal use")
	}
	if m.OptRes != "" {
		return fmt.Errorf("Invalid field specified: OptRes, this field is only for internal use")
	}
	if m.Resources.Vms != nil {
		return fmt.Errorf("Invalid field specified: Resources.Vms, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	return nil
}

func (m *ClusterInst) IsValidArgsForUpdateClusterInst() error {
	if m.Flavor.Name != "" {
		return fmt.Errorf("Invalid field specified: Flavor.Name, this field is only for internal use")
	}
	if m.State != 0 {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.Errors != nil {
		return fmt.Errorf("Invalid field specified: Errors, this field is only for internal use")
	}
	if m.IpAccess != 0 {
		return fmt.Errorf("Invalid field specified: IpAccess, this field is only for internal use")
	}
	if m.AllocatedIp != "" {
		return fmt.Errorf("Invalid field specified: AllocatedIp, this field is only for internal use")
	}
	if m.Liveness != 0 {
		return fmt.Errorf("Invalid field specified: Liveness, this field is only for internal use")
	}
	if m.Auto != false {
		return fmt.Errorf("Invalid field specified: Auto, this field is only for internal use")
	}
	if m.NodeFlavor != "" {
		return fmt.Errorf("Invalid field specified: NodeFlavor, this field is only for internal use")
	}
	if m.NumMasters != 0 {
		return fmt.Errorf("Invalid field specified: NumMasters, this field is only for internal use")
	}
	if m.Deployment != "" {
		return fmt.Errorf("Invalid field specified: Deployment, this field is only for internal use")
	}
	if m.Status.TaskNumber != 0 {
		return fmt.Errorf("Invalid field specified: Status.TaskNumber, this field is only for internal use")
	}
	if m.Status.MaxTasks != 0 {
		return fmt.Errorf("Invalid field specified: Status.MaxTasks, this field is only for internal use")
	}
	if m.Status.TaskName != "" {
		return fmt.Errorf("Invalid field specified: Status.TaskName, this field is only for internal use")
	}
	if m.Status.StepName != "" {
		return fmt.Errorf("Invalid field specified: Status.StepName, this field is only for internal use")
	}
	if m.Status.MsgCount != 0 {
		return fmt.Errorf("Invalid field specified: Status.MsgCount, this field is only for internal use")
	}
	if m.Status.Msgs != nil {
		return fmt.Errorf("Invalid field specified: Status.Msgs, this field is only for internal use")
	}
	if m.ExternalVolumeSize != 0 {
		return fmt.Errorf("Invalid field specified: ExternalVolumeSize, this field is only for internal use")
	}
	if m.AvailabilityZone != "" {
		return fmt.Errorf("Invalid field specified: AvailabilityZone, this field is only for internal use")
	}
	if m.ImageName != "" {
		return fmt.Errorf("Invalid field specified: ImageName, this field is only for internal use")
	}
	if m.Reservable != false {
		return fmt.Errorf("Invalid field specified: Reservable, this field is only for internal use")
	}
	if m.ReservedBy != "" {
		return fmt.Errorf("Invalid field specified: ReservedBy, this field is only for internal use")
	}
	if m.SharedVolumeSize != 0 {
		return fmt.Errorf("Invalid field specified: SharedVolumeSize, this field is only for internal use")
	}
	if m.MasterNodeFlavor != "" {
		return fmt.Errorf("Invalid field specified: MasterNodeFlavor, this field is only for internal use")
	}
	if m.OptRes != "" {
		return fmt.Errorf("Invalid field specified: OptRes, this field is only for internal use")
	}
	if m.Resources.Vms != nil {
		return fmt.Errorf("Invalid field specified: Resources.Vms, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	return nil
}

func (m *IdleReservableClusterInsts) IsValidArgsForDeleteIdleReservableClusterInsts() error {
	return nil
}

func (m *ClusterInstKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ClusterKey.Size()
	n += 1 + l + sovClusterinst(uint64(l))
	l = m.CloudletKey.Size()
	n += 1 + l + sovClusterinst(uint64(l))
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovClusterinst(uint64(l))
	}
	return n
}

func (m *ClusterInst) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovClusterinst(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovClusterinst(uint64(l))
	l = m.Flavor.Size()
	n += 1 + l + sovClusterinst(uint64(l))
	if m.State != 0 {
		n += 1 + sovClusterinst(uint64(m.State))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovClusterinst(uint64(l))
		}
	}
	if m.CrmOverride != 0 {
		n += 1 + sovClusterinst(uint64(m.CrmOverride))
	}
	if m.IpAccess != 0 {
		n += 1 + sovClusterinst(uint64(m.IpAccess))
	}
	l = len(m.AllocatedIp)
	if l > 0 {
		n += 1 + l + sovClusterinst(uint64(l))
	}
	if m.Liveness != 0 {
		n += 1 + sovClusterinst(uint64(m.Liveness))
	}
	if m.Auto {
		n += 2
	}
	l = len(m.NodeFlavor)
	if l > 0 {
		n += 1 + l + sovClusterinst(uint64(l))
	}
	if m.NumMasters != 0 {
		n += 1 + sovClusterinst(uint64(m.NumMasters))
	}
	if m.NumNodes != 0 {
		n += 1 + sovClusterinst(uint64(m.NumNodes))
	}
	l = len(m.Deployment)
	if l > 0 {
		n += 1 + l + sovClusterinst(uint64(l))
	}
	l = m.Status.Size()
	n += 2 + l + sovClusterinst(uint64(l))
	if m.ExternalVolumeSize != 0 {
		n += 2 + sovClusterinst(uint64(m.ExternalVolumeSize))
	}
	l = len(m.AutoScalePolicy)
	if l > 0 {
		n += 2 + l + sovClusterinst(uint64(l))
	}
	l = len(m.AvailabilityZone)
	if l > 0 {
		n += 2 + l + sovClusterinst(uint64(l))
	}
	l = len(m.ImageName)
	if l > 0 {
		n += 2 + l + sovClusterinst(uint64(l))
	}
	if m.Reservable {
		n += 3
	}
	l = len(m.ReservedBy)
	if l > 0 {
		n += 2 + l + sovClusterinst(uint64(l))
	}
	if m.SharedVolumeSize != 0 {
		n += 2 + sovClusterinst(uint64(m.SharedVolumeSize))
	}
	l = len(m.MasterNodeFlavor)
	if l > 0 {
		n += 2 + l + sovClusterinst(uint64(l))
	}
	if m.SkipCrmCleanupOnFailure {
		n += 3
	}
	l = len(m.OptRes)
	if l > 0 {
		n += 2 + l + sovClusterinst(uint64(l))
	}
	l = m.Resources.Size()
	n += 2 + l + sovClusterinst(uint64(l))
	l = m.CreatedAt.Size()
	n += 2 + l + sovClusterinst(uint64(l))
	l = m.UpdatedAt.Size()
	n += 2 + l + sovClusterinst(uint64(l))
	l = m.ReservationEndedAt.Size()
	n += 2 + l + sovClusterinst(uint64(l))
	if m.MultiTenant {
		n += 3
	}
	return n
}

func (m *IdleReservableClusterInsts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdleTime != 0 {
		n += 1 + sovClusterinst(uint64(m.IdleTime))
	}
	return n
}

func (m *ClusterInstInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovClusterinst(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovClusterinst(uint64(l))
	if m.NotifyId != 0 {
		n += 1 + sovClusterinst(uint64(m.NotifyId))
	}
	if m.State != 0 {
		n += 1 + sovClusterinst(uint64(m.State))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovClusterinst(uint64(l))
		}
	}
	l = m.Status.Size()
	n += 1 + l + sovClusterinst(uint64(l))
	l = m.Resources.Size()
	n += 1 + l + sovClusterinst(uint64(l))
	return n
}

func sovClusterinst(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozClusterinst(x uint64) (n int) {
	return sovClusterinst(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClusterInstKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClusterinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterInstKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterInstKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CloudletKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClusterinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClusterinst
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClusterinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterInst) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClusterinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterInst: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterInst: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flavor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Flavor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= TrackedState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrmOverride", wireType)
			}
			m.CrmOverride = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrmOverride |= CRMOverride(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAccess", wireType)
			}
			m.IpAccess = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpAccess |= IpAccess(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocatedIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocatedIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liveness", wireType)
			}
			m.Liveness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Liveness |= Liveness(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auto", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Auto = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeFlavor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeFlavor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumMasters", wireType)
			}
			m.NumMasters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumMasters |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumNodes", wireType)
			}
			m.NumNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumNodes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deployment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalVolumeSize", wireType)
			}
			m.ExternalVolumeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalVolumeSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoScalePolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AutoScalePolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reservable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reservable = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReservedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedVolumeSize", wireType)
			}
			m.SharedVolumeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SharedVolumeSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterNodeFlavor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MasterNodeFlavor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipCrmCleanupOnFailure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipCrmCleanupOnFailure = bool(v != 0)
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptRes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptRes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservationEndedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReservationEndedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiTenant", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MultiTenant = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipClusterinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClusterinst
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClusterinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdleReservableClusterInsts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClusterinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdleReservableClusterInsts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdleReservableClusterInsts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTime", wireType)
			}
			m.IdleTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleTime |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipClusterinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClusterinst
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClusterinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterInstInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClusterinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterInstInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterInstInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyId", wireType)
			}
			m.NotifyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotifyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= TrackedState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClusterinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClusterinst
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClusterinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipClusterinst(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowClusterinst
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthClusterinst
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupClusterinst
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthClusterinst
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthClusterinst        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowClusterinst          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupClusterinst = fmt.Errorf("proto: unexpected end of group")
)
