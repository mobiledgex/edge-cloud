// Application instance on a Cloudlet

syntax = "proto3";
package edgeproto;

import "google/api/annotations.proto";
import "result.proto";
import "github.com/mobiledgex/edge-cloud/protogen/protogen.proto";
import "github.com/mobiledgex/edge-cloud/protoc-gen-cmd/protocmd/protocmd.proto";
import "app.proto";
import "cloudlet.proto";
import "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto/loc.proto";
import "github.com/gogo/protobuf/gogoproto/gogo.proto";

message AppInstKey {
  // App key
  AppKey app_key = 1 [(gogoproto.nullable) = false];
  // Cloudlet it's on
  CloudletKey cloudlet_key = 2 [(gogoproto.nullable) = false];
  // inst id
  fixed64 id = 3;
  option (protogen.generate_matches) = true;
  option (protogen.obj_key) = true;
  option (gogoproto.gostring) = true;
}

// AppInsts are instances of an application instantiated
// on a cloudlet, like a docker or VM instance.
message AppInst {
  repeated string fields = 1;
  // Unique identifier key
  AppInstKey key = 2 [(gogoproto.nullable) = false];
  // Cache the location of the cloudlet
  distributed_match_engine.Loc cloudlet_loc = 3 [(gogoproto.nullable) = false];
  // URI to connect to this instance
  string uri = 4 [(protogen.test_update) = true];
  // IP to connect to this instance (XXX why is this needed?)
  bytes ip = 8;
  // type of instance
  enum Liveness {
    UNKNOWN = 0;
    STATIC = 1;
    DYNAMIC = 2;
  }
  Liveness liveness = 6;
  // cache app path from app
  string app_path = 7;
  option (protogen.generate_matches) = true;
  option (protogen.generate_cud) = true;
  option (protogen.generate_cache) = true;
  option (protocmd.noconfig) = "CloudletLoc,AppPath";
}

// This API is for manual configuration of static app instances.
// The long term goal is that most app instance creation/deletion
// will be dynamic based on load.
service AppInstApi {
  rpc CreateAppInst(AppInst) returns (Result) {
    option (google.api.http) = {
      post: "/create/appinst"
      body: "*"
    };
  }
  rpc DeleteAppInst(AppInst) returns (Result) {
   option (google.api.http) = {
      post: "/delete/appinst"
      body: "*"
    };
  }
  rpc UpdateAppInst(AppInst) returns (Result) {
   option (google.api.http) = {
      post: "/update/appinst"
      body: "*"
    };
  }
  rpc ShowAppInst(AppInst) returns (stream AppInst) {
   option (google.api.http) = {
      post: "/show/appinst"
      body: "*"
    };
  }
}

// AppInstInfo contains data collected by the CRM to be sent
// to the connected controller.
message AppInstInfo {
  // Unique identifier key
  AppInstKey key = 2 [(gogoproto.nullable) = false];
  // TODO: When max load is reached on k8s cluster, tell controller.
  // At this point k8s cluster has already scaled AppInst to max instances.
  // The only recourse is to instantiate another k8s cluster on another
  // cloudlet, or perhaps expand the k8s cluster on this cloudlet.
  // This is a placeholder, not sure how this will work.
  uint64 load = 3;
  // TODO: Used resources (for billing)
  // These are also placeholders. What is supplied here
  // depends on what Openstack/Kubernetes/Agents can measure.
  uint64 cpu = 4;
  uint64 max_disk = 5;
  uint64 network_in = 6;
  uint64 network_out = 7;
}
