// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: version.proto

package edgeproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/mobiledgex/edge-cloud/protogen"
import _ "github.com/mobiledgex/edge-cloud/protoc-gen-cmd/protocmd"

import binary "encoding/binary"

import "errors"
import "strconv"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Below enum lists hashes as well as corresponding versions
type VersionHash int32

const (
	VersionHash_HASH_c7889840e4365a901ca3fa938eb589e4 VersionHash = 0
)

var VersionHash_name = map[int32]string{
	0: "HASH_c7889840e4365a901ca3fa938eb589e4",
}
var VersionHash_value = map[string]int32{
	"HASH_c7889840e4365a901ca3fa938eb589e4": 0,
}

func (x VersionHash) String() string {
	return proto.EnumName(VersionHash_name, int32(x))
}
func (VersionHash) EnumDescriptor() ([]byte, []int) { return fileDescriptorVersion, []int{0} }

// Version of the edgeproto
type DataModelVersion struct {
	// Version ID
	Version uint32 `protobuf:"fixed32,1,opt,name=version,proto3" json:"version,omitempty"`
	// Hash string for comparison
	VersionHash VersionHash `protobuf:"varint,2,opt,name=version_hash,json=versionHash,proto3,enum=edgeproto.VersionHash" json:"version_hash,omitempty"`
}

func (m *DataModelVersion) Reset()                    { *m = DataModelVersion{} }
func (m *DataModelVersion) String() string            { return proto.CompactTextString(m) }
func (*DataModelVersion) ProtoMessage()               {}
func (*DataModelVersion) Descriptor() ([]byte, []int) { return fileDescriptorVersion, []int{0} }

func init() {
	proto.RegisterType((*DataModelVersion)(nil), "edgeproto.DataModelVersion")
	proto.RegisterEnum("edgeproto.VersionHash", VersionHash_name, VersionHash_value)
}
func (m *DataModelVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataModelVersion) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		dAtA[i] = 0xd
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.Version))
		i += 4
	}
	if m.VersionHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.VersionHash))
	}
	return i, nil
}

func encodeVarintVersion(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DataModelVersion) CopyInFields(src *DataModelVersion) {
	m.Version = src.Version
	m.VersionHash = src.VersionHash
}

// Helper method to check that enums have valid values
func (m *DataModelVersion) ValidateEnums() error {
	if _, ok := VersionHash_name[int32(m.VersionHash)]; !ok {
		return errors.New("invalid VersionHash")
	}
	return nil
}

// Keys being hashed:
// DeveloperKey
// FlavorKey
// ClusterFlavorKey
// ClusterKey
// AppKey
// OperatorKey
// CloudletKey
// ClusterInstKey
// AppInstKey
// ControllerKey
// NodeKey
var versionHashString = "c7889840e4365a901ca3fa938eb589e4"

func GetDataModelVersion() string {
	return versionHashString
}

var VersionHashStrings = []string{
	"HASH_c7889840e4365a901ca3fa938eb589e4",
}

const (
	VersionHashHASHC7889840E4365A901Ca3Fa938Eb589E4 uint64 = 1 << 0
)

func (e *VersionHash) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := VersionHash_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = VersionHash_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = VersionHash(val)
	return nil
}

func (e VersionHash) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

func (m *DataModelVersion) Size() (n int) {
	var l int
	_ = l
	if m.Version != 0 {
		n += 5
	}
	if m.VersionHash != 0 {
		n += 1 + sovVersion(uint64(m.VersionHash))
	}
	return n
}

func sovVersion(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozVersion(x uint64) (n int) {
	return sovVersion(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DataModelVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataModelVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataModelVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionHash", wireType)
			}
			m.VersionHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionHash |= (VersionHash(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVersion(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVersion
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthVersion
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowVersion
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipVersion(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthVersion = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVersion   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("version.proto", fileDescriptorVersion) }

var fileDescriptorVersion = []byte{
	// 291 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x2d, 0x4b, 0x2d, 0x2a,
	0xce, 0xcc, 0xcf, 0xd3, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x4c, 0x4d, 0x49, 0x4f, 0x05,
	0x33, 0xa5, 0x64, 0xd2, 0xf3, 0xf3, 0xd3, 0x73, 0x52, 0xf5, 0x13, 0x0b, 0x32, 0xf5, 0x13, 0xf3,
	0xf2, 0xf2, 0x4b, 0x12, 0x4b, 0x32, 0xf3, 0xf3, 0x8a, 0x21, 0x0a, 0xa5, 0x2c, 0xd2, 0x33, 0x4b,
	0x32, 0x4a, 0x93, 0xf4, 0x92, 0xf3, 0x73, 0xf5, 0x73, 0xf3, 0x93, 0x32, 0x73, 0x40, 0x1a, 0x2b,
	0xf4, 0x41, 0xa4, 0x6e, 0x72, 0x4e, 0x7e, 0x69, 0x8a, 0x3e, 0x58, 0x5d, 0x7a, 0x6a, 0x1e, 0x9c,
	0x01, 0xd5, 0xe9, 0x4e, 0x9c, 0xce, 0x64, 0xdd, 0xf4, 0xd4, 0x3c, 0xdd, 0xe4, 0x5c, 0x18, 0x17,
	0x89, 0x01, 0x31, 0x48, 0xa9, 0x9c, 0x4b, 0xc0, 0x25, 0xb1, 0x24, 0xd1, 0x37, 0x3f, 0x25, 0x35,
	0x27, 0x0c, 0xe2, 0x0b, 0x21, 0x09, 0x2e, 0x76, 0xa8, 0x87, 0x24, 0x18, 0x15, 0x18, 0x35, 0xd8,
	0x83, 0x60, 0x5c, 0x21, 0x7b, 0x2e, 0x1e, 0x28, 0x33, 0x3e, 0x23, 0xb1, 0x38, 0x43, 0x82, 0x49,
	0x81, 0x51, 0x83, 0xcf, 0x48, 0x4c, 0x0f, 0xee, 0x61, 0x3d, 0xa8, 0x19, 0x1e, 0x89, 0xc5, 0x19,
	0x4e, 0x2c, 0x2b, 0xbe, 0x48, 0x30, 0x06, 0x71, 0x97, 0x21, 0x84, 0xac, 0x38, 0x7e, 0x7c, 0x91,
	0x60, 0x6c, 0xf8, 0x2a, 0xc1, 0xa8, 0x65, 0xc7, 0xc5, 0x8d, 0xa4, 0x56, 0x48, 0x93, 0x4b, 0xd5,
	0xc3, 0x31, 0xd8, 0x23, 0x3e, 0xd9, 0xdc, 0xc2, 0xc2, 0xd2, 0xc2, 0xc4, 0x20, 0xd5, 0xc4, 0xd8,
	0xcc, 0x34, 0xd1, 0xd2, 0xc0, 0x30, 0x39, 0xd1, 0x38, 0x2d, 0xd1, 0xd2, 0xd8, 0x22, 0x35, 0xc9,
	0xd4, 0xc2, 0x32, 0xd5, 0x44, 0x80, 0x41, 0x8a, 0xa5, 0xe3, 0xab, 0x04, 0xa3, 0x93, 0xc0, 0x89,
	0x87, 0x72, 0x0c, 0x27, 0x1e, 0xc9, 0x31, 0x5e, 0x78, 0x24, 0xc7, 0xf8, 0xe0, 0x91, 0x1c, 0x63,
	0x12, 0x1b, 0xd8, 0x05, 0xc6, 0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0x56, 0x90, 0x2e, 0xcb, 0x8e,
	0x01, 0x00, 0x00,
}
