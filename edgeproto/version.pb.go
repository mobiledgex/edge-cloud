// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: version.proto

package edgeproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/mobiledgex/edge-cloud/protogen"
import _ "github.com/mobiledgex/edge-cloud/protoc-gen-cmd/protocmd"

import binary "encoding/binary"

import "errors"
import "strconv"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Below enum lists hashes as well as corresponding versions
type VersionHash int32

const (
	VersionHash_HASH_c7889840e4365a901ca3fa938eb589e4 VersionHash = 0
)

var VersionHash_name = map[int32]string{
	0: "HASH_c7889840e4365a901ca3fa938eb589e4",
}
var VersionHash_value = map[string]int32{
	"HASH_c7889840e4365a901ca3fa938eb589e4": 0,
}

func (x VersionHash) String() string {
	return proto.EnumName(VersionHash_name, int32(x))
}
func (VersionHash) EnumDescriptor() ([]byte, []int) { return fileDescriptorVersion, []int{0} }

// Upgrade functions
type UpgradeFunc struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *UpgradeFunc) Reset()                    { *m = UpgradeFunc{} }
func (m *UpgradeFunc) String() string            { return proto.CompactTextString(m) }
func (*UpgradeFunc) ProtoMessage()               {}
func (*UpgradeFunc) Descriptor() ([]byte, []int) { return fileDescriptorVersion, []int{0} }

// Map of version hashes to ugpgrade function
type DataVersionUpgrades struct {
	UpgradeFunctions map[int32]*UpgradeFunc `protobuf:"bytes,1,rep,name=upgrade_functions,json=upgradeFunctions" json:"upgrade_functions,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *DataVersionUpgrades) Reset()                    { *m = DataVersionUpgrades{} }
func (m *DataVersionUpgrades) String() string            { return proto.CompactTextString(m) }
func (*DataVersionUpgrades) ProtoMessage()               {}
func (*DataVersionUpgrades) Descriptor() ([]byte, []int) { return fileDescriptorVersion, []int{1} }

// Version of the edgeproto
type DataModelVersion struct {
	// Version ID
	Version uint32 `protobuf:"fixed32,1,opt,name=version,proto3" json:"version,omitempty"`
	// Hash string for comparison
	VersionHash VersionHash `protobuf:"varint,2,opt,name=version_hash,json=versionHash,proto3,enum=edgeproto.VersionHash" json:"version_hash,omitempty"`
}

func (m *DataModelVersion) Reset()                    { *m = DataModelVersion{} }
func (m *DataModelVersion) String() string            { return proto.CompactTextString(m) }
func (*DataModelVersion) ProtoMessage()               {}
func (*DataModelVersion) Descriptor() ([]byte, []int) { return fileDescriptorVersion, []int{2} }

func init() {
	proto.RegisterType((*UpgradeFunc)(nil), "edgeproto.UpgradeFunc")
	proto.RegisterType((*DataVersionUpgrades)(nil), "edgeproto.DataVersionUpgrades")
	proto.RegisterType((*DataModelVersion)(nil), "edgeproto.DataModelVersion")
	proto.RegisterEnum("edgeproto.VersionHash", VersionHash_name, VersionHash_value)
}
func (m *UpgradeFunc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpgradeFunc) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVersion(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *DataVersionUpgrades) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataVersionUpgrades) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UpgradeFunctions) > 0 {
		for k, _ := range m.UpgradeFunctions {
			dAtA[i] = 0xa
			i++
			v := m.UpgradeFunctions[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVersion(uint64(msgSize))
			}
			mapSize := 1 + sovVersion(uint64(k)) + msgSize
			i = encodeVarintVersion(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintVersion(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintVersion(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	return i, nil
}

func (m *DataModelVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataModelVersion) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		dAtA[i] = 0xd
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.Version))
		i += 4
	}
	if m.VersionHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.VersionHash))
	}
	return i, nil
}

func encodeVarintVersion(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *UpgradeFunc) CopyInFields(src *UpgradeFunc) {
	m.Name = src.Name
}

// Helper method to check that enums have valid values
func (m *UpgradeFunc) ValidateEnums() error {
	return nil
}

func (m *DataVersionUpgrades) CopyInFields(src *DataVersionUpgrades) {
	if src.UpgradeFunctions != nil {
		m.UpgradeFunctions = make(map[int32]*UpgradeFunc)
		for k0, _ := range src.UpgradeFunctions {
			m.UpgradeFunctions[k0] = &UpgradeFunc{}
			m.UpgradeFunctions[k0].Name = src.UpgradeFunctions[k0].Name
		}
	}
}

// Helper method to check that enums have valid values
func (m *DataVersionUpgrades) ValidateEnums() error {
	return nil
}

func (m *DataModelVersion) CopyInFields(src *DataModelVersion) {
	m.Version = src.Version
	m.VersionHash = src.VersionHash
}

// Helper method to check that enums have valid values
func (m *DataModelVersion) ValidateEnums() error {
	if _, ok := VersionHash_name[int32(m.VersionHash)]; !ok {
		return errors.New("invalid VersionHash")
	}
	return nil
}

func (m *DataModelVersion) VersionCheck(oldVer DataModelVersion) bool {
	return m.VersionHash == oldVer.VersionHash && m.Version == oldVer.Version
}

//Messages hash:
// DeveloperKey
// FlavorKey
// ClusterFlavorKey
// ClusterKey
// AppKey
// OperatorKey
// CloudletKey
// ClusterInstKey
// AppInstKey
// ControllerKey
// NodeKey
var versionHashString = "c7889840e4365a901ca3fa938eb589e4"

func GetDataModelVersion() string {
	return versionHashString
}

// Lat Value = HASH_c7889840e4365a901ca3fa938eb589e4
var VersionHashStrings = []string{
	"HASH_c7889840e4365a901ca3fa938eb589e4",
}

const (
	VersionHashHASHC7889840E4365A901Ca3Fa938Eb589E4 uint64 = 1 << 0
)

func (e *VersionHash) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := VersionHash_value[str]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = VersionHash_name[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = VersionHash(val)
	return nil
}

func (e VersionHash) MarshalYAML() (interface{}, error) {
	return e.String(), nil
}

func (m *UpgradeFunc) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovVersion(uint64(l))
	}
	return n
}

func (m *DataVersionUpgrades) Size() (n int) {
	var l int
	_ = l
	if len(m.UpgradeFunctions) > 0 {
		for k, v := range m.UpgradeFunctions {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVersion(uint64(l))
			}
			mapEntrySize := 1 + sovVersion(uint64(k)) + l
			n += mapEntrySize + 1 + sovVersion(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DataModelVersion) Size() (n int) {
	var l int
	_ = l
	if m.Version != 0 {
		n += 5
	}
	if m.VersionHash != 0 {
		n += 1 + sovVersion(uint64(m.VersionHash))
	}
	return n
}

func sovVersion(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozVersion(x uint64) (n int) {
	return sovVersion(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UpgradeFunc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradeFunc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradeFunc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataVersionUpgrades) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataVersionUpgrades: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataVersionUpgrades: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeFunctions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpgradeFunctions == nil {
				m.UpgradeFunctions = make(map[int32]*UpgradeFunc)
			}
			var mapkey int32
			var mapvalue *UpgradeFunc
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVersion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVersion
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVersion
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthVersion
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthVersion
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &UpgradeFunc{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipVersion(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthVersion
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UpgradeFunctions[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataModelVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataModelVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataModelVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionHash", wireType)
			}
			m.VersionHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionHash |= (VersionHash(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVersion(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVersion
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthVersion
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowVersion
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipVersion(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthVersion = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVersion   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("version.proto", fileDescriptorVersion) }

var fileDescriptorVersion = []byte{
	// 415 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x91, 0x3d, 0x8f, 0xd3, 0x30,
	0x1c, 0xc6, 0xcf, 0x77, 0x3d, 0x8e, 0x73, 0x00, 0x05, 0x23, 0x90, 0x15, 0xa1, 0xa8, 0x54, 0x42,
	0x2a, 0x88, 0x26, 0xc7, 0x25, 0x07, 0x49, 0x07, 0x10, 0x15, 0x2f, 0x5d, 0x58, 0x82, 0x60, 0x61,
	0xa8, 0x1c, 0xc7, 0x4d, 0x22, 0x12, 0xbb, 0xca, 0x4b, 0xa1, 0x1b, 0x23, 0x1f, 0x85, 0x8f, 0xd2,
	0x91, 0x85, 0x1d, 0xfa, 0x19, 0x5a, 0x89, 0x11, 0xc5, 0x49, 0x4b, 0x40, 0x1d, 0x58, 0xa2, 0x9f,
	0xad, 0xe7, 0x79, 0xfe, 0xcf, 0x3f, 0x86, 0x57, 0xe7, 0x2c, 0xcb, 0x63, 0xc1, 0x8d, 0x59, 0x26,
	0x0a, 0x81, 0x4e, 0x59, 0x10, 0x32, 0x89, 0xda, 0xed, 0x50, 0x88, 0x30, 0x61, 0x26, 0x99, 0xc5,
	0x26, 0xe1, 0x5c, 0x14, 0xa4, 0x88, 0x05, 0xcf, 0x6b, 0xa1, 0xe6, 0x84, 0x71, 0x11, 0x95, 0xbe,
	0x41, 0x45, 0x6a, 0xa6, 0xc2, 0x8f, 0x93, 0xca, 0xf8, 0xc9, 0xac, 0xbe, 0x03, 0x9a, 0x88, 0x32,
	0x30, 0xa5, 0x2e, 0x64, 0x7c, 0x07, 0x8d, 0xf3, 0xd5, 0xff, 0x39, 0xe9, 0x20, 0x64, 0x7c, 0x40,
	0xd3, 0xed, 0xb1, 0x05, 0x75, 0x50, 0xef, 0x0e, 0x54, 0xde, 0xce, 0xc2, 0x8c, 0x04, 0xec, 0x65,
	0xc9, 0x29, 0x42, 0xb0, 0xc3, 0x49, 0xca, 0x30, 0xe8, 0x82, 0xfe, 0xa9, 0x27, 0xb9, 0xf7, 0x1d,
	0xc0, 0x1b, 0xcf, 0x49, 0x41, 0xde, 0xd5, 0x4b, 0x36, 0xf2, 0x1c, 0x11, 0x78, 0xbd, 0xac, 0x79,
	0x32, 0x2d, 0x39, 0x95, 0x8b, 0x61, 0xd0, 0x3d, 0xea, 0x2b, 0xe7, 0xb6, 0xb1, 0xfb, 0x05, 0xc6,
	0x1e, 0xab, 0xd1, 0x1a, 0x29, 0x6d, 0x2f, 0x78, 0x91, 0x2d, 0x3c, 0xb5, 0xfc, 0xe7, 0x5a, 0x7b,
	0x0f, 0x6f, 0xee, 0x95, 0x22, 0x15, 0x1e, 0x7d, 0x60, 0x0b, 0x59, 0xf3, 0xd8, 0xab, 0x10, 0x3d,
	0x80, 0xc7, 0x73, 0x92, 0x94, 0x0c, 0x1f, 0x76, 0x41, 0x5f, 0x39, 0xbf, 0xd5, 0x6a, 0xd0, 0x8a,
	0xf0, 0x6a, 0xd1, 0xf0, 0xd0, 0x01, 0xbd, 0x8f, 0x50, 0xad, 0xba, 0xbd, 0x16, 0x01, 0x4b, 0x9a,
	0x82, 0x08, 0xc3, 0x93, 0xe6, 0x2d, 0x65, 0xf6, 0x89, 0xb7, 0x3d, 0xa2, 0xa7, 0xf0, 0x4a, 0x83,
	0x93, 0x88, 0xe4, 0x91, 0x1c, 0x73, 0xed, 0xaf, 0x31, 0x4d, 0xc6, 0x98, 0xe4, 0xd1, 0xa8, 0xf3,
	0x75, 0x8d, 0x81, 0xa7, 0xcc, 0xff, 0x5c, 0x0d, 0x2f, 0xff, 0x5a, 0x63, 0xf0, 0x79, 0x83, 0xc1,
	0xfd, 0x27, 0x50, 0x69, 0x69, 0xd1, 0x3d, 0x78, 0x77, 0xfc, 0xec, 0xcd, 0x78, 0x42, 0x1f, 0x3b,
	0x8e, 0xeb, 0xd8, 0x67, 0xcc, 0xb6, 0x1e, 0x5d, 0x10, 0xf7, 0xec, 0x21, 0x25, 0xd6, 0x94, 0xb8,
	0x96, 0xc3, 0xfc, 0x0b, 0xc7, 0x65, 0xb6, 0x7a, 0xa0, 0x75, 0xbe, 0x6c, 0x30, 0x18, 0xa9, 0xcb,
	0x9f, 0xfa, 0xc1, 0x72, 0xa5, 0x83, 0x6f, 0x2b, 0x1d, 0xfc, 0x58, 0xe9, 0xc0, 0xbf, 0x24, 0x1b,
	0x58, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0xe1, 0xcf, 0xfe, 0x37, 0x89, 0x02, 0x00, 0x00,
}
