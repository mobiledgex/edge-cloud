// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: appinstclient.proto

package edgeproto

import (
	context "context"
	"encoding/json"
	fmt "fmt"
	"github.com/coreos/etcd/clientv3/concurrency"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	distributed_match_engine "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto"
	dme_proto "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto"
	"github.com/mobiledgex/edge-cloud/log"
	"github.com/mobiledgex/edge-cloud/objstore"
	_ "github.com/mobiledgex/edge-cloud/protogen"
	"github.com/mobiledgex/edge-cloud/util"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AppInstClientLookupKey struct {
	// AppInst Key
	Appinstkey *AppInstKey `protobuf:"bytes,1,opt,name=appinstkey,proto3" json:"appinstkey,omitempty"`
	// AppInstClient Unique Id
	UniqueId string `protobuf:"bytes,2,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
	// AppInstClient Unique Id Type
	UniqueIdType string `protobuf:"bytes,3,opt,name=unique_id_type,json=uniqueIdType,proto3" json:"unique_id_type,omitempty"`
}

func (m *AppInstClientLookupKey) Reset()         { *m = AppInstClientLookupKey{} }
func (m *AppInstClientLookupKey) String() string { return proto.CompactTextString(m) }
func (*AppInstClientLookupKey) ProtoMessage()    {}
func (*AppInstClientLookupKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_a8b03148dc570743, []int{0}
}
func (m *AppInstClientLookupKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppInstClientLookupKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppInstClientLookupKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppInstClientLookupKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppInstClientLookupKey.Merge(m, src)
}
func (m *AppInstClientLookupKey) XXX_Size() int {
	return m.Size()
}
func (m *AppInstClientLookupKey) XXX_DiscardUnknown() {
	xxx_messageInfo_AppInstClientLookupKey.DiscardUnknown(m)
}

var xxx_messageInfo_AppInstClientLookupKey proto.InternalMessageInfo

// AppKey uniquely identifies an App
type AppInstClientKey struct {
	Key AppInstClientLookupKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
}

func (m *AppInstClientKey) Reset()         { *m = AppInstClientKey{} }
func (m *AppInstClientKey) String() string { return proto.CompactTextString(m) }
func (*AppInstClientKey) ProtoMessage()    {}
func (*AppInstClientKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_a8b03148dc570743, []int{1}
}
func (m *AppInstClientKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppInstClientKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppInstClientKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppInstClientKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppInstClientKey.Merge(m, src)
}
func (m *AppInstClientKey) XXX_Size() int {
	return m.Size()
}
func (m *AppInstClientKey) XXX_DiscardUnknown() {
	xxx_messageInfo_AppInstClientKey.DiscardUnknown(m)
}

var xxx_messageInfo_AppInstClientKey proto.InternalMessageInfo

// Client is an AppInst client that called FindCloudlet DME Api
type AppInstClient struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique identifier key
	ClientKey AppInstClientKey `protobuf:"bytes,2,opt,name=client_key,json=clientKey,proto3" json:"client_key"`
	// Location of the Client
	Location dme_proto.Loc `protobuf:"bytes,3,opt,name=location,proto3" json:"location"`
	// Id of client assigned by server (internal use only)
	NotifyId int64 `protobuf:"varint,4,opt,name=notify_id,json=notifyId,proto3" json:"notify_id,omitempty"`
}

func (m *AppInstClient) Reset()         { *m = AppInstClient{} }
func (m *AppInstClient) String() string { return proto.CompactTextString(m) }
func (*AppInstClient) ProtoMessage()    {}
func (*AppInstClient) Descriptor() ([]byte, []int) {
	return fileDescriptor_a8b03148dc570743, []int{2}
}
func (m *AppInstClient) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppInstClient) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppInstClient.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppInstClient) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppInstClient.Merge(m, src)
}
func (m *AppInstClient) XXX_Size() int {
	return m.Size()
}
func (m *AppInstClient) XXX_DiscardUnknown() {
	xxx_messageInfo_AppInstClient.DiscardUnknown(m)
}

var xxx_messageInfo_AppInstClient proto.InternalMessageInfo

func init() {
	proto.RegisterType((*AppInstClientLookupKey)(nil), "edgeproto.AppInstClientLookupKey")
	proto.RegisterType((*AppInstClientKey)(nil), "edgeproto.AppInstClientKey")
	proto.RegisterType((*AppInstClient)(nil), "edgeproto.AppInstClient")
}

func init() { proto.RegisterFile("appinstclient.proto", fileDescriptor_a8b03148dc570743) }

var fileDescriptor_a8b03148dc570743 = []byte{
	// 771 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0x31, 0x4f, 0x1b, 0x49,
	0x14, 0xf6, 0xd8, 0x80, 0xec, 0xc1, 0x20, 0x6e, 0xb9, 0x43, 0x03, 0xc7, 0x19, 0x9f, 0x2b, 0x1f,
	0xb2, 0xbd, 0x88, 0x93, 0x4e, 0x77, 0x96, 0x4e, 0x77, 0x36, 0x4a, 0x81, 0x40, 0x89, 0x64, 0x12,
	0x5a, 0x6b, 0xbd, 0x3b, 0xac, 0x47, 0xec, 0xce, 0x6c, 0x76, 0x67, 0x43, 0x36, 0x15, 0xca, 0x2f,
	0x40, 0xa4, 0x4b, 0x15, 0xa5, 0x09, 0x65, 0x44, 0xe9, 0x2a, 0x25, 0x25, 0x52, 0x9a, 0x14, 0x51,
	0x44, 0x4c, 0x8a, 0x28, 0x15, 0x12, 0xc6, 0x4a, 0x19, 0xcd, 0xee, 0xda, 0xd8, 0x4e, 0x1c, 0x02,
	0x8d, 0xf5, 0xe6, 0xcd, 0xf7, 0xcd, 0xfb, 0x3e, 0xfb, 0xbd, 0x67, 0x38, 0xad, 0x58, 0x16, 0xa1,
	0x0e, 0x57, 0x0d, 0x82, 0x29, 0x2f, 0x58, 0x36, 0xe3, 0x4c, 0x4a, 0x60, 0x4d, 0xc7, 0x7e, 0x38,
	0x37, 0xaf, 0x33, 0xa6, 0x1b, 0x58, 0x56, 0x2c, 0x22, 0x2b, 0x94, 0x32, 0xae, 0x70, 0xc2, 0xa8,
	0x13, 0x00, 0xe7, 0xfe, 0xd6, 0x09, 0xaf, 0xbb, 0xb5, 0x82, 0xca, 0x4c, 0xd9, 0x64, 0x35, 0x62,
	0x08, 0xe2, 0x43, 0x59, 0x7c, 0xe6, 0x55, 0x83, 0xb9, 0x9a, 0xec, 0xe3, 0x74, 0x4c, 0xbb, 0x41,
	0xc8, 0x5c, 0xb9, 0x92, 0xa9, 0xe5, 0x4d, 0x85, 0xab, 0xf5, 0x3c, 0xa6, 0x3a, 0xa1, 0x58, 0xd6,
	0x4c, 0x9c, 0xf7, 0xa9, 0xb2, 0xc1, 0xd4, 0xf0, 0x91, 0x89, 0x50, 0x7c, 0x78, 0xfc, 0x59, 0x67,
	0x3a, 0x0b, 0x30, 0x22, 0x0a, 0xb2, 0x99, 0x63, 0x00, 0x67, 0x4a, 0x96, 0xb5, 0x4a, 0x1d, 0xbe,
	0xe2, 0x9b, 0x5c, 0x67, 0x6c, 0xdb, 0xb5, 0xd6, 0xb0, 0x27, 0xdd, 0x82, 0x30, 0x7c, 0x61, 0x1b,
	0x7b, 0x08, 0xa4, 0x41, 0x76, 0x7c, 0xf9, 0x97, 0x42, 0xd7, 0x7c, 0x21, 0xa4, 0xad, 0x61, 0xaf,
	0x3c, 0xd9, 0x68, 0xa3, 0x1e, 0x70, 0xa5, 0x27, 0x96, 0xfe, 0x80, 0x09, 0x97, 0x92, 0xfb, 0x2e,
	0xae, 0x12, 0x0d, 0x45, 0xd3, 0x20, 0x9b, 0x28, 0x27, 0x1b, 0x6d, 0x14, 0x0f, 0x92, 0x44, 0xab,
	0x84, 0xd1, 0xaa, 0x26, 0xfd, 0x05, 0x27, 0xbb, 0xd0, 0x2a, 0xf7, 0x2c, 0x8c, 0x62, 0x3e, 0x7e,
	0xaa, 0xd1, 0x46, 0xc9, 0x0e, 0x5e, 0xe4, 0x2b, 0xc9, 0x0e, 0xe7, 0xae, 0x67, 0xe1, 0x62, 0xf2,
	0xe3, 0x39, 0x02, 0x9f, 0xcf, 0x11, 0x78, 0xf9, 0x6c, 0x01, 0x64, 0x9a, 0xa3, 0x70, 0xaa, 0xcf,
	0x92, 0x30, 0xf3, 0x0f, 0x8c, 0x5d, 0xba, 0xf8, 0xfd, 0x6b, 0x17, 0x03, 0xe6, 0xcb, 0x23, 0x47,
	0xef, 0x16, 0x22, 0x15, 0xc1, 0x29, 0xee, 0x8f, 0x8a, 0xe7, 0xcf, 0xce, 0x11, 0xd8, 0x6d, 0x21,
	0xb0, 0xd7, 0x42, 0xe0, 0x55, 0x0b, 0x81, 0xa7, 0x17, 0x68, 0x2f, 0xd6, 0xd1, 0xf4, 0xef, 0x1a,
	0xf6, 0x0a, 0xf7, 0x42, 0x49, 0xb9, 0x5e, 0xa5, 0x7d, 0x37, 0x42, 0x6c, 0x4e, 0xb1, 0x2c, 0xaa,
	0x98, 0xc1, 0x45, 0xa9, 0xfb, 0x35, 0x89, 0x50, 0x64, 0x6e, 0x2b, 0xa6, 0x0f, 0x79, 0x80, 0x6d,
	0x67, 0x08, 0x64, 0x13, 0xdb, 0x0e, 0x61, 0x54, 0xa0, 0xf2, 0xcc, 0xd6, 0x87, 0xa0, 0xee, 0xd8,
	0xba, 0x42, 0xc9, 0x23, 0xbf, 0x21, 0x73, 0xaa, 0xe1, 0x3a, 0x1c, 0xdb, 0x83, 0xd0, 0x95, 0x20,
	0x1d, 0xfe, 0x8a, 0x9d, 0x63, 0x57, 0x46, 0xc8, 0xfa, 0x56, 0x91, 0x01, 0xe6, 0x40, 0x31, 0xe6,
	0x6a, 0x06, 0xe6, 0x57, 0x56, 0x0b, 0x60, 0x3d, 0xe5, 0x82, 0xc4, 0x0f, 0xd4, 0xeb, 0xe5, 0xf6,
	0xd6, 0x7e, 0x7e, 0x81, 0xde, 0x82, 0xeb, 0x99, 0xbc, 0x86, 0xb1, 0x6b, 0xfa, 0xb9, 0x99, 0x85,
	0x5c, 0x5f, 0x2b, 0x0d, 0x76, 0xcf, 0x61, 0x1b, 0x8d, 0x50, 0x46, 0x71, 0xe6, 0x04, 0xc0, 0x89,
	0xbe, 0xd6, 0x95, 0x66, 0xe0, 0xd8, 0x16, 0xc1, 0x86, 0xe6, 0x20, 0x90, 0x8e, 0x65, 0x13, 0x95,
	0xf0, 0x24, 0xfd, 0x0f, 0x61, 0xb0, 0xbe, 0xaa, 0x62, 0x00, 0xa2, 0xfe, 0x00, 0xfc, 0x3a, 0x6c,
	0x00, 0x2e, 0x5b, 0x3f, 0xa1, 0x76, 0x67, 0xe7, 0x3f, 0x18, 0x37, 0x98, 0xea, 0xab, 0xf3, 0x07,
	0x72, 0x7c, 0xf9, 0xb7, 0x82, 0x46, 0x1c, 0x6e, 0x93, 0x9a, 0xcb, 0xb1, 0x56, 0xf5, 0x37, 0x51,
	0x35, 0xd8, 0x44, 0x85, 0x75, 0xa6, 0x86, 0x2f, 0x74, 0x49, 0xd2, 0x22, 0x4c, 0x50, 0xc6, 0xc9,
	0x96, 0x27, 0x56, 0xc0, 0x48, 0x1a, 0x64, 0x63, 0xe5, 0x89, 0x83, 0x16, 0x02, 0xfb, 0x87, 0xb3,
	0xa3, 0x94, 0xa9, 0xa6, 0x55, 0x89, 0x07, 0xf7, 0xab, 0x5a, 0x31, 0x2e, 0x86, 0xeb, 0xac, 0x85,
	0x22, 0xcb, 0x2f, 0xa2, 0x03, 0x73, 0x5c, 0xb2, 0x88, 0xd4, 0x00, 0xf0, 0xa7, 0x8d, 0x3a, 0xdb,
	0xe9, 0xf7, 0xfe, 0x3d, 0x3f, 0x73, 0x68, 0xd8, 0x65, 0xc6, 0xf8, 0xd4, 0x42, 0xe5, 0x0a, 0x76,
	0x98, 0x6b, 0xab, 0xb8, 0x64, 0x59, 0x25, 0xaa, 0x18, 0x1e, 0x27, 0xaa, 0x93, 0x2b, 0xa9, 0x42,
	0xf8, 0x26, 0xc1, 0x3b, 0xb9, 0xab, 0xc7, 0xeb, 0xe0, 0x02, 0x81, 0xdd, 0x36, 0x02, 0x8f, 0x5f,
	0x7f, 0x78, 0x12, 0x45, 0x99, 0x69, 0xd9, 0xa9, 0xb3, 0x1d, 0xb9, 0xef, 0xaf, 0xa3, 0x08, 0x16,
	0x97, 0x80, 0xb4, 0x09, 0x67, 0x37, 0xb8, 0x8d, 0x15, 0xb3, 0x4f, 0x86, 0xb3, 0xce, 0x54, 0xc5,
	0xb8, 0xa9, 0x87, 0xc8, 0x12, 0x28, 0xcf, 0x1f, 0xbd, 0x4f, 0x45, 0x8e, 0x9a, 0x29, 0x70, 0xdc,
	0x4c, 0x81, 0x93, 0x66, 0x0a, 0xec, 0x9d, 0xa6, 0x22, 0xc7, 0xa7, 0xa9, 0xc8, 0x9b, 0xd3, 0x54,
	0xa4, 0x36, 0xe6, 0xd3, 0xfe, 0xfc, 0x12, 0x00, 0x00, 0xff, 0xff, 0x70, 0x16, 0x0a, 0xf2, 0xcd,
	0x06, 0x00, 0x00,
}

func (this *AppInstClientLookupKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&edgeproto.AppInstClientLookupKey{")
	if this.Appinstkey != nil {
		s = append(s, "Appinstkey: "+fmt.Sprintf("%#v", this.Appinstkey)+",\n")
	}
	s = append(s, "UniqueId: "+fmt.Sprintf("%#v", this.UniqueId)+",\n")
	s = append(s, "UniqueIdType: "+fmt.Sprintf("%#v", this.UniqueIdType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAppinstclient(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AppInstClientApiClient is the client API for AppInstClientApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AppInstClientApiClient interface {
	// Show application instance clients.
	ShowAppInstClient(ctx context.Context, in *AppInstClientKey, opts ...grpc.CallOption) (AppInstClientApi_ShowAppInstClientClient, error)
	// This is used unternally to forward AppInstClients to other Controllers
	StreamAppInstClientsLocal(ctx context.Context, in *AppInstClientKey, opts ...grpc.CallOption) (AppInstClientApi_StreamAppInstClientsLocalClient, error)
}

type appInstClientApiClient struct {
	cc *grpc.ClientConn
}

func NewAppInstClientApiClient(cc *grpc.ClientConn) AppInstClientApiClient {
	return &appInstClientApiClient{cc}
}

func (c *appInstClientApiClient) ShowAppInstClient(ctx context.Context, in *AppInstClientKey, opts ...grpc.CallOption) (AppInstClientApi_ShowAppInstClientClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AppInstClientApi_serviceDesc.Streams[0], "/edgeproto.AppInstClientApi/ShowAppInstClient", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstClientApiShowAppInstClientClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstClientApi_ShowAppInstClientClient interface {
	Recv() (*AppInstClient, error)
	grpc.ClientStream
}

type appInstClientApiShowAppInstClientClient struct {
	grpc.ClientStream
}

func (x *appInstClientApiShowAppInstClientClient) Recv() (*AppInstClient, error) {
	m := new(AppInstClient)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *appInstClientApiClient) StreamAppInstClientsLocal(ctx context.Context, in *AppInstClientKey, opts ...grpc.CallOption) (AppInstClientApi_StreamAppInstClientsLocalClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AppInstClientApi_serviceDesc.Streams[1], "/edgeproto.AppInstClientApi/StreamAppInstClientsLocal", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstClientApiStreamAppInstClientsLocalClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstClientApi_StreamAppInstClientsLocalClient interface {
	Recv() (*AppInstClient, error)
	grpc.ClientStream
}

type appInstClientApiStreamAppInstClientsLocalClient struct {
	grpc.ClientStream
}

func (x *appInstClientApiStreamAppInstClientsLocalClient) Recv() (*AppInstClient, error) {
	m := new(AppInstClient)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AppInstClientApiServer is the server API for AppInstClientApi service.
type AppInstClientApiServer interface {
	// Show application instance clients.
	ShowAppInstClient(*AppInstClientKey, AppInstClientApi_ShowAppInstClientServer) error
	// This is used unternally to forward AppInstClients to other Controllers
	StreamAppInstClientsLocal(*AppInstClientKey, AppInstClientApi_StreamAppInstClientsLocalServer) error
}

// UnimplementedAppInstClientApiServer can be embedded to have forward compatible implementations.
type UnimplementedAppInstClientApiServer struct {
}

func (*UnimplementedAppInstClientApiServer) ShowAppInstClient(req *AppInstClientKey, srv AppInstClientApi_ShowAppInstClientServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowAppInstClient not implemented")
}
func (*UnimplementedAppInstClientApiServer) StreamAppInstClientsLocal(req *AppInstClientKey, srv AppInstClientApi_StreamAppInstClientsLocalServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamAppInstClientsLocal not implemented")
}

func RegisterAppInstClientApiServer(s *grpc.Server, srv AppInstClientApiServer) {
	s.RegisterService(&_AppInstClientApi_serviceDesc, srv)
}

func _AppInstClientApi_ShowAppInstClient_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInstClientKey)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstClientApiServer).ShowAppInstClient(m, &appInstClientApiShowAppInstClientServer{stream})
}

type AppInstClientApi_ShowAppInstClientServer interface {
	Send(*AppInstClient) error
	grpc.ServerStream
}

type appInstClientApiShowAppInstClientServer struct {
	grpc.ServerStream
}

func (x *appInstClientApiShowAppInstClientServer) Send(m *AppInstClient) error {
	return x.ServerStream.SendMsg(m)
}

func _AppInstClientApi_StreamAppInstClientsLocal_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInstClientKey)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstClientApiServer).StreamAppInstClientsLocal(m, &appInstClientApiStreamAppInstClientsLocalServer{stream})
}

type AppInstClientApi_StreamAppInstClientsLocalServer interface {
	Send(*AppInstClient) error
	grpc.ServerStream
}

type appInstClientApiStreamAppInstClientsLocalServer struct {
	grpc.ServerStream
}

func (x *appInstClientApiStreamAppInstClientsLocalServer) Send(m *AppInstClient) error {
	return x.ServerStream.SendMsg(m)
}

var _AppInstClientApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.AppInstClientApi",
	HandlerType: (*AppInstClientApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowAppInstClient",
			Handler:       _AppInstClientApi_ShowAppInstClient_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamAppInstClientsLocal",
			Handler:       _AppInstClientApi_StreamAppInstClientsLocal_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "appinstclient.proto",
}

func (m *AppInstClientLookupKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstClientLookupKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppInstClientLookupKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UniqueIdType) > 0 {
		i -= len(m.UniqueIdType)
		copy(dAtA[i:], m.UniqueIdType)
		i = encodeVarintAppinstclient(dAtA, i, uint64(len(m.UniqueIdType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UniqueId) > 0 {
		i -= len(m.UniqueId)
		copy(dAtA[i:], m.UniqueId)
		i = encodeVarintAppinstclient(dAtA, i, uint64(len(m.UniqueId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Appinstkey != nil {
		{
			size, err := m.Appinstkey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppinstclient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppInstClientKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstClientKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppInstClientKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinstclient(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AppInstClient) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstClient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppInstClient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NotifyId != 0 {
		i = encodeVarintAppinstclient(dAtA, i, uint64(m.NotifyId))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinstclient(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.ClientKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinstclient(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintAppinstclient(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintAppinstclient(dAtA []byte, offset int, v uint64) int {
	offset -= sovAppinstclient(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AppInstClientLookupKey) Matches(o *AppInstClientLookupKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.Appinstkey != nil {
		if m.Appinstkey == nil && o.Appinstkey != nil || m.Appinstkey != nil && o.Appinstkey == nil {
			return false
		} else if m.Appinstkey != nil && o.Appinstkey != nil {
			if !m.Appinstkey.Matches(o.Appinstkey, fopts...) {
				return false
			}
		}
	}
	if !opts.Filter || o.UniqueId != "" {
		if o.UniqueId != m.UniqueId {
			return false
		}
	}
	if !opts.Filter || o.UniqueIdType != "" {
		if o.UniqueIdType != m.UniqueIdType {
			return false
		}
	}
	return true
}

func (m *AppInstClientLookupKey) CopyInFields(src *AppInstClientLookupKey) int {
	changed := 0
	if src.Appinstkey != nil {
		m.Appinstkey = &AppInstKey{}
		if m.Appinstkey.AppKey.Organization != src.Appinstkey.AppKey.Organization {
			m.Appinstkey.AppKey.Organization = src.Appinstkey.AppKey.Organization
			changed++
		}
		if m.Appinstkey.AppKey.Name != src.Appinstkey.AppKey.Name {
			m.Appinstkey.AppKey.Name = src.Appinstkey.AppKey.Name
			changed++
		}
		if m.Appinstkey.AppKey.Version != src.Appinstkey.AppKey.Version {
			m.Appinstkey.AppKey.Version = src.Appinstkey.AppKey.Version
			changed++
		}
		if m.Appinstkey.ClusterInstKey.ClusterKey.Name != src.Appinstkey.ClusterInstKey.ClusterKey.Name {
			m.Appinstkey.ClusterInstKey.ClusterKey.Name = src.Appinstkey.ClusterInstKey.ClusterKey.Name
			changed++
		}
		if m.Appinstkey.ClusterInstKey.CloudletKey.Organization != src.Appinstkey.ClusterInstKey.CloudletKey.Organization {
			m.Appinstkey.ClusterInstKey.CloudletKey.Organization = src.Appinstkey.ClusterInstKey.CloudletKey.Organization
			changed++
		}
		if m.Appinstkey.ClusterInstKey.CloudletKey.Name != src.Appinstkey.ClusterInstKey.CloudletKey.Name {
			m.Appinstkey.ClusterInstKey.CloudletKey.Name = src.Appinstkey.ClusterInstKey.CloudletKey.Name
			changed++
		}
		if m.Appinstkey.ClusterInstKey.Organization != src.Appinstkey.ClusterInstKey.Organization {
			m.Appinstkey.ClusterInstKey.Organization = src.Appinstkey.ClusterInstKey.Organization
			changed++
		}
	} else if m.Appinstkey != nil {
		m.Appinstkey = nil
		changed++
	}
	if m.UniqueId != src.UniqueId {
		m.UniqueId = src.UniqueId
		changed++
	}
	if m.UniqueIdType != src.UniqueIdType {
		m.UniqueIdType = src.UniqueIdType
		changed++
	}
	return changed
}

func (m *AppInstClientLookupKey) DeepCopyIn(src *AppInstClientLookupKey) {
	if src.Appinstkey != nil {
		var tmp_Appinstkey AppInstKey
		tmp_Appinstkey.DeepCopyIn(src.Appinstkey)
		m.Appinstkey = &tmp_Appinstkey
	} else {
		m.Appinstkey = nil
	}
	m.UniqueId = src.UniqueId
	m.UniqueIdType = src.UniqueIdType
}

func (m *AppInstClientLookupKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal AppInstClientLookupKey key string", "obj", m)
	}
	return string(key)
}

func AppInstClientLookupKeyStringParse(str string, key *AppInstClientLookupKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal AppInstClientLookupKey key string", "str", str)
	}
}

func (m *AppInstClientLookupKey) NotFoundError() error {
	return fmt.Errorf("AppInstClientLookup key %s not found", m.GetKeyString())
}

func (m *AppInstClientLookupKey) ExistsError() error {
	return fmt.Errorf("AppInstClientLookup key %s already exists", m.GetKeyString())
}

var AppInstClientLookupKeyTagUniqueId = "uniqueid"
var AppInstClientLookupKeyTagUniqueIdType = "uniqueidtype"

func (m *AppInstClientLookupKey) GetTags() map[string]string {
	tags := make(map[string]string)
	tags["apporg"] = m.Appinstkey.AppKey.Organization
	tags["app"] = m.Appinstkey.AppKey.Name
	tags["appver"] = m.Appinstkey.AppKey.Version
	tags["cluster"] = m.Appinstkey.ClusterInstKey.ClusterKey.Name
	tags["cloudletorg"] = m.Appinstkey.ClusterInstKey.CloudletKey.Organization
	tags["cloudlet"] = m.Appinstkey.ClusterInstKey.CloudletKey.Name
	tags["clusterorg"] = m.Appinstkey.ClusterInstKey.Organization
	tags["uniqueid"] = m.UniqueId
	tags["uniqueidtype"] = m.UniqueIdType
	return tags
}

// Helper method to check that enums have valid values
func (m *AppInstClientLookupKey) ValidateEnums() error {
	if err := m.Appinstkey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *AppInstClientKey) Matches(o *AppInstClientKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	return true
}

func (m *AppInstClientKey) CopyInFields(src *AppInstClientKey) int {
	changed := 0
	if src.Key.Appinstkey != nil {
		m.Key.Appinstkey = &AppInstKey{}
		if m.Key.Appinstkey.AppKey.Organization != src.Key.Appinstkey.AppKey.Organization {
			m.Key.Appinstkey.AppKey.Organization = src.Key.Appinstkey.AppKey.Organization
			changed++
		}
		if m.Key.Appinstkey.AppKey.Name != src.Key.Appinstkey.AppKey.Name {
			m.Key.Appinstkey.AppKey.Name = src.Key.Appinstkey.AppKey.Name
			changed++
		}
		if m.Key.Appinstkey.AppKey.Version != src.Key.Appinstkey.AppKey.Version {
			m.Key.Appinstkey.AppKey.Version = src.Key.Appinstkey.AppKey.Version
			changed++
		}
		if m.Key.Appinstkey.ClusterInstKey.ClusterKey.Name != src.Key.Appinstkey.ClusterInstKey.ClusterKey.Name {
			m.Key.Appinstkey.ClusterInstKey.ClusterKey.Name = src.Key.Appinstkey.ClusterInstKey.ClusterKey.Name
			changed++
		}
		if m.Key.Appinstkey.ClusterInstKey.CloudletKey.Organization != src.Key.Appinstkey.ClusterInstKey.CloudletKey.Organization {
			m.Key.Appinstkey.ClusterInstKey.CloudletKey.Organization = src.Key.Appinstkey.ClusterInstKey.CloudletKey.Organization
			changed++
		}
		if m.Key.Appinstkey.ClusterInstKey.CloudletKey.Name != src.Key.Appinstkey.ClusterInstKey.CloudletKey.Name {
			m.Key.Appinstkey.ClusterInstKey.CloudletKey.Name = src.Key.Appinstkey.ClusterInstKey.CloudletKey.Name
			changed++
		}
		if m.Key.Appinstkey.ClusterInstKey.Organization != src.Key.Appinstkey.ClusterInstKey.Organization {
			m.Key.Appinstkey.ClusterInstKey.Organization = src.Key.Appinstkey.ClusterInstKey.Organization
			changed++
		}
	} else if m.Key.Appinstkey != nil {
		m.Key.Appinstkey = nil
		changed++
	}
	if m.Key.UniqueId != src.Key.UniqueId {
		m.Key.UniqueId = src.Key.UniqueId
		changed++
	}
	if m.Key.UniqueIdType != src.Key.UniqueIdType {
		m.Key.UniqueIdType = src.Key.UniqueIdType
		changed++
	}
	return changed
}

func (m *AppInstClientKey) DeepCopyIn(src *AppInstClientKey) {
	m.Key.DeepCopyIn(&src.Key)
}

func (s *AppInstClientKey) HasFields() bool {
	return false
}

type AppInstClientKeyStore struct {
	kvstore objstore.KVStore
}

func NewAppInstClientKeyStore(kvstore objstore.KVStore) AppInstClientKeyStore {
	return AppInstClientKeyStore{kvstore: kvstore}
}

func (s *AppInstClientKeyStore) Create(ctx context.Context, m *AppInstClientKey, wait func(int64)) (*Result, error) {
	err := m.Validate(nil)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstClientKey", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstClientKeyStore) Update(ctx context.Context, m *AppInstClientKey, wait func(int64)) (*Result, error) {
	err := m.Validate(nil)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstClientKey", m.GetKey())
	var vers int64 = 0
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstClientKeyStore) Put(ctx context.Context, m *AppInstClientKey, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(nil)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstClientKey", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstClientKeyStore) Delete(ctx context.Context, m *AppInstClientKey, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstClientKey", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstClientKeyStore) LoadOne(key string) (*AppInstClientKey, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj AppInstClientKey
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse AppInstClientKey data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *AppInstClientKeyStore) STMGet(stm concurrency.STM, key *AppInstClientLookupKey, buf *AppInstClientKey) bool {
	keystr := objstore.DbKeyString("AppInstClientKey", key)
	valstr := stm.Get(keystr)
	if valstr == "" {
		return false
	}
	if buf != nil {
		err := json.Unmarshal([]byte(valstr), buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *AppInstClientKeyStore) STMPut(stm concurrency.STM, obj *AppInstClientKey, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("AppInstClientKey", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("AppInstClientKey json marsahal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *AppInstClientKeyStore) STMDel(stm concurrency.STM, key *AppInstClientLookupKey) {
	keystr := objstore.DbKeyString("AppInstClientKey", key)
	stm.Del(keystr)
}

type AppInstClientKeyKeyWatcher struct {
	cb func(ctx context.Context)
}

type AppInstClientKeyCacheData struct {
	Obj    *AppInstClientKey
	ModRev int64
}

// AppInstClientKeyCache caches AppInstClientKey objects in memory in a hash table
// and keeps them in sync with the database.
type AppInstClientKeyCache struct {
	Objs          map[AppInstClientLookupKey]*AppInstClientKeyCacheData
	Mux           util.Mutex
	List          map[AppInstClientLookupKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *AppInstClientLookupKey, old *AppInstClientKey, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *AppInstClientKey, new *AppInstClientKey)
	DeletedCbs    []func(ctx context.Context, old *AppInstClientKey)
	KeyWatchers   map[AppInstClientLookupKey][]*AppInstClientKeyKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *AppInstClientLookupKey)
	DeletedKeyCbs []func(ctx context.Context, key *AppInstClientLookupKey)
}

func NewAppInstClientKeyCache() *AppInstClientKeyCache {
	cache := AppInstClientKeyCache{}
	InitAppInstClientKeyCache(&cache)
	return &cache
}

func InitAppInstClientKeyCache(cache *AppInstClientKeyCache) {
	cache.Objs = make(map[AppInstClientLookupKey]*AppInstClientKeyCacheData)
	cache.KeyWatchers = make(map[AppInstClientLookupKey][]*AppInstClientKeyKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *AppInstClientKeyCache) GetTypeString() string {
	return "AppInstClientKey"
}

func (c *AppInstClientKeyCache) Get(key *AppInstClientLookupKey, valbuf *AppInstClientKey) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *AppInstClientKeyCache) GetWithRev(key *AppInstClientLookupKey, valbuf *AppInstClientKey, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *AppInstClientKeyCache) HasKey(key *AppInstClientLookupKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *AppInstClientKeyCache) GetAllKeys(ctx context.Context, cb func(key *AppInstClientLookupKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *AppInstClientKeyCache) Update(ctx context.Context, in *AppInstClientKey, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *AppInstClientKey) (*AppInstClientKey, bool) {
		return in, true
	})
}

func (c *AppInstClientKeyCache) UpdateModFunc(ctx context.Context, key *AppInstClientLookupKey, modRev int64, modFunc func(old *AppInstClientKey) (new *AppInstClientKey, changed bool)) {
	c.Mux.Lock()
	var old *AppInstClientKey
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	for _, cb := range c.UpdatedCbs {
		newCopy := &AppInstClientKey{}
		newCopy.DeepCopyIn(new)
		defer cb(ctx, old, newCopy)
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			defer cb(ctx, new.GetKey(), old, modRev)
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &AppInstClientKey{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &AppInstClientKeyCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *AppInstClientKeyCache) Delete(ctx context.Context, in *AppInstClientKey, modRev int64) {
	c.Mux.Lock()
	var old *AppInstClientKey
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	c.Mux.Unlock()
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, in.GetKey(), old, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *AppInstClientKeyCache) Prune(ctx context.Context, validKeys map[AppInstClientLookupKey]struct{}) {
	notify := make(map[AppInstClientLookupKey]*AppInstClientKeyCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, old.Obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *AppInstClientKeyCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *AppInstClientKeyCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *AppInstClientKeyCache) Show(filter *AppInstClientKey, cb func(ret *AppInstClientKey) error) error {
	log.DebugLog(log.DebugLevelApi, "Show AppInstClientKey", "count", len(c.Objs))
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		log.DebugLog(log.DebugLevelApi, "Compare AppInstClientKey", "filter", filter, "data", data)
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		log.DebugLog(log.DebugLevelApi, "Show AppInstClientKey", "obj", data.Obj)
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func AppInstClientKeyGenericNotifyCb(fn func(key *AppInstClientLookupKey, old *AppInstClientKey)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*AppInstClientLookupKey), obj.(*AppInstClientKey))
	}
}

func (c *AppInstClientKeyCache) SetNotifyCb(fn func(ctx context.Context, obj *AppInstClientLookupKey, old *AppInstClientKey, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *AppInstClientLookupKey, old *AppInstClientKey, modRev int64){fn}
}

func (c *AppInstClientKeyCache) SetUpdatedCb(fn func(ctx context.Context, old *AppInstClientKey, new *AppInstClientKey)) {
	c.UpdatedCbs = []func(ctx context.Context, old *AppInstClientKey, new *AppInstClientKey){fn}
}

func (c *AppInstClientKeyCache) SetDeletedCb(fn func(ctx context.Context, old *AppInstClientKey)) {
	c.DeletedCbs = []func(ctx context.Context, old *AppInstClientKey){fn}
}

func (c *AppInstClientKeyCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *AppInstClientLookupKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *AppInstClientLookupKey){fn}
}

func (c *AppInstClientKeyCache) SetDeletedKeyCb(fn func(ctx context.Context, key *AppInstClientLookupKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *AppInstClientLookupKey){fn}
}

func (c *AppInstClientKeyCache) AddUpdatedCb(fn func(ctx context.Context, old *AppInstClientKey, new *AppInstClientKey)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *AppInstClientKeyCache) AddDeletedCb(fn func(ctx context.Context, old *AppInstClientKey)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *AppInstClientKeyCache) AddNotifyCb(fn func(ctx context.Context, obj *AppInstClientLookupKey, old *AppInstClientKey, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *AppInstClientKeyCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *AppInstClientLookupKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *AppInstClientKeyCache) AddDeletedKeyCb(fn func(ctx context.Context, key *AppInstClientLookupKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *AppInstClientKeyCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *AppInstClientKeyCache) WatchKey(key *AppInstClientLookupKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*AppInstClientKeyKeyWatcher, 0)
	}
	watcher := AppInstClientKeyKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching AppInstClientKey", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *AppInstClientKeyCache) TriggerKeyWatchers(ctx context.Context, key *AppInstClientLookupKey) {
	watchers := make([]*AppInstClientKeyKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *AppInstClientKeyCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := AppInstClientKey{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse AppInstClientKey data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *AppInstClientKeyCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := AppInstClientKey{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	AppInstClientLookupKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *AppInstClientKeyCache) SyncListStart(ctx context.Context) {
	c.List = make(map[AppInstClientLookupKey]struct{})
}

func (c *AppInstClientKeyCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[AppInstClientLookupKey]*AppInstClientKeyCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, val.Obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *AppInstClientKeyCache) UsesOrg(org string) bool {
	return false
}

func (m *AppInstClientKey) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *AppInstClientKey) GetKey() *AppInstClientLookupKey {
	return &m.Key
}

func (m *AppInstClientKey) GetKeyVal() AppInstClientLookupKey {
	return m.Key
}

func (m *AppInstClientKey) SetKey(key *AppInstClientLookupKey) {
	m.Key = *key
}

func CmpSortAppInstClientKey(a AppInstClientKey, b AppInstClientKey) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *AppInstClientKey) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

const AppInstClientFieldClientKey = "2"
const AppInstClientFieldClientKeyKey = "2.1"
const AppInstClientFieldClientKeyKeyAppinstkey = "2.1.1"
const AppInstClientFieldClientKeyKeyAppinstkeyAppKey = "2.1.1.1"
const AppInstClientFieldClientKeyKeyAppinstkeyAppKeyOrganization = "2.1.1.1.1"
const AppInstClientFieldClientKeyKeyAppinstkeyAppKeyName = "2.1.1.1.2"
const AppInstClientFieldClientKeyKeyAppinstkeyAppKeyVersion = "2.1.1.1.3"
const AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKey = "2.1.1.4"
const AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyClusterKey = "2.1.1.4.1"
const AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyClusterKeyName = "2.1.1.4.1.1"
const AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyCloudletKey = "2.1.1.4.2"
const AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyCloudletKeyOrganization = "2.1.1.4.2.1"
const AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyCloudletKeyName = "2.1.1.4.2.2"
const AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyOrganization = "2.1.1.4.3"
const AppInstClientFieldClientKeyKeyUniqueId = "2.1.2"
const AppInstClientFieldClientKeyKeyUniqueIdType = "2.1.3"
const AppInstClientFieldLocation = "3"
const AppInstClientFieldLocationLatitude = "3.1"
const AppInstClientFieldLocationLongitude = "3.2"
const AppInstClientFieldLocationHorizontalAccuracy = "3.3"
const AppInstClientFieldLocationVerticalAccuracy = "3.4"
const AppInstClientFieldLocationAltitude = "3.5"
const AppInstClientFieldLocationCourse = "3.6"
const AppInstClientFieldLocationSpeed = "3.7"
const AppInstClientFieldLocationTimestamp = "3.8"
const AppInstClientFieldLocationTimestampSeconds = "3.8.1"
const AppInstClientFieldLocationTimestampNanos = "3.8.2"
const AppInstClientFieldNotifyId = "4"

var AppInstClientAllFields = []string{
	AppInstClientFieldClientKeyKeyAppinstkeyAppKeyOrganization,
	AppInstClientFieldClientKeyKeyAppinstkeyAppKeyName,
	AppInstClientFieldClientKeyKeyAppinstkeyAppKeyVersion,
	AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyClusterKeyName,
	AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyCloudletKeyOrganization,
	AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyCloudletKeyName,
	AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyOrganization,
	AppInstClientFieldClientKeyKeyUniqueId,
	AppInstClientFieldClientKeyKeyUniqueIdType,
	AppInstClientFieldLocationLatitude,
	AppInstClientFieldLocationLongitude,
	AppInstClientFieldLocationHorizontalAccuracy,
	AppInstClientFieldLocationVerticalAccuracy,
	AppInstClientFieldLocationAltitude,
	AppInstClientFieldLocationCourse,
	AppInstClientFieldLocationSpeed,
	AppInstClientFieldLocationTimestampSeconds,
	AppInstClientFieldLocationTimestampNanos,
	AppInstClientFieldNotifyId,
}

var AppInstClientAllFieldsMap = map[string]struct{}{
	AppInstClientFieldClientKeyKeyAppinstkeyAppKeyOrganization:                    struct{}{},
	AppInstClientFieldClientKeyKeyAppinstkeyAppKeyName:                            struct{}{},
	AppInstClientFieldClientKeyKeyAppinstkeyAppKeyVersion:                         struct{}{},
	AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyClusterKeyName:          struct{}{},
	AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyCloudletKeyOrganization: struct{}{},
	AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyCloudletKeyName:         struct{}{},
	AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyOrganization:            struct{}{},
	AppInstClientFieldClientKeyKeyUniqueId:                                        struct{}{},
	AppInstClientFieldClientKeyKeyUniqueIdType:                                    struct{}{},
	AppInstClientFieldLocationLatitude:                                            struct{}{},
	AppInstClientFieldLocationLongitude:                                           struct{}{},
	AppInstClientFieldLocationHorizontalAccuracy:                                  struct{}{},
	AppInstClientFieldLocationVerticalAccuracy:                                    struct{}{},
	AppInstClientFieldLocationAltitude:                                            struct{}{},
	AppInstClientFieldLocationCourse:                                              struct{}{},
	AppInstClientFieldLocationSpeed:                                               struct{}{},
	AppInstClientFieldLocationTimestampSeconds:                                    struct{}{},
	AppInstClientFieldLocationTimestampNanos:                                      struct{}{},
	AppInstClientFieldNotifyId:                                                    struct{}{},
}

var AppInstClientAllFieldsStringMap = map[string]string{
	AppInstClientFieldClientKeyKeyAppinstkeyAppKeyOrganization:                    "Client Key Key Appinstkey App Key Organization",
	AppInstClientFieldClientKeyKeyAppinstkeyAppKeyName:                            "Client Key Key Appinstkey App Key Name",
	AppInstClientFieldClientKeyKeyAppinstkeyAppKeyVersion:                         "Client Key Key Appinstkey App Key Version",
	AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyClusterKeyName:          "Client Key Key Appinstkey Cluster Inst Key Cluster Key Name",
	AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyCloudletKeyOrganization: "Client Key Key Appinstkey Cluster Inst Key Cloudlet Key Organization",
	AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyCloudletKeyName:         "Client Key Key Appinstkey Cluster Inst Key Cloudlet Key Name",
	AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyOrganization:            "Client Key Key Appinstkey Cluster Inst Key Organization",
	AppInstClientFieldClientKeyKeyUniqueId:                                        "Client Key Key Unique Id",
	AppInstClientFieldClientKeyKeyUniqueIdType:                                    "Client Key Key Unique Id Type",
	AppInstClientFieldLocationLatitude:                                            "Location Latitude",
	AppInstClientFieldLocationLongitude:                                           "Location Longitude",
	AppInstClientFieldLocationHorizontalAccuracy:                                  "Location Horizontal Accuracy",
	AppInstClientFieldLocationVerticalAccuracy:                                    "Location Vertical Accuracy",
	AppInstClientFieldLocationAltitude:                                            "Location Altitude",
	AppInstClientFieldLocationCourse:                                              "Location Course",
	AppInstClientFieldLocationSpeed:                                               "Location Speed",
	AppInstClientFieldLocationTimestampSeconds:                                    "Location Timestamp Seconds",
	AppInstClientFieldLocationTimestampNanos:                                      "Location Timestamp Nanos",
	AppInstClientFieldNotifyId:                                                    "Notify Id",
}

func (m *AppInstClient) IsKeyField(s string) bool {
	return strings.HasPrefix(s, AppInstClientFieldClientKey+".") || s == AppInstClientFieldClientKey
}

func (m *AppInstClient) DiffFields(o *AppInstClient, fields map[string]struct{}) {
	if m.ClientKey.Key.Appinstkey != nil && o.ClientKey.Key.Appinstkey != nil {
		if m.ClientKey.Key.Appinstkey.AppKey.Organization != o.ClientKey.Key.Appinstkey.AppKey.Organization {
			fields[AppInstClientFieldClientKeyKeyAppinstkeyAppKeyOrganization] = struct{}{}
			fields[AppInstClientFieldClientKeyKeyAppinstkeyAppKey] = struct{}{}
			fields[AppInstClientFieldClientKeyKeyAppinstkey] = struct{}{}
			fields[AppInstClientFieldClientKeyKey] = struct{}{}
			fields[AppInstClientFieldClientKey] = struct{}{}
		}
		if m.ClientKey.Key.Appinstkey.AppKey.Name != o.ClientKey.Key.Appinstkey.AppKey.Name {
			fields[AppInstClientFieldClientKeyKeyAppinstkeyAppKeyName] = struct{}{}
			fields[AppInstClientFieldClientKeyKeyAppinstkeyAppKey] = struct{}{}
			fields[AppInstClientFieldClientKeyKeyAppinstkey] = struct{}{}
			fields[AppInstClientFieldClientKeyKey] = struct{}{}
			fields[AppInstClientFieldClientKey] = struct{}{}
		}
		if m.ClientKey.Key.Appinstkey.AppKey.Version != o.ClientKey.Key.Appinstkey.AppKey.Version {
			fields[AppInstClientFieldClientKeyKeyAppinstkeyAppKeyVersion] = struct{}{}
			fields[AppInstClientFieldClientKeyKeyAppinstkeyAppKey] = struct{}{}
			fields[AppInstClientFieldClientKeyKeyAppinstkey] = struct{}{}
			fields[AppInstClientFieldClientKeyKey] = struct{}{}
			fields[AppInstClientFieldClientKey] = struct{}{}
		}
		if m.ClientKey.Key.Appinstkey.ClusterInstKey.ClusterKey.Name != o.ClientKey.Key.Appinstkey.ClusterInstKey.ClusterKey.Name {
			fields[AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyClusterKeyName] = struct{}{}
			fields[AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyClusterKey] = struct{}{}
			fields[AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKey] = struct{}{}
			fields[AppInstClientFieldClientKeyKeyAppinstkey] = struct{}{}
			fields[AppInstClientFieldClientKeyKey] = struct{}{}
			fields[AppInstClientFieldClientKey] = struct{}{}
		}
		if m.ClientKey.Key.Appinstkey.ClusterInstKey.CloudletKey.Organization != o.ClientKey.Key.Appinstkey.ClusterInstKey.CloudletKey.Organization {
			fields[AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyCloudletKeyOrganization] = struct{}{}
			fields[AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyCloudletKey] = struct{}{}
			fields[AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKey] = struct{}{}
			fields[AppInstClientFieldClientKeyKeyAppinstkey] = struct{}{}
			fields[AppInstClientFieldClientKeyKey] = struct{}{}
			fields[AppInstClientFieldClientKey] = struct{}{}
		}
		if m.ClientKey.Key.Appinstkey.ClusterInstKey.CloudletKey.Name != o.ClientKey.Key.Appinstkey.ClusterInstKey.CloudletKey.Name {
			fields[AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyCloudletKeyName] = struct{}{}
			fields[AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyCloudletKey] = struct{}{}
			fields[AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKey] = struct{}{}
			fields[AppInstClientFieldClientKeyKeyAppinstkey] = struct{}{}
			fields[AppInstClientFieldClientKeyKey] = struct{}{}
			fields[AppInstClientFieldClientKey] = struct{}{}
		}
		if m.ClientKey.Key.Appinstkey.ClusterInstKey.Organization != o.ClientKey.Key.Appinstkey.ClusterInstKey.Organization {
			fields[AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKeyOrganization] = struct{}{}
			fields[AppInstClientFieldClientKeyKeyAppinstkeyClusterInstKey] = struct{}{}
			fields[AppInstClientFieldClientKeyKeyAppinstkey] = struct{}{}
			fields[AppInstClientFieldClientKeyKey] = struct{}{}
			fields[AppInstClientFieldClientKey] = struct{}{}
		}
	} else if (m.ClientKey.Key.Appinstkey != nil && o.ClientKey.Key.Appinstkey == nil) || (m.ClientKey.Key.Appinstkey == nil && o.ClientKey.Key.Appinstkey != nil) {
		fields[AppInstClientFieldClientKeyKeyAppinstkey] = struct{}{}
		fields[AppInstClientFieldClientKeyKey] = struct{}{}
		fields[AppInstClientFieldClientKey] = struct{}{}
	}
	if m.ClientKey.Key.UniqueId != o.ClientKey.Key.UniqueId {
		fields[AppInstClientFieldClientKeyKeyUniqueId] = struct{}{}
		fields[AppInstClientFieldClientKeyKey] = struct{}{}
		fields[AppInstClientFieldClientKey] = struct{}{}
	}
	if m.ClientKey.Key.UniqueIdType != o.ClientKey.Key.UniqueIdType {
		fields[AppInstClientFieldClientKeyKeyUniqueIdType] = struct{}{}
		fields[AppInstClientFieldClientKeyKey] = struct{}{}
		fields[AppInstClientFieldClientKey] = struct{}{}
	}
	if m.Location.Latitude != o.Location.Latitude {
		fields[AppInstClientFieldLocationLatitude] = struct{}{}
		fields[AppInstClientFieldLocation] = struct{}{}
	}
	if m.Location.Longitude != o.Location.Longitude {
		fields[AppInstClientFieldLocationLongitude] = struct{}{}
		fields[AppInstClientFieldLocation] = struct{}{}
	}
	if m.Location.HorizontalAccuracy != o.Location.HorizontalAccuracy {
		fields[AppInstClientFieldLocationHorizontalAccuracy] = struct{}{}
		fields[AppInstClientFieldLocation] = struct{}{}
	}
	if m.Location.VerticalAccuracy != o.Location.VerticalAccuracy {
		fields[AppInstClientFieldLocationVerticalAccuracy] = struct{}{}
		fields[AppInstClientFieldLocation] = struct{}{}
	}
	if m.Location.Altitude != o.Location.Altitude {
		fields[AppInstClientFieldLocationAltitude] = struct{}{}
		fields[AppInstClientFieldLocation] = struct{}{}
	}
	if m.Location.Course != o.Location.Course {
		fields[AppInstClientFieldLocationCourse] = struct{}{}
		fields[AppInstClientFieldLocation] = struct{}{}
	}
	if m.Location.Speed != o.Location.Speed {
		fields[AppInstClientFieldLocationSpeed] = struct{}{}
		fields[AppInstClientFieldLocation] = struct{}{}
	}
	if m.Location.Timestamp != nil && o.Location.Timestamp != nil {
		if m.Location.Timestamp.Seconds != o.Location.Timestamp.Seconds {
			fields[AppInstClientFieldLocationTimestampSeconds] = struct{}{}
			fields[AppInstClientFieldLocationTimestamp] = struct{}{}
			fields[AppInstClientFieldLocation] = struct{}{}
		}
		if m.Location.Timestamp.Nanos != o.Location.Timestamp.Nanos {
			fields[AppInstClientFieldLocationTimestampNanos] = struct{}{}
			fields[AppInstClientFieldLocationTimestamp] = struct{}{}
			fields[AppInstClientFieldLocation] = struct{}{}
		}
	} else if (m.Location.Timestamp != nil && o.Location.Timestamp == nil) || (m.Location.Timestamp == nil && o.Location.Timestamp != nil) {
		fields[AppInstClientFieldLocationTimestamp] = struct{}{}
		fields[AppInstClientFieldLocation] = struct{}{}
	}
	if m.NotifyId != o.NotifyId {
		fields[AppInstClientFieldNotifyId] = struct{}{}
	}
}

func (m *AppInstClient) CopyInFields(src *AppInstClient) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if _, set := fmap["2.1.1"]; set {
				if src.ClientKey.Key.Appinstkey != nil {
					m.ClientKey.Key.Appinstkey = &AppInstKey{}
					if _, set := fmap["2.1.1.1"]; set {
						if _, set := fmap["2.1.1.1.1"]; set {
							if m.ClientKey.Key.Appinstkey.AppKey.Organization != src.ClientKey.Key.Appinstkey.AppKey.Organization {
								m.ClientKey.Key.Appinstkey.AppKey.Organization = src.ClientKey.Key.Appinstkey.AppKey.Organization
								changed++
							}
						}
						if _, set := fmap["2.1.1.1.2"]; set {
							if m.ClientKey.Key.Appinstkey.AppKey.Name != src.ClientKey.Key.Appinstkey.AppKey.Name {
								m.ClientKey.Key.Appinstkey.AppKey.Name = src.ClientKey.Key.Appinstkey.AppKey.Name
								changed++
							}
						}
						if _, set := fmap["2.1.1.1.3"]; set {
							if m.ClientKey.Key.Appinstkey.AppKey.Version != src.ClientKey.Key.Appinstkey.AppKey.Version {
								m.ClientKey.Key.Appinstkey.AppKey.Version = src.ClientKey.Key.Appinstkey.AppKey.Version
								changed++
							}
						}
					}
					if _, set := fmap["2.1.1.4"]; set {
						if _, set := fmap["2.1.1.4.1"]; set {
							if _, set := fmap["2.1.1.4.1.1"]; set {
								if m.ClientKey.Key.Appinstkey.ClusterInstKey.ClusterKey.Name != src.ClientKey.Key.Appinstkey.ClusterInstKey.ClusterKey.Name {
									m.ClientKey.Key.Appinstkey.ClusterInstKey.ClusterKey.Name = src.ClientKey.Key.Appinstkey.ClusterInstKey.ClusterKey.Name
									changed++
								}
							}
						}
						if _, set := fmap["2.1.1.4.2"]; set {
							if _, set := fmap["2.1.1.4.2.1"]; set {
								if m.ClientKey.Key.Appinstkey.ClusterInstKey.CloudletKey.Organization != src.ClientKey.Key.Appinstkey.ClusterInstKey.CloudletKey.Organization {
									m.ClientKey.Key.Appinstkey.ClusterInstKey.CloudletKey.Organization = src.ClientKey.Key.Appinstkey.ClusterInstKey.CloudletKey.Organization
									changed++
								}
							}
							if _, set := fmap["2.1.1.4.2.2"]; set {
								if m.ClientKey.Key.Appinstkey.ClusterInstKey.CloudletKey.Name != src.ClientKey.Key.Appinstkey.ClusterInstKey.CloudletKey.Name {
									m.ClientKey.Key.Appinstkey.ClusterInstKey.CloudletKey.Name = src.ClientKey.Key.Appinstkey.ClusterInstKey.CloudletKey.Name
									changed++
								}
							}
						}
						if _, set := fmap["2.1.1.4.3"]; set {
							if m.ClientKey.Key.Appinstkey.ClusterInstKey.Organization != src.ClientKey.Key.Appinstkey.ClusterInstKey.Organization {
								m.ClientKey.Key.Appinstkey.ClusterInstKey.Organization = src.ClientKey.Key.Appinstkey.ClusterInstKey.Organization
								changed++
							}
						}
					}
				} else if m.ClientKey.Key.Appinstkey != nil {
					m.ClientKey.Key.Appinstkey = nil
					changed++
				}
			}
			if _, set := fmap["2.1.2"]; set {
				if m.ClientKey.Key.UniqueId != src.ClientKey.Key.UniqueId {
					m.ClientKey.Key.UniqueId = src.ClientKey.Key.UniqueId
					changed++
				}
			}
			if _, set := fmap["2.1.3"]; set {
				if m.ClientKey.Key.UniqueIdType != src.ClientKey.Key.UniqueIdType {
					m.ClientKey.Key.UniqueIdType = src.ClientKey.Key.UniqueIdType
					changed++
				}
			}
		}
	}
	if _, set := fmap["3"]; set {
		if _, set := fmap["3.1"]; set {
			if m.Location.Latitude != src.Location.Latitude {
				m.Location.Latitude = src.Location.Latitude
				changed++
			}
		}
		if _, set := fmap["3.2"]; set {
			if m.Location.Longitude != src.Location.Longitude {
				m.Location.Longitude = src.Location.Longitude
				changed++
			}
		}
		if _, set := fmap["3.3"]; set {
			if m.Location.HorizontalAccuracy != src.Location.HorizontalAccuracy {
				m.Location.HorizontalAccuracy = src.Location.HorizontalAccuracy
				changed++
			}
		}
		if _, set := fmap["3.4"]; set {
			if m.Location.VerticalAccuracy != src.Location.VerticalAccuracy {
				m.Location.VerticalAccuracy = src.Location.VerticalAccuracy
				changed++
			}
		}
		if _, set := fmap["3.5"]; set {
			if m.Location.Altitude != src.Location.Altitude {
				m.Location.Altitude = src.Location.Altitude
				changed++
			}
		}
		if _, set := fmap["3.6"]; set {
			if m.Location.Course != src.Location.Course {
				m.Location.Course = src.Location.Course
				changed++
			}
		}
		if _, set := fmap["3.7"]; set {
			if m.Location.Speed != src.Location.Speed {
				m.Location.Speed = src.Location.Speed
				changed++
			}
		}
		if _, set := fmap["3.8"]; set {
			if src.Location.Timestamp != nil {
				m.Location.Timestamp = &distributed_match_engine.Timestamp{}
				if _, set := fmap["3.8.1"]; set {
					if m.Location.Timestamp.Seconds != src.Location.Timestamp.Seconds {
						m.Location.Timestamp.Seconds = src.Location.Timestamp.Seconds
						changed++
					}
				}
				if _, set := fmap["3.8.2"]; set {
					if m.Location.Timestamp.Nanos != src.Location.Timestamp.Nanos {
						m.Location.Timestamp.Nanos = src.Location.Timestamp.Nanos
						changed++
					}
				}
			} else if m.Location.Timestamp != nil {
				m.Location.Timestamp = nil
				changed++
			}
		}
	}
	if _, set := fmap["4"]; set {
		if m.NotifyId != src.NotifyId {
			m.NotifyId = src.NotifyId
			changed++
		}
	}
	return changed
}

func (m *AppInstClient) DeepCopyIn(src *AppInstClient) {
	m.ClientKey.DeepCopyIn(&src.ClientKey)
	m.Location = src.Location
	m.NotifyId = src.NotifyId
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *AppInstClient) ValidateEnums() error {
	if err := m.ClientKey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func IgnoreAppInstClientFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "NotifyId")
	}
	return cmpopts.IgnoreFields(AppInstClient{}, names...)
}

func (m *AppInstClientLookupKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Appinstkey != nil {
		l = m.Appinstkey.Size()
		n += 1 + l + sovAppinstclient(uint64(l))
	}
	l = len(m.UniqueId)
	if l > 0 {
		n += 1 + l + sovAppinstclient(uint64(l))
	}
	l = len(m.UniqueIdType)
	if l > 0 {
		n += 1 + l + sovAppinstclient(uint64(l))
	}
	return n
}

func (m *AppInstClientKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovAppinstclient(uint64(l))
	return n
}

func (m *AppInstClient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovAppinstclient(uint64(l))
		}
	}
	l = m.ClientKey.Size()
	n += 1 + l + sovAppinstclient(uint64(l))
	l = m.Location.Size()
	n += 1 + l + sovAppinstclient(uint64(l))
	if m.NotifyId != 0 {
		n += 1 + sovAppinstclient(uint64(m.NotifyId))
	}
	return n
}

func sovAppinstclient(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAppinstclient(x uint64) (n int) {
	return sovAppinstclient(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AppInstClientLookupKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinstclient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstClientLookupKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstClientLookupKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appinstkey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinstclient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinstclient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Appinstkey == nil {
				m.Appinstkey = &AppInstKey{}
			}
			if err := m.Appinstkey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinstclient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinstclient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueIdType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinstclient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinstclient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueIdType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppinstclient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstClientKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinstclient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstClientKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstClientKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinstclient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinstclient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppinstclient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstClient) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinstclient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstClient: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstClient: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinstclient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinstclient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinstclient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinstclient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClientKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinstclient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinstclient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyId", wireType)
			}
			m.NotifyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinstclient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotifyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppinstclient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAppinstclient(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAppinstclient
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppinstclient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppinstclient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAppinstclient
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAppinstclient
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAppinstclient
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAppinstclient        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAppinstclient          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAppinstclient = fmt.Errorf("proto: unexpected end of group")
)
