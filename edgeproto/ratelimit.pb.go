// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ratelimit.proto

package edgeproto

import (
	encoding_binary "encoding/binary"
	"encoding/json"
	"errors"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	"github.com/mobiledgex/edge-cloud/util"
	io "io"
	math "math"
	math_bits "math/bits"
	"strconv"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type FlowRateLimitAlgorithm int32

const (
	FlowRateLimitAlgorithm_NO_FLOW_ALGORITHM      FlowRateLimitAlgorithm = 0
	FlowRateLimitAlgorithm_TOKEN_BUCKET_ALGORITHM FlowRateLimitAlgorithm = 1
	FlowRateLimitAlgorithm_LEAKY_BUCKET_ALGORITHM FlowRateLimitAlgorithm = 2
)

var FlowRateLimitAlgorithm_name = map[int32]string{
	0: "NO_FLOW_ALGORITHM",
	1: "TOKEN_BUCKET_ALGORITHM",
	2: "LEAKY_BUCKET_ALGORITHM",
}

var FlowRateLimitAlgorithm_value = map[string]int32{
	"NO_FLOW_ALGORITHM":      0,
	"TOKEN_BUCKET_ALGORITHM": 1,
	"LEAKY_BUCKET_ALGORITHM": 2,
}

func (x FlowRateLimitAlgorithm) String() string {
	return proto.EnumName(FlowRateLimitAlgorithm_name, int32(x))
}

func (FlowRateLimitAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9c81fd649b00920f, []int{0}
}

type MaxReqsRateLimitAlgorithm int32

const (
	MaxReqsRateLimitAlgorithm_NO_MAX_REQS_ALGORITHM    MaxReqsRateLimitAlgorithm = 0
	MaxReqsRateLimitAlgorithm_FIXED_WINDOW_ALGORITHM   MaxReqsRateLimitAlgorithm = 1
	MaxReqsRateLimitAlgorithm_ROLLING_WINDOW_ALGORITHM MaxReqsRateLimitAlgorithm = 2
)

var MaxReqsRateLimitAlgorithm_name = map[int32]string{
	0: "NO_MAX_REQS_ALGORITHM",
	1: "FIXED_WINDOW_ALGORITHM",
	2: "ROLLING_WINDOW_ALGORITHM",
}

var MaxReqsRateLimitAlgorithm_value = map[string]int32{
	"NO_MAX_REQS_ALGORITHM":    0,
	"FIXED_WINDOW_ALGORITHM":   1,
	"ROLLING_WINDOW_ALGORITHM": 2,
}

func (x MaxReqsRateLimitAlgorithm) String() string {
	return proto.EnumName(MaxReqsRateLimitAlgorithm_name, int32(x))
}

func (MaxReqsRateLimitAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9c81fd649b00920f, []int{1}
}

type ApiEndpointRateLimitSettings struct {
	EndpointRateLimitSettings        *RateLimitSettings `protobuf:"bytes,1,opt,name=endpoint_rate_limit_settings,json=endpointRateLimitSettings,proto3" json:"endpoint_rate_limit_settings,omitempty"`
	EndpointPerIpRateLimitSettings   *RateLimitSettings `protobuf:"bytes,2,opt,name=endpoint_per_ip_rate_limit_settings,json=endpointPerIpRateLimitSettings,proto3" json:"endpoint_per_ip_rate_limit_settings,omitempty"`
	EndpointPerUserRateLimitSettings *RateLimitSettings `protobuf:"bytes,3,opt,name=endpoint_per_user_rate_limit_settings,json=endpointPerUserRateLimitSettings,proto3" json:"endpoint_per_user_rate_limit_settings,omitempty"`
	EndpointPerOrgRateLimitSettings  *RateLimitSettings `protobuf:"bytes,4,opt,name=endpoint_per_org_rate_limit_settings,json=endpointPerOrgRateLimitSettings,proto3" json:"endpoint_per_org_rate_limit_settings,omitempty"`
	XXX_NoUnkeyedLiteral             struct{}           `json:"-"`
	XXX_unrecognized                 []byte             `json:"-"`
	XXX_sizecache                    int32              `json:"-"`
}

func (m *ApiEndpointRateLimitSettings) Reset()         { *m = ApiEndpointRateLimitSettings{} }
func (m *ApiEndpointRateLimitSettings) String() string { return proto.CompactTextString(m) }
func (*ApiEndpointRateLimitSettings) ProtoMessage()    {}
func (*ApiEndpointRateLimitSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9c81fd649b00920f, []int{0}
}
func (m *ApiEndpointRateLimitSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApiEndpointRateLimitSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApiEndpointRateLimitSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApiEndpointRateLimitSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApiEndpointRateLimitSettings.Merge(m, src)
}
func (m *ApiEndpointRateLimitSettings) XXX_Size() int {
	return m.Size()
}
func (m *ApiEndpointRateLimitSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_ApiEndpointRateLimitSettings.DiscardUnknown(m)
}

var xxx_messageInfo_ApiEndpointRateLimitSettings proto.InternalMessageInfo

type RateLimitSettings struct {
	FlowRateLimitSettings    *FlowRateLimitSettings    `protobuf:"bytes,1,opt,name=flow_rate_limit_settings,json=flowRateLimitSettings,proto3" json:"flow_rate_limit_settings,omitempty"`
	MaxReqsRateLimitSettings *MaxReqsRateLimitSettings `protobuf:"bytes,2,opt,name=max_reqs_rate_limit_settings,json=maxReqsRateLimitSettings,proto3" json:"max_reqs_rate_limit_settings,omitempty"`
	XXX_NoUnkeyedLiteral     struct{}                  `json:"-"`
	XXX_unrecognized         []byte                    `json:"-"`
	XXX_sizecache            int32                     `json:"-"`
}

func (m *RateLimitSettings) Reset()         { *m = RateLimitSettings{} }
func (m *RateLimitSettings) String() string { return proto.CompactTextString(m) }
func (*RateLimitSettings) ProtoMessage()    {}
func (*RateLimitSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9c81fd649b00920f, []int{1}
}
func (m *RateLimitSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimitSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimitSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimitSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitSettings.Merge(m, src)
}
func (m *RateLimitSettings) XXX_Size() int {
	return m.Size()
}
func (m *RateLimitSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitSettings.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitSettings proto.InternalMessageInfo

type FlowRateLimitSettings struct {
	FlowAlgorithm FlowRateLimitAlgorithm `protobuf:"varint,1,opt,name=flow_algorithm,json=flowAlgorithm,proto3,enum=edgeproto.FlowRateLimitAlgorithm" json:"flow_algorithm,omitempty"`
	// requests per second
	ReqsPerSecond float64 `protobuf:"fixed64,2,opt,name=reqsPerSecond,proto3" json:"reqsPerSecond,omitempty"`
	// burst size
	BurstSize            int64    `protobuf:"varint,3,opt,name=burstSize,proto3" json:"burstSize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FlowRateLimitSettings) Reset()         { *m = FlowRateLimitSettings{} }
func (m *FlowRateLimitSettings) String() string { return proto.CompactTextString(m) }
func (*FlowRateLimitSettings) ProtoMessage()    {}
func (*FlowRateLimitSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9c81fd649b00920f, []int{2}
}
func (m *FlowRateLimitSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowRateLimitSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowRateLimitSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowRateLimitSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowRateLimitSettings.Merge(m, src)
}
func (m *FlowRateLimitSettings) XXX_Size() int {
	return m.Size()
}
func (m *FlowRateLimitSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowRateLimitSettings.DiscardUnknown(m)
}

var xxx_messageInfo_FlowRateLimitSettings proto.InternalMessageInfo

type MaxReqsRateLimitSettings struct {
	MaxReqsAlgorithm     MaxReqsRateLimitAlgorithm `protobuf:"varint,1,opt,name=max_reqs_algorithm,json=maxReqsAlgorithm,proto3,enum=edgeproto.MaxReqsRateLimitAlgorithm" json:"max_reqs_algorithm,omitempty"`
	MaxRequestsPerSecond int64                     `protobuf:"varint,2,opt,name=max_requests_per_second,json=maxRequestsPerSecond,proto3" json:"max_requests_per_second,omitempty"`
	MaxRequestsPerMinute int64                     `protobuf:"varint,3,opt,name=max_requests_per_minute,json=maxRequestsPerMinute,proto3" json:"max_requests_per_minute,omitempty"`
	MaxRequestsPerHour   int64                     `protobuf:"varint,4,opt,name=max_requests_per_hour,json=maxRequestsPerHour,proto3" json:"max_requests_per_hour,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *MaxReqsRateLimitSettings) Reset()         { *m = MaxReqsRateLimitSettings{} }
func (m *MaxReqsRateLimitSettings) String() string { return proto.CompactTextString(m) }
func (*MaxReqsRateLimitSettings) ProtoMessage()    {}
func (*MaxReqsRateLimitSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9c81fd649b00920f, []int{3}
}
func (m *MaxReqsRateLimitSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaxReqsRateLimitSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaxReqsRateLimitSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaxReqsRateLimitSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaxReqsRateLimitSettings.Merge(m, src)
}
func (m *MaxReqsRateLimitSettings) XXX_Size() int {
	return m.Size()
}
func (m *MaxReqsRateLimitSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_MaxReqsRateLimitSettings.DiscardUnknown(m)
}

var xxx_messageInfo_MaxReqsRateLimitSettings proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("edgeproto.FlowRateLimitAlgorithm", FlowRateLimitAlgorithm_name, FlowRateLimitAlgorithm_value)
	proto.RegisterEnum("edgeproto.MaxReqsRateLimitAlgorithm", MaxReqsRateLimitAlgorithm_name, MaxReqsRateLimitAlgorithm_value)
	proto.RegisterType((*ApiEndpointRateLimitSettings)(nil), "edgeproto.ApiEndpointRateLimitSettings")
	proto.RegisterType((*RateLimitSettings)(nil), "edgeproto.RateLimitSettings")
	proto.RegisterType((*FlowRateLimitSettings)(nil), "edgeproto.FlowRateLimitSettings")
	proto.RegisterType((*MaxReqsRateLimitSettings)(nil), "edgeproto.MaxReqsRateLimitSettings")
}

func init() { proto.RegisterFile("ratelimit.proto", fileDescriptor_9c81fd649b00920f) }

var fileDescriptor_9c81fd649b00920f = []byte{
	// 533 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x92, 0xdf, 0x6e, 0x12, 0x41,
	0x14, 0xc6, 0xbb, 0x60, 0x4c, 0x7a, 0x4c, 0x6b, 0x3b, 0x91, 0x0a, 0x66, 0x83, 0x48, 0x31, 0x31,
	0xbd, 0x20, 0xb1, 0xc6, 0x07, 0xa0, 0x76, 0x29, 0x84, 0x85, 0xad, 0x03, 0x4d, 0xdb, 0x0b, 0x33,
	0xa1, 0x65, 0xba, 0x9d, 0xc8, 0x32, 0xdb, 0x99, 0xd9, 0xb4, 0xf1, 0x25, 0x7c, 0x0a, 0xdf, 0xc4,
	0x8b, 0x5e, 0x9a, 0xf8, 0x02, 0xca, 0x93, 0x18, 0x46, 0xfe, 0xcf, 0x2e, 0xe1, 0x6e, 0x77, 0xbe,
	0x39, 0xdf, 0xef, 0x3b, 0x67, 0x0e, 0x3c, 0x17, 0x5d, 0x45, 0xfb, 0x2c, 0x60, 0xaa, 0x1c, 0x0a,
	0xae, 0x38, 0xda, 0xa4, 0x3d, 0x9f, 0xea, 0xcf, 0xe2, 0xcf, 0x34, 0xd8, 0x95, 0x90, 0x39, 0x83,
	0x5e, 0xc8, 0xd9, 0x40, 0xe1, 0xae, 0xa2, 0xee, 0xe8, 0x66, 0x9b, 0x2a, 0xc5, 0x06, 0xbe, 0x44,
	0x5f, 0xc0, 0xa6, 0x63, 0x91, 0x8c, 0x7c, 0x88, 0x36, 0x22, 0x72, 0xac, 0x67, 0xad, 0x82, 0xf5,
	0xee, 0xd9, 0xa1, 0x5d, 0x9e, 0x5a, 0x96, 0x0d, 0x0f, 0x9c, 0xa3, 0x89, 0xf6, 0x0c, 0xf6, 0xa7,
	0xf6, 0x21, 0x15, 0x84, 0x85, 0xb1, 0x94, 0xd4, 0x1a, 0x94, 0xfc, 0xc4, 0xe8, 0x94, 0x8a, 0x7a,
	0x68, 0xa2, 0x02, 0x78, 0xbb, 0x80, 0x8a, 0x24, 0x15, 0xb1, 0xb0, 0xf4, 0x1a, 0xb0, 0xc2, 0x1c,
	0xec, 0x4c, 0x52, 0x61, 0xe2, 0xbe, 0x42, 0x69, 0x01, 0xc7, 0x85, 0x1f, 0x4b, 0x7b, 0xb2, 0x06,
	0xed, 0xf5, 0x1c, 0xcd, 0x13, 0xbe, 0x71, 0xa1, 0xf8, 0xdb, 0x82, 0x5d, 0x33, 0xc2, 0x25, 0x64,
	0x6f, 0xfa, 0xfc, 0x7e, 0xc5, 0xbb, 0x15, 0xe6, 0xb0, 0xd5, 0x3e, 0xbf, 0x37, 0xd1, 0x99, 0x9b,
	0xb8, 0x63, 0x74, 0x0d, 0x76, 0xd0, 0x7d, 0x20, 0x82, 0xde, 0xc9, 0x15, 0x0f, 0xb6, 0x3f, 0x67,
	0xdf, 0xec, 0x3e, 0x60, 0x7a, 0x27, 0x4d, 0x42, 0x36, 0x48, 0x50, 0x8a, 0x3f, 0x2c, 0xc8, 0xc4,
	0xa6, 0x42, 0x35, 0xd8, 0xd6, 0x9d, 0x75, 0xfb, 0x3e, 0x17, 0x4c, 0xdd, 0x06, 0xba, 0x9f, 0xed,
	0xc3, 0x37, 0x49, 0xfd, 0x54, 0x26, 0x17, 0xf1, 0xd6, 0xa8, 0x70, 0xfa, 0x8b, 0x4a, 0xb0, 0x35,
	0x6a, 0xe2, 0x94, 0x8a, 0x36, 0xbd, 0xe6, 0x83, 0x9e, 0x4e, 0x6e, 0xe1, 0xc5, 0x43, 0x64, 0xc3,
	0xe6, 0x55, 0x24, 0xa4, 0x6a, 0xb3, 0x6f, 0x54, 0xef, 0x47, 0x1a, 0xcf, 0x0e, 0x8a, 0xdf, 0x53,
	0x90, 0x4d, 0x6a, 0x0f, 0x61, 0x40, 0xd3, 0x49, 0x2d, 0xc7, 0x2d, 0xad, 0x98, 0xcf, 0x2c, 0xf1,
	0xce, 0x78, 0x40, 0xb3, 0xd0, 0x1f, 0xe1, 0xe5, 0xd8, 0x33, 0xa2, 0x52, 0x49, 0xbd, 0x5f, 0x72,
	0x16, 0x3f, 0x8d, 0x5f, 0xfc, 0x2f, 0xd1, 0xea, 0xac, 0x8b, 0xb8, 0xb2, 0x80, 0x0d, 0x22, 0x35,
	0xe9, 0x69, 0xa9, 0xac, 0xa9, 0x35, 0xf4, 0x1e, 0x32, 0x46, 0xd9, 0x2d, 0x8f, 0x84, 0x5e, 0xdd,
	0x34, 0x46, 0x8b, 0x45, 0x35, 0x1e, 0x89, 0x03, 0x1f, 0xf6, 0xe2, 0xc7, 0x8f, 0x32, 0xb0, 0xdb,
	0xf2, 0x48, 0xd5, 0xf5, 0xce, 0x49, 0xc5, 0x3d, 0xf1, 0x70, 0xbd, 0x53, 0x6b, 0xee, 0x6c, 0xa0,
	0x57, 0xb0, 0xd7, 0xf1, 0x1a, 0x4e, 0x8b, 0x1c, 0x9d, 0x7d, 0x6a, 0x38, 0x9d, 0x39, 0xcd, 0x1a,
	0x69, 0xae, 0x53, 0x69, 0x5c, 0x9a, 0x5a, 0xea, 0x20, 0x84, 0x5c, 0xe2, 0xe0, 0x50, 0x0e, 0x32,
	0x2d, 0x8f, 0x34, 0x2b, 0x17, 0x04, 0x3b, 0x9f, 0xdb, 0xcb, 0xbc, 0x6a, 0xfd, 0xc2, 0x39, 0x26,
	0xe7, 0xf5, 0xd6, 0xf1, 0x42, 0x16, 0x0b, 0xd9, 0x90, 0xc5, 0x9e, 0xeb, 0xd6, 0x5b, 0x27, 0xa6,
	0x9a, 0x3a, 0xda, 0x79, 0xfc, 0x9b, 0xdf, 0x78, 0x1c, 0xe6, 0xad, 0x5f, 0xc3, 0xbc, 0xf5, 0x67,
	0x98, 0xb7, 0xae, 0x9e, 0xea, 0x07, 0xfc, 0xf0, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x71, 0x7b, 0x58,
	0xd3, 0x68, 0x05, 0x00, 0x00,
}

func (m *ApiEndpointRateLimitSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApiEndpointRateLimitSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApiEndpointRateLimitSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EndpointPerOrgRateLimitSettings != nil {
		{
			size, err := m.EndpointPerOrgRateLimitSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRatelimit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.EndpointPerUserRateLimitSettings != nil {
		{
			size, err := m.EndpointPerUserRateLimitSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRatelimit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.EndpointPerIpRateLimitSettings != nil {
		{
			size, err := m.EndpointPerIpRateLimitSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRatelimit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.EndpointRateLimitSettings != nil {
		{
			size, err := m.EndpointRateLimitSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRatelimit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RateLimitSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimitSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimitSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxReqsRateLimitSettings != nil {
		{
			size, err := m.MaxReqsRateLimitSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRatelimit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.FlowRateLimitSettings != nil {
		{
			size, err := m.FlowRateLimitSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRatelimit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FlowRateLimitSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowRateLimitSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowRateLimitSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BurstSize != 0 {
		i = encodeVarintRatelimit(dAtA, i, uint64(m.BurstSize))
		i--
		dAtA[i] = 0x18
	}
	if m.ReqsPerSecond != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ReqsPerSecond))))
		i--
		dAtA[i] = 0x11
	}
	if m.FlowAlgorithm != 0 {
		i = encodeVarintRatelimit(dAtA, i, uint64(m.FlowAlgorithm))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MaxReqsRateLimitSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaxReqsRateLimitSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaxReqsRateLimitSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxRequestsPerHour != 0 {
		i = encodeVarintRatelimit(dAtA, i, uint64(m.MaxRequestsPerHour))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxRequestsPerMinute != 0 {
		i = encodeVarintRatelimit(dAtA, i, uint64(m.MaxRequestsPerMinute))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxRequestsPerSecond != 0 {
		i = encodeVarintRatelimit(dAtA, i, uint64(m.MaxRequestsPerSecond))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxReqsAlgorithm != 0 {
		i = encodeVarintRatelimit(dAtA, i, uint64(m.MaxReqsAlgorithm))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintRatelimit(dAtA []byte, offset int, v uint64) int {
	offset -= sovRatelimit(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ApiEndpointRateLimitSettings) CopyInFields(src *ApiEndpointRateLimitSettings) int {
	changed := 0
	if src.EndpointRateLimitSettings != nil {
		m.EndpointRateLimitSettings = &RateLimitSettings{}
		if src.EndpointRateLimitSettings.FlowRateLimitSettings != nil {
			m.EndpointRateLimitSettings.FlowRateLimitSettings = &FlowRateLimitSettings{}
			if m.EndpointRateLimitSettings.FlowRateLimitSettings.FlowAlgorithm != src.EndpointRateLimitSettings.FlowRateLimitSettings.FlowAlgorithm {
				m.EndpointRateLimitSettings.FlowRateLimitSettings.FlowAlgorithm = src.EndpointRateLimitSettings.FlowRateLimitSettings.FlowAlgorithm
				changed++
			}
			if m.EndpointRateLimitSettings.FlowRateLimitSettings.ReqsPerSecond != src.EndpointRateLimitSettings.FlowRateLimitSettings.ReqsPerSecond {
				m.EndpointRateLimitSettings.FlowRateLimitSettings.ReqsPerSecond = src.EndpointRateLimitSettings.FlowRateLimitSettings.ReqsPerSecond
				changed++
			}
			if m.EndpointRateLimitSettings.FlowRateLimitSettings.BurstSize != src.EndpointRateLimitSettings.FlowRateLimitSettings.BurstSize {
				m.EndpointRateLimitSettings.FlowRateLimitSettings.BurstSize = src.EndpointRateLimitSettings.FlowRateLimitSettings.BurstSize
				changed++
			}
		} else if m.EndpointRateLimitSettings.FlowRateLimitSettings != nil {
			m.EndpointRateLimitSettings.FlowRateLimitSettings = nil
			changed++
		}
		if src.EndpointRateLimitSettings.MaxReqsRateLimitSettings != nil {
			m.EndpointRateLimitSettings.MaxReqsRateLimitSettings = &MaxReqsRateLimitSettings{}
			if m.EndpointRateLimitSettings.MaxReqsRateLimitSettings.MaxReqsAlgorithm != src.EndpointRateLimitSettings.MaxReqsRateLimitSettings.MaxReqsAlgorithm {
				m.EndpointRateLimitSettings.MaxReqsRateLimitSettings.MaxReqsAlgorithm = src.EndpointRateLimitSettings.MaxReqsRateLimitSettings.MaxReqsAlgorithm
				changed++
			}
			if m.EndpointRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerSecond != src.EndpointRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerSecond {
				m.EndpointRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerSecond = src.EndpointRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerSecond
				changed++
			}
			if m.EndpointRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerMinute != src.EndpointRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerMinute {
				m.EndpointRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerMinute = src.EndpointRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerMinute
				changed++
			}
			if m.EndpointRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerHour != src.EndpointRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerHour {
				m.EndpointRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerHour = src.EndpointRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerHour
				changed++
			}
		} else if m.EndpointRateLimitSettings.MaxReqsRateLimitSettings != nil {
			m.EndpointRateLimitSettings.MaxReqsRateLimitSettings = nil
			changed++
		}
	} else if m.EndpointRateLimitSettings != nil {
		m.EndpointRateLimitSettings = nil
		changed++
	}
	if src.EndpointPerIpRateLimitSettings != nil {
		m.EndpointPerIpRateLimitSettings = &RateLimitSettings{}
		if src.EndpointPerIpRateLimitSettings.FlowRateLimitSettings != nil {
			m.EndpointPerIpRateLimitSettings.FlowRateLimitSettings = &FlowRateLimitSettings{}
			if m.EndpointPerIpRateLimitSettings.FlowRateLimitSettings.FlowAlgorithm != src.EndpointPerIpRateLimitSettings.FlowRateLimitSettings.FlowAlgorithm {
				m.EndpointPerIpRateLimitSettings.FlowRateLimitSettings.FlowAlgorithm = src.EndpointPerIpRateLimitSettings.FlowRateLimitSettings.FlowAlgorithm
				changed++
			}
			if m.EndpointPerIpRateLimitSettings.FlowRateLimitSettings.ReqsPerSecond != src.EndpointPerIpRateLimitSettings.FlowRateLimitSettings.ReqsPerSecond {
				m.EndpointPerIpRateLimitSettings.FlowRateLimitSettings.ReqsPerSecond = src.EndpointPerIpRateLimitSettings.FlowRateLimitSettings.ReqsPerSecond
				changed++
			}
			if m.EndpointPerIpRateLimitSettings.FlowRateLimitSettings.BurstSize != src.EndpointPerIpRateLimitSettings.FlowRateLimitSettings.BurstSize {
				m.EndpointPerIpRateLimitSettings.FlowRateLimitSettings.BurstSize = src.EndpointPerIpRateLimitSettings.FlowRateLimitSettings.BurstSize
				changed++
			}
		} else if m.EndpointPerIpRateLimitSettings.FlowRateLimitSettings != nil {
			m.EndpointPerIpRateLimitSettings.FlowRateLimitSettings = nil
			changed++
		}
		if src.EndpointPerIpRateLimitSettings.MaxReqsRateLimitSettings != nil {
			m.EndpointPerIpRateLimitSettings.MaxReqsRateLimitSettings = &MaxReqsRateLimitSettings{}
			if m.EndpointPerIpRateLimitSettings.MaxReqsRateLimitSettings.MaxReqsAlgorithm != src.EndpointPerIpRateLimitSettings.MaxReqsRateLimitSettings.MaxReqsAlgorithm {
				m.EndpointPerIpRateLimitSettings.MaxReqsRateLimitSettings.MaxReqsAlgorithm = src.EndpointPerIpRateLimitSettings.MaxReqsRateLimitSettings.MaxReqsAlgorithm
				changed++
			}
			if m.EndpointPerIpRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerSecond != src.EndpointPerIpRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerSecond {
				m.EndpointPerIpRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerSecond = src.EndpointPerIpRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerSecond
				changed++
			}
			if m.EndpointPerIpRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerMinute != src.EndpointPerIpRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerMinute {
				m.EndpointPerIpRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerMinute = src.EndpointPerIpRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerMinute
				changed++
			}
			if m.EndpointPerIpRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerHour != src.EndpointPerIpRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerHour {
				m.EndpointPerIpRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerHour = src.EndpointPerIpRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerHour
				changed++
			}
		} else if m.EndpointPerIpRateLimitSettings.MaxReqsRateLimitSettings != nil {
			m.EndpointPerIpRateLimitSettings.MaxReqsRateLimitSettings = nil
			changed++
		}
	} else if m.EndpointPerIpRateLimitSettings != nil {
		m.EndpointPerIpRateLimitSettings = nil
		changed++
	}
	if src.EndpointPerUserRateLimitSettings != nil {
		m.EndpointPerUserRateLimitSettings = &RateLimitSettings{}
		if src.EndpointPerUserRateLimitSettings.FlowRateLimitSettings != nil {
			m.EndpointPerUserRateLimitSettings.FlowRateLimitSettings = &FlowRateLimitSettings{}
			if m.EndpointPerUserRateLimitSettings.FlowRateLimitSettings.FlowAlgorithm != src.EndpointPerUserRateLimitSettings.FlowRateLimitSettings.FlowAlgorithm {
				m.EndpointPerUserRateLimitSettings.FlowRateLimitSettings.FlowAlgorithm = src.EndpointPerUserRateLimitSettings.FlowRateLimitSettings.FlowAlgorithm
				changed++
			}
			if m.EndpointPerUserRateLimitSettings.FlowRateLimitSettings.ReqsPerSecond != src.EndpointPerUserRateLimitSettings.FlowRateLimitSettings.ReqsPerSecond {
				m.EndpointPerUserRateLimitSettings.FlowRateLimitSettings.ReqsPerSecond = src.EndpointPerUserRateLimitSettings.FlowRateLimitSettings.ReqsPerSecond
				changed++
			}
			if m.EndpointPerUserRateLimitSettings.FlowRateLimitSettings.BurstSize != src.EndpointPerUserRateLimitSettings.FlowRateLimitSettings.BurstSize {
				m.EndpointPerUserRateLimitSettings.FlowRateLimitSettings.BurstSize = src.EndpointPerUserRateLimitSettings.FlowRateLimitSettings.BurstSize
				changed++
			}
		} else if m.EndpointPerUserRateLimitSettings.FlowRateLimitSettings != nil {
			m.EndpointPerUserRateLimitSettings.FlowRateLimitSettings = nil
			changed++
		}
		if src.EndpointPerUserRateLimitSettings.MaxReqsRateLimitSettings != nil {
			m.EndpointPerUserRateLimitSettings.MaxReqsRateLimitSettings = &MaxReqsRateLimitSettings{}
			if m.EndpointPerUserRateLimitSettings.MaxReqsRateLimitSettings.MaxReqsAlgorithm != src.EndpointPerUserRateLimitSettings.MaxReqsRateLimitSettings.MaxReqsAlgorithm {
				m.EndpointPerUserRateLimitSettings.MaxReqsRateLimitSettings.MaxReqsAlgorithm = src.EndpointPerUserRateLimitSettings.MaxReqsRateLimitSettings.MaxReqsAlgorithm
				changed++
			}
			if m.EndpointPerUserRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerSecond != src.EndpointPerUserRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerSecond {
				m.EndpointPerUserRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerSecond = src.EndpointPerUserRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerSecond
				changed++
			}
			if m.EndpointPerUserRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerMinute != src.EndpointPerUserRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerMinute {
				m.EndpointPerUserRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerMinute = src.EndpointPerUserRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerMinute
				changed++
			}
			if m.EndpointPerUserRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerHour != src.EndpointPerUserRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerHour {
				m.EndpointPerUserRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerHour = src.EndpointPerUserRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerHour
				changed++
			}
		} else if m.EndpointPerUserRateLimitSettings.MaxReqsRateLimitSettings != nil {
			m.EndpointPerUserRateLimitSettings.MaxReqsRateLimitSettings = nil
			changed++
		}
	} else if m.EndpointPerUserRateLimitSettings != nil {
		m.EndpointPerUserRateLimitSettings = nil
		changed++
	}
	if src.EndpointPerOrgRateLimitSettings != nil {
		m.EndpointPerOrgRateLimitSettings = &RateLimitSettings{}
		if src.EndpointPerOrgRateLimitSettings.FlowRateLimitSettings != nil {
			m.EndpointPerOrgRateLimitSettings.FlowRateLimitSettings = &FlowRateLimitSettings{}
			if m.EndpointPerOrgRateLimitSettings.FlowRateLimitSettings.FlowAlgorithm != src.EndpointPerOrgRateLimitSettings.FlowRateLimitSettings.FlowAlgorithm {
				m.EndpointPerOrgRateLimitSettings.FlowRateLimitSettings.FlowAlgorithm = src.EndpointPerOrgRateLimitSettings.FlowRateLimitSettings.FlowAlgorithm
				changed++
			}
			if m.EndpointPerOrgRateLimitSettings.FlowRateLimitSettings.ReqsPerSecond != src.EndpointPerOrgRateLimitSettings.FlowRateLimitSettings.ReqsPerSecond {
				m.EndpointPerOrgRateLimitSettings.FlowRateLimitSettings.ReqsPerSecond = src.EndpointPerOrgRateLimitSettings.FlowRateLimitSettings.ReqsPerSecond
				changed++
			}
			if m.EndpointPerOrgRateLimitSettings.FlowRateLimitSettings.BurstSize != src.EndpointPerOrgRateLimitSettings.FlowRateLimitSettings.BurstSize {
				m.EndpointPerOrgRateLimitSettings.FlowRateLimitSettings.BurstSize = src.EndpointPerOrgRateLimitSettings.FlowRateLimitSettings.BurstSize
				changed++
			}
		} else if m.EndpointPerOrgRateLimitSettings.FlowRateLimitSettings != nil {
			m.EndpointPerOrgRateLimitSettings.FlowRateLimitSettings = nil
			changed++
		}
		if src.EndpointPerOrgRateLimitSettings.MaxReqsRateLimitSettings != nil {
			m.EndpointPerOrgRateLimitSettings.MaxReqsRateLimitSettings = &MaxReqsRateLimitSettings{}
			if m.EndpointPerOrgRateLimitSettings.MaxReqsRateLimitSettings.MaxReqsAlgorithm != src.EndpointPerOrgRateLimitSettings.MaxReqsRateLimitSettings.MaxReqsAlgorithm {
				m.EndpointPerOrgRateLimitSettings.MaxReqsRateLimitSettings.MaxReqsAlgorithm = src.EndpointPerOrgRateLimitSettings.MaxReqsRateLimitSettings.MaxReqsAlgorithm
				changed++
			}
			if m.EndpointPerOrgRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerSecond != src.EndpointPerOrgRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerSecond {
				m.EndpointPerOrgRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerSecond = src.EndpointPerOrgRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerSecond
				changed++
			}
			if m.EndpointPerOrgRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerMinute != src.EndpointPerOrgRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerMinute {
				m.EndpointPerOrgRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerMinute = src.EndpointPerOrgRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerMinute
				changed++
			}
			if m.EndpointPerOrgRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerHour != src.EndpointPerOrgRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerHour {
				m.EndpointPerOrgRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerHour = src.EndpointPerOrgRateLimitSettings.MaxReqsRateLimitSettings.MaxRequestsPerHour
				changed++
			}
		} else if m.EndpointPerOrgRateLimitSettings.MaxReqsRateLimitSettings != nil {
			m.EndpointPerOrgRateLimitSettings.MaxReqsRateLimitSettings = nil
			changed++
		}
	} else if m.EndpointPerOrgRateLimitSettings != nil {
		m.EndpointPerOrgRateLimitSettings = nil
		changed++
	}
	return changed
}

func (m *ApiEndpointRateLimitSettings) DeepCopyIn(src *ApiEndpointRateLimitSettings) {
	if src.EndpointRateLimitSettings != nil {
		var tmp_EndpointRateLimitSettings RateLimitSettings
		tmp_EndpointRateLimitSettings.DeepCopyIn(src.EndpointRateLimitSettings)
		m.EndpointRateLimitSettings = &tmp_EndpointRateLimitSettings
	} else {
		m.EndpointRateLimitSettings = nil
	}
	if src.EndpointPerIpRateLimitSettings != nil {
		var tmp_EndpointPerIpRateLimitSettings RateLimitSettings
		tmp_EndpointPerIpRateLimitSettings.DeepCopyIn(src.EndpointPerIpRateLimitSettings)
		m.EndpointPerIpRateLimitSettings = &tmp_EndpointPerIpRateLimitSettings
	} else {
		m.EndpointPerIpRateLimitSettings = nil
	}
	if src.EndpointPerUserRateLimitSettings != nil {
		var tmp_EndpointPerUserRateLimitSettings RateLimitSettings
		tmp_EndpointPerUserRateLimitSettings.DeepCopyIn(src.EndpointPerUserRateLimitSettings)
		m.EndpointPerUserRateLimitSettings = &tmp_EndpointPerUserRateLimitSettings
	} else {
		m.EndpointPerUserRateLimitSettings = nil
	}
	if src.EndpointPerOrgRateLimitSettings != nil {
		var tmp_EndpointPerOrgRateLimitSettings RateLimitSettings
		tmp_EndpointPerOrgRateLimitSettings.DeepCopyIn(src.EndpointPerOrgRateLimitSettings)
		m.EndpointPerOrgRateLimitSettings = &tmp_EndpointPerOrgRateLimitSettings
	} else {
		m.EndpointPerOrgRateLimitSettings = nil
	}
}

// Helper method to check that enums have valid values
func (m *ApiEndpointRateLimitSettings) ValidateEnums() error {
	if err := m.EndpointRateLimitSettings.ValidateEnums(); err != nil {
		return err
	}
	if err := m.EndpointPerIpRateLimitSettings.ValidateEnums(); err != nil {
		return err
	}
	if err := m.EndpointPerUserRateLimitSettings.ValidateEnums(); err != nil {
		return err
	}
	if err := m.EndpointPerOrgRateLimitSettings.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *RateLimitSettings) CopyInFields(src *RateLimitSettings) int {
	changed := 0
	if src.FlowRateLimitSettings != nil {
		m.FlowRateLimitSettings = &FlowRateLimitSettings{}
		if m.FlowRateLimitSettings.FlowAlgorithm != src.FlowRateLimitSettings.FlowAlgorithm {
			m.FlowRateLimitSettings.FlowAlgorithm = src.FlowRateLimitSettings.FlowAlgorithm
			changed++
		}
		if m.FlowRateLimitSettings.ReqsPerSecond != src.FlowRateLimitSettings.ReqsPerSecond {
			m.FlowRateLimitSettings.ReqsPerSecond = src.FlowRateLimitSettings.ReqsPerSecond
			changed++
		}
		if m.FlowRateLimitSettings.BurstSize != src.FlowRateLimitSettings.BurstSize {
			m.FlowRateLimitSettings.BurstSize = src.FlowRateLimitSettings.BurstSize
			changed++
		}
	} else if m.FlowRateLimitSettings != nil {
		m.FlowRateLimitSettings = nil
		changed++
	}
	if src.MaxReqsRateLimitSettings != nil {
		m.MaxReqsRateLimitSettings = &MaxReqsRateLimitSettings{}
		if m.MaxReqsRateLimitSettings.MaxReqsAlgorithm != src.MaxReqsRateLimitSettings.MaxReqsAlgorithm {
			m.MaxReqsRateLimitSettings.MaxReqsAlgorithm = src.MaxReqsRateLimitSettings.MaxReqsAlgorithm
			changed++
		}
		if m.MaxReqsRateLimitSettings.MaxRequestsPerSecond != src.MaxReqsRateLimitSettings.MaxRequestsPerSecond {
			m.MaxReqsRateLimitSettings.MaxRequestsPerSecond = src.MaxReqsRateLimitSettings.MaxRequestsPerSecond
			changed++
		}
		if m.MaxReqsRateLimitSettings.MaxRequestsPerMinute != src.MaxReqsRateLimitSettings.MaxRequestsPerMinute {
			m.MaxReqsRateLimitSettings.MaxRequestsPerMinute = src.MaxReqsRateLimitSettings.MaxRequestsPerMinute
			changed++
		}
		if m.MaxReqsRateLimitSettings.MaxRequestsPerHour != src.MaxReqsRateLimitSettings.MaxRequestsPerHour {
			m.MaxReqsRateLimitSettings.MaxRequestsPerHour = src.MaxReqsRateLimitSettings.MaxRequestsPerHour
			changed++
		}
	} else if m.MaxReqsRateLimitSettings != nil {
		m.MaxReqsRateLimitSettings = nil
		changed++
	}
	return changed
}

func (m *RateLimitSettings) DeepCopyIn(src *RateLimitSettings) {
	if src.FlowRateLimitSettings != nil {
		var tmp_FlowRateLimitSettings FlowRateLimitSettings
		tmp_FlowRateLimitSettings.DeepCopyIn(src.FlowRateLimitSettings)
		m.FlowRateLimitSettings = &tmp_FlowRateLimitSettings
	} else {
		m.FlowRateLimitSettings = nil
	}
	if src.MaxReqsRateLimitSettings != nil {
		var tmp_MaxReqsRateLimitSettings MaxReqsRateLimitSettings
		tmp_MaxReqsRateLimitSettings.DeepCopyIn(src.MaxReqsRateLimitSettings)
		m.MaxReqsRateLimitSettings = &tmp_MaxReqsRateLimitSettings
	} else {
		m.MaxReqsRateLimitSettings = nil
	}
}

// Helper method to check that enums have valid values
func (m *RateLimitSettings) ValidateEnums() error {
	if err := m.FlowRateLimitSettings.ValidateEnums(); err != nil {
		return err
	}
	if err := m.MaxReqsRateLimitSettings.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *FlowRateLimitSettings) CopyInFields(src *FlowRateLimitSettings) int {
	changed := 0
	if m.FlowAlgorithm != src.FlowAlgorithm {
		m.FlowAlgorithm = src.FlowAlgorithm
		changed++
	}
	if m.ReqsPerSecond != src.ReqsPerSecond {
		m.ReqsPerSecond = src.ReqsPerSecond
		changed++
	}
	if m.BurstSize != src.BurstSize {
		m.BurstSize = src.BurstSize
		changed++
	}
	return changed
}

func (m *FlowRateLimitSettings) DeepCopyIn(src *FlowRateLimitSettings) {
	m.FlowAlgorithm = src.FlowAlgorithm
	m.ReqsPerSecond = src.ReqsPerSecond
	m.BurstSize = src.BurstSize
}

// Helper method to check that enums have valid values
func (m *FlowRateLimitSettings) ValidateEnums() error {
	if _, ok := FlowRateLimitAlgorithm_name[int32(m.FlowAlgorithm)]; !ok {
		return errors.New("invalid FlowAlgorithm")
	}
	return nil
}

func (m *MaxReqsRateLimitSettings) CopyInFields(src *MaxReqsRateLimitSettings) int {
	changed := 0
	if m.MaxReqsAlgorithm != src.MaxReqsAlgorithm {
		m.MaxReqsAlgorithm = src.MaxReqsAlgorithm
		changed++
	}
	if m.MaxRequestsPerSecond != src.MaxRequestsPerSecond {
		m.MaxRequestsPerSecond = src.MaxRequestsPerSecond
		changed++
	}
	if m.MaxRequestsPerMinute != src.MaxRequestsPerMinute {
		m.MaxRequestsPerMinute = src.MaxRequestsPerMinute
		changed++
	}
	if m.MaxRequestsPerHour != src.MaxRequestsPerHour {
		m.MaxRequestsPerHour = src.MaxRequestsPerHour
		changed++
	}
	return changed
}

func (m *MaxReqsRateLimitSettings) DeepCopyIn(src *MaxReqsRateLimitSettings) {
	m.MaxReqsAlgorithm = src.MaxReqsAlgorithm
	m.MaxRequestsPerSecond = src.MaxRequestsPerSecond
	m.MaxRequestsPerMinute = src.MaxRequestsPerMinute
	m.MaxRequestsPerHour = src.MaxRequestsPerHour
}

// Helper method to check that enums have valid values
func (m *MaxReqsRateLimitSettings) ValidateEnums() error {
	if _, ok := MaxReqsRateLimitAlgorithm_name[int32(m.MaxReqsAlgorithm)]; !ok {
		return errors.New("invalid MaxReqsAlgorithm")
	}
	return nil
}

var FlowRateLimitAlgorithmStrings = []string{
	"NO_FLOW_ALGORITHM",
	"TOKEN_BUCKET_ALGORITHM",
	"LEAKY_BUCKET_ALGORITHM",
}

const (
	FlowRateLimitAlgorithmNO_FLOW_ALGORITHM      uint64 = 1 << 0
	FlowRateLimitAlgorithmTOKEN_BUCKET_ALGORITHM uint64 = 1 << 1
	FlowRateLimitAlgorithmLEAKY_BUCKET_ALGORITHM uint64 = 1 << 2
)

var FlowRateLimitAlgorithm_CamelName = map[int32]string{
	// NO_FLOW_ALGORITHM -> NoFlowAlgorithm
	0: "NoFlowAlgorithm",
	// TOKEN_BUCKET_ALGORITHM -> TokenBucketAlgorithm
	1: "TokenBucketAlgorithm",
	// LEAKY_BUCKET_ALGORITHM -> LeakyBucketAlgorithm
	2: "LeakyBucketAlgorithm",
}
var FlowRateLimitAlgorithm_CamelValue = map[string]int32{
	"NoFlowAlgorithm":      0,
	"TokenBucketAlgorithm": 1,
	"LeakyBucketAlgorithm": 2,
}

func (e *FlowRateLimitAlgorithm) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := FlowRateLimitAlgorithm_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = FlowRateLimitAlgorithm_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = FlowRateLimitAlgorithm(val)
	return nil
}

func (e FlowRateLimitAlgorithm) MarshalYAML() (interface{}, error) {
	return proto.EnumName(FlowRateLimitAlgorithm_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *FlowRateLimitAlgorithm) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := FlowRateLimitAlgorithm_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = FlowRateLimitAlgorithm_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = FlowRateLimitAlgorithm(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = FlowRateLimitAlgorithm(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

var MaxReqsRateLimitAlgorithmStrings = []string{
	"NO_MAX_REQS_ALGORITHM",
	"FIXED_WINDOW_ALGORITHM",
	"ROLLING_WINDOW_ALGORITHM",
}

const (
	MaxReqsRateLimitAlgorithmNO_MAX_REQS_ALGORITHM    uint64 = 1 << 0
	MaxReqsRateLimitAlgorithmFIXED_WINDOW_ALGORITHM   uint64 = 1 << 1
	MaxReqsRateLimitAlgorithmROLLING_WINDOW_ALGORITHM uint64 = 1 << 2
)

var MaxReqsRateLimitAlgorithm_CamelName = map[int32]string{
	// NO_MAX_REQS_ALGORITHM -> NoMaxReqsAlgorithm
	0: "NoMaxReqsAlgorithm",
	// FIXED_WINDOW_ALGORITHM -> FixedWindowAlgorithm
	1: "FixedWindowAlgorithm",
	// ROLLING_WINDOW_ALGORITHM -> RollingWindowAlgorithm
	2: "RollingWindowAlgorithm",
}
var MaxReqsRateLimitAlgorithm_CamelValue = map[string]int32{
	"NoMaxReqsAlgorithm":     0,
	"FixedWindowAlgorithm":   1,
	"RollingWindowAlgorithm": 2,
}

func (e *MaxReqsRateLimitAlgorithm) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := MaxReqsRateLimitAlgorithm_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = MaxReqsRateLimitAlgorithm_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = MaxReqsRateLimitAlgorithm(val)
	return nil
}

func (e MaxReqsRateLimitAlgorithm) MarshalYAML() (interface{}, error) {
	return proto.EnumName(MaxReqsRateLimitAlgorithm_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *MaxReqsRateLimitAlgorithm) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := MaxReqsRateLimitAlgorithm_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = MaxReqsRateLimitAlgorithm_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = MaxReqsRateLimitAlgorithm(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = MaxReqsRateLimitAlgorithm(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}
func (m *ApiEndpointRateLimitSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EndpointRateLimitSettings != nil {
		l = m.EndpointRateLimitSettings.Size()
		n += 1 + l + sovRatelimit(uint64(l))
	}
	if m.EndpointPerIpRateLimitSettings != nil {
		l = m.EndpointPerIpRateLimitSettings.Size()
		n += 1 + l + sovRatelimit(uint64(l))
	}
	if m.EndpointPerUserRateLimitSettings != nil {
		l = m.EndpointPerUserRateLimitSettings.Size()
		n += 1 + l + sovRatelimit(uint64(l))
	}
	if m.EndpointPerOrgRateLimitSettings != nil {
		l = m.EndpointPerOrgRateLimitSettings.Size()
		n += 1 + l + sovRatelimit(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimitSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlowRateLimitSettings != nil {
		l = m.FlowRateLimitSettings.Size()
		n += 1 + l + sovRatelimit(uint64(l))
	}
	if m.MaxReqsRateLimitSettings != nil {
		l = m.MaxReqsRateLimitSettings.Size()
		n += 1 + l + sovRatelimit(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowRateLimitSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlowAlgorithm != 0 {
		n += 1 + sovRatelimit(uint64(m.FlowAlgorithm))
	}
	if m.ReqsPerSecond != 0 {
		n += 9
	}
	if m.BurstSize != 0 {
		n += 1 + sovRatelimit(uint64(m.BurstSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MaxReqsRateLimitSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxReqsAlgorithm != 0 {
		n += 1 + sovRatelimit(uint64(m.MaxReqsAlgorithm))
	}
	if m.MaxRequestsPerSecond != 0 {
		n += 1 + sovRatelimit(uint64(m.MaxRequestsPerSecond))
	}
	if m.MaxRequestsPerMinute != 0 {
		n += 1 + sovRatelimit(uint64(m.MaxRequestsPerMinute))
	}
	if m.MaxRequestsPerHour != 0 {
		n += 1 + sovRatelimit(uint64(m.MaxRequestsPerHour))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRatelimit(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRatelimit(x uint64) (n int) {
	return sovRatelimit(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ApiEndpointRateLimitSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRatelimit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApiEndpointRateLimitSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApiEndpointRateLimitSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointRateLimitSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndpointRateLimitSettings == nil {
				m.EndpointRateLimitSettings = &RateLimitSettings{}
			}
			if err := m.EndpointRateLimitSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointPerIpRateLimitSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndpointPerIpRateLimitSettings == nil {
				m.EndpointPerIpRateLimitSettings = &RateLimitSettings{}
			}
			if err := m.EndpointPerIpRateLimitSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointPerUserRateLimitSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndpointPerUserRateLimitSettings == nil {
				m.EndpointPerUserRateLimitSettings = &RateLimitSettings{}
			}
			if err := m.EndpointPerUserRateLimitSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointPerOrgRateLimitSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndpointPerOrgRateLimitSettings == nil {
				m.EndpointPerOrgRateLimitSettings = &RateLimitSettings{}
			}
			if err := m.EndpointPerOrgRateLimitSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRatelimit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimitSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRatelimit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RateLimitSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RateLimitSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowRateLimitSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowRateLimitSettings == nil {
				m.FlowRateLimitSettings = &FlowRateLimitSettings{}
			}
			if err := m.FlowRateLimitSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReqsRateLimitSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxReqsRateLimitSettings == nil {
				m.MaxReqsRateLimitSettings = &MaxReqsRateLimitSettings{}
			}
			if err := m.MaxReqsRateLimitSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRatelimit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowRateLimitSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRatelimit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowRateLimitSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowRateLimitSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowAlgorithm", wireType)
			}
			m.FlowAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowAlgorithm |= FlowRateLimitAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqsPerSecond", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ReqsPerSecond = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurstSize", wireType)
			}
			m.BurstSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BurstSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRatelimit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaxReqsRateLimitSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRatelimit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaxReqsRateLimitSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaxReqsRateLimitSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReqsAlgorithm", wireType)
			}
			m.MaxReqsAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxReqsAlgorithm |= MaxReqsRateLimitAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestsPerSecond", wireType)
			}
			m.MaxRequestsPerSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequestsPerSecond |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestsPerMinute", wireType)
			}
			m.MaxRequestsPerMinute = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequestsPerMinute |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestsPerHour", wireType)
			}
			m.MaxRequestsPerHour = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequestsPerHour |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRatelimit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRatelimit(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRatelimit
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRatelimit
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRatelimit
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRatelimit
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRatelimit        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRatelimit          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRatelimit = fmt.Errorf("proto: unexpected end of group")
)
