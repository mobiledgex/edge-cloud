// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gpu.proto

package edgeproto

import (
	context "context"
	"encoding/json"
	"errors"
	fmt "fmt"
	"github.com/coreos/etcd/clientv3/concurrency"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/mobiledgex/edge-cloud/log"
	"github.com/mobiledgex/edge-cloud/objstore"
	_ "github.com/mobiledgex/edge-cloud/protogen"
	"github.com/mobiledgex/edge-cloud/util"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	"strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GPU Type
//
// GPUType is the type of GPU supported by a Cloudlet
//
// 0: `GPU_TYPE_NONE`
// 1: `GPU_TYPE_PASSTHROUGH`
// 2: `GPU_TYPE_VGPU`
type GPUType int32

const (
	// GPU not supported
	GPUType_GPU_TYPE_NONE GPUType = 0
	// Passthrough GPU
	GPUType_GPU_TYPE_PASSTHROUGH GPUType = 1
	// Virtual GPU
	GPUType_GPU_TYPE_VGPU GPUType = 2
)

var GPUType_name = map[int32]string{
	0: "GPU_TYPE_NONE",
	1: "GPU_TYPE_PASSTHROUGH",
	2: "GPU_TYPE_VGPU",
}

var GPUType_value = map[string]int32{
	"GPU_TYPE_NONE":        0,
	"GPU_TYPE_PASSTHROUGH": 1,
	"GPU_TYPE_VGPU":        2,
}

func (x GPUType) String() string {
	return proto.EnumName(GPUType_name, int32(x))
}

func (GPUType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_423e7ee1fd9c7f2c, []int{0}
}

// Operating System Type
//
// OSType is the type of the Operator System
//
//  0: `Linux`
//  1: `Windows`
// 20: `Others`
type OSType int32

const (
	// Linux Operating System
	OSType_LINUX OSType = 0
	// Windows Operating System
	OSType_WINDOWS OSType = 1
	// Other Operating Systems
	OSType_OTHERS OSType = 20
)

var OSType_name = map[int32]string{
	0:  "LINUX",
	1:  "WINDOWS",
	20: "OTHERS",
}

var OSType_value = map[string]int32{
	"LINUX":   0,
	"WINDOWS": 1,
	"OTHERS":  20,
}

func (x OSType) String() string {
	return proto.EnumName(OSType_name, int32(x))
}

func (OSType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_423e7ee1fd9c7f2c, []int{1}
}

// GPU Driver Key
//
// GPUDriverKey uniquely identifies a GPU driver
type GPUDriverKey struct {
	// Name of the driver
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Organization to which the driver belongs to
	Organization string `protobuf:"bytes,2,opt,name=organization,proto3" json:"organization,omitempty"`
}

func (m *GPUDriverKey) Reset()         { *m = GPUDriverKey{} }
func (m *GPUDriverKey) String() string { return proto.CompactTextString(m) }
func (*GPUDriverKey) ProtoMessage()    {}
func (*GPUDriverKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_423e7ee1fd9c7f2c, []int{0}
}
func (m *GPUDriverKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUDriverKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUDriverKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUDriverKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUDriverKey.Merge(m, src)
}
func (m *GPUDriverKey) XXX_Size() int {
	return m.Size()
}
func (m *GPUDriverKey) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUDriverKey.DiscardUnknown(m)
}

var xxx_messageInfo_GPUDriverKey proto.InternalMessageInfo

type GPUDriverBuild struct {
	// Unique identifier key
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Path where the driver package is located, if it is authenticated path,
	// then credentials must be passed as part of URL (one-time download path)
	DriverPath string `protobuf:"bytes,2,opt,name=driver_path,json=driverPath,proto3" json:"driver_path,omitempty"`
	// Optional credentials (username:password) to access driver path
	DriverPathCreds string `protobuf:"bytes,3,opt,name=driver_path_creds,json=driverPathCreds,proto3" json:"driver_path_creds,omitempty"`
	// Operator System supported by GPU driver build
	OperatingSystem OSType `protobuf:"varint,4,opt,name=operating_system,json=operatingSystem,proto3,enum=edgeproto.OSType" json:"operating_system,omitempty"`
	// Kernel Version supported by GPU driver build
	KernelVersion string `protobuf:"bytes,5,opt,name=kernel_version,json=kernelVersion,proto3" json:"kernel_version,omitempty"`
	// Info on hypervisor supported by vGPU driver
	HypervisorInfo string `protobuf:"bytes,6,opt,name=hypervisor_info,json=hypervisorInfo,proto3" json:"hypervisor_info,omitempty"`
	// Driver package md5sum to ensure package is not corrupted
	Md5Sum string `protobuf:"bytes,7,opt,name=md5sum,proto3" json:"md5sum,omitempty"`
}

func (m *GPUDriverBuild) Reset()         { *m = GPUDriverBuild{} }
func (m *GPUDriverBuild) String() string { return proto.CompactTextString(m) }
func (*GPUDriverBuild) ProtoMessage()    {}
func (*GPUDriverBuild) Descriptor() ([]byte, []int) {
	return fileDescriptor_423e7ee1fd9c7f2c, []int{1}
}
func (m *GPUDriverBuild) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUDriverBuild) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUDriverBuild.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUDriverBuild) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUDriverBuild.Merge(m, src)
}
func (m *GPUDriverBuild) XXX_Size() int {
	return m.Size()
}
func (m *GPUDriverBuild) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUDriverBuild.DiscardUnknown(m)
}

var xxx_messageInfo_GPUDriverBuild proto.InternalMessageInfo

type GPUDriverBuildMember struct {
	// Unique identifier key
	Key GPUDriverKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
	// GPU driver build
	Build GPUDriverBuild `protobuf:"bytes,2,opt,name=build,proto3" json:"build"`
	// Ignore state will ignore any action in-progress on the GPU driver
	IgnoreState bool `protobuf:"varint,3,opt,name=ignore_state,json=ignoreState,proto3" json:"ignore_state,omitempty"`
}

func (m *GPUDriverBuildMember) Reset()         { *m = GPUDriverBuildMember{} }
func (m *GPUDriverBuildMember) String() string { return proto.CompactTextString(m) }
func (*GPUDriverBuildMember) ProtoMessage()    {}
func (*GPUDriverBuildMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_423e7ee1fd9c7f2c, []int{2}
}
func (m *GPUDriverBuildMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUDriverBuildMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUDriverBuildMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUDriverBuildMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUDriverBuildMember.Merge(m, src)
}
func (m *GPUDriverBuildMember) XXX_Size() int {
	return m.Size()
}
func (m *GPUDriverBuildMember) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUDriverBuildMember.DiscardUnknown(m)
}

var xxx_messageInfo_GPUDriverBuildMember proto.InternalMessageInfo

type GPUDriverBuildURL struct {
	// Build URL path
	BuildUrlPath string `protobuf:"bytes,1,opt,name=build_url_path,json=buildUrlPath,proto3" json:"build_url_path,omitempty"`
	// Build URL path validity
	Validity Duration `protobuf:"varint,2,opt,name=validity,proto3,casttype=Duration" json:"validity,omitempty"`
}

func (m *GPUDriverBuildURL) Reset()         { *m = GPUDriverBuildURL{} }
func (m *GPUDriverBuildURL) String() string { return proto.CompactTextString(m) }
func (*GPUDriverBuildURL) ProtoMessage()    {}
func (*GPUDriverBuildURL) Descriptor() ([]byte, []int) {
	return fileDescriptor_423e7ee1fd9c7f2c, []int{3}
}
func (m *GPUDriverBuildURL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUDriverBuildURL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUDriverBuildURL.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUDriverBuildURL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUDriverBuildURL.Merge(m, src)
}
func (m *GPUDriverBuildURL) XXX_Size() int {
	return m.Size()
}
func (m *GPUDriverBuildURL) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUDriverBuildURL.DiscardUnknown(m)
}

var xxx_messageInfo_GPUDriverBuildURL proto.InternalMessageInfo

type GPUDriver struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique identifier key
	Key GPUDriverKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// Type of GPU hardware
	Type GPUType `protobuf:"varint,3,opt,name=type,proto3,enum=edgeproto.GPUType" json:"type,omitempty"`
	// List of GPU driver build
	Builds []GPUDriverBuild `protobuf:"bytes,4,rep,name=builds,proto3" json:"builds"`
	// License config to setup license (will be stored in secure storage)
	LicenseConfig string `protobuf:"bytes,5,opt,name=license_config,json=licenseConfig,proto3" json:"license_config,omitempty"`
	// License config md5sum, to ensure integrity of license config
	LicenseConfigMd5Sum string `protobuf:"bytes,9,opt,name=license_config_md5sum,json=licenseConfigMd5sum,proto3" json:"license_config_md5sum,omitempty"`
	// Additional properties associated with GPU driver build
	// For example: license server information, driver release date, etc
	Properties map[string]string `protobuf:"bytes,6,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// State to figure out if any action on the GPU driver is in-progress
	State string `protobuf:"bytes,7,opt,name=state,proto3" json:"state,omitempty"`
	// Ignore state will ignore any action in-progress on the GPU driver
	IgnoreState bool `protobuf:"varint,8,opt,name=ignore_state,json=ignoreState,proto3" json:"ignore_state,omitempty"`
}

func (m *GPUDriver) Reset()         { *m = GPUDriver{} }
func (m *GPUDriver) String() string { return proto.CompactTextString(m) }
func (*GPUDriver) ProtoMessage()    {}
func (*GPUDriver) Descriptor() ([]byte, []int) {
	return fileDescriptor_423e7ee1fd9c7f2c, []int{4}
}
func (m *GPUDriver) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUDriver) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUDriver.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUDriver) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUDriver.Merge(m, src)
}
func (m *GPUDriver) XXX_Size() int {
	return m.Size()
}
func (m *GPUDriver) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUDriver.DiscardUnknown(m)
}

var xxx_messageInfo_GPUDriver proto.InternalMessageInfo

type GPUConfig struct {
	// GPU driver key
	Driver GPUDriverKey `protobuf:"bytes,1,opt,name=driver,proto3" json:"driver"`
	// Type of GPU hardware supported by the Cloudlet
	GpuType GPUType `protobuf:"varint,2,opt,name=gpu_type,json=gpuType,proto3,enum=edgeproto.GPUType" json:"gpu_type,omitempty"`
	// Properties to identify specifics of GPU
	Properties map[string]string `protobuf:"bytes,3,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *GPUConfig) Reset()         { *m = GPUConfig{} }
func (m *GPUConfig) String() string { return proto.CompactTextString(m) }
func (*GPUConfig) ProtoMessage()    {}
func (*GPUConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_423e7ee1fd9c7f2c, []int{5}
}
func (m *GPUConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUConfig.Merge(m, src)
}
func (m *GPUConfig) XXX_Size() int {
	return m.Size()
}
func (m *GPUConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GPUConfig proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("edgeproto.GPUType", GPUType_name, GPUType_value)
	proto.RegisterEnum("edgeproto.OSType", OSType_name, OSType_value)
	proto.RegisterType((*GPUDriverKey)(nil), "edgeproto.GPUDriverKey")
	proto.RegisterType((*GPUDriverBuild)(nil), "edgeproto.GPUDriverBuild")
	proto.RegisterType((*GPUDriverBuildMember)(nil), "edgeproto.GPUDriverBuildMember")
	proto.RegisterType((*GPUDriverBuildURL)(nil), "edgeproto.GPUDriverBuildURL")
	proto.RegisterType((*GPUDriver)(nil), "edgeproto.GPUDriver")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.GPUDriver.PropertiesEntry")
	proto.RegisterType((*GPUConfig)(nil), "edgeproto.GPUConfig")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.GPUConfig.PropertiesEntry")
}

func init() { proto.RegisterFile("gpu.proto", fileDescriptor_423e7ee1fd9c7f2c) }

var fileDescriptor_423e7ee1fd9c7f2c = []byte{
	// 1274 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0xcd, 0x6f, 0x1b, 0xc5,
	0x1b, 0xf6, 0x38, 0x89, 0x13, 0x4f, 0x9c, 0xd8, 0x99, 0xfa, 0xd7, 0xdf, 0x34, 0x54, 0x4e, 0x6a,
	0x15, 0xa8, 0xa2, 0x24, 0x8b, 0x02, 0x11, 0x55, 0x44, 0x91, 0xf2, 0xa5, 0x24, 0x6a, 0x12, 0x5b,
	0xeb, 0xb8, 0x85, 0x03, 0x5a, 0x6d, 0xbc, 0x93, 0xf5, 0xaa, 0xeb, 0x9d, 0xd5, 0xec, 0xae, 0x8b,
	0x39, 0x55, 0x9c, 0xb8, 0x51, 0xca, 0xa1, 0xa8, 0x5c, 0x10, 0x12, 0x12, 0xe2, 0x54, 0x71, 0x41,
	0xf4, 0x2f, 0xc8, 0x31, 0x12, 0x17, 0xc4, 0xa1, 0x82, 0x84, 0x03, 0x82, 0x4b, 0xa5, 0xda, 0x11,
	0xe2, 0x84, 0x76, 0x66, 0xbb, 0xfe, 0x88, 0x43, 0x83, 0x41, 0x5c, 0xac, 0x99, 0x77, 0x9e, 0xd9,
	0xf7, 0x79, 0x9f, 0xf7, 0xf1, 0xcc, 0xc0, 0xb8, 0x6e, 0x7b, 0xb3, 0x36, 0xa3, 0x2e, 0x45, 0x71,
	0xa2, 0xe9, 0x84, 0x0f, 0xc7, 0x2f, 0xea, 0x94, 0xea, 0x26, 0x91, 0x54, 0xdb, 0x90, 0x54, 0xcb,
	0xa2, 0xae, 0xea, 0x1a, 0xd4, 0x72, 0x04, 0x70, 0xfc, 0xaa, 0x6e, 0xb8, 0x65, 0x6f, 0x77, 0xb6,
	0x44, 0x2b, 0x52, 0x85, 0xee, 0x1a, 0xa6, 0xbf, 0xf1, 0x5d, 0xc9, 0xff, 0x9d, 0x29, 0x99, 0xd4,
	0xd3, 0x24, 0x8e, 0xd3, 0x89, 0x15, 0x0e, 0x82, 0x9d, 0x09, 0x46, 0x1c, 0xcf, 0x74, 0x83, 0x59,
	0x5a, 0xa7, 0x3a, 0xe5, 0x43, 0xc9, 0x1f, 0x89, 0x68, 0xd6, 0x83, 0x89, 0xb5, 0x7c, 0x71, 0x85,
	0x19, 0x55, 0xc2, 0xae, 0x93, 0x1a, 0xba, 0x04, 0xfb, 0x2d, 0xb5, 0x42, 0x30, 0x98, 0x04, 0x57,
	0xe2, 0x4b, 0x23, 0x8f, 0x8e, 0xb1, 0xcf, 0x59, 0xe3, 0xeb, 0x32, 0x5f, 0x42, 0xaf, 0xc1, 0x04,
	0x65, 0xba, 0x6a, 0x19, 0xef, 0x71, 0x9e, 0x38, 0xca, 0xa1, 0xa9, 0x47, 0xc7, 0x38, 0x11, 0x42,
	0x29, 0xd3, 0xe5, 0x36, 0xd4, 0x42, 0xe2, 0x97, 0xa7, 0x18, 0xfc, 0xfe, 0x14, 0x83, 0x87, 0x9f,
	0x4d, 0x80, 0xec, 0xfd, 0x28, 0x1c, 0x0d, 0xf3, 0x2e, 0x79, 0x86, 0xa9, 0x21, 0xd4, 0x9a, 0x39,
	0x48, 0x35, 0x01, 0x87, 0xc5, 0xf7, 0x14, 0x5b, 0x75, 0xcb, 0x22, 0x93, 0x0c, 0x45, 0x28, 0xaf,
	0xba, 0x65, 0x34, 0x05, 0xc7, 0x5a, 0x00, 0x4a, 0x89, 0x11, 0xcd, 0xc1, 0x7d, 0x1c, 0x96, 0x6c,
	0xc2, 0x96, 0xfd, 0x30, 0x7a, 0x03, 0xa6, 0xa8, 0x4d, 0x98, 0xea, 0x1a, 0x96, 0xae, 0x38, 0x35,
	0xc7, 0x25, 0x15, 0xdc, 0x3f, 0x09, 0xae, 0x8c, 0xce, 0x8d, 0xcd, 0x86, 0xcd, 0x98, 0xcd, 0x15,
	0x76, 0x6a, 0x36, 0x91, 0x93, 0x21, 0xb4, 0xc0, 0x91, 0xe8, 0x45, 0x38, 0x7a, 0x8b, 0x30, 0x8b,
	0x98, 0x4a, 0x95, 0x30, 0xc7, 0xaf, 0x7b, 0x80, 0xa7, 0x19, 0x11, 0xd1, 0x1b, 0x22, 0x88, 0x5e,
	0x86, 0xc9, 0x72, 0xcd, 0x26, 0xac, 0x6a, 0x38, 0x94, 0x29, 0x86, 0xb5, 0x47, 0x71, 0x8c, 0xe3,
	0x46, 0x9b, 0xe1, 0x0d, 0x6b, 0x8f, 0xa2, 0xf3, 0x30, 0x56, 0xd1, 0xe6, 0x1d, 0xaf, 0x82, 0x07,
	0xf9, 0x7a, 0x30, 0xcb, 0x3e, 0x01, 0x30, 0xdd, 0xae, 0xcc, 0x16, 0xa9, 0xec, 0x12, 0x86, 0x24,
	0xd8, 0x77, 0x8b, 0xd4, 0xb8, 0x3c, 0xc3, 0x73, 0xff, 0x6f, 0x61, 0xdc, 0xda, 0xbf, 0xa5, 0xfe,
	0xfd, 0xc7, 0x13, 0x11, 0xd9, 0x47, 0xa2, 0x79, 0x38, 0xb0, 0xeb, 0xef, 0xe7, 0xb2, 0x0d, 0xcf,
	0x5d, 0xe8, 0xb6, 0x85, 0x27, 0x08, 0x36, 0x09, 0x34, 0xba, 0x04, 0x13, 0x86, 0x6e, 0x51, 0x46,
	0x14, 0xc7, 0x55, 0x5d, 0xc2, 0xd5, 0x1c, 0x92, 0x87, 0x45, 0xac, 0xe0, 0x87, 0x16, 0xb6, 0x1e,
	0x34, 0xf0, 0x7c, 0xd8, 0x6b, 0xbf, 0x53, 0xd7, 0xae, 0x93, 0xda, 0xec, 0xb6, 0x5a, 0x21, 0xd3,
	0x61, 0x78, 0x86, 0x32, 0x9d, 0x87, 0x73, 0x2d, 0x36, 0xf8, 0xfa, 0x18, 0xa7, 0x6e, 0x91, 0xda,
	0xb5, 0xd6, 0x58, 0xb6, 0x04, 0xc7, 0xda, 0x09, 0x15, 0xe5, 0x4d, 0x74, 0x19, 0x8e, 0x72, 0x3e,
	0x8a, 0xc7, 0x4c, 0xd1, 0x7d, 0x61, 0x8c, 0x04, 0x8f, 0x16, 0x99, 0xc9, 0xfb, 0x7f, 0x05, 0x0e,
	0x55, 0x55, 0xd3, 0xd0, 0x0c, 0xb7, 0xc6, 0xcb, 0xec, 0x5b, 0x4a, 0xfc, 0xf1, 0x78, 0x62, 0x68,
	0xc5, 0x63, 0xfc, 0xd3, 0x72, 0xb8, 0x9a, 0xfd, 0xad, 0x1f, 0xc6, 0xc3, 0x2c, 0xbe, 0xfa, 0x7b,
	0x06, 0x31, 0x35, 0x07, 0x83, 0xc9, 0x3e, 0x5f, 0x7d, 0x31, 0x7b, 0x26, 0x72, 0xf4, 0xcc, 0x22,
	0xbf, 0x04, 0xfb, 0xdd, 0x9a, 0x2d, 0x54, 0x1a, 0x9d, 0x43, 0xed, 0x3b, 0xb8, 0x93, 0xf8, 0x3a,
	0x7a, 0x1d, 0xc6, 0x38, 0x71, 0x07, 0xf7, 0x4f, 0xf6, 0x9d, 0xa5, 0x1b, 0x01, 0xdc, 0xf7, 0x9d,
	0x69, 0x94, 0x88, 0xe5, 0x10, 0xa5, 0x44, 0xad, 0x3d, 0x43, 0x7f, 0xe6, 0xbb, 0x20, 0xba, 0xcc,
	0x83, 0x68, 0x0e, 0xfe, 0xaf, 0x1d, 0xa6, 0x04, 0xee, 0x8a, 0x73, 0xf4, 0xb9, 0x36, 0xf4, 0x16,
	0x5f, 0x42, 0x2b, 0x10, 0xda, 0xcc, 0xf7, 0xb9, 0x6b, 0x10, 0x07, 0xc7, 0x38, 0xaf, 0xcb, 0xdd,
	0x78, 0xcd, 0xe6, 0x43, 0xd8, 0xaa, 0xe5, 0xb2, 0x9a, 0xdc, 0xb2, 0x0f, 0xa5, 0xe1, 0x80, 0x30,
	0x8a, 0xf0, 0xb1, 0x98, 0x9c, 0x70, 0xd1, 0xd0, 0x09, 0x17, 0x8d, 0x5f, 0x83, 0xc9, 0x8e, 0xef,
	0xa2, 0x54, 0xd3, 0xe3, 0x71, 0xa1, 0x6f, 0x1a, 0x0e, 0x54, 0x55, 0xd3, 0x23, 0xc1, 0x7f, 0x5f,
	0x4c, 0x16, 0xa2, 0x57, 0xc1, 0xc2, 0x03, 0xe0, 0x9f, 0x28, 0x4f, 0x9e, 0x62, 0x70, 0xa7, 0x8e,
	0xc1, 0xdd, 0x3a, 0x06, 0x9f, 0xd4, 0x31, 0x78, 0x58, 0xc7, 0x60, 0xbf, 0x8e, 0xc1, 0xbd, 0x06,
	0xbe, 0xc0, 0xd3, 0x4c, 0x6f, 0x9e, 0xac, 0xbc, 0x67, 0xfb, 0x7e, 0xde, 0xc0, 0xa9, 0x33, 0x59,
	0xfa, 0x18, 0x70, 0xb7, 0x05, 0xcd, 0x99, 0x87, 0x31, 0xf1, 0xd1, 0xb3, 0xfd, 0x7b, 0x03, 0x30,
	0x9a, 0x81, 0x43, 0xba, 0xed, 0x29, 0xdc, 0x5f, 0xd1, 0x53, 0xfd, 0x35, 0xa8, 0xdb, 0x9e, 0x3f,
	0xe8, 0x68, 0x67, 0x5f, 0xb7, 0x76, 0x0a, 0x3e, 0x7f, 0xd5, 0xce, 0x7f, 0xd8, 0x95, 0xa9, 0x0d,
	0x38, 0x18, 0x10, 0x43, 0x63, 0x70, 0x64, 0x2d, 0x5f, 0x54, 0x76, 0xde, 0xce, 0xaf, 0x2a, 0xdb,
	0xb9, 0xed, 0xd5, 0x54, 0x04, 0x61, 0x7e, 0xb6, 0x89, 0x50, 0x7e, 0xb1, 0x50, 0xd8, 0x59, 0x97,
	0x73, 0xc5, 0xb5, 0xf5, 0x14, 0x68, 0x03, 0xdf, 0x58, 0xcb, 0x17, 0x53, 0xd1, 0xa9, 0x69, 0x18,
	0x13, 0x87, 0x31, 0x8a, 0xc3, 0x81, 0xcd, 0x8d, 0xed, 0xe2, 0x5b, 0xa9, 0x08, 0x1a, 0x86, 0x83,
	0x37, 0x37, 0xb6, 0x57, 0x72, 0x37, 0x0b, 0x29, 0x80, 0x20, 0x8c, 0xe5, 0x76, 0xd6, 0x57, 0xe5,
	0x42, 0x2a, 0x3d, 0x77, 0x67, 0xb8, 0xe5, 0x26, 0x5b, 0xb4, 0x0d, 0xf4, 0x05, 0x80, 0xc9, 0x65,
	0x46, 0x54, 0x97, 0x34, 0xff, 0xf6, 0xe9, 0x6e, 0xc2, 0x8f, 0xb7, 0x1e, 0xff, 0x32, 0xbf, 0x32,
	0xb3, 0xfa, 0xaf, 0x75, 0x2c, 0xc9, 0xc4, 0xa1, 0x1e, 0x2b, 0x91, 0x65, 0xff, 0x96, 0x35, 0x89,
	0xeb, 0x4c, 0x2f, 0x96, 0xfc, 0xee, 0x6e, 0xa9, 0x96, 0xaa, 0x93, 0xe9, 0x4e, 0x23, 0x7c, 0xd9,
	0xc0, 0xe0, 0xab, 0xe3, 0x93, 0x06, 0x79, 0xff, 0xbb, 0x9f, 0x3f, 0x8e, 0x9e, 0xcf, 0x8e, 0x49,
	0x25, 0xce, 0x46, 0x0a, 0x2d, 0xb6, 0x00, 0xa6, 0x5e, 0x01, 0xe8, 0x23, 0x00, 0x93, 0x2b, 0xc4,
	0x24, 0x3d, 0xf1, 0x2c, 0xf4, 0xc8, 0x33, 0xe4, 0xa4, 0xf1, 0xcc, 0x9d, 0x9c, 0x3e, 0x05, 0x30,
	0x59, 0xb4, 0xb5, 0xde, 0xb4, 0x7b, 0xa7, 0x47, 0x4e, 0x3f, 0x34, 0x70, 0x8c, 0x9f, 0x80, 0x4e,
	0xc8, 0xce, 0xe3, 0x1c, 0x3a, 0xd9, 0xdd, 0x03, 0x70, 0xa4, 0x50, 0xa6, 0xb7, 0x9f, 0xc7, 0xad,
	0x6b, 0x94, 0x4b, 0x36, 0x73, 0x1a, 0xbd, 0x1b, 0x06, 0xb9, 0xdd, 0x95, 0xdc, 0xc1, 0x33, 0xd1,
	0xd2, 0xd9, 0xa4, 0xe4, 0x94, 0xe9, 0xed, 0x4e, 0x52, 0x47, 0x00, 0x8e, 0x2d, 0x6a, 0x5a, 0xc7,
	0xa3, 0x66, 0xe2, 0xd4, 0x63, 0x5e, 0xdc, 0xea, 0xdd, 0xf4, 0xbb, 0x0f, 0x7a, 0x14, 0xf0, 0xb0,
	0x81, 0xdf, 0xe4, 0xdf, 0x16, 0x47, 0x99, 0x18, 0xae, 0x84, 0xaf, 0xa0, 0x20, 0xb0, 0xa5, 0xcd,
	0x17, 0xbc, 0x4a, 0x30, 0xc9, 0xb5, 0xbf, 0x72, 0x78, 0x85, 0x38, 0x7b, 0x4e, 0x52, 0x35, 0xad,
	0x59, 0x20, 0xbf, 0x89, 0x44, 0x95, 0x1f, 0x44, 0x61, 0x5a, 0x26, 0x15, 0x5a, 0x25, 0xff, 0x42,
	0xa1, 0xdf, 0x82, 0xde, 0x9d, 0x92, 0x3b, 0xa5, 0xba, 0x8e, 0x82, 0x82, 0xe8, 0xf5, 0xd6, 0x37,
	0x5a, 0x10, 0x5b, 0x6f, 0x7b, 0x8f, 0x1d, 0x36, 0x30, 0x6c, 0x6a, 0xc7, 0x75, 0x78, 0x21, 0x7b,
	0x5e, 0x62, 0xbc, 0xd6, 0xae, 0x52, 0x7c, 0x18, 0x85, 0xe9, 0x35, 0xe2, 0x9e, 0x7c, 0xb9, 0x3c,
	0x57, 0x8a, 0x8b, 0xa7, 0x02, 0x8a, 0xf2, 0x66, 0xf6, 0x1b, 0xf0, 0xb7, 0x0d, 0x7a, 0xf0, 0x9f,
	0x6a, 0xa2, 0x13, 0xb7, 0x43, 0x10, 0x8f, 0x99, 0x0b, 0x60, 0x6a, 0xe9, 0xe2, 0xfe, 0x4f, 0x99,
	0xc8, 0xfe, 0x61, 0x06, 0x1c, 0x1c, 0x66, 0xc0, 0x8f, 0x87, 0x19, 0x70, 0xf7, 0x28, 0x13, 0x39,
	0x38, 0xca, 0x44, 0xbe, 0x3f, 0xca, 0x44, 0x76, 0x63, 0xbc, 0xe0, 0x57, 0xff, 0x0c, 0x00, 0x00,
	0xff, 0xff, 0x9c, 0x1a, 0xec, 0xf9, 0x04, 0x0d, 0x00, 0x00,
}

func (this *GPUDriverKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&edgeproto.GPUDriverKey{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Organization: "+fmt.Sprintf("%#v", this.Organization)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringGpu(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GPUDriverApiClient is the client API for GPUDriverApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GPUDriverApiClient interface {
	// Create GPU Driver. Creates GPU driver with all the config
	// required to install it.
	CreateGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_CreateGPUDriverClient, error)
	// Delete GPU Driver. Deletes GPU driver given that it is not
	// used by any cloudlet.
	DeleteGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_DeleteGPUDriverClient, error)
	// Update GPU Driver. Updates GPU driver config.
	UpdateGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_UpdateGPUDriverClient, error)
	// Show GPU Drivers. Lists all the MobiledgeX created GPU drivers and operator
	// created GPU drivers.
	ShowGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_ShowGPUDriverClient, error)
	// Add GPU Driver Build. Adds new build to GPU driver.
	AddGPUDriverBuild(ctx context.Context, in *GPUDriverBuildMember, opts ...grpc.CallOption) (GPUDriverApi_AddGPUDriverBuildClient, error)
	// Remove GPU Driver Build. Removes build from GPU driver.
	RemoveGPUDriverBuild(ctx context.Context, in *GPUDriverBuildMember, opts ...grpc.CallOption) (GPUDriverApi_RemoveGPUDriverBuildClient, error)
	// Get GPU Driver Build URL. Returns a time-limited signed URL to download GPU driver.
	GetGPUDriverBuildURL(ctx context.Context, in *GPUDriverBuildMember, opts ...grpc.CallOption) (*GPUDriverBuildURL, error)
}

type gPUDriverApiClient struct {
	cc *grpc.ClientConn
}

func NewGPUDriverApiClient(cc *grpc.ClientConn) GPUDriverApiClient {
	return &gPUDriverApiClient{cc}
}

func (c *gPUDriverApiClient) CreateGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_CreateGPUDriverClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GPUDriverApi_serviceDesc.Streams[0], "/edgeproto.GPUDriverApi/CreateGPUDriver", opts...)
	if err != nil {
		return nil, err
	}
	x := &gPUDriverApiCreateGPUDriverClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GPUDriverApi_CreateGPUDriverClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type gPUDriverApiCreateGPUDriverClient struct {
	grpc.ClientStream
}

func (x *gPUDriverApiCreateGPUDriverClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gPUDriverApiClient) DeleteGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_DeleteGPUDriverClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GPUDriverApi_serviceDesc.Streams[1], "/edgeproto.GPUDriverApi/DeleteGPUDriver", opts...)
	if err != nil {
		return nil, err
	}
	x := &gPUDriverApiDeleteGPUDriverClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GPUDriverApi_DeleteGPUDriverClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type gPUDriverApiDeleteGPUDriverClient struct {
	grpc.ClientStream
}

func (x *gPUDriverApiDeleteGPUDriverClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gPUDriverApiClient) UpdateGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_UpdateGPUDriverClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GPUDriverApi_serviceDesc.Streams[2], "/edgeproto.GPUDriverApi/UpdateGPUDriver", opts...)
	if err != nil {
		return nil, err
	}
	x := &gPUDriverApiUpdateGPUDriverClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GPUDriverApi_UpdateGPUDriverClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type gPUDriverApiUpdateGPUDriverClient struct {
	grpc.ClientStream
}

func (x *gPUDriverApiUpdateGPUDriverClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gPUDriverApiClient) ShowGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_ShowGPUDriverClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GPUDriverApi_serviceDesc.Streams[3], "/edgeproto.GPUDriverApi/ShowGPUDriver", opts...)
	if err != nil {
		return nil, err
	}
	x := &gPUDriverApiShowGPUDriverClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GPUDriverApi_ShowGPUDriverClient interface {
	Recv() (*GPUDriver, error)
	grpc.ClientStream
}

type gPUDriverApiShowGPUDriverClient struct {
	grpc.ClientStream
}

func (x *gPUDriverApiShowGPUDriverClient) Recv() (*GPUDriver, error) {
	m := new(GPUDriver)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gPUDriverApiClient) AddGPUDriverBuild(ctx context.Context, in *GPUDriverBuildMember, opts ...grpc.CallOption) (GPUDriverApi_AddGPUDriverBuildClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GPUDriverApi_serviceDesc.Streams[4], "/edgeproto.GPUDriverApi/AddGPUDriverBuild", opts...)
	if err != nil {
		return nil, err
	}
	x := &gPUDriverApiAddGPUDriverBuildClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GPUDriverApi_AddGPUDriverBuildClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type gPUDriverApiAddGPUDriverBuildClient struct {
	grpc.ClientStream
}

func (x *gPUDriverApiAddGPUDriverBuildClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gPUDriverApiClient) RemoveGPUDriverBuild(ctx context.Context, in *GPUDriverBuildMember, opts ...grpc.CallOption) (GPUDriverApi_RemoveGPUDriverBuildClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GPUDriverApi_serviceDesc.Streams[5], "/edgeproto.GPUDriverApi/RemoveGPUDriverBuild", opts...)
	if err != nil {
		return nil, err
	}
	x := &gPUDriverApiRemoveGPUDriverBuildClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GPUDriverApi_RemoveGPUDriverBuildClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type gPUDriverApiRemoveGPUDriverBuildClient struct {
	grpc.ClientStream
}

func (x *gPUDriverApiRemoveGPUDriverBuildClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gPUDriverApiClient) GetGPUDriverBuildURL(ctx context.Context, in *GPUDriverBuildMember, opts ...grpc.CallOption) (*GPUDriverBuildURL, error) {
	out := new(GPUDriverBuildURL)
	err := c.cc.Invoke(ctx, "/edgeproto.GPUDriverApi/GetGPUDriverBuildURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GPUDriverApiServer is the server API for GPUDriverApi service.
type GPUDriverApiServer interface {
	// Create GPU Driver. Creates GPU driver with all the config
	// required to install it.
	CreateGPUDriver(*GPUDriver, GPUDriverApi_CreateGPUDriverServer) error
	// Delete GPU Driver. Deletes GPU driver given that it is not
	// used by any cloudlet.
	DeleteGPUDriver(*GPUDriver, GPUDriverApi_DeleteGPUDriverServer) error
	// Update GPU Driver. Updates GPU driver config.
	UpdateGPUDriver(*GPUDriver, GPUDriverApi_UpdateGPUDriverServer) error
	// Show GPU Drivers. Lists all the MobiledgeX created GPU drivers and operator
	// created GPU drivers.
	ShowGPUDriver(*GPUDriver, GPUDriverApi_ShowGPUDriverServer) error
	// Add GPU Driver Build. Adds new build to GPU driver.
	AddGPUDriverBuild(*GPUDriverBuildMember, GPUDriverApi_AddGPUDriverBuildServer) error
	// Remove GPU Driver Build. Removes build from GPU driver.
	RemoveGPUDriverBuild(*GPUDriverBuildMember, GPUDriverApi_RemoveGPUDriverBuildServer) error
	// Get GPU Driver Build URL. Returns a time-limited signed URL to download GPU driver.
	GetGPUDriverBuildURL(context.Context, *GPUDriverBuildMember) (*GPUDriverBuildURL, error)
}

// UnimplementedGPUDriverApiServer can be embedded to have forward compatible implementations.
type UnimplementedGPUDriverApiServer struct {
}

func (*UnimplementedGPUDriverApiServer) CreateGPUDriver(req *GPUDriver, srv GPUDriverApi_CreateGPUDriverServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateGPUDriver not implemented")
}
func (*UnimplementedGPUDriverApiServer) DeleteGPUDriver(req *GPUDriver, srv GPUDriverApi_DeleteGPUDriverServer) error {
	return status.Errorf(codes.Unimplemented, "method DeleteGPUDriver not implemented")
}
func (*UnimplementedGPUDriverApiServer) UpdateGPUDriver(req *GPUDriver, srv GPUDriverApi_UpdateGPUDriverServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateGPUDriver not implemented")
}
func (*UnimplementedGPUDriverApiServer) ShowGPUDriver(req *GPUDriver, srv GPUDriverApi_ShowGPUDriverServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowGPUDriver not implemented")
}
func (*UnimplementedGPUDriverApiServer) AddGPUDriverBuild(req *GPUDriverBuildMember, srv GPUDriverApi_AddGPUDriverBuildServer) error {
	return status.Errorf(codes.Unimplemented, "method AddGPUDriverBuild not implemented")
}
func (*UnimplementedGPUDriverApiServer) RemoveGPUDriverBuild(req *GPUDriverBuildMember, srv GPUDriverApi_RemoveGPUDriverBuildServer) error {
	return status.Errorf(codes.Unimplemented, "method RemoveGPUDriverBuild not implemented")
}
func (*UnimplementedGPUDriverApiServer) GetGPUDriverBuildURL(ctx context.Context, req *GPUDriverBuildMember) (*GPUDriverBuildURL, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGPUDriverBuildURL not implemented")
}

func RegisterGPUDriverApiServer(s *grpc.Server, srv GPUDriverApiServer) {
	s.RegisterService(&_GPUDriverApi_serviceDesc, srv)
}

func _GPUDriverApi_CreateGPUDriver_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GPUDriver)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GPUDriverApiServer).CreateGPUDriver(m, &gPUDriverApiCreateGPUDriverServer{stream})
}

type GPUDriverApi_CreateGPUDriverServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type gPUDriverApiCreateGPUDriverServer struct {
	grpc.ServerStream
}

func (x *gPUDriverApiCreateGPUDriverServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _GPUDriverApi_DeleteGPUDriver_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GPUDriver)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GPUDriverApiServer).DeleteGPUDriver(m, &gPUDriverApiDeleteGPUDriverServer{stream})
}

type GPUDriverApi_DeleteGPUDriverServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type gPUDriverApiDeleteGPUDriverServer struct {
	grpc.ServerStream
}

func (x *gPUDriverApiDeleteGPUDriverServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _GPUDriverApi_UpdateGPUDriver_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GPUDriver)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GPUDriverApiServer).UpdateGPUDriver(m, &gPUDriverApiUpdateGPUDriverServer{stream})
}

type GPUDriverApi_UpdateGPUDriverServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type gPUDriverApiUpdateGPUDriverServer struct {
	grpc.ServerStream
}

func (x *gPUDriverApiUpdateGPUDriverServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _GPUDriverApi_ShowGPUDriver_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GPUDriver)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GPUDriverApiServer).ShowGPUDriver(m, &gPUDriverApiShowGPUDriverServer{stream})
}

type GPUDriverApi_ShowGPUDriverServer interface {
	Send(*GPUDriver) error
	grpc.ServerStream
}

type gPUDriverApiShowGPUDriverServer struct {
	grpc.ServerStream
}

func (x *gPUDriverApiShowGPUDriverServer) Send(m *GPUDriver) error {
	return x.ServerStream.SendMsg(m)
}

func _GPUDriverApi_AddGPUDriverBuild_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GPUDriverBuildMember)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GPUDriverApiServer).AddGPUDriverBuild(m, &gPUDriverApiAddGPUDriverBuildServer{stream})
}

type GPUDriverApi_AddGPUDriverBuildServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type gPUDriverApiAddGPUDriverBuildServer struct {
	grpc.ServerStream
}

func (x *gPUDriverApiAddGPUDriverBuildServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _GPUDriverApi_RemoveGPUDriverBuild_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GPUDriverBuildMember)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GPUDriverApiServer).RemoveGPUDriverBuild(m, &gPUDriverApiRemoveGPUDriverBuildServer{stream})
}

type GPUDriverApi_RemoveGPUDriverBuildServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type gPUDriverApiRemoveGPUDriverBuildServer struct {
	grpc.ServerStream
}

func (x *gPUDriverApiRemoveGPUDriverBuildServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _GPUDriverApi_GetGPUDriverBuildURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GPUDriverBuildMember)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GPUDriverApiServer).GetGPUDriverBuildURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.GPUDriverApi/GetGPUDriverBuildURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GPUDriverApiServer).GetGPUDriverBuildURL(ctx, req.(*GPUDriverBuildMember))
	}
	return interceptor(ctx, in, info, handler)
}

var _GPUDriverApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.GPUDriverApi",
	HandlerType: (*GPUDriverApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetGPUDriverBuildURL",
			Handler:    _GPUDriverApi_GetGPUDriverBuildURL_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreateGPUDriver",
			Handler:       _GPUDriverApi_CreateGPUDriver_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DeleteGPUDriver",
			Handler:       _GPUDriverApi_DeleteGPUDriver_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdateGPUDriver",
			Handler:       _GPUDriverApi_UpdateGPUDriver_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowGPUDriver",
			Handler:       _GPUDriverApi_ShowGPUDriver_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AddGPUDriverBuild",
			Handler:       _GPUDriverApi_AddGPUDriverBuild_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RemoveGPUDriverBuild",
			Handler:       _GPUDriverApi_RemoveGPUDriverBuild_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "gpu.proto",
}

func (m *GPUDriverKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUDriverKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPUDriverKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintGpu(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGpu(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GPUDriverBuild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUDriverBuild) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPUDriverBuild) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Md5Sum) > 0 {
		i -= len(m.Md5Sum)
		copy(dAtA[i:], m.Md5Sum)
		i = encodeVarintGpu(dAtA, i, uint64(len(m.Md5Sum)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.HypervisorInfo) > 0 {
		i -= len(m.HypervisorInfo)
		copy(dAtA[i:], m.HypervisorInfo)
		i = encodeVarintGpu(dAtA, i, uint64(len(m.HypervisorInfo)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.KernelVersion) > 0 {
		i -= len(m.KernelVersion)
		copy(dAtA[i:], m.KernelVersion)
		i = encodeVarintGpu(dAtA, i, uint64(len(m.KernelVersion)))
		i--
		dAtA[i] = 0x2a
	}
	if m.OperatingSystem != 0 {
		i = encodeVarintGpu(dAtA, i, uint64(m.OperatingSystem))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DriverPathCreds) > 0 {
		i -= len(m.DriverPathCreds)
		copy(dAtA[i:], m.DriverPathCreds)
		i = encodeVarintGpu(dAtA, i, uint64(len(m.DriverPathCreds)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DriverPath) > 0 {
		i -= len(m.DriverPath)
		copy(dAtA[i:], m.DriverPath)
		i = encodeVarintGpu(dAtA, i, uint64(len(m.DriverPath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGpu(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GPUDriverBuildMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUDriverBuildMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPUDriverBuildMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IgnoreState {
		i--
		if m.IgnoreState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Build.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGpu(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGpu(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GPUDriverBuildURL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUDriverBuildURL) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPUDriverBuildURL) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Validity != 0 {
		i = encodeVarintGpu(dAtA, i, uint64(m.Validity))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BuildUrlPath) > 0 {
		i -= len(m.BuildUrlPath)
		copy(dAtA[i:], m.BuildUrlPath)
		i = encodeVarintGpu(dAtA, i, uint64(len(m.BuildUrlPath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GPUDriver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUDriver) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPUDriver) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LicenseConfigMd5Sum) > 0 {
		i -= len(m.LicenseConfigMd5Sum)
		copy(dAtA[i:], m.LicenseConfigMd5Sum)
		i = encodeVarintGpu(dAtA, i, uint64(len(m.LicenseConfigMd5Sum)))
		i--
		dAtA[i] = 0x4a
	}
	if m.IgnoreState {
		i--
		if m.IgnoreState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintGpu(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Properties) > 0 {
		for k := range m.Properties {
			v := m.Properties[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGpu(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGpu(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGpu(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.LicenseConfig) > 0 {
		i -= len(m.LicenseConfig)
		copy(dAtA[i:], m.LicenseConfig)
		i = encodeVarintGpu(dAtA, i, uint64(len(m.LicenseConfig)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Builds) > 0 {
		for iNdEx := len(m.Builds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Builds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGpu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Type != 0 {
		i = encodeVarintGpu(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGpu(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintGpu(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GPUConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPUConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Properties) > 0 {
		for k := range m.Properties {
			v := m.Properties[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGpu(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGpu(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGpu(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.GpuType != 0 {
		i = encodeVarintGpu(dAtA, i, uint64(m.GpuType))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Driver.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGpu(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintGpu(dAtA []byte, offset int, v uint64) int {
	offset -= sovGpu(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GPUDriverKey) Matches(o *GPUDriverKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.Name != "" {
		if o.Name != m.Name {
			return false
		}
	}
	if !opts.Filter || o.Organization != "" {
		if o.Organization != m.Organization {
			return false
		}
	}
	return true
}

func (m *GPUDriverKey) CopyInFields(src *GPUDriverKey) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.Organization != src.Organization {
		m.Organization = src.Organization
		changed++
	}
	return changed
}

func (m *GPUDriverKey) DeepCopyIn(src *GPUDriverKey) {
	m.Name = src.Name
	m.Organization = src.Organization
}

func (m *GPUDriverKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal GPUDriverKey key string", "obj", m)
	}
	return string(key)
}

func GPUDriverKeyStringParse(str string, key *GPUDriverKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal GPUDriverKey key string", "str", str)
	}
}

func (m *GPUDriverKey) NotFoundError() error {
	return fmt.Errorf("GPUDriver key %s not found", m.GetKeyString())
}

func (m *GPUDriverKey) ExistsError() error {
	return fmt.Errorf("GPUDriver key %s already exists", m.GetKeyString())
}

var GPUDriverKeyTagName = "gpudriver"
var GPUDriverKeyTagOrganization = "gpudriverorg"

func (m *GPUDriverKey) GetTags() map[string]string {
	tags := make(map[string]string)
	tags["gpudriver"] = m.Name
	tags["gpudriverorg"] = m.Organization
	return tags
}

// Helper method to check that enums have valid values
func (m *GPUDriverKey) ValidateEnums() error {
	return nil
}

func (m *GPUDriverBuild) CopyInFields(src *GPUDriverBuild) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.DriverPath != src.DriverPath {
		m.DriverPath = src.DriverPath
		changed++
	}
	if m.DriverPathCreds != src.DriverPathCreds {
		m.DriverPathCreds = src.DriverPathCreds
		changed++
	}
	if m.OperatingSystem != src.OperatingSystem {
		m.OperatingSystem = src.OperatingSystem
		changed++
	}
	if m.KernelVersion != src.KernelVersion {
		m.KernelVersion = src.KernelVersion
		changed++
	}
	if m.HypervisorInfo != src.HypervisorInfo {
		m.HypervisorInfo = src.HypervisorInfo
		changed++
	}
	if m.Md5Sum != src.Md5Sum {
		m.Md5Sum = src.Md5Sum
		changed++
	}
	return changed
}

func (m *GPUDriverBuild) DeepCopyIn(src *GPUDriverBuild) {
	m.Name = src.Name
	m.DriverPath = src.DriverPath
	m.DriverPathCreds = src.DriverPathCreds
	m.OperatingSystem = src.OperatingSystem
	m.KernelVersion = src.KernelVersion
	m.HypervisorInfo = src.HypervisorInfo
	m.Md5Sum = src.Md5Sum
}

// Helper method to check that enums have valid values
func (m *GPUDriverBuild) ValidateEnums() error {
	if _, ok := OSType_name[int32(m.OperatingSystem)]; !ok {
		return errors.New("invalid OperatingSystem")
	}
	return nil
}

func (m *GPUDriverBuildMember) CopyInFields(src *GPUDriverBuildMember) int {
	changed := 0
	if m.Key.Name != src.Key.Name {
		m.Key.Name = src.Key.Name
		changed++
	}
	if m.Key.Organization != src.Key.Organization {
		m.Key.Organization = src.Key.Organization
		changed++
	}
	if m.Build.Name != src.Build.Name {
		m.Build.Name = src.Build.Name
		changed++
	}
	if m.Build.DriverPath != src.Build.DriverPath {
		m.Build.DriverPath = src.Build.DriverPath
		changed++
	}
	if m.Build.DriverPathCreds != src.Build.DriverPathCreds {
		m.Build.DriverPathCreds = src.Build.DriverPathCreds
		changed++
	}
	if m.Build.OperatingSystem != src.Build.OperatingSystem {
		m.Build.OperatingSystem = src.Build.OperatingSystem
		changed++
	}
	if m.Build.KernelVersion != src.Build.KernelVersion {
		m.Build.KernelVersion = src.Build.KernelVersion
		changed++
	}
	if m.Build.HypervisorInfo != src.Build.HypervisorInfo {
		m.Build.HypervisorInfo = src.Build.HypervisorInfo
		changed++
	}
	if m.Build.Md5Sum != src.Build.Md5Sum {
		m.Build.Md5Sum = src.Build.Md5Sum
		changed++
	}
	if m.IgnoreState != src.IgnoreState {
		m.IgnoreState = src.IgnoreState
		changed++
	}
	return changed
}

func (m *GPUDriverBuildMember) DeepCopyIn(src *GPUDriverBuildMember) {
	m.Key.DeepCopyIn(&src.Key)
	m.Build.DeepCopyIn(&src.Build)
	m.IgnoreState = src.IgnoreState
}

func (m *GPUDriverBuildMember) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *GPUDriverBuildMember) GetKey() *GPUDriverKey {
	return &m.Key
}

func (m *GPUDriverBuildMember) GetKeyVal() GPUDriverKey {
	return m.Key
}

func (m *GPUDriverBuildMember) SetKey(key *GPUDriverKey) {
	m.Key = *key
}

func CmpSortGPUDriverBuildMember(a GPUDriverBuildMember, b GPUDriverBuildMember) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *GPUDriverBuildMember) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if err := m.Build.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *GPUDriverBuildURL) CopyInFields(src *GPUDriverBuildURL) int {
	changed := 0
	if m.BuildUrlPath != src.BuildUrlPath {
		m.BuildUrlPath = src.BuildUrlPath
		changed++
	}
	if m.Validity != src.Validity {
		m.Validity = src.Validity
		changed++
	}
	return changed
}

func (m *GPUDriverBuildURL) DeepCopyIn(src *GPUDriverBuildURL) {
	m.BuildUrlPath = src.BuildUrlPath
	m.Validity = src.Validity
}

// Helper method to check that enums have valid values
func (m *GPUDriverBuildURL) ValidateEnums() error {
	return nil
}

func (m *GPUDriver) Matches(o *GPUDriver, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.Type != 0 {
		if o.Type != m.Type {
			return false
		}
	}
	if !opts.Filter || o.Builds != nil {
		if len(m.Builds) == 0 && len(o.Builds) > 0 || len(m.Builds) > 0 && len(o.Builds) == 0 {
			return false
		} else if m.Builds != nil && o.Builds != nil {
			if !opts.Filter && len(m.Builds) != len(o.Builds) {
				return false
			}
		}
	}
	if !opts.Filter || o.LicenseConfig != "" {
		if o.LicenseConfig != m.LicenseConfig {
			return false
		}
	}
	if !opts.Filter || o.Properties != nil {
		if len(m.Properties) == 0 && len(o.Properties) > 0 || len(m.Properties) > 0 && len(o.Properties) == 0 {
			return false
		} else if m.Properties != nil && o.Properties != nil {
			if !opts.Filter && len(m.Properties) != len(o.Properties) {
				return false
			}
			for k, _ := range o.Properties {
				_, ok := m.Properties[k]
				if !ok {
					return false
				}
				if o.Properties[k] != m.Properties[k] {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.State != "" {
		if o.State != m.State {
			return false
		}
	}
	if !opts.Filter || o.IgnoreState != false {
		if o.IgnoreState != m.IgnoreState {
			return false
		}
	}
	if !opts.Filter || o.LicenseConfigMd5Sum != "" {
		if o.LicenseConfigMd5Sum != m.LicenseConfigMd5Sum {
			return false
		}
	}
	return true
}

const GPUDriverFieldKey = "2"
const GPUDriverFieldKeyName = "2.1"
const GPUDriverFieldKeyOrganization = "2.2"
const GPUDriverFieldType = "3"
const GPUDriverFieldBuilds = "4"
const GPUDriverFieldBuildsName = "4.1"
const GPUDriverFieldBuildsDriverPath = "4.2"
const GPUDriverFieldBuildsDriverPathCreds = "4.3"
const GPUDriverFieldBuildsOperatingSystem = "4.4"
const GPUDriverFieldBuildsKernelVersion = "4.5"
const GPUDriverFieldBuildsHypervisorInfo = "4.6"
const GPUDriverFieldBuildsMd5Sum = "4.7"
const GPUDriverFieldLicenseConfig = "5"
const GPUDriverFieldProperties = "6"
const GPUDriverFieldPropertiesKey = "6.1"
const GPUDriverFieldPropertiesValue = "6.2"
const GPUDriverFieldState = "7"
const GPUDriverFieldIgnoreState = "8"
const GPUDriverFieldLicenseConfigMd5Sum = "9"

var GPUDriverAllFields = []string{
	GPUDriverFieldKeyName,
	GPUDriverFieldKeyOrganization,
	GPUDriverFieldType,
	GPUDriverFieldBuildsName,
	GPUDriverFieldBuildsDriverPath,
	GPUDriverFieldBuildsDriverPathCreds,
	GPUDriverFieldBuildsOperatingSystem,
	GPUDriverFieldBuildsKernelVersion,
	GPUDriverFieldBuildsHypervisorInfo,
	GPUDriverFieldBuildsMd5Sum,
	GPUDriverFieldLicenseConfig,
	GPUDriverFieldPropertiesKey,
	GPUDriverFieldPropertiesValue,
	GPUDriverFieldState,
	GPUDriverFieldIgnoreState,
	GPUDriverFieldLicenseConfigMd5Sum,
}

var GPUDriverAllFieldsMap = map[string]struct{}{
	GPUDriverFieldKeyName:               struct{}{},
	GPUDriverFieldKeyOrganization:       struct{}{},
	GPUDriverFieldType:                  struct{}{},
	GPUDriverFieldBuildsName:            struct{}{},
	GPUDriverFieldBuildsDriverPath:      struct{}{},
	GPUDriverFieldBuildsDriverPathCreds: struct{}{},
	GPUDriverFieldBuildsOperatingSystem: struct{}{},
	GPUDriverFieldBuildsKernelVersion:   struct{}{},
	GPUDriverFieldBuildsHypervisorInfo:  struct{}{},
	GPUDriverFieldBuildsMd5Sum:          struct{}{},
	GPUDriverFieldLicenseConfig:         struct{}{},
	GPUDriverFieldPropertiesKey:         struct{}{},
	GPUDriverFieldPropertiesValue:       struct{}{},
	GPUDriverFieldState:                 struct{}{},
	GPUDriverFieldIgnoreState:           struct{}{},
	GPUDriverFieldLicenseConfigMd5Sum:   struct{}{},
}

var GPUDriverAllFieldsStringMap = map[string]string{
	GPUDriverFieldKeyName:               "Key Name",
	GPUDriverFieldKeyOrganization:       "Key Organization",
	GPUDriverFieldType:                  "Type",
	GPUDriverFieldBuildsName:            "Builds Name",
	GPUDriverFieldBuildsDriverPath:      "Builds Driver Path",
	GPUDriverFieldBuildsDriverPathCreds: "Builds Driver Path Creds",
	GPUDriverFieldBuildsOperatingSystem: "Builds Operating System",
	GPUDriverFieldBuildsKernelVersion:   "Builds Kernel Version",
	GPUDriverFieldBuildsHypervisorInfo:  "Builds Hypervisor Info",
	GPUDriverFieldBuildsMd5Sum:          "Builds Md5 Sum",
	GPUDriverFieldLicenseConfig:         "License Config",
	GPUDriverFieldPropertiesKey:         "Properties Key",
	GPUDriverFieldPropertiesValue:       "Properties Value",
	GPUDriverFieldState:                 "State",
	GPUDriverFieldIgnoreState:           "Ignore State",
	GPUDriverFieldLicenseConfigMd5Sum:   "License Config Md5 Sum",
}

func (m *GPUDriver) IsKeyField(s string) bool {
	return strings.HasPrefix(s, GPUDriverFieldKey+".") || s == GPUDriverFieldKey
}

func (m *GPUDriver) DiffFields(o *GPUDriver, fields map[string]struct{}) {
	if m.Key.Name != o.Key.Name {
		fields[GPUDriverFieldKeyName] = struct{}{}
		fields[GPUDriverFieldKey] = struct{}{}
	}
	if m.Key.Organization != o.Key.Organization {
		fields[GPUDriverFieldKeyOrganization] = struct{}{}
		fields[GPUDriverFieldKey] = struct{}{}
	}
	if m.Type != o.Type {
		fields[GPUDriverFieldType] = struct{}{}
	}
	if len(m.Builds) != len(o.Builds) {
		fields[GPUDriverFieldBuilds] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.Builds); i0++ {
			if m.Builds[i0].Name != o.Builds[i0].Name {
				fields[GPUDriverFieldBuildsName] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
			if m.Builds[i0].DriverPath != o.Builds[i0].DriverPath {
				fields[GPUDriverFieldBuildsDriverPath] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
			if m.Builds[i0].DriverPathCreds != o.Builds[i0].DriverPathCreds {
				fields[GPUDriverFieldBuildsDriverPathCreds] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
			if m.Builds[i0].OperatingSystem != o.Builds[i0].OperatingSystem {
				fields[GPUDriverFieldBuildsOperatingSystem] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
			if m.Builds[i0].KernelVersion != o.Builds[i0].KernelVersion {
				fields[GPUDriverFieldBuildsKernelVersion] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
			if m.Builds[i0].HypervisorInfo != o.Builds[i0].HypervisorInfo {
				fields[GPUDriverFieldBuildsHypervisorInfo] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
			if m.Builds[i0].Md5Sum != o.Builds[i0].Md5Sum {
				fields[GPUDriverFieldBuildsMd5Sum] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
		}
	}
	if m.LicenseConfig != o.LicenseConfig {
		fields[GPUDriverFieldLicenseConfig] = struct{}{}
	}
	if m.Properties != nil && o.Properties != nil {
		if len(m.Properties) != len(o.Properties) {
			fields[GPUDriverFieldProperties] = struct{}{}
		} else {
			for k0, _ := range m.Properties {
				_, vok0 := o.Properties[k0]
				if !vok0 {
					fields[GPUDriverFieldProperties] = struct{}{}
				} else {
					if m.Properties[k0] != o.Properties[k0] {
						fields[GPUDriverFieldProperties] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.Properties != nil && o.Properties == nil) || (m.Properties == nil && o.Properties != nil) {
		fields[GPUDriverFieldProperties] = struct{}{}
	}
	if m.State != o.State {
		fields[GPUDriverFieldState] = struct{}{}
	}
	if m.IgnoreState != o.IgnoreState {
		fields[GPUDriverFieldIgnoreState] = struct{}{}
	}
	if m.LicenseConfigMd5Sum != o.LicenseConfigMd5Sum {
		fields[GPUDriverFieldLicenseConfigMd5Sum] = struct{}{}
	}
}

var UpdateGPUDriverFieldsMap = map[string]struct{}{
	GPUDriverFieldType:                struct{}{},
	GPUDriverFieldLicenseConfig:       struct{}{},
	GPUDriverFieldProperties:          struct{}{},
	GPUDriverFieldPropertiesValue:     struct{}{},
	GPUDriverFieldIgnoreState:         struct{}{},
	GPUDriverFieldLicenseConfigMd5Sum: struct{}{},
}

func (m *GPUDriver) ValidateUpdateFields() error {
	if m.Fields == nil {
		return fmt.Errorf("nothing specified to update")
	}
	fmap := MakeFieldMap(m.Fields)
	badFieldStrs := []string{}
	for field, _ := range fmap {
		if m.IsKeyField(field) {
			continue
		}
		if _, ok := UpdateGPUDriverFieldsMap[field]; !ok {
			if _, ok := GPUDriverAllFieldsStringMap[field]; !ok {
				continue
			}
			badFieldStrs = append(badFieldStrs, GPUDriverAllFieldsStringMap[field])
		}
	}
	if len(badFieldStrs) > 0 {
		return fmt.Errorf("specified field(s) %s cannot be modified", strings.Join(badFieldStrs, ","))
	}
	return nil
}

func (m *GPUDriver) CopyInFields(src *GPUDriver) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
		if _, set := fmap["2.2"]; set {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
	}
	if _, set := fmap["3"]; set {
		if m.Type != src.Type {
			m.Type = src.Type
			changed++
		}
	}
	if _, set := fmap["4"]; set {
		if src.Builds != nil {
			m.Builds = src.Builds
			changed++
		} else if m.Builds != nil {
			m.Builds = nil
			changed++
		}
	}
	if _, set := fmap["5"]; set {
		if m.LicenseConfig != src.LicenseConfig {
			m.LicenseConfig = src.LicenseConfig
			changed++
		}
	}
	if _, set := fmap["6"]; set {
		if src.Properties != nil {
			m.Properties = make(map[string]string)
			for k0, _ := range src.Properties {
				m.Properties[k0] = src.Properties[k0]
			}
		} else if m.Properties != nil {
			m.Properties = nil
			changed++
		}
	}
	if _, set := fmap["7"]; set {
		if m.State != src.State {
			m.State = src.State
			changed++
		}
	}
	if _, set := fmap["8"]; set {
		if m.IgnoreState != src.IgnoreState {
			m.IgnoreState = src.IgnoreState
			changed++
		}
	}
	if _, set := fmap["9"]; set {
		if m.LicenseConfigMd5Sum != src.LicenseConfigMd5Sum {
			m.LicenseConfigMd5Sum = src.LicenseConfigMd5Sum
			changed++
		}
	}
	return changed
}

func (m *GPUDriver) DeepCopyIn(src *GPUDriver) {
	m.Key.DeepCopyIn(&src.Key)
	m.Type = src.Type
	if src.Builds != nil {
		m.Builds = make([]GPUDriverBuild, len(src.Builds), len(src.Builds))
		for ii, s := range src.Builds {
			m.Builds[ii].DeepCopyIn(&s)
		}
	} else {
		m.Builds = nil
	}
	m.LicenseConfig = src.LicenseConfig
	if src.Properties != nil {
		m.Properties = make(map[string]string)
		for k, v := range src.Properties {
			m.Properties[k] = v
		}
	} else {
		m.Properties = nil
	}
	m.State = src.State
	m.IgnoreState = src.IgnoreState
	m.LicenseConfigMd5Sum = src.LicenseConfigMd5Sum
}

func (s *GPUDriver) HasFields() bool {
	return true
}

type GPUDriverStore struct {
	kvstore objstore.KVStore
}

func NewGPUDriverStore(kvstore objstore.KVStore) GPUDriverStore {
	return GPUDriverStore{kvstore: kvstore}
}

func (s *GPUDriverStore) Create(ctx context.Context, m *GPUDriver, wait func(int64)) (*Result, error) {
	err := m.Validate(GPUDriverAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("GPUDriver", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *GPUDriverStore) Update(ctx context.Context, m *GPUDriver, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("GPUDriver", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur GPUDriver
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *GPUDriverStore) Put(ctx context.Context, m *GPUDriver, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(GPUDriverAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("GPUDriver", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *GPUDriverStore) Delete(ctx context.Context, m *GPUDriver, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("GPUDriver", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *GPUDriverStore) LoadOne(key string) (*GPUDriver, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj GPUDriver
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse GPUDriver data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *GPUDriverStore) STMGet(stm concurrency.STM, key *GPUDriverKey, buf *GPUDriver) bool {
	keystr := objstore.DbKeyString("GPUDriver", key)
	valstr := stm.Get(keystr)
	if valstr == "" {
		return false
	}
	if buf != nil {
		err := json.Unmarshal([]byte(valstr), buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *GPUDriverStore) STMPut(stm concurrency.STM, obj *GPUDriver, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("GPUDriver", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("GPUDriver json marsahal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *GPUDriverStore) STMDel(stm concurrency.STM, key *GPUDriverKey) {
	keystr := objstore.DbKeyString("GPUDriver", key)
	stm.Del(keystr)
}

type GPUDriverKeyWatcher struct {
	cb func(ctx context.Context)
}

type GPUDriverCacheData struct {
	Obj    *GPUDriver
	ModRev int64
}

// GPUDriverCache caches GPUDriver objects in memory in a hash table
// and keeps them in sync with the database.
type GPUDriverCache struct {
	Objs          map[GPUDriverKey]*GPUDriverCacheData
	Mux           util.Mutex
	List          map[GPUDriverKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *GPUDriverKey, old *GPUDriver, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *GPUDriver, new *GPUDriver)
	DeletedCbs    []func(ctx context.Context, old *GPUDriver)
	KeyWatchers   map[GPUDriverKey][]*GPUDriverKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *GPUDriverKey)
	DeletedKeyCbs []func(ctx context.Context, key *GPUDriverKey)
}

func NewGPUDriverCache() *GPUDriverCache {
	cache := GPUDriverCache{}
	InitGPUDriverCache(&cache)
	return &cache
}

func InitGPUDriverCache(cache *GPUDriverCache) {
	cache.Objs = make(map[GPUDriverKey]*GPUDriverCacheData)
	cache.KeyWatchers = make(map[GPUDriverKey][]*GPUDriverKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *GPUDriverCache) GetTypeString() string {
	return "GPUDriver"
}

func (c *GPUDriverCache) Get(key *GPUDriverKey, valbuf *GPUDriver) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *GPUDriverCache) GetWithRev(key *GPUDriverKey, valbuf *GPUDriver, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *GPUDriverCache) HasKey(key *GPUDriverKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *GPUDriverCache) GetAllKeys(ctx context.Context, cb func(key *GPUDriverKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *GPUDriverCache) Update(ctx context.Context, in *GPUDriver, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *GPUDriver) (*GPUDriver, bool) {
		return in, true
	})
}

func (c *GPUDriverCache) UpdateModFunc(ctx context.Context, key *GPUDriverKey, modRev int64, modFunc func(old *GPUDriver) (new *GPUDriver, changed bool)) {
	c.Mux.Lock()
	var old *GPUDriver
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	for _, cb := range c.UpdatedCbs {
		newCopy := &GPUDriver{}
		newCopy.DeepCopyIn(new)
		defer cb(ctx, old, newCopy)
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			defer cb(ctx, new.GetKey(), old, modRev)
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &GPUDriver{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &GPUDriverCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *GPUDriverCache) Delete(ctx context.Context, in *GPUDriver, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *GPUDriver) bool {
		return true
	})
}

func (c *GPUDriverCache) DeleteCondFunc(ctx context.Context, in *GPUDriver, modRev int64, condFunc func(old *GPUDriver) bool) {
	c.Mux.Lock()
	var old *GPUDriver
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	c.Mux.Unlock()
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, in.GetKey(), old, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *GPUDriverCache) Prune(ctx context.Context, validKeys map[GPUDriverKey]struct{}) {
	notify := make(map[GPUDriverKey]*GPUDriverCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, old.Obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *GPUDriverCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *GPUDriverCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *GPUDriverCache) Show(filter *GPUDriver, cb func(ret *GPUDriver) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func GPUDriverGenericNotifyCb(fn func(key *GPUDriverKey, old *GPUDriver)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*GPUDriverKey), obj.(*GPUDriver))
	}
}

func (c *GPUDriverCache) SetNotifyCb(fn func(ctx context.Context, obj *GPUDriverKey, old *GPUDriver, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *GPUDriverKey, old *GPUDriver, modRev int64){fn}
}

func (c *GPUDriverCache) SetUpdatedCb(fn func(ctx context.Context, old *GPUDriver, new *GPUDriver)) {
	c.UpdatedCbs = []func(ctx context.Context, old *GPUDriver, new *GPUDriver){fn}
}

func (c *GPUDriverCache) SetDeletedCb(fn func(ctx context.Context, old *GPUDriver)) {
	c.DeletedCbs = []func(ctx context.Context, old *GPUDriver){fn}
}

func (c *GPUDriverCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *GPUDriverKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *GPUDriverKey){fn}
}

func (c *GPUDriverCache) SetDeletedKeyCb(fn func(ctx context.Context, key *GPUDriverKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *GPUDriverKey){fn}
}

func (c *GPUDriverCache) AddUpdatedCb(fn func(ctx context.Context, old *GPUDriver, new *GPUDriver)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *GPUDriverCache) AddDeletedCb(fn func(ctx context.Context, old *GPUDriver)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *GPUDriverCache) AddNotifyCb(fn func(ctx context.Context, obj *GPUDriverKey, old *GPUDriver, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *GPUDriverCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *GPUDriverKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *GPUDriverCache) AddDeletedKeyCb(fn func(ctx context.Context, key *GPUDriverKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *GPUDriverCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *GPUDriverCache) WatchKey(key *GPUDriverKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*GPUDriverKeyWatcher, 0)
	}
	watcher := GPUDriverKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching GPUDriver", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *GPUDriverCache) TriggerKeyWatchers(ctx context.Context, key *GPUDriverKey) {
	watchers := make([]*GPUDriverKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *GPUDriverCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := GPUDriver{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse GPUDriver data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *GPUDriverCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := GPUDriver{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	GPUDriverKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *GPUDriverCache) SyncListStart(ctx context.Context) {
	c.List = make(map[GPUDriverKey]struct{})
}

func (c *GPUDriverCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[GPUDriverKey]*GPUDriverCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, val.Obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *GPUDriverCache) UsesOrg(org string) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		if key.Organization == org {
			return true
		}
	}
	return false
}

func (m *GPUDriver) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *GPUDriver) GetKey() *GPUDriverKey {
	return &m.Key
}

func (m *GPUDriver) GetKeyVal() GPUDriverKey {
	return m.Key
}

func (m *GPUDriver) SetKey(key *GPUDriverKey) {
	m.Key = *key
}

func CmpSortGPUDriver(a GPUDriver, b GPUDriver) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *GPUDriver) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := GPUType_name[int32(m.Type)]; !ok {
		return errors.New("invalid Type")
	}
	for _, e := range m.Builds {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *GPUConfig) CopyInFields(src *GPUConfig) int {
	changed := 0
	if m.Driver.Name != src.Driver.Name {
		m.Driver.Name = src.Driver.Name
		changed++
	}
	if m.Driver.Organization != src.Driver.Organization {
		m.Driver.Organization = src.Driver.Organization
		changed++
	}
	if m.GpuType != src.GpuType {
		m.GpuType = src.GpuType
		changed++
	}
	if src.Properties != nil {
		m.Properties = make(map[string]string)
		for k0, _ := range src.Properties {
			m.Properties[k0] = src.Properties[k0]
		}
	} else if m.Properties != nil {
		m.Properties = nil
		changed++
	}
	return changed
}

func (m *GPUConfig) DeepCopyIn(src *GPUConfig) {
	m.Driver.DeepCopyIn(&src.Driver)
	m.GpuType = src.GpuType
	if src.Properties != nil {
		m.Properties = make(map[string]string)
		for k, v := range src.Properties {
			m.Properties[k] = v
		}
	} else {
		m.Properties = nil
	}
}

// Helper method to check that enums have valid values
func (m *GPUConfig) ValidateEnums() error {
	if err := m.Driver.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := GPUType_name[int32(m.GpuType)]; !ok {
		return errors.New("invalid GpuType")
	}
	return nil
}

var GPUTypeStrings = []string{
	"GPU_TYPE_NONE",
	"GPU_TYPE_PASSTHROUGH",
	"GPU_TYPE_VGPU",
}

const (
	GPUTypeGPU_TYPE_NONE        uint64 = 1 << 0
	GPUTypeGPU_TYPE_PASSTHROUGH uint64 = 1 << 1
	GPUTypeGPU_TYPE_VGPU        uint64 = 1 << 2
)

var GPUType_CamelName = map[int32]string{
	// GPU_TYPE_NONE -> GpuTypeNone
	0: "GpuTypeNone",
	// GPU_TYPE_PASSTHROUGH -> GpuTypePassthrough
	1: "GpuTypePassthrough",
	// GPU_TYPE_VGPU -> GpuTypeVgpu
	2: "GpuTypeVgpu",
}
var GPUType_CamelValue = map[string]int32{
	"GpuTypeNone":        0,
	"GpuTypePassthrough": 1,
	"GpuTypeVgpu":        2,
}

func (e *GPUType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := GPUType_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = GPUType_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = GPUType(val)
	return nil
}

func (e GPUType) MarshalYAML() (interface{}, error) {
	return proto.EnumName(GPUType_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *GPUType) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := GPUType_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = GPUType_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = GPUType(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = GPUType(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

var OSTypeStrings = []string{
	"LINUX",
	"WINDOWS",
	"OTHERS",
}

const (
	OSTypeLINUX   uint64 = 1 << 0
	OSTypeWINDOWS uint64 = 1 << 1
	OSTypeOTHERS  uint64 = 1 << 2
)

var OSType_CamelName = map[int32]string{
	// LINUX -> Linux
	0: "Linux",
	// WINDOWS -> Windows
	1: "Windows",
	// OTHERS -> Others
	20: "Others",
}
var OSType_CamelValue = map[string]int32{
	"Linux":   0,
	"Windows": 1,
	"Others":  20,
}

func (e *OSType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := OSType_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = OSType_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = OSType(val)
	return nil
}

func (e OSType) MarshalYAML() (interface{}, error) {
	return proto.EnumName(OSType_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *OSType) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := OSType_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = OSType_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = OSType(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = OSType(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}
func (m *GPUDriver) IsValidArgsForCreateGPUDriver() error {
	if m.State != "" {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	return nil
}

func (m *GPUDriver) IsValidArgsForDeleteGPUDriver() error {
	if m.State != "" {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	return nil
}

func (m *GPUDriver) IsValidArgsForUpdateGPUDriver() error {
	if m.Builds != nil {
		return fmt.Errorf("Invalid field specified: Builds, this field is only for internal use")
	}
	if m.State != "" {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	return nil
}

func (m *GPUDriverBuildMember) IsValidArgsForAddGPUDriverBuild() error {
	return nil
}

func (m *GPUDriverBuildMember) IsValidArgsForRemoveGPUDriverBuild() error {
	if m.Build.DriverPath != "" {
		return fmt.Errorf("Invalid field specified: Build.DriverPath, this field is only for internal use")
	}
	if m.Build.OperatingSystem != 0 {
		return fmt.Errorf("Invalid field specified: Build.OperatingSystem, this field is only for internal use")
	}
	if m.Build.KernelVersion != "" {
		return fmt.Errorf("Invalid field specified: Build.KernelVersion, this field is only for internal use")
	}
	if m.Build.HypervisorInfo != "" {
		return fmt.Errorf("Invalid field specified: Build.HypervisorInfo, this field is only for internal use")
	}
	return nil
}

func (m *GPUDriverBuildMember) IsValidArgsForGetGPUDriverBuildURL() error {
	if m.Build.DriverPath != "" {
		return fmt.Errorf("Invalid field specified: Build.DriverPath, this field is only for internal use")
	}
	if m.Build.OperatingSystem != 0 {
		return fmt.Errorf("Invalid field specified: Build.OperatingSystem, this field is only for internal use")
	}
	if m.Build.KernelVersion != "" {
		return fmt.Errorf("Invalid field specified: Build.KernelVersion, this field is only for internal use")
	}
	if m.Build.HypervisorInfo != "" {
		return fmt.Errorf("Invalid field specified: Build.HypervisorInfo, this field is only for internal use")
	}
	return nil
}

func (m *GPUDriverKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGpu(uint64(l))
	}
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovGpu(uint64(l))
	}
	return n
}

func (m *GPUDriverBuild) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGpu(uint64(l))
	}
	l = len(m.DriverPath)
	if l > 0 {
		n += 1 + l + sovGpu(uint64(l))
	}
	l = len(m.DriverPathCreds)
	if l > 0 {
		n += 1 + l + sovGpu(uint64(l))
	}
	if m.OperatingSystem != 0 {
		n += 1 + sovGpu(uint64(m.OperatingSystem))
	}
	l = len(m.KernelVersion)
	if l > 0 {
		n += 1 + l + sovGpu(uint64(l))
	}
	l = len(m.HypervisorInfo)
	if l > 0 {
		n += 1 + l + sovGpu(uint64(l))
	}
	l = len(m.Md5Sum)
	if l > 0 {
		n += 1 + l + sovGpu(uint64(l))
	}
	return n
}

func (m *GPUDriverBuildMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovGpu(uint64(l))
	l = m.Build.Size()
	n += 1 + l + sovGpu(uint64(l))
	if m.IgnoreState {
		n += 2
	}
	return n
}

func (m *GPUDriverBuildURL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BuildUrlPath)
	if l > 0 {
		n += 1 + l + sovGpu(uint64(l))
	}
	if m.Validity != 0 {
		n += 1 + sovGpu(uint64(m.Validity))
	}
	return n
}

func (m *GPUDriver) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovGpu(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovGpu(uint64(l))
	if m.Type != 0 {
		n += 1 + sovGpu(uint64(m.Type))
	}
	if len(m.Builds) > 0 {
		for _, e := range m.Builds {
			l = e.Size()
			n += 1 + l + sovGpu(uint64(l))
		}
	}
	l = len(m.LicenseConfig)
	if l > 0 {
		n += 1 + l + sovGpu(uint64(l))
	}
	if len(m.Properties) > 0 {
		for k, v := range m.Properties {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGpu(uint64(len(k))) + 1 + len(v) + sovGpu(uint64(len(v)))
			n += mapEntrySize + 1 + sovGpu(uint64(mapEntrySize))
		}
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovGpu(uint64(l))
	}
	if m.IgnoreState {
		n += 2
	}
	l = len(m.LicenseConfigMd5Sum)
	if l > 0 {
		n += 1 + l + sovGpu(uint64(l))
	}
	return n
}

func (m *GPUConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Driver.Size()
	n += 1 + l + sovGpu(uint64(l))
	if m.GpuType != 0 {
		n += 1 + sovGpu(uint64(m.GpuType))
	}
	if len(m.Properties) > 0 {
		for k, v := range m.Properties {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGpu(uint64(len(k))) + 1 + len(v) + sovGpu(uint64(len(v)))
			n += mapEntrySize + 1 + sovGpu(uint64(mapEntrySize))
		}
	}
	return n
}

func sovGpu(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGpu(x uint64) (n int) {
	return sovGpu(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GPUDriverKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGpu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUDriverKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUDriverKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGpu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGpu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGpu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUDriverBuild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGpu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUDriverBuild: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUDriverBuild: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriverPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DriverPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriverPathCreds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DriverPathCreds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystem", wireType)
			}
			m.OperatingSystem = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperatingSystem |= OSType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KernelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HypervisorInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HypervisorInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5Sum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5Sum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGpu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGpu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGpu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUDriverBuildMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGpu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUDriverBuildMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUDriverBuildMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGpu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGpu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGpu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGpu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Build.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreState = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGpu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGpu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGpu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUDriverBuildURL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGpu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUDriverBuildURL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUDriverBuildURL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildUrlPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildUrlPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validity", wireType)
			}
			m.Validity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Validity |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGpu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGpu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGpu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUDriver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGpu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUDriver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUDriver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGpu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGpu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= GPUType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Builds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGpu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGpu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Builds = append(m.Builds, GPUDriverBuild{})
			if err := m.Builds[len(m.Builds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LicenseConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LicenseConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGpu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGpu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGpu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGpu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGpu
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGpu
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGpu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGpu
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGpu
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGpu(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGpu
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Properties[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreState = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LicenseConfigMd5Sum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LicenseConfigMd5Sum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGpu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGpu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGpu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGpu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGpu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGpu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Driver.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuType", wireType)
			}
			m.GpuType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpuType |= GPUType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGpu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGpu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGpu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGpu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGpu
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGpu
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGpu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGpu
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGpu
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGpu(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGpu
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Properties[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGpu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGpu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGpu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGpu(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGpu
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGpu
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGpu
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGpu
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGpu
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGpu        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGpu          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGpu = fmt.Errorf("proto: unexpected end of group")
)
