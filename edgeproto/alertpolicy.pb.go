// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: alertpolicy.proto

package edgeproto

import (
	context "context"
	"encoding/json"
	fmt "fmt"
	"github.com/coreos/etcd/clientv3/concurrency"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/mobiledgex/edge-cloud/log"
	"github.com/mobiledgex/edge-cloud/objstore"
	_ "github.com/mobiledgex/edge-cloud/protogen"
	"github.com/mobiledgex/edge-cloud/util"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AlertPolicyKey struct {
	// Name of the organization for the app that this alert can be applied to
	Organization string `protobuf:"bytes,1,opt,name=organization,proto3" json:"organization,omitempty"`
	// Alert Policy name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *AlertPolicyKey) Reset()         { *m = AlertPolicyKey{} }
func (m *AlertPolicyKey) String() string { return proto.CompactTextString(m) }
func (*AlertPolicyKey) ProtoMessage()    {}
func (*AlertPolicyKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_acb416d0b807474a, []int{0}
}
func (m *AlertPolicyKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlertPolicyKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlertPolicyKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlertPolicyKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlertPolicyKey.Merge(m, src)
}
func (m *AlertPolicyKey) XXX_Size() int {
	return m.Size()
}
func (m *AlertPolicyKey) XXX_DiscardUnknown() {
	xxx_messageInfo_AlertPolicyKey.DiscardUnknown(m)
}

var xxx_messageInfo_AlertPolicyKey proto.InternalMessageInfo

type AlertPolicy struct {
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique identifier key
	Key AlertPolicyKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// Container or pod CPU utilization rate(percentage) across all nodes. Valid values 1-100
	CpuUtilizationLimit uint32 `protobuf:"varint,3,opt,name=cpu_utilization_limit,json=cpuUtilizationLimit,proto3" json:"cpu_utilization_limit,omitempty"`
	// Container or pod memory utilization rate(percentage) across all nodes. Valid values 1-100
	MemUtilizationLimit uint32 `protobuf:"varint,4,opt,name=mem_utilization_limit,json=memUtilizationLimit,proto3" json:"mem_utilization_limit,omitempty"`
	// Container or pod disk utilization rate(percentage) across all nodes. Valid values 1-100
	DiskUtilizationLimit uint32 `protobuf:"varint,5,opt,name=disk_utilization_limit,json=diskUtilizationLimit,proto3" json:"disk_utilization_limit,omitempty"`
	// Active Connections alert threshold. Valid values 1-4294967295
	ActiveConnLimit uint32 `protobuf:"varint,6,opt,name=active_conn_limit,json=activeConnLimit,proto3" json:"active_conn_limit,omitempty"`
	// Alert severity level - one of "info", "warning", "error"
	Severity string `protobuf:"bytes,7,opt,name=severity,proto3" json:"severity,omitempty"`
	// Duration for which alert interval is active (max 72 hours)
	TriggerTime Duration `protobuf:"varint,8,opt,name=trigger_time,json=triggerTime,proto3,casttype=Duration" json:"trigger_time,omitempty"`
	// Additional Labels
	Labels map[string]string `protobuf:"bytes,9,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Additional Annotations for extra information about the alert
	Annotations map[string]string `protobuf:"bytes,10,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Description of the alert policy
	Description string `protobuf:"bytes,11,opt,name=description,proto3" json:"description,omitempty"`
	// Preparing to be deleted
	DeletePrepare bool `protobuf:"varint,12,opt,name=delete_prepare,json=deletePrepare,proto3" json:"delete_prepare,omitempty"`
}

func (m *AlertPolicy) Reset()         { *m = AlertPolicy{} }
func (m *AlertPolicy) String() string { return proto.CompactTextString(m) }
func (*AlertPolicy) ProtoMessage()    {}
func (*AlertPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_acb416d0b807474a, []int{1}
}
func (m *AlertPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlertPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlertPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlertPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlertPolicy.Merge(m, src)
}
func (m *AlertPolicy) XXX_Size() int {
	return m.Size()
}
func (m *AlertPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_AlertPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_AlertPolicy proto.InternalMessageInfo

func init() {
	proto.RegisterType((*AlertPolicyKey)(nil), "edgeproto.AlertPolicyKey")
	proto.RegisterType((*AlertPolicy)(nil), "edgeproto.AlertPolicy")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.AlertPolicy.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.AlertPolicy.LabelsEntry")
}

func init() { proto.RegisterFile("alertpolicy.proto", fileDescriptor_acb416d0b807474a) }

var fileDescriptor_acb416d0b807474a = []byte{
	// 881 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x94, 0x4f, 0x6f, 0x1b, 0x45,
	0x18, 0xc6, 0x3d, 0x71, 0x9c, 0xda, 0xb3, 0x4e, 0x1b, 0x6f, 0x43, 0x34, 0xb5, 0x8a, 0x63, 0xf9,
	0x82, 0x55, 0xad, 0xbd, 0x25, 0x2d, 0x52, 0xb1, 0x64, 0x24, 0x3b, 0xe1, 0x80, 0xda, 0x42, 0xb5,
	0x69, 0xe1, 0x68, 0xad, 0xd7, 0x2f, 0x9b, 0x51, 0x76, 0x77, 0x56, 0xb3, 0xbb, 0x36, 0xe6, 0x84,
	0xf8, 0x04, 0x11, 0x1c, 0x28, 0x9c, 0x38, 0x22, 0x4e, 0xa8, 0x17, 0xa4, 0x7e, 0x82, 0x1c, 0x2b,
	0xb8, 0x70, 0x40, 0x15, 0x38, 0x1c, 0x50, 0x4f, 0x48, 0x71, 0x2c, 0xc4, 0x09, 0xed, 0xec, 0xe2,
	0xac, 0xff, 0x14, 0x41, 0x2f, 0xbd, 0x58, 0x33, 0xef, 0x3c, 0xcf, 0xcc, 0x6f, 0xc7, 0xcf, 0x3b,
	0xb8, 0xa0, 0x5b, 0xc0, 0x7d, 0x97, 0x59, 0xd4, 0x18, 0xd6, 0x5d, 0xce, 0x7c, 0x26, 0xe7, 0xa0,
	0x67, 0x82, 0x18, 0x16, 0xaf, 0x9a, 0x8c, 0x99, 0x16, 0xa8, 0xba, 0x4b, 0x55, 0xdd, 0x71, 0x98,
	0xaf, 0xfb, 0x94, 0x39, 0x5e, 0x24, 0x2c, 0xe6, 0x39, 0x78, 0x81, 0xe5, 0xc7, 0xb3, 0x5b, 0x26,
	0xf5, 0x0f, 0x82, 0x6e, 0xdd, 0x60, 0xb6, 0x6a, 0xb3, 0x2e, 0xb5, 0xc2, 0x6d, 0x3e, 0x52, 0xc3,
	0xdf, 0x9a, 0x61, 0xb1, 0xa0, 0xa7, 0x0a, 0x9d, 0x09, 0xce, 0x74, 0x10, 0x3b, 0x37, 0x4d, 0x66,
	0x32, 0x31, 0x54, 0xc3, 0x51, 0x54, 0xad, 0x30, 0x7c, 0xb1, 0x15, 0xb2, 0xdd, 0x13, 0x6c, 0xb7,
	0x61, 0x28, 0x5f, 0xc7, 0x79, 0xc6, 0x4d, 0xdd, 0xa1, 0x1f, 0x0b, 0x0c, 0x82, 0xca, 0xa8, 0x9a,
	0x6b, 0xe7, 0x1f, 0x4f, 0x48, 0x56, 0x7c, 0x05, 0xe3, 0xa6, 0x36, 0xa3, 0x90, 0x5f, 0xc5, 0xab,
	0x8e, 0x6e, 0x03, 0x59, 0x11, 0xca, 0xdc, 0xe3, 0x09, 0xc9, 0x08, 0xa5, 0x26, 0xca, 0x8d, 0xfc,
	0xef, 0xa7, 0x04, 0xfd, 0x79, 0x4a, 0xd0, 0x77, 0x5f, 0x6f, 0xa3, 0xca, 0xcf, 0x17, 0xb0, 0x94,
	0x38, 0x51, 0xde, 0xc2, 0x6b, 0x1f, 0x52, 0xb0, 0x7a, 0x1e, 0x41, 0xe5, 0x74, 0x35, 0xa7, 0xc5,
	0x33, 0xf9, 0x75, 0x9c, 0x3e, 0x84, 0xa1, 0xd8, 0x53, 0xda, 0xb9, 0x52, 0x9f, 0xde, 0x56, 0x7d,
	0x16, 0xb7, 0xbd, 0x7a, 0xfc, 0x74, 0x3b, 0xa5, 0x85, 0x5a, 0x79, 0x07, 0xbf, 0x62, 0xb8, 0x41,
	0x27, 0xf0, 0xa9, 0x15, 0xa3, 0x75, 0x2c, 0x6a, 0x53, 0x9f, 0xa4, 0xcb, 0xa8, 0xba, 0xae, 0x5d,
	0x36, 0xdc, 0xe0, 0xc1, 0xf9, 0xda, 0x9d, 0x70, 0x29, 0xf4, 0xd8, 0x60, 0x2f, 0xf1, 0xac, 0x46,
	0x1e, 0x1b, 0xec, 0x05, 0xcf, 0x4d, 0xbc, 0xd5, 0xa3, 0xde, 0xe1, 0x12, 0x53, 0x46, 0x98, 0x36,
	0xc3, 0xd5, 0x05, 0xd7, 0x35, 0x5c, 0xd0, 0x0d, 0x9f, 0xf6, 0xa1, 0x63, 0x30, 0xe7, 0x1f, 0xc3,
	0x9a, 0x30, 0x5c, 0x8a, 0x16, 0x76, 0x99, 0x13, 0x6b, 0x8b, 0x38, 0xeb, 0x41, 0x1f, 0x38, 0xf5,
	0x87, 0xe4, 0x42, 0x78, 0xab, 0xda, 0x74, 0x2e, 0xab, 0x38, 0xef, 0x73, 0x6a, 0x9a, 0xc0, 0x3b,
	0x3e, 0xb5, 0x81, 0x64, 0xcb, 0xa8, 0x9a, 0x6e, 0xe7, 0xff, 0x7a, 0xba, 0x9d, 0xdd, 0x0b, 0xb8,
	0x38, 0x50, 0x93, 0x62, 0xc5, 0x7d, 0x6a, 0x83, 0xdc, 0xc0, 0x6b, 0x96, 0xde, 0x05, 0xcb, 0x23,
	0xb9, 0x72, 0xba, 0x2a, 0xed, 0x54, 0x96, 0x5f, 0x66, 0xfd, 0x8e, 0x10, 0xbd, 0xed, 0xf8, 0x7c,
	0xa8, 0xc5, 0x0e, 0xf9, 0x1d, 0x2c, 0x25, 0x12, 0x49, 0xb0, 0xd8, 0xe0, 0xb5, 0xe7, 0x6c, 0xd0,
	0x3a, 0x57, 0x46, 0xbb, 0x24, 0xbd, 0x72, 0x19, 0x4b, 0x3d, 0xf0, 0x0c, 0x4e, 0x5d, 0x11, 0x2b,
	0x49, 0x7c, 0x56, 0xb2, 0x24, 0xdf, 0xc4, 0x17, 0x7b, 0x60, 0x81, 0x0f, 0x1d, 0x97, 0x83, 0xab,
	0x73, 0x20, 0xf9, 0x32, 0xaa, 0x66, 0xdb, 0xeb, 0xdf, 0x8c, 0x09, 0xfa, 0xec, 0xd1, 0x95, 0x8c,
	0xc3, 0x0c, 0xdb, 0xd5, 0xd6, 0x23, 0xd1, 0xbd, 0x48, 0x53, 0x7c, 0x13, 0x4b, 0x09, 0x72, 0x79,
	0x23, 0xca, 0x8d, 0x48, 0x6d, 0x14, 0x8b, 0x4d, 0x9c, 0xe9, 0xeb, 0x56, 0x10, 0xe7, 0x53, 0x8b,
	0x26, 0x8d, 0x95, 0x5b, 0xa8, 0xf8, 0x16, 0xde, 0x98, 0x67, 0xfe, 0x3f, 0xfe, 0xc6, 0xd1, 0x4a,
	0x18, 0xed, 0x3f, 0x4e, 0x09, 0xfa, 0x64, 0x4c, 0xd0, 0xd1, 0x98, 0xa0, 0x87, 0x21, 0xe9, 0x19,
	0x59, 0xdf, 0x4b, 0x22, 0x7e, 0x75, 0x46, 0x7e, 0x40, 0x61, 0x2b, 0x34, 0x6f, 0xc3, 0xb0, 0xfe,
	0xae, 0x6e, 0x83, 0x22, 0xfa, 0xa3, 0xc6, 0xb8, 0x29, 0x4a, 0xef, 0x25, 0xba, 0x49, 0x31, 0xdc,
	0xa0, 0x96, 0x48, 0x56, 0x73, 0x77, 0x31, 0xb5, 0x8a, 0x0d, 0xf6, 0x8c, 0xe6, 0xee, 0x62, 0x4a,
	0x95, 0x30, 0x84, 0x33, 0xa2, 0xbd, 0x25, 0xa9, 0x54, 0xa2, 0xe4, 0xd5, 0xc2, 0x48, 0x82, 0x21,
	0xae, 0xa1, 0xd9, 0x9a, 0x0d, 0xa3, 0x12, 0x67, 0xa9, 0x16, 0xa6, 0xad, 0x79, 0xff, 0x3c, 0x58,
	0x8f, 0x26, 0x64, 0xe3, 0x10, 0x86, 0xcd, 0x24, 0xfd, 0xce, 0x97, 0x99, 0x99, 0x07, 0xa5, 0xe5,
	0x52, 0xf9, 0x7b, 0x84, 0x0b, 0xbb, 0x1c, 0x74, 0x1f, 0x66, 0xfa, 0x7e, 0x79, 0x88, 0x8a, 0x85,
	0x44, 0x5d, 0x13, 0x2f, 0x5f, 0x65, 0xf0, 0x6c, 0x4c, 0xde, 0xd0, 0xc0, 0x63, 0x01, 0x37, 0x60,
	0x0f, 0xfa, 0x60, 0x31, 0x17, 0x78, 0xa4, 0x57, 0x5a, 0x82, 0xfa, 0xae, 0xee, 0xe8, 0x26, 0x28,
	0xf3, 0x97, 0x39, 0x3a, 0x23, 0xd9, 0xfd, 0xb8, 0x71, 0xbe, 0x9d, 0x90, 0x8d, 0xf9, 0xf5, 0x4f,
	0x7f, 0xfc, 0xed, 0xf3, 0x15, 0x52, 0xb9, 0xac, 0x1a, 0x82, 0x4f, 0x4d, 0x3c, 0xd3, 0x0d, 0x74,
	0x4d, 0xfe, 0x02, 0xe1, 0x42, 0xf4, 0x4f, 0xbe, 0x20, 0xf9, 0x07, 0x2f, 0x4c, 0x3e, 0x25, 0x8b,
	0xc2, 0xbe, 0x8c, 0xec, 0x81, 0xdb, 0xd3, 0x5f, 0x26, 0x59, 0x20, 0xce, 0x9f, 0x27, 0x7b, 0x88,
	0xf0, 0xa5, 0xfd, 0x03, 0x36, 0xf8, 0x2f, 0x5c, 0xcf, 0xa9, 0x57, 0xf6, 0x9f, 0x8d, 0xc9, 0x8d,
	0x7f, 0x87, 0x7b, 0x9f, 0xc2, 0x60, 0x39, 0xda, 0x56, 0xa5, 0xa0, 0x7a, 0x07, 0x6c, 0x30, 0x07,
	0x76, 0x1d, 0xb5, 0xaf, 0x1e, 0xff, 0x5a, 0x4a, 0x1d, 0x8f, 0x4a, 0xe8, 0xc9, 0xa8, 0x84, 0x7e,
	0x19, 0x95, 0xd0, 0xd1, 0x49, 0x29, 0xf5, 0xe4, 0xa4, 0x94, 0xfa, 0xe9, 0xa4, 0x94, 0xea, 0xae,
	0x09, 0x8e, 0x1b, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0x11, 0xc2, 0x48, 0xeb, 0xac, 0x07, 0x00,
	0x00,
}

func (this *AlertPolicyKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&edgeproto.AlertPolicyKey{")
	s = append(s, "Organization: "+fmt.Sprintf("%#v", this.Organization)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAlertpolicy(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AlertPolicyApiClient is the client API for AlertPolicyApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AlertPolicyApiClient interface {
	// Create an Alert Policy
	CreateAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*Result, error)
	// Delete an Alert Policy
	DeleteAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*Result, error)
	// Update an Alert Policy
	UpdateAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*Result, error)
	// Show Alert Policies. Any fields specified will be used to filter results.
	ShowAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (AlertPolicyApi_ShowAlertPolicyClient, error)
}

type alertPolicyApiClient struct {
	cc *grpc.ClientConn
}

func NewAlertPolicyApiClient(cc *grpc.ClientConn) AlertPolicyApiClient {
	return &alertPolicyApiClient{cc}
}

func (c *alertPolicyApiClient) CreateAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.AlertPolicyApi/CreateAlertPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertPolicyApiClient) DeleteAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.AlertPolicyApi/DeleteAlertPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertPolicyApiClient) UpdateAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.AlertPolicyApi/UpdateAlertPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertPolicyApiClient) ShowAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (AlertPolicyApi_ShowAlertPolicyClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AlertPolicyApi_serviceDesc.Streams[0], "/edgeproto.AlertPolicyApi/ShowAlertPolicy", opts...)
	if err != nil {
		return nil, err
	}
	x := &alertPolicyApiShowAlertPolicyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AlertPolicyApi_ShowAlertPolicyClient interface {
	Recv() (*AlertPolicy, error)
	grpc.ClientStream
}

type alertPolicyApiShowAlertPolicyClient struct {
	grpc.ClientStream
}

func (x *alertPolicyApiShowAlertPolicyClient) Recv() (*AlertPolicy, error) {
	m := new(AlertPolicy)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AlertPolicyApiServer is the server API for AlertPolicyApi service.
type AlertPolicyApiServer interface {
	// Create an Alert Policy
	CreateAlertPolicy(context.Context, *AlertPolicy) (*Result, error)
	// Delete an Alert Policy
	DeleteAlertPolicy(context.Context, *AlertPolicy) (*Result, error)
	// Update an Alert Policy
	UpdateAlertPolicy(context.Context, *AlertPolicy) (*Result, error)
	// Show Alert Policies. Any fields specified will be used to filter results.
	ShowAlertPolicy(*AlertPolicy, AlertPolicyApi_ShowAlertPolicyServer) error
}

// UnimplementedAlertPolicyApiServer can be embedded to have forward compatible implementations.
type UnimplementedAlertPolicyApiServer struct {
}

func (*UnimplementedAlertPolicyApiServer) CreateAlertPolicy(ctx context.Context, req *AlertPolicy) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAlertPolicy not implemented")
}
func (*UnimplementedAlertPolicyApiServer) DeleteAlertPolicy(ctx context.Context, req *AlertPolicy) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAlertPolicy not implemented")
}
func (*UnimplementedAlertPolicyApiServer) UpdateAlertPolicy(ctx context.Context, req *AlertPolicy) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAlertPolicy not implemented")
}
func (*UnimplementedAlertPolicyApiServer) ShowAlertPolicy(req *AlertPolicy, srv AlertPolicyApi_ShowAlertPolicyServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowAlertPolicy not implemented")
}

func RegisterAlertPolicyApiServer(s *grpc.Server, srv AlertPolicyApiServer) {
	s.RegisterService(&_AlertPolicyApi_serviceDesc, srv)
}

func _AlertPolicyApi_CreateAlertPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertPolicyApiServer).CreateAlertPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.AlertPolicyApi/CreateAlertPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertPolicyApiServer).CreateAlertPolicy(ctx, req.(*AlertPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertPolicyApi_DeleteAlertPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertPolicyApiServer).DeleteAlertPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.AlertPolicyApi/DeleteAlertPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertPolicyApiServer).DeleteAlertPolicy(ctx, req.(*AlertPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertPolicyApi_UpdateAlertPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertPolicyApiServer).UpdateAlertPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.AlertPolicyApi/UpdateAlertPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertPolicyApiServer).UpdateAlertPolicy(ctx, req.(*AlertPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertPolicyApi_ShowAlertPolicy_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AlertPolicy)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AlertPolicyApiServer).ShowAlertPolicy(m, &alertPolicyApiShowAlertPolicyServer{stream})
}

type AlertPolicyApi_ShowAlertPolicyServer interface {
	Send(*AlertPolicy) error
	grpc.ServerStream
}

type alertPolicyApiShowAlertPolicyServer struct {
	grpc.ServerStream
}

func (x *alertPolicyApiShowAlertPolicyServer) Send(m *AlertPolicy) error {
	return x.ServerStream.SendMsg(m)
}

var _AlertPolicyApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.AlertPolicyApi",
	HandlerType: (*AlertPolicyApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAlertPolicy",
			Handler:    _AlertPolicyApi_CreateAlertPolicy_Handler,
		},
		{
			MethodName: "DeleteAlertPolicy",
			Handler:    _AlertPolicyApi_DeleteAlertPolicy_Handler,
		},
		{
			MethodName: "UpdateAlertPolicy",
			Handler:    _AlertPolicyApi_UpdateAlertPolicy_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowAlertPolicy",
			Handler:       _AlertPolicyApi_ShowAlertPolicy_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "alertpolicy.proto",
}

func (m *AlertPolicyKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertPolicyKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlertPolicyKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAlertpolicy(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintAlertpolicy(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlertPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlertPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeletePrepare {
		i--
		if m.DeletePrepare {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintAlertpolicy(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Annotations) > 0 {
		for k := range m.Annotations {
			v := m.Annotations[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAlertpolicy(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAlertpolicy(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAlertpolicy(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAlertpolicy(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAlertpolicy(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAlertpolicy(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.TriggerTime != 0 {
		i = encodeVarintAlertpolicy(dAtA, i, uint64(m.TriggerTime))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Severity) > 0 {
		i -= len(m.Severity)
		copy(dAtA[i:], m.Severity)
		i = encodeVarintAlertpolicy(dAtA, i, uint64(len(m.Severity)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ActiveConnLimit != 0 {
		i = encodeVarintAlertpolicy(dAtA, i, uint64(m.ActiveConnLimit))
		i--
		dAtA[i] = 0x30
	}
	if m.DiskUtilizationLimit != 0 {
		i = encodeVarintAlertpolicy(dAtA, i, uint64(m.DiskUtilizationLimit))
		i--
		dAtA[i] = 0x28
	}
	if m.MemUtilizationLimit != 0 {
		i = encodeVarintAlertpolicy(dAtA, i, uint64(m.MemUtilizationLimit))
		i--
		dAtA[i] = 0x20
	}
	if m.CpuUtilizationLimit != 0 {
		i = encodeVarintAlertpolicy(dAtA, i, uint64(m.CpuUtilizationLimit))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAlertpolicy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintAlertpolicy(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintAlertpolicy(dAtA []byte, offset int, v uint64) int {
	offset -= sovAlertpolicy(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AlertPolicyKey) Matches(o *AlertPolicyKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.Organization != "" {
		if o.Organization != m.Organization {
			return false
		}
	}
	if !opts.Filter || o.Name != "" {
		if o.Name != m.Name {
			return false
		}
	}
	return true
}

func (m *AlertPolicyKey) CopyInFields(src *AlertPolicyKey) int {
	changed := 0
	if m.Organization != src.Organization {
		m.Organization = src.Organization
		changed++
	}
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	return changed
}

func (m *AlertPolicyKey) DeepCopyIn(src *AlertPolicyKey) {
	m.Organization = src.Organization
	m.Name = src.Name
}

func (m *AlertPolicyKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal AlertPolicyKey key string", "obj", m)
	}
	return string(key)
}

func AlertPolicyKeyStringParse(str string, key *AlertPolicyKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal AlertPolicyKey key string", "str", str)
	}
}

func (m *AlertPolicyKey) NotFoundError() error {
	return fmt.Errorf("AlertPolicy key %s not found", m.GetKeyString())
}

func (m *AlertPolicyKey) ExistsError() error {
	return fmt.Errorf("AlertPolicy key %s already exists", m.GetKeyString())
}

var AlertPolicyKeyTagOrganization = "alertorg"
var AlertPolicyKeyTagName = "alert"

func (m *AlertPolicyKey) GetTags() map[string]string {
	tags := make(map[string]string)
	tags["alertorg"] = m.Organization
	tags["alert"] = m.Name
	return tags
}

// Helper method to check that enums have valid values
func (m *AlertPolicyKey) ValidateEnums() error {
	return nil
}

func (m *AlertPolicy) Matches(o *AlertPolicy, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.CpuUtilizationLimit != 0 {
		if o.CpuUtilizationLimit != m.CpuUtilizationLimit {
			return false
		}
	}
	if !opts.Filter || o.MemUtilizationLimit != 0 {
		if o.MemUtilizationLimit != m.MemUtilizationLimit {
			return false
		}
	}
	if !opts.Filter || o.DiskUtilizationLimit != 0 {
		if o.DiskUtilizationLimit != m.DiskUtilizationLimit {
			return false
		}
	}
	if !opts.Filter || o.ActiveConnLimit != 0 {
		if o.ActiveConnLimit != m.ActiveConnLimit {
			return false
		}
	}
	if !opts.Filter || o.Severity != "" {
		if o.Severity != m.Severity {
			return false
		}
	}
	if !opts.Filter || o.TriggerTime != 0 {
		if o.TriggerTime != m.TriggerTime {
			return false
		}
	}
	if !opts.Filter || o.Labels != nil {
		if len(m.Labels) == 0 && len(o.Labels) > 0 || len(m.Labels) > 0 && len(o.Labels) == 0 {
			return false
		} else if m.Labels != nil && o.Labels != nil {
			if !opts.Filter && len(m.Labels) != len(o.Labels) {
				return false
			}
			for k, _ := range o.Labels {
				_, ok := m.Labels[k]
				if !ok {
					return false
				}
				if o.Labels[k] != m.Labels[k] {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.Annotations != nil {
		if len(m.Annotations) == 0 && len(o.Annotations) > 0 || len(m.Annotations) > 0 && len(o.Annotations) == 0 {
			return false
		} else if m.Annotations != nil && o.Annotations != nil {
			if !opts.Filter && len(m.Annotations) != len(o.Annotations) {
				return false
			}
			for k, _ := range o.Annotations {
				_, ok := m.Annotations[k]
				if !ok {
					return false
				}
				if o.Annotations[k] != m.Annotations[k] {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.Description != "" {
		if o.Description != m.Description {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DeletePrepare != false {
			if o.DeletePrepare != m.DeletePrepare {
				return false
			}
		}
	}
	return true
}

const AlertPolicyFieldKey = "2"
const AlertPolicyFieldKeyOrganization = "2.1"
const AlertPolicyFieldKeyName = "2.2"
const AlertPolicyFieldCpuUtilizationLimit = "3"
const AlertPolicyFieldMemUtilizationLimit = "4"
const AlertPolicyFieldDiskUtilizationLimit = "5"
const AlertPolicyFieldActiveConnLimit = "6"
const AlertPolicyFieldSeverity = "7"
const AlertPolicyFieldTriggerTime = "8"
const AlertPolicyFieldLabels = "9"
const AlertPolicyFieldLabelsKey = "9.1"
const AlertPolicyFieldLabelsValue = "9.2"
const AlertPolicyFieldAnnotations = "10"
const AlertPolicyFieldAnnotationsKey = "10.1"
const AlertPolicyFieldAnnotationsValue = "10.2"
const AlertPolicyFieldDescription = "11"
const AlertPolicyFieldDeletePrepare = "12"

var AlertPolicyAllFields = []string{
	AlertPolicyFieldKeyOrganization,
	AlertPolicyFieldKeyName,
	AlertPolicyFieldCpuUtilizationLimit,
	AlertPolicyFieldMemUtilizationLimit,
	AlertPolicyFieldDiskUtilizationLimit,
	AlertPolicyFieldActiveConnLimit,
	AlertPolicyFieldSeverity,
	AlertPolicyFieldTriggerTime,
	AlertPolicyFieldLabelsKey,
	AlertPolicyFieldLabelsValue,
	AlertPolicyFieldAnnotationsKey,
	AlertPolicyFieldAnnotationsValue,
	AlertPolicyFieldDescription,
	AlertPolicyFieldDeletePrepare,
}

var AlertPolicyAllFieldsMap = map[string]struct{}{
	AlertPolicyFieldKeyOrganization:      struct{}{},
	AlertPolicyFieldKeyName:              struct{}{},
	AlertPolicyFieldCpuUtilizationLimit:  struct{}{},
	AlertPolicyFieldMemUtilizationLimit:  struct{}{},
	AlertPolicyFieldDiskUtilizationLimit: struct{}{},
	AlertPolicyFieldActiveConnLimit:      struct{}{},
	AlertPolicyFieldSeverity:             struct{}{},
	AlertPolicyFieldTriggerTime:          struct{}{},
	AlertPolicyFieldLabelsKey:            struct{}{},
	AlertPolicyFieldLabelsValue:          struct{}{},
	AlertPolicyFieldAnnotationsKey:       struct{}{},
	AlertPolicyFieldAnnotationsValue:     struct{}{},
	AlertPolicyFieldDescription:          struct{}{},
	AlertPolicyFieldDeletePrepare:        struct{}{},
}

var AlertPolicyAllFieldsStringMap = map[string]string{
	AlertPolicyFieldKeyOrganization:      "Key Organization",
	AlertPolicyFieldKeyName:              "Key Name",
	AlertPolicyFieldCpuUtilizationLimit:  "Cpu Utilization Limit",
	AlertPolicyFieldMemUtilizationLimit:  "Mem Utilization Limit",
	AlertPolicyFieldDiskUtilizationLimit: "Disk Utilization Limit",
	AlertPolicyFieldActiveConnLimit:      "Active Conn Limit",
	AlertPolicyFieldSeverity:             "Severity",
	AlertPolicyFieldTriggerTime:          "Trigger Time",
	AlertPolicyFieldLabelsKey:            "Labels Key",
	AlertPolicyFieldLabelsValue:          "Labels Value",
	AlertPolicyFieldAnnotationsKey:       "Annotations Key",
	AlertPolicyFieldAnnotationsValue:     "Annotations Value",
	AlertPolicyFieldDescription:          "Description",
	AlertPolicyFieldDeletePrepare:        "Delete Prepare",
}

func (m *AlertPolicy) IsKeyField(s string) bool {
	return strings.HasPrefix(s, AlertPolicyFieldKey+".") || s == AlertPolicyFieldKey
}

func (m *AlertPolicy) DiffFields(o *AlertPolicy, fields map[string]struct{}) {
	if m.Key.Organization != o.Key.Organization {
		fields[AlertPolicyFieldKeyOrganization] = struct{}{}
		fields[AlertPolicyFieldKey] = struct{}{}
	}
	if m.Key.Name != o.Key.Name {
		fields[AlertPolicyFieldKeyName] = struct{}{}
		fields[AlertPolicyFieldKey] = struct{}{}
	}
	if m.CpuUtilizationLimit != o.CpuUtilizationLimit {
		fields[AlertPolicyFieldCpuUtilizationLimit] = struct{}{}
	}
	if m.MemUtilizationLimit != o.MemUtilizationLimit {
		fields[AlertPolicyFieldMemUtilizationLimit] = struct{}{}
	}
	if m.DiskUtilizationLimit != o.DiskUtilizationLimit {
		fields[AlertPolicyFieldDiskUtilizationLimit] = struct{}{}
	}
	if m.ActiveConnLimit != o.ActiveConnLimit {
		fields[AlertPolicyFieldActiveConnLimit] = struct{}{}
	}
	if m.Severity != o.Severity {
		fields[AlertPolicyFieldSeverity] = struct{}{}
	}
	if m.TriggerTime != o.TriggerTime {
		fields[AlertPolicyFieldTriggerTime] = struct{}{}
	}
	if m.Labels != nil && o.Labels != nil {
		if len(m.Labels) != len(o.Labels) {
			fields[AlertPolicyFieldLabels] = struct{}{}
		} else {
			for k0, _ := range m.Labels {
				_, vok0 := o.Labels[k0]
				if !vok0 {
					fields[AlertPolicyFieldLabels] = struct{}{}
				} else {
					if m.Labels[k0] != o.Labels[k0] {
						fields[AlertPolicyFieldLabels] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.Labels != nil && o.Labels == nil) || (m.Labels == nil && o.Labels != nil) {
		fields[AlertPolicyFieldLabels] = struct{}{}
	}
	if m.Annotations != nil && o.Annotations != nil {
		if len(m.Annotations) != len(o.Annotations) {
			fields[AlertPolicyFieldAnnotations] = struct{}{}
		} else {
			for k0, _ := range m.Annotations {
				_, vok0 := o.Annotations[k0]
				if !vok0 {
					fields[AlertPolicyFieldAnnotations] = struct{}{}
				} else {
					if m.Annotations[k0] != o.Annotations[k0] {
						fields[AlertPolicyFieldAnnotations] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.Annotations != nil && o.Annotations == nil) || (m.Annotations == nil && o.Annotations != nil) {
		fields[AlertPolicyFieldAnnotations] = struct{}{}
	}
	if m.Description != o.Description {
		fields[AlertPolicyFieldDescription] = struct{}{}
	}
	if m.DeletePrepare != o.DeletePrepare {
		fields[AlertPolicyFieldDeletePrepare] = struct{}{}
	}
}

var UpdateAlertPolicyFieldsMap = map[string]struct{}{
	AlertPolicyFieldCpuUtilizationLimit:  struct{}{},
	AlertPolicyFieldMemUtilizationLimit:  struct{}{},
	AlertPolicyFieldDiskUtilizationLimit: struct{}{},
	AlertPolicyFieldActiveConnLimit:      struct{}{},
	AlertPolicyFieldSeverity:             struct{}{},
	AlertPolicyFieldTriggerTime:          struct{}{},
	AlertPolicyFieldLabels:               struct{}{},
	AlertPolicyFieldLabelsValue:          struct{}{},
	AlertPolicyFieldAnnotations:          struct{}{},
	AlertPolicyFieldAnnotationsValue:     struct{}{},
	AlertPolicyFieldDescription:          struct{}{},
}

func (m *AlertPolicy) ValidateUpdateFields() error {
	if m.Fields == nil {
		return fmt.Errorf("nothing specified to update")
	}
	fmap := MakeFieldMap(m.Fields)
	badFieldStrs := []string{}
	for field, _ := range fmap {
		if m.IsKeyField(field) {
			continue
		}
		if _, ok := UpdateAlertPolicyFieldsMap[field]; !ok {
			if _, ok := AlertPolicyAllFieldsStringMap[field]; !ok {
				continue
			}
			badFieldStrs = append(badFieldStrs, AlertPolicyAllFieldsStringMap[field])
		}
	}
	if len(badFieldStrs) > 0 {
		return fmt.Errorf("specified field(s) %s cannot be modified", strings.Join(badFieldStrs, ","))
	}
	return nil
}

func (m *AlertPolicy) CopyInFields(src *AlertPolicy) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
		if _, set := fmap["2.2"]; set {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
	}
	if _, set := fmap["3"]; set {
		if m.CpuUtilizationLimit != src.CpuUtilizationLimit {
			m.CpuUtilizationLimit = src.CpuUtilizationLimit
			changed++
		}
	}
	if _, set := fmap["4"]; set {
		if m.MemUtilizationLimit != src.MemUtilizationLimit {
			m.MemUtilizationLimit = src.MemUtilizationLimit
			changed++
		}
	}
	if _, set := fmap["5"]; set {
		if m.DiskUtilizationLimit != src.DiskUtilizationLimit {
			m.DiskUtilizationLimit = src.DiskUtilizationLimit
			changed++
		}
	}
	if _, set := fmap["6"]; set {
		if m.ActiveConnLimit != src.ActiveConnLimit {
			m.ActiveConnLimit = src.ActiveConnLimit
			changed++
		}
	}
	if _, set := fmap["7"]; set {
		if m.Severity != src.Severity {
			m.Severity = src.Severity
			changed++
		}
	}
	if _, set := fmap["8"]; set {
		if m.TriggerTime != src.TriggerTime {
			m.TriggerTime = src.TriggerTime
			changed++
		}
	}
	if _, set := fmap["9"]; set {
		if src.Labels != nil {
			m.Labels = make(map[string]string)
			for k0, _ := range src.Labels {
				m.Labels[k0] = src.Labels[k0]
				changed++
			}
		} else if m.Labels != nil {
			m.Labels = nil
			changed++
		}
	}
	if _, set := fmap["10"]; set {
		if src.Annotations != nil {
			m.Annotations = make(map[string]string)
			for k0, _ := range src.Annotations {
				m.Annotations[k0] = src.Annotations[k0]
				changed++
			}
		} else if m.Annotations != nil {
			m.Annotations = nil
			changed++
		}
	}
	if _, set := fmap["11"]; set {
		if m.Description != src.Description {
			m.Description = src.Description
			changed++
		}
	}
	if _, set := fmap["12"]; set {
		if m.DeletePrepare != src.DeletePrepare {
			m.DeletePrepare = src.DeletePrepare
			changed++
		}
	}
	return changed
}

func (m *AlertPolicy) DeepCopyIn(src *AlertPolicy) {
	m.Key.DeepCopyIn(&src.Key)
	m.CpuUtilizationLimit = src.CpuUtilizationLimit
	m.MemUtilizationLimit = src.MemUtilizationLimit
	m.DiskUtilizationLimit = src.DiskUtilizationLimit
	m.ActiveConnLimit = src.ActiveConnLimit
	m.Severity = src.Severity
	m.TriggerTime = src.TriggerTime
	if src.Labels != nil {
		m.Labels = make(map[string]string)
		for k, v := range src.Labels {
			m.Labels[k] = v
		}
	} else {
		m.Labels = nil
	}
	if src.Annotations != nil {
		m.Annotations = make(map[string]string)
		for k, v := range src.Annotations {
			m.Annotations[k] = v
		}
	} else {
		m.Annotations = nil
	}
	m.Description = src.Description
	m.DeletePrepare = src.DeletePrepare
}

func (s *AlertPolicy) HasFields() bool {
	return true
}

type AlertPolicyStore interface {
	Create(ctx context.Context, m *AlertPolicy, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *AlertPolicy, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *AlertPolicy, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *AlertPolicy, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*AlertPolicy, int64, error)
	Get(ctx context.Context, key *AlertPolicyKey, buf *AlertPolicy) bool
	STMGet(stm concurrency.STM, key *AlertPolicyKey, buf *AlertPolicy) bool
	STMPut(stm concurrency.STM, obj *AlertPolicy, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *AlertPolicyKey)
}

type AlertPolicyStoreImpl struct {
	kvstore objstore.KVStore
}

func NewAlertPolicyStore(kvstore objstore.KVStore) *AlertPolicyStoreImpl {
	return &AlertPolicyStoreImpl{kvstore: kvstore}
}

func (s *AlertPolicyStoreImpl) Create(ctx context.Context, m *AlertPolicy, wait func(int64)) (*Result, error) {
	err := m.Validate(AlertPolicyAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AlertPolicy", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AlertPolicyStoreImpl) Update(ctx context.Context, m *AlertPolicy, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AlertPolicy", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur AlertPolicy
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AlertPolicyStoreImpl) Put(ctx context.Context, m *AlertPolicy, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(AlertPolicyAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AlertPolicy", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AlertPolicyStoreImpl) Delete(ctx context.Context, m *AlertPolicy, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AlertPolicy", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AlertPolicyStoreImpl) LoadOne(key string) (*AlertPolicy, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj AlertPolicy
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse AlertPolicy data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *AlertPolicyStoreImpl) Get(ctx context.Context, key *AlertPolicyKey, buf *AlertPolicy) bool {
	keystr := objstore.DbKeyString("AlertPolicy", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *AlertPolicyStoreImpl) STMGet(stm concurrency.STM, key *AlertPolicyKey, buf *AlertPolicy) bool {
	keystr := objstore.DbKeyString("AlertPolicy", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *AlertPolicyStoreImpl) parseGetData(val []byte, buf *AlertPolicy) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = AlertPolicy{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *AlertPolicyStoreImpl) STMPut(stm concurrency.STM, obj *AlertPolicy, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("AlertPolicy", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("AlertPolicy json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *AlertPolicyStoreImpl) STMDel(stm concurrency.STM, key *AlertPolicyKey) {
	keystr := objstore.DbKeyString("AlertPolicy", key)
	stm.Del(keystr)
}

type AlertPolicyKeyWatcher struct {
	cb func(ctx context.Context)
}

type AlertPolicyCacheData struct {
	Obj    *AlertPolicy
	ModRev int64
}

// AlertPolicyCache caches AlertPolicy objects in memory in a hash table
// and keeps them in sync with the database.
type AlertPolicyCache struct {
	Objs          map[AlertPolicyKey]*AlertPolicyCacheData
	Mux           util.Mutex
	List          map[AlertPolicyKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *AlertPolicyKey, old *AlertPolicy, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *AlertPolicy, new *AlertPolicy)
	DeletedCbs    []func(ctx context.Context, old *AlertPolicy)
	KeyWatchers   map[AlertPolicyKey][]*AlertPolicyKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *AlertPolicyKey)
	DeletedKeyCbs []func(ctx context.Context, key *AlertPolicyKey)
}

func NewAlertPolicyCache() *AlertPolicyCache {
	cache := AlertPolicyCache{}
	InitAlertPolicyCache(&cache)
	return &cache
}

func InitAlertPolicyCache(cache *AlertPolicyCache) {
	cache.Objs = make(map[AlertPolicyKey]*AlertPolicyCacheData)
	cache.KeyWatchers = make(map[AlertPolicyKey][]*AlertPolicyKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *AlertPolicyCache) GetTypeString() string {
	return "AlertPolicy"
}

func (c *AlertPolicyCache) Get(key *AlertPolicyKey, valbuf *AlertPolicy) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *AlertPolicyCache) GetWithRev(key *AlertPolicyKey, valbuf *AlertPolicy, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *AlertPolicyCache) HasKey(key *AlertPolicyKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *AlertPolicyCache) GetAllKeys(ctx context.Context, cb func(key *AlertPolicyKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *AlertPolicyCache) Update(ctx context.Context, in *AlertPolicy, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *AlertPolicy) (*AlertPolicy, bool) {
		return in, true
	})
}

func (c *AlertPolicyCache) UpdateModFunc(ctx context.Context, key *AlertPolicyKey, modRev int64, modFunc func(old *AlertPolicy) (new *AlertPolicy, changed bool)) {
	c.Mux.Lock()
	var old *AlertPolicy
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	for _, cb := range c.UpdatedCbs {
		newCopy := &AlertPolicy{}
		newCopy.DeepCopyIn(new)
		defer cb(ctx, old, newCopy)
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			defer cb(ctx, new.GetKey(), old, modRev)
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &AlertPolicy{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &AlertPolicyCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *AlertPolicyCache) Delete(ctx context.Context, in *AlertPolicy, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *AlertPolicy) bool {
		return true
	})
}

func (c *AlertPolicyCache) DeleteCondFunc(ctx context.Context, in *AlertPolicy, modRev int64, condFunc func(old *AlertPolicy) bool) {
	c.Mux.Lock()
	var old *AlertPolicy
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	c.Mux.Unlock()
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, in.GetKey(), old, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *AlertPolicyCache) Prune(ctx context.Context, validKeys map[AlertPolicyKey]struct{}) {
	notify := make(map[AlertPolicyKey]*AlertPolicyCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, old.Obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *AlertPolicyCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *AlertPolicyCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *AlertPolicyCache) Show(filter *AlertPolicy, cb func(ret *AlertPolicy) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func AlertPolicyGenericNotifyCb(fn func(key *AlertPolicyKey, old *AlertPolicy)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*AlertPolicyKey), obj.(*AlertPolicy))
	}
}

func (c *AlertPolicyCache) SetNotifyCb(fn func(ctx context.Context, obj *AlertPolicyKey, old *AlertPolicy, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *AlertPolicyKey, old *AlertPolicy, modRev int64){fn}
}

func (c *AlertPolicyCache) SetUpdatedCb(fn func(ctx context.Context, old *AlertPolicy, new *AlertPolicy)) {
	c.UpdatedCbs = []func(ctx context.Context, old *AlertPolicy, new *AlertPolicy){fn}
}

func (c *AlertPolicyCache) SetDeletedCb(fn func(ctx context.Context, old *AlertPolicy)) {
	c.DeletedCbs = []func(ctx context.Context, old *AlertPolicy){fn}
}

func (c *AlertPolicyCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *AlertPolicyKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *AlertPolicyKey){fn}
}

func (c *AlertPolicyCache) SetDeletedKeyCb(fn func(ctx context.Context, key *AlertPolicyKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *AlertPolicyKey){fn}
}

func (c *AlertPolicyCache) AddUpdatedCb(fn func(ctx context.Context, old *AlertPolicy, new *AlertPolicy)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *AlertPolicyCache) AddDeletedCb(fn func(ctx context.Context, old *AlertPolicy)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *AlertPolicyCache) AddNotifyCb(fn func(ctx context.Context, obj *AlertPolicyKey, old *AlertPolicy, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *AlertPolicyCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *AlertPolicyKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *AlertPolicyCache) AddDeletedKeyCb(fn func(ctx context.Context, key *AlertPolicyKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *AlertPolicyCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *AlertPolicyCache) WatchKey(key *AlertPolicyKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*AlertPolicyKeyWatcher, 0)
	}
	watcher := AlertPolicyKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching AlertPolicy", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *AlertPolicyCache) TriggerKeyWatchers(ctx context.Context, key *AlertPolicyKey) {
	watchers := make([]*AlertPolicyKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *AlertPolicyCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := AlertPolicy{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse AlertPolicy data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *AlertPolicyCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := AlertPolicy{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	AlertPolicyKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *AlertPolicyCache) SyncListStart(ctx context.Context) {
	c.List = make(map[AlertPolicyKey]struct{})
}

func (c *AlertPolicyCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[AlertPolicyKey]*AlertPolicyCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, val.Obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *AlertPolicyCache) UsesOrg(org string) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		if key.Organization == org {
			return true
		}
	}
	return false
}

func (m *AlertPolicy) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *AlertPolicy) GetKey() *AlertPolicyKey {
	return &m.Key
}

func (m *AlertPolicy) GetKeyVal() AlertPolicyKey {
	return m.Key
}

func (m *AlertPolicy) SetKey(key *AlertPolicyKey) {
	m.Key = *key
}

func CmpSortAlertPolicy(a AlertPolicy, b AlertPolicy) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *AlertPolicy) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func IgnoreAlertPolicyFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "DeletePrepare")
	}
	return cmpopts.IgnoreFields(AlertPolicy{}, names...)
}

func (m *AlertPolicy) IsValidArgsForCreateAlertPolicy() error {
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	return nil
}

func (m *AlertPolicy) IsValidArgsForDeleteAlertPolicy() error {
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	return nil
}

func (m *AlertPolicy) IsValidArgsForUpdateAlertPolicy() error {
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	return nil
}

func (m *AlertPolicyKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovAlertpolicy(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAlertpolicy(uint64(l))
	}
	return n
}

func (m *AlertPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovAlertpolicy(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovAlertpolicy(uint64(l))
	if m.CpuUtilizationLimit != 0 {
		n += 1 + sovAlertpolicy(uint64(m.CpuUtilizationLimit))
	}
	if m.MemUtilizationLimit != 0 {
		n += 1 + sovAlertpolicy(uint64(m.MemUtilizationLimit))
	}
	if m.DiskUtilizationLimit != 0 {
		n += 1 + sovAlertpolicy(uint64(m.DiskUtilizationLimit))
	}
	if m.ActiveConnLimit != 0 {
		n += 1 + sovAlertpolicy(uint64(m.ActiveConnLimit))
	}
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovAlertpolicy(uint64(l))
	}
	if m.TriggerTime != 0 {
		n += 1 + sovAlertpolicy(uint64(m.TriggerTime))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAlertpolicy(uint64(len(k))) + 1 + len(v) + sovAlertpolicy(uint64(len(v)))
			n += mapEntrySize + 1 + sovAlertpolicy(uint64(mapEntrySize))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAlertpolicy(uint64(len(k))) + 1 + len(v) + sovAlertpolicy(uint64(len(v)))
			n += mapEntrySize + 1 + sovAlertpolicy(uint64(mapEntrySize))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAlertpolicy(uint64(l))
	}
	if m.DeletePrepare {
		n += 2
	}
	return n
}

func sovAlertpolicy(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAlertpolicy(x uint64) (n int) {
	return sovAlertpolicy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AlertPolicyKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertpolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertPolicyKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertPolicyKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertpolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlertpolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlertpolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertpolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlertpolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlertpolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlertpolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertpolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAlertpolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertpolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertpolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlertpolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlertpolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertpolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlertpolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlertpolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUtilizationLimit", wireType)
			}
			m.CpuUtilizationLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertpolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuUtilizationLimit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemUtilizationLimit", wireType)
			}
			m.MemUtilizationLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertpolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemUtilizationLimit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskUtilizationLimit", wireType)
			}
			m.DiskUtilizationLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertpolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskUtilizationLimit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveConnLimit", wireType)
			}
			m.ActiveConnLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertpolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveConnLimit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertpolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlertpolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlertpolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerTime", wireType)
			}
			m.TriggerTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertpolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggerTime |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertpolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlertpolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlertpolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAlertpolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAlertpolicy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAlertpolicy
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAlertpolicy
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAlertpolicy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAlertpolicy
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAlertpolicy
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAlertpolicy(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAlertpolicy
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertpolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlertpolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlertpolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAlertpolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAlertpolicy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAlertpolicy
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAlertpolicy
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAlertpolicy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAlertpolicy
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAlertpolicy
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAlertpolicy(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAlertpolicy
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertpolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlertpolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlertpolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletePrepare", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertpolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeletePrepare = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAlertpolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertpolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAlertpolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAlertpolicy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAlertpolicy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlertpolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlertpolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAlertpolicy
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAlertpolicy
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAlertpolicy
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAlertpolicy        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAlertpolicy          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAlertpolicy = fmt.Errorf("proto: unexpected end of group")
)
