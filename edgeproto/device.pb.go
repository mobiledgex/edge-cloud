// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: device.proto

package edgeproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/mobiledgex/edge-cloud/protogen"
import _ "github.com/gogo/protobuf/gogoproto"
import google_protobuf1 "github.com/gogo/protobuf/types"

import strings "strings"
import reflect "reflect"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import "encoding/json"
import "github.com/mobiledgex/edge-cloud/objstore"
import "github.com/coreos/etcd/clientv3/concurrency"
import "github.com/mobiledgex/edge-cloud/util"
import "github.com/mobiledgex/edge-cloud/log"
import "github.com/google/go-cmp/cmp"
import "github.com/google/go-cmp/cmp/cmpopts"
import google_protobuf "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// DeviceReport is a reporting message. It takes a begining and end time
// for the report
type DeviceReport struct {
	// Device Key
	Key DeviceKey `protobuf:"bytes,1,opt,name=key" json:"key"`
	// Timestamp of the beginning of the report
	Begin *google_protobuf1.Timestamp `protobuf:"bytes,2,opt,name=begin" json:"begin,omitempty"`
	// Timestamp of the beginning of the report
	End *google_protobuf1.Timestamp `protobuf:"bytes,3,opt,name=end" json:"end,omitempty"`
}

func (m *DeviceReport) Reset()                    { *m = DeviceReport{} }
func (m *DeviceReport) String() string            { return proto.CompactTextString(m) }
func (*DeviceReport) ProtoMessage()               {}
func (*DeviceReport) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{0} }

// DeviceKey is an identifier for a given device on the MobiledgeX platform
// It is defined by a unique id and unique id type
// And example of such a device is a MEL device that hosts several applications
type DeviceKey struct {
	// Type of unique ID provided by the client
	UniqueIdType string `protobuf:"bytes,1,opt,name=unique_id_type,json=uniqueIdType,proto3" json:"unique_id_type,omitempty"`
	// Unique identification of the client device or user. May be overridden by the server.
	UniqueId string `protobuf:"bytes,2,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
}

func (m *DeviceKey) Reset()                    { *m = DeviceKey{} }
func (m *DeviceKey) String() string            { return proto.CompactTextString(m) }
func (*DeviceKey) ProtoMessage()               {}
func (*DeviceKey) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{1} }

// Device represents a device on the MobiledgeX platform
// We record when this device first showed up on our platform
type Device struct {
	Fields []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty"`
	// Key
	Key DeviceKey `protobuf:"bytes,2,opt,name=key" json:"key"`
	// Timestamp when the device was registered
	FirstSeen *google_protobuf1.Timestamp `protobuf:"bytes,3,opt,name=first_seen,json=firstSeen" json:"first_seen,omitempty"`
	// Timestamp when the device was last seen(Future use)
	LastSeen *google_protobuf1.Timestamp `protobuf:"bytes,4,opt,name=last_seen,json=lastSeen" json:"last_seen,omitempty"`
	// Id of client assigned by server (internal use only)
	NotifyId int64 `protobuf:"varint,5,opt,name=notify_id,json=notifyId,proto3" json:"notify_id,omitempty"`
}

func (m *Device) Reset()                    { *m = Device{} }
func (m *Device) String() string            { return proto.CompactTextString(m) }
func (*Device) ProtoMessage()               {}
func (*Device) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{2} }

func init() {
	proto.RegisterType((*DeviceReport)(nil), "edgeproto.DeviceReport")
	proto.RegisterType((*DeviceKey)(nil), "edgeproto.DeviceKey")
	proto.RegisterType((*Device)(nil), "edgeproto.Device")
}
func (this *DeviceKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&edgeproto.DeviceKey{")
	s = append(s, "UniqueIdType: "+fmt.Sprintf("%#v", this.UniqueIdType)+",\n")
	s = append(s, "UniqueId: "+fmt.Sprintf("%#v", this.UniqueId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringDevice(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DeviceApi service

type DeviceApiClient interface {
	InjectDevice(ctx context.Context, in *Device, opts ...grpc.CallOption) (*Result, error)
	ShowDevice(ctx context.Context, in *Device, opts ...grpc.CallOption) (DeviceApi_ShowDeviceClient, error)
	EvictDevice(ctx context.Context, in *Device, opts ...grpc.CallOption) (*Result, error)
	// Device Reports API.
	ShowDeviceReport(ctx context.Context, in *DeviceReport, opts ...grpc.CallOption) (DeviceApi_ShowDeviceReportClient, error)
}

type deviceApiClient struct {
	cc *grpc.ClientConn
}

func NewDeviceApiClient(cc *grpc.ClientConn) DeviceApiClient {
	return &deviceApiClient{cc}
}

func (c *deviceApiClient) InjectDevice(ctx context.Context, in *Device, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.DeviceApi/InjectDevice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceApiClient) ShowDevice(ctx context.Context, in *Device, opts ...grpc.CallOption) (DeviceApi_ShowDeviceClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DeviceApi_serviceDesc.Streams[0], c.cc, "/edgeproto.DeviceApi/ShowDevice", opts...)
	if err != nil {
		return nil, err
	}
	x := &deviceApiShowDeviceClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DeviceApi_ShowDeviceClient interface {
	Recv() (*Device, error)
	grpc.ClientStream
}

type deviceApiShowDeviceClient struct {
	grpc.ClientStream
}

func (x *deviceApiShowDeviceClient) Recv() (*Device, error) {
	m := new(Device)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *deviceApiClient) EvictDevice(ctx context.Context, in *Device, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.DeviceApi/EvictDevice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceApiClient) ShowDeviceReport(ctx context.Context, in *DeviceReport, opts ...grpc.CallOption) (DeviceApi_ShowDeviceReportClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DeviceApi_serviceDesc.Streams[1], c.cc, "/edgeproto.DeviceApi/ShowDeviceReport", opts...)
	if err != nil {
		return nil, err
	}
	x := &deviceApiShowDeviceReportClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DeviceApi_ShowDeviceReportClient interface {
	Recv() (*Device, error)
	grpc.ClientStream
}

type deviceApiShowDeviceReportClient struct {
	grpc.ClientStream
}

func (x *deviceApiShowDeviceReportClient) Recv() (*Device, error) {
	m := new(Device)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for DeviceApi service

type DeviceApiServer interface {
	InjectDevice(context.Context, *Device) (*Result, error)
	ShowDevice(*Device, DeviceApi_ShowDeviceServer) error
	EvictDevice(context.Context, *Device) (*Result, error)
	// Device Reports API.
	ShowDeviceReport(*DeviceReport, DeviceApi_ShowDeviceReportServer) error
}

func RegisterDeviceApiServer(s *grpc.Server, srv DeviceApiServer) {
	s.RegisterService(&_DeviceApi_serviceDesc, srv)
}

func _DeviceApi_InjectDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceApiServer).InjectDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.DeviceApi/InjectDevice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceApiServer).InjectDevice(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceApi_ShowDevice_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Device)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DeviceApiServer).ShowDevice(m, &deviceApiShowDeviceServer{stream})
}

type DeviceApi_ShowDeviceServer interface {
	Send(*Device) error
	grpc.ServerStream
}

type deviceApiShowDeviceServer struct {
	grpc.ServerStream
}

func (x *deviceApiShowDeviceServer) Send(m *Device) error {
	return x.ServerStream.SendMsg(m)
}

func _DeviceApi_EvictDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceApiServer).EvictDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.DeviceApi/EvictDevice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceApiServer).EvictDevice(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceApi_ShowDeviceReport_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DeviceReport)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DeviceApiServer).ShowDeviceReport(m, &deviceApiShowDeviceReportServer{stream})
}

type DeviceApi_ShowDeviceReportServer interface {
	Send(*Device) error
	grpc.ServerStream
}

type deviceApiShowDeviceReportServer struct {
	grpc.ServerStream
}

func (x *deviceApiShowDeviceReportServer) Send(m *Device) error {
	return x.ServerStream.SendMsg(m)
}

var _DeviceApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.DeviceApi",
	HandlerType: (*DeviceApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InjectDevice",
			Handler:    _DeviceApi_InjectDevice_Handler,
		},
		{
			MethodName: "EvictDevice",
			Handler:    _DeviceApi_EvictDevice_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowDevice",
			Handler:       _DeviceApi_ShowDevice_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowDeviceReport",
			Handler:       _DeviceApi_ShowDeviceReport_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "device.proto",
}

func (m *DeviceReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceReport) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintDevice(dAtA, i, uint64(m.Key.Size()))
	n1, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.Begin != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Begin.Size()))
		n2, err := m.Begin.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.End != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.End.Size()))
		n3, err := m.End.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *DeviceKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UniqueIdType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.UniqueIdType)))
		i += copy(dAtA[i:], m.UniqueIdType)
	}
	if len(m.UniqueId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.UniqueId)))
		i += copy(dAtA[i:], m.UniqueId)
	}
	return i, nil
}

func (m *Device) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Device) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintDevice(dAtA, i, uint64(m.Key.Size()))
	n4, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if m.FirstSeen != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.FirstSeen.Size()))
		n5, err := m.FirstSeen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.LastSeen != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.LastSeen.Size()))
		n6, err := m.LastSeen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.NotifyId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.NotifyId))
	}
	return i, nil
}

func encodeVarintDevice(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DeviceReport) CopyInFields(src *DeviceReport) int {
	changed := 0
	if m.Key.UniqueIdType != src.Key.UniqueIdType {
		m.Key.UniqueIdType = src.Key.UniqueIdType
		changed++
	}
	if m.Key.UniqueId != src.Key.UniqueId {
		m.Key.UniqueId = src.Key.UniqueId
		changed++
	}
	if src.Begin != nil {
		m.Begin = &google_protobuf.Timestamp{}
		if m.Begin.Seconds != src.Begin.Seconds {
			m.Begin.Seconds = src.Begin.Seconds
			changed++
		}
		if m.Begin.Nanos != src.Begin.Nanos {
			m.Begin.Nanos = src.Begin.Nanos
			changed++
		}
	} else if m.Begin != nil {
		m.Begin = nil
		changed++
	}
	if src.End != nil {
		m.End = &google_protobuf.Timestamp{}
		if m.End.Seconds != src.End.Seconds {
			m.End.Seconds = src.End.Seconds
			changed++
		}
		if m.End.Nanos != src.End.Nanos {
			m.End.Nanos = src.End.Nanos
			changed++
		}
	} else if m.End != nil {
		m.End = nil
		changed++
	}
	return changed
}

func (m *DeviceReport) DeepCopyIn(src *DeviceReport) {
	m.Key.DeepCopyIn(&src.Key)
	if src.Begin != nil {
		var tmp_Begin google_protobuf.Timestamp
		tmp_Begin = *src.Begin
		m.Begin = &tmp_Begin
	} else {
		m.Begin = nil
	}
	if src.End != nil {
		var tmp_End google_protobuf.Timestamp
		tmp_End = *src.End
		m.End = &tmp_End
	} else {
		m.End = nil
	}
}

func (s *DeviceReport) HasFields() bool {
	return false
}

type DeviceReportStore struct {
	kvstore objstore.KVStore
}

func NewDeviceReportStore(kvstore objstore.KVStore) DeviceReportStore {
	return DeviceReportStore{kvstore: kvstore}
}

func (s *DeviceReportStore) Create(ctx context.Context, m *DeviceReport, wait func(int64)) (*Result, error) {
	err := m.Validate(nil)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("DeviceReport", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *DeviceReportStore) Update(ctx context.Context, m *DeviceReport, wait func(int64)) (*Result, error) {
	err := m.Validate(nil)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("DeviceReport", m.GetKey())
	var vers int64 = 0
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *DeviceReportStore) Put(ctx context.Context, m *DeviceReport, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(nil)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("DeviceReport", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *DeviceReportStore) Delete(ctx context.Context, m *DeviceReport, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("DeviceReport", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *DeviceReportStore) LoadOne(key string) (*DeviceReport, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj DeviceReport
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse DeviceReport data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *DeviceReportStore) STMGet(stm concurrency.STM, key *DeviceKey, buf *DeviceReport) bool {
	keystr := objstore.DbKeyString("DeviceReport", key)
	valstr := stm.Get(keystr)
	if valstr == "" {
		return false
	}
	if buf != nil {
		err := json.Unmarshal([]byte(valstr), buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *DeviceReportStore) STMPut(stm concurrency.STM, obj *DeviceReport, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("DeviceReport", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("DeviceReport json marsahal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *DeviceReportStore) STMDel(stm concurrency.STM, key *DeviceKey) {
	keystr := objstore.DbKeyString("DeviceReport", key)
	stm.Del(keystr)
}

func (m *DeviceReport) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *DeviceReport) GetKey() *DeviceKey {
	return &m.Key
}

func (m *DeviceReport) GetKeyVal() DeviceKey {
	return m.Key
}

func (m *DeviceReport) SetKey(key *DeviceKey) {
	m.Key = *key
}

func CmpSortDeviceReport(a DeviceReport, b DeviceReport) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *DeviceReport) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *DeviceKey) Matches(o *DeviceKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.UniqueIdType != "" {
		if o.UniqueIdType != m.UniqueIdType {
			return false
		}
	}
	if !opts.Filter || o.UniqueId != "" {
		if o.UniqueId != m.UniqueId {
			return false
		}
	}
	return true
}

func (m *DeviceKey) CopyInFields(src *DeviceKey) int {
	changed := 0
	if m.UniqueIdType != src.UniqueIdType {
		m.UniqueIdType = src.UniqueIdType
		changed++
	}
	if m.UniqueId != src.UniqueId {
		m.UniqueId = src.UniqueId
		changed++
	}
	return changed
}

func (m *DeviceKey) DeepCopyIn(src *DeviceKey) {
	m.UniqueIdType = src.UniqueIdType
	m.UniqueId = src.UniqueId
}

func (m *DeviceKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal DeviceKey key string", "obj", m)
	}
	return string(key)
}

func DeviceKeyStringParse(str string, key *DeviceKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal DeviceKey key string", "str", str)
	}
}

func (m *DeviceKey) NotFoundError() error {
	return fmt.Errorf("Device key %s not found", m.GetKeyString())
}

func (m *DeviceKey) ExistsError() error {
	return fmt.Errorf("Device key %s already exists", m.GetKeyString())
}

var DeviceKeyTagUniqueIdType = "deviceidtype"
var DeviceKeyTagUniqueId = "deviceid"

func (m *DeviceKey) GetTags() map[string]string {
	tags := make(map[string]string)
	tags["deviceidtype"] = m.UniqueIdType
	tags["deviceid"] = m.UniqueId
	return tags
}

// Helper method to check that enums have valid values
func (m *DeviceKey) ValidateEnums() error {
	return nil
}

func (m *Device) Matches(o *Device, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.FirstSeen != nil {
		if m.FirstSeen == nil && o.FirstSeen != nil || m.FirstSeen != nil && o.FirstSeen == nil {
			return false
		} else if m.FirstSeen != nil && o.FirstSeen != nil {
			if m.FirstSeen.Seconds != o.FirstSeen.Seconds || m.FirstSeen.Nanos != o.FirstSeen.Nanos {
				return false
			}
		}
	}
	if !opts.Filter || o.LastSeen != nil {
		if m.LastSeen == nil && o.LastSeen != nil || m.LastSeen != nil && o.LastSeen == nil {
			return false
		} else if m.LastSeen != nil && o.LastSeen != nil {
			if m.LastSeen.Seconds != o.LastSeen.Seconds || m.LastSeen.Nanos != o.LastSeen.Nanos {
				return false
			}
		}
	}
	if !opts.Filter || o.NotifyId != 0 {
		if o.NotifyId != m.NotifyId {
			return false
		}
	}
	return true
}

const DeviceFieldKey = "2"
const DeviceFieldKeyUniqueIdType = "2.1"
const DeviceFieldKeyUniqueId = "2.2"
const DeviceFieldFirstSeen = "3"
const DeviceFieldFirstSeenSeconds = "3.1"
const DeviceFieldFirstSeenNanos = "3.2"
const DeviceFieldLastSeen = "4"
const DeviceFieldLastSeenSeconds = "4.1"
const DeviceFieldLastSeenNanos = "4.2"
const DeviceFieldNotifyId = "5"

var DeviceAllFields = []string{
	DeviceFieldKeyUniqueIdType,
	DeviceFieldKeyUniqueId,
	DeviceFieldFirstSeenSeconds,
	DeviceFieldFirstSeenNanos,
	DeviceFieldLastSeenSeconds,
	DeviceFieldLastSeenNanos,
	DeviceFieldNotifyId,
}

var DeviceAllFieldsMap = map[string]struct{}{
	DeviceFieldKeyUniqueIdType:  struct{}{},
	DeviceFieldKeyUniqueId:      struct{}{},
	DeviceFieldFirstSeenSeconds: struct{}{},
	DeviceFieldFirstSeenNanos:   struct{}{},
	DeviceFieldLastSeenSeconds:  struct{}{},
	DeviceFieldLastSeenNanos:    struct{}{},
	DeviceFieldNotifyId:         struct{}{},
}

var DeviceAllFieldsStringMap = map[string]string{
	DeviceFieldKeyUniqueIdType:  "Key Unique Id Type",
	DeviceFieldKeyUniqueId:      "Key Unique Id",
	DeviceFieldFirstSeenSeconds: "First Seen Seconds",
	DeviceFieldFirstSeenNanos:   "First Seen Nanos",
	DeviceFieldLastSeenSeconds:  "Last Seen Seconds",
	DeviceFieldLastSeenNanos:    "Last Seen Nanos",
	DeviceFieldNotifyId:         "Notify Id",
}

func (m *Device) IsKeyField(s string) bool {
	return strings.HasPrefix(s, DeviceFieldKey+".") || s == DeviceFieldKey
}

func (m *Device) DiffFields(o *Device, fields map[string]struct{}) {
	if m.Key.UniqueIdType != o.Key.UniqueIdType {
		fields[DeviceFieldKeyUniqueIdType] = struct{}{}
		fields[DeviceFieldKey] = struct{}{}
	}
	if m.Key.UniqueId != o.Key.UniqueId {
		fields[DeviceFieldKeyUniqueId] = struct{}{}
		fields[DeviceFieldKey] = struct{}{}
	}
	if m.FirstSeen != nil && o.FirstSeen != nil {
		if m.FirstSeen.Seconds != o.FirstSeen.Seconds {
			fields[DeviceFieldFirstSeenSeconds] = struct{}{}
			fields[DeviceFieldFirstSeen] = struct{}{}
		}
		if m.FirstSeen.Nanos != o.FirstSeen.Nanos {
			fields[DeviceFieldFirstSeenNanos] = struct{}{}
			fields[DeviceFieldFirstSeen] = struct{}{}
		}
	} else if (m.FirstSeen != nil && o.FirstSeen == nil) || (m.FirstSeen == nil && o.FirstSeen != nil) {
		fields[DeviceFieldFirstSeen] = struct{}{}
	}
	if m.LastSeen != nil && o.LastSeen != nil {
		if m.LastSeen.Seconds != o.LastSeen.Seconds {
			fields[DeviceFieldLastSeenSeconds] = struct{}{}
			fields[DeviceFieldLastSeen] = struct{}{}
		}
		if m.LastSeen.Nanos != o.LastSeen.Nanos {
			fields[DeviceFieldLastSeenNanos] = struct{}{}
			fields[DeviceFieldLastSeen] = struct{}{}
		}
	} else if (m.LastSeen != nil && o.LastSeen == nil) || (m.LastSeen == nil && o.LastSeen != nil) {
		fields[DeviceFieldLastSeen] = struct{}{}
	}
	if m.NotifyId != o.NotifyId {
		fields[DeviceFieldNotifyId] = struct{}{}
	}
}

func (m *Device) CopyInFields(src *Device) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if m.Key.UniqueIdType != src.Key.UniqueIdType {
				m.Key.UniqueIdType = src.Key.UniqueIdType
				changed++
			}
		}
		if _, set := fmap["2.2"]; set {
			if m.Key.UniqueId != src.Key.UniqueId {
				m.Key.UniqueId = src.Key.UniqueId
				changed++
			}
		}
	}
	if _, set := fmap["3"]; set {
		if src.FirstSeen != nil {
			m.FirstSeen = &google_protobuf.Timestamp{}
			if _, set := fmap["3.1"]; set {
				if m.FirstSeen.Seconds != src.FirstSeen.Seconds {
					m.FirstSeen.Seconds = src.FirstSeen.Seconds
					changed++
				}
			}
			if _, set := fmap["3.2"]; set {
				if m.FirstSeen.Nanos != src.FirstSeen.Nanos {
					m.FirstSeen.Nanos = src.FirstSeen.Nanos
					changed++
				}
			}
		} else if m.FirstSeen != nil {
			m.FirstSeen = nil
			changed++
		}
	}
	if _, set := fmap["4"]; set {
		if src.LastSeen != nil {
			m.LastSeen = &google_protobuf.Timestamp{}
			if _, set := fmap["4.1"]; set {
				if m.LastSeen.Seconds != src.LastSeen.Seconds {
					m.LastSeen.Seconds = src.LastSeen.Seconds
					changed++
				}
			}
			if _, set := fmap["4.2"]; set {
				if m.LastSeen.Nanos != src.LastSeen.Nanos {
					m.LastSeen.Nanos = src.LastSeen.Nanos
					changed++
				}
			}
		} else if m.LastSeen != nil {
			m.LastSeen = nil
			changed++
		}
	}
	if _, set := fmap["5"]; set {
		if m.NotifyId != src.NotifyId {
			m.NotifyId = src.NotifyId
			changed++
		}
	}
	return changed
}

func (m *Device) DeepCopyIn(src *Device) {
	m.Key.DeepCopyIn(&src.Key)
	if src.FirstSeen != nil {
		var tmp_FirstSeen google_protobuf.Timestamp
		tmp_FirstSeen = *src.FirstSeen
		m.FirstSeen = &tmp_FirstSeen
	} else {
		m.FirstSeen = nil
	}
	if src.LastSeen != nil {
		var tmp_LastSeen google_protobuf.Timestamp
		tmp_LastSeen = *src.LastSeen
		m.LastSeen = &tmp_LastSeen
	} else {
		m.LastSeen = nil
	}
	m.NotifyId = src.NotifyId
}

func (s *Device) HasFields() bool {
	return true
}

type DeviceStore struct {
	kvstore objstore.KVStore
}

func NewDeviceStore(kvstore objstore.KVStore) DeviceStore {
	return DeviceStore{kvstore: kvstore}
}

func (s *DeviceStore) Create(ctx context.Context, m *Device, wait func(int64)) (*Result, error) {
	err := m.Validate(DeviceAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Device", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *DeviceStore) Update(ctx context.Context, m *Device, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Device", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur Device
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *DeviceStore) Put(ctx context.Context, m *Device, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(DeviceAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Device", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *DeviceStore) Delete(ctx context.Context, m *Device, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Device", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *DeviceStore) LoadOne(key string) (*Device, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj Device
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse Device data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *DeviceStore) STMGet(stm concurrency.STM, key *DeviceKey, buf *Device) bool {
	keystr := objstore.DbKeyString("Device", key)
	valstr := stm.Get(keystr)
	if valstr == "" {
		return false
	}
	if buf != nil {
		err := json.Unmarshal([]byte(valstr), buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *DeviceStore) STMPut(stm concurrency.STM, obj *Device, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("Device", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("Device json marsahal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *DeviceStore) STMDel(stm concurrency.STM, key *DeviceKey) {
	keystr := objstore.DbKeyString("Device", key)
	stm.Del(keystr)
}

type DeviceKeyWatcher struct {
	cb func(ctx context.Context)
}

type DeviceCacheData struct {
	Obj    *Device
	ModRev int64
}

// DeviceCache caches Device objects in memory in a hash table
// and keeps them in sync with the database.
type DeviceCache struct {
	Objs          map[DeviceKey]*DeviceCacheData
	Mux           util.Mutex
	List          map[DeviceKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *DeviceKey, old *Device, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *Device, new *Device)
	DeletedCbs    []func(ctx context.Context, old *Device)
	KeyWatchers   map[DeviceKey][]*DeviceKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *DeviceKey)
	DeletedKeyCbs []func(ctx context.Context, key *DeviceKey)
}

func NewDeviceCache() *DeviceCache {
	cache := DeviceCache{}
	InitDeviceCache(&cache)
	return &cache
}

func InitDeviceCache(cache *DeviceCache) {
	cache.Objs = make(map[DeviceKey]*DeviceCacheData)
	cache.KeyWatchers = make(map[DeviceKey][]*DeviceKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *DeviceCache) GetTypeString() string {
	return "Device"
}

func (c *DeviceCache) Get(key *DeviceKey, valbuf *Device) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *DeviceCache) GetWithRev(key *DeviceKey, valbuf *Device, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *DeviceCache) HasKey(key *DeviceKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *DeviceCache) GetAllKeys(ctx context.Context, cb func(key *DeviceKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *DeviceCache) Update(ctx context.Context, in *Device, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *Device) (*Device, bool) {
		return in, true
	})
}

func (c *DeviceCache) UpdateModFunc(ctx context.Context, key *DeviceKey, modRev int64, modFunc func(old *Device) (new *Device, changed bool)) {
	c.Mux.Lock()
	var old *Device
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	for _, cb := range c.UpdatedCbs {
		newCopy := &Device{}
		newCopy.DeepCopyIn(new)
		defer cb(ctx, old, newCopy)
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			defer cb(ctx, new.GetKey(), old, modRev)
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &Device{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &DeviceCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *DeviceCache) Delete(ctx context.Context, in *Device, modRev int64) {
	c.Mux.Lock()
	var old *Device
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	c.Mux.Unlock()
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, in.GetKey(), old, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *DeviceCache) Prune(ctx context.Context, validKeys map[DeviceKey]struct{}) {
	notify := make(map[DeviceKey]*DeviceCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, old.Obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *DeviceCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *DeviceCache) Flush(ctx context.Context, notifyId int64) {
	log.SpanLog(ctx, log.DebugLevelApi, "CacheFlush Device", "notifyId", notifyId, "FlushAll", c.FlushAll)
	flushed := make(map[DeviceKey]*DeviceCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if !c.FlushAll && val.Obj.NotifyId != notifyId {
			continue
		}
		flushed[key] = c.Objs[key]
		log.SpanLog(ctx, log.DebugLevelApi, "CacheFlush Device delete", "key", key)
		delete(c.Objs, key)
	}
	c.Mux.Unlock()
	if len(flushed) > 0 {
		for key, old := range flushed {
			for _, cb := range c.NotifyCbs {
				if cb != nil {
					cb(ctx, &key, old.Obj, old.ModRev)
				}
			}
			for _, cb := range c.DeletedKeyCbs {
				cb(ctx, &key)
			}
			if old.Obj != nil {
				for _, cb := range c.DeletedCbs {
					cb(ctx, old.Obj)
				}
			}
			c.TriggerKeyWatchers(ctx, &key)
		}
	}
}

func (c *DeviceCache) Show(filter *Device, cb func(ret *Device) error) error {
	log.DebugLog(log.DebugLevelApi, "Show Device", "count", len(c.Objs))
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		log.DebugLog(log.DebugLevelApi, "Compare Device", "filter", filter, "data", data)
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		log.DebugLog(log.DebugLevelApi, "Show Device", "obj", data.Obj)
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func DeviceGenericNotifyCb(fn func(key *DeviceKey, old *Device)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*DeviceKey), obj.(*Device))
	}
}

func (c *DeviceCache) SetNotifyCb(fn func(ctx context.Context, obj *DeviceKey, old *Device, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *DeviceKey, old *Device, modRev int64){fn}
}

func (c *DeviceCache) SetUpdatedCb(fn func(ctx context.Context, old *Device, new *Device)) {
	c.UpdatedCbs = []func(ctx context.Context, old *Device, new *Device){fn}
}

func (c *DeviceCache) SetDeletedCb(fn func(ctx context.Context, old *Device)) {
	c.DeletedCbs = []func(ctx context.Context, old *Device){fn}
}

func (c *DeviceCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *DeviceKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *DeviceKey){fn}
}

func (c *DeviceCache) SetDeletedKeyCb(fn func(ctx context.Context, key *DeviceKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *DeviceKey){fn}
}

func (c *DeviceCache) AddUpdatedCb(fn func(ctx context.Context, old *Device, new *Device)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *DeviceCache) AddDeletedCb(fn func(ctx context.Context, old *Device)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *DeviceCache) AddNotifyCb(fn func(ctx context.Context, obj *DeviceKey, old *Device, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *DeviceCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *DeviceKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *DeviceCache) AddDeletedKeyCb(fn func(ctx context.Context, key *DeviceKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *DeviceCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *DeviceCache) WatchKey(key *DeviceKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*DeviceKeyWatcher, 0)
	}
	watcher := DeviceKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching Device", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *DeviceCache) TriggerKeyWatchers(ctx context.Context, key *DeviceKey) {
	watchers := make([]*DeviceKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *DeviceCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := Device{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse Device data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *DeviceCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := Device{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	DeviceKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *DeviceCache) SyncListStart(ctx context.Context) {
	c.List = make(map[DeviceKey]struct{})
}

func (c *DeviceCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[DeviceKey]*DeviceCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, val.Obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *DeviceCache) UsesOrg(org string) bool {
	return false
}

func (m *Device) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *Device) GetKey() *DeviceKey {
	return &m.Key
}

func (m *Device) GetKeyVal() DeviceKey {
	return m.Key
}

func (m *Device) SetKey(key *DeviceKey) {
	m.Key = *key
}

func CmpSortDevice(a Device, b Device) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *Device) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func IgnoreDeviceFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "NotifyId")
	}
	return cmpopts.IgnoreFields(Device{}, names...)
}

func (m *DeviceReport) Size() (n int) {
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovDevice(uint64(l))
	if m.Begin != nil {
		l = m.Begin.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceKey) Size() (n int) {
	var l int
	_ = l
	l = len(m.UniqueIdType)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.UniqueId)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *Device) Size() (n int) {
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovDevice(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovDevice(uint64(l))
	if m.FirstSeen != nil {
		l = m.FirstSeen.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.LastSeen != nil {
		l = m.LastSeen.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.NotifyId != 0 {
		n += 1 + sovDevice(uint64(m.NotifyId))
	}
	return n
}

func sovDevice(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDevice(x uint64) (n int) {
	return sovDevice(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DeviceReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Begin == nil {
				m.Begin = &google_protobuf1.Timestamp{}
			}
			if err := m.Begin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &google_protobuf1.Timestamp{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueIdType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueIdType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Device) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Device: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Device: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstSeen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FirstSeen == nil {
				m.FirstSeen = &google_protobuf1.Timestamp{}
			}
			if err := m.FirstSeen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSeen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastSeen == nil {
				m.LastSeen = &google_protobuf1.Timestamp{}
			}
			if err := m.LastSeen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyId", wireType)
			}
			m.NotifyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotifyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDevice(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDevice
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDevice
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDevice(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDevice = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDevice   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("device.proto", fileDescriptorDevice) }

var fileDescriptorDevice = []byte{
	// 633 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x93, 0xc1, 0x4f, 0xd4, 0x4e,
	0x14, 0xc7, 0x99, 0xdd, 0x85, 0xd0, 0xa1, 0x3f, 0x02, 0xfd, 0x11, 0x19, 0x37, 0x64, 0xd9, 0xf4,
	0x60, 0xd0, 0x60, 0x4b, 0x30, 0x2a, 0xac, 0x27, 0x56, 0x3d, 0x10, 0xe3, 0xa5, 0x10, 0xaf, 0xa4,
	0xdb, 0xbe, 0x2d, 0x23, 0xbb, 0x33, 0xb5, 0x9d, 0x82, 0x9b, 0x68, 0x62, 0x3c, 0x7b, 0x30, 0xfa,
	0x0f, 0x10, 0xff, 0x02, 0xc3, 0x91, 0xbf, 0x80, 0xa3, 0x89, 0x07, 0x6f, 0x06, 0x89, 0x07, 0xc3,
	0xc9, 0x84, 0x86, 0x78, 0x34, 0x33, 0x6d, 0x17, 0x12, 0x48, 0x58, 0x2f, 0xcd, 0x9b, 0x37, 0x9f,
	0xf7, 0xbe, 0xf3, 0x7d, 0xd3, 0xc1, 0xba, 0x0f, 0xdb, 0xd4, 0x03, 0x2b, 0x8c, 0xb8, 0xe0, 0x86,
	0x06, 0x7e, 0x00, 0x2a, 0xac, 0xce, 0x04, 0x9c, 0x07, 0x1d, 0xb0, 0xdd, 0x90, 0xda, 0x2e, 0x63,
	0x5c, 0xb8, 0x82, 0x72, 0x16, 0x67, 0x60, 0x75, 0x29, 0xa0, 0x62, 0x33, 0x69, 0x59, 0x1e, 0xef,
	0xda, 0x5d, 0xde, 0xa2, 0x1d, 0x59, 0xf8, 0xd2, 0x96, 0xdf, 0xdb, 0x5e, 0x87, 0x27, 0xbe, 0xad,
	0xb8, 0x00, 0x58, 0x3f, 0xc8, 0x2b, 0xa7, 0x02, 0x1e, 0x70, 0x15, 0xda, 0x32, 0xca, 0xb3, 0x7a,
	0x04, 0x71, 0xd2, 0x11, 0xf9, 0x6a, 0x36, 0xd7, 0x56, 0xab, 0x56, 0xd2, 0xb6, 0x05, 0xed, 0x42,
	0x2c, 0xdc, 0x6e, 0x98, 0x01, 0xe6, 0x27, 0x84, 0xf5, 0x47, 0xea, 0xe0, 0x0e, 0x84, 0x3c, 0x12,
	0xc6, 0x3c, 0x2e, 0x6f, 0x41, 0x8f, 0xa0, 0x3a, 0x9a, 0x1b, 0x5b, 0x9c, 0xb2, 0xfa, 0x36, 0xac,
	0x8c, 0x7a, 0x02, 0xbd, 0x66, 0xe5, 0xe0, 0xfb, 0xec, 0x90, 0x23, 0x31, 0x63, 0x01, 0x0f, 0xb7,
	0x20, 0xa0, 0x8c, 0x94, 0x14, 0x5f, 0xb5, 0x32, 0x3d, 0xab, 0xd0, 0xb3, 0xd6, 0x0b, 0x3d, 0x27,
	0x03, 0x65, 0x7f, 0x60, 0x3e, 0x29, 0x5f, 0xc9, 0x4b, 0xac, 0x51, 0xf9, 0x7d, 0x42, 0x90, 0xf9,
	0x0a, 0x6b, 0x7d, 0x75, 0xe3, 0x1e, 0x1e, 0x4f, 0x18, 0x7d, 0x91, 0xc0, 0x06, 0xf5, 0x37, 0x44,
	0x2f, 0x04, 0x75, 0x56, 0xad, 0x39, 0xb1, 0x7f, 0x4a, 0xf2, 0x3b, 0xa0, 0xbe, 0xcc, 0x3b, 0x7a,
	0xc6, 0xad, 0xfa, 0xeb, 0xbd, 0x10, 0x8c, 0x9b, 0x58, 0xeb, 0xd7, 0xa9, 0xe3, 0x6a, 0x4d, 0x7d,
	0xff, 0x94, 0x8c, 0x16, 0x25, 0xce, 0x68, 0x81, 0x37, 0xf4, 0x5f, 0x27, 0x04, 0xfd, 0x39, 0x21,
	0xe8, 0xf3, 0xee, 0x2c, 0x32, 0xdf, 0x95, 0xf0, 0x48, 0x26, 0x6f, 0x5c, 0xc3, 0x23, 0x6d, 0x0a,
	0x1d, 0x3f, 0x26, 0xa8, 0x5e, 0x9e, 0xd3, 0x9c, 0x7c, 0x55, 0x0c, 0xad, 0x34, 0xd8, 0xd0, 0x96,
	0x31, 0x6e, 0xd3, 0x28, 0x16, 0x1b, 0x31, 0x00, 0x1b, 0x60, 0x12, 0x9a, 0xa2, 0xd7, 0x00, 0x98,
	0x71, 0x1f, 0x6b, 0x1d, 0xb7, 0xa8, 0xac, 0x5c, 0x59, 0x39, 0x2a, 0x61, 0x55, 0x78, 0x03, 0x6b,
	0x8c, 0x0b, 0xda, 0xee, 0x49, 0xf7, 0xc3, 0x75, 0x34, 0x57, 0x6e, 0x6a, 0x1f, 0xf6, 0xae, 0x0f,
	0x33, 0xee, 0x49, 0x2e, 0xdb, 0x5b, 0xf5, 0x1b, 0x75, 0x69, 0x5d, 0x0e, 0xfd, 0x4d, 0x4a, 0xd0,
	0xfb, 0x94, 0xa0, 0xdd, 0x94, 0xa0, 0xc3, 0x94, 0xa0, 0xbd, 0x53, 0x52, 0x61, 0x9c, 0xc1, 0xe2,
	0xb7, 0x72, 0x71, 0x1b, 0x2b, 0x21, 0x35, 0x38, 0xd6, 0x57, 0xd9, 0x73, 0xf0, 0x44, 0x3e, 0xa1,
	0xc9, 0x0b, 0xe6, 0xab, 0xe7, 0x53, 0x8e, 0xfa, 0x39, 0xcd, 0xe5, 0xe3, 0x94, 0xcc, 0x38, 0x10,
	0xf3, 0x24, 0xf2, 0xe0, 0x21, 0x67, 0x6d, 0x1a, 0xcc, 0xaf, 0x78, 0xf2, 0x59, 0x3c, 0x75, 0x99,
	0x1b, 0xc0, 0xfc, 0xdb, 0xaf, 0x3f, 0x3f, 0x96, 0xfe, 0x37, 0xc7, 0x6d, 0x2f, 0x02, 0x57, 0x80,
	0x9d, 0x5d, 0x52, 0x03, 0xdd, 0x32, 0xb6, 0x30, 0x5e, 0xdb, 0xe4, 0x3b, 0x83, 0xc9, 0x65, 0x29,
	0xf3, 0xee, 0x71, 0x4a, 0xaa, 0x97, 0xca, 0x3d, 0xa3, 0xb0, 0x93, 0x89, 0x4d, 0x9a, 0xba, 0x1d,
	0x6f, 0xf2, 0x9d, 0x33, 0xa9, 0x05, 0x64, 0x74, 0xf1, 0xd8, 0xe3, 0x6d, 0xfa, 0x8f, 0xe6, 0x96,
	0x06, 0x32, 0x67, 0x98, 0xff, 0xd9, 0xb2, 0x85, 0x38, 0xe7, 0xed, 0x35, 0x9e, 0x38, 0xf3, 0x96,
	0xbf, 0xc7, 0xe9, 0x0b, 0x9a, 0xd9, 0xc6, 0x65, 0x3e, 0x1f, 0x0c, 0xe0, 0x73, 0xda, 0x34, 0xce,
	0xfb, 0x8c, 0x54, 0x33, 0xe5, 0xb6, 0x39, 0x71, 0xf0, 0xa3, 0x36, 0x74, 0x70, 0x54, 0x43, 0x5f,
	0x8e, 0x6a, 0xe8, 0xf0, 0xa8, 0x86, 0x5a, 0x23, 0xaa, 0xfd, 0x9d, 0xbf, 0x01, 0x00, 0x00, 0xff,
	0xff, 0x9d, 0xea, 0xbc, 0x67, 0xdc, 0x04, 0x00, 0x00,
}
