// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: device.proto

package edgeproto

import (
	context "context"
	"encoding/json"
	fmt "fmt"
	"github.com/coreos/etcd/clientv3/concurrency"
	"github.com/edgexr/edge-cloud/log"
	"github.com/edgexr/edge-cloud/objstore"
	_ "github.com/edgexr/edge-cloud/protogen"
	"github.com/edgexr/edge-cloud/util"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	google_protobuf "github.com/gogo/protobuf/types"
	types "github.com/gogo/protobuf/types"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// DeviceReport is a reporting message. It takes a begining and end time
// for the report
type DeviceReport struct {
	// Device Key
	Key DeviceKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
	// Timestamp of the beginning of the report
	Begin *types.Timestamp `protobuf:"bytes,2,opt,name=begin,proto3" json:"begin,omitempty"`
	// Timestamp of the beginning of the report
	End *types.Timestamp `protobuf:"bytes,3,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *DeviceReport) Reset()         { *m = DeviceReport{} }
func (m *DeviceReport) String() string { return proto.CompactTextString(m) }
func (*DeviceReport) ProtoMessage()    {}
func (*DeviceReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{0}
}
func (m *DeviceReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceReport.Merge(m, src)
}
func (m *DeviceReport) XXX_Size() int {
	return m.Size()
}
func (m *DeviceReport) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceReport.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceReport proto.InternalMessageInfo

// DeviceKey is an identifier for a given device on the MobiledgeX platform
// It is defined by a unique id and unique id type
// And example of such a device is a MEL device that hosts several applications
type DeviceKey struct {
	// Type of unique ID provided by the client
	UniqueIdType string `protobuf:"bytes,1,opt,name=unique_id_type,json=uniqueIdType,proto3" json:"unique_id_type,omitempty"`
	// Unique identification of the client device or user. May be overridden by the server.
	UniqueId string `protobuf:"bytes,2,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
}

func (m *DeviceKey) Reset()         { *m = DeviceKey{} }
func (m *DeviceKey) String() string { return proto.CompactTextString(m) }
func (*DeviceKey) ProtoMessage()    {}
func (*DeviceKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{1}
}
func (m *DeviceKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceKey.Merge(m, src)
}
func (m *DeviceKey) XXX_Size() int {
	return m.Size()
}
func (m *DeviceKey) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceKey.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceKey proto.InternalMessageInfo

// Device represents a device on the MobiledgeX platform
// We record when this device first showed up on our platform
type Device struct {
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Key
	Key DeviceKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// Timestamp when the device was registered
	FirstSeen *types.Timestamp `protobuf:"bytes,3,opt,name=first_seen,json=firstSeen,proto3" json:"first_seen,omitempty"`
	// Timestamp when the device was last seen(Future use)
	LastSeen *types.Timestamp `protobuf:"bytes,4,opt,name=last_seen,json=lastSeen,proto3" json:"last_seen,omitempty"`
	// Id of client assigned by server (internal use only)
	NotifyId int64 `protobuf:"varint,5,opt,name=notify_id,json=notifyId,proto3" json:"notify_id,omitempty"`
}

func (m *Device) Reset()         { *m = Device{} }
func (m *Device) String() string { return proto.CompactTextString(m) }
func (*Device) ProtoMessage()    {}
func (*Device) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{2}
}
func (m *Device) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Device) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Device.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Device) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Device.Merge(m, src)
}
func (m *Device) XXX_Size() int {
	return m.Size()
}
func (m *Device) XXX_DiscardUnknown() {
	xxx_messageInfo_Device.DiscardUnknown(m)
}

var xxx_messageInfo_Device proto.InternalMessageInfo

type DeviceData struct {
	Devices []Device `protobuf:"bytes,1,rep,name=devices,proto3" json:"devices"`
}

func (m *DeviceData) Reset()         { *m = DeviceData{} }
func (m *DeviceData) String() string { return proto.CompactTextString(m) }
func (*DeviceData) ProtoMessage()    {}
func (*DeviceData) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{3}
}
func (m *DeviceData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceData.Merge(m, src)
}
func (m *DeviceData) XXX_Size() int {
	return m.Size()
}
func (m *DeviceData) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceData.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceData proto.InternalMessageInfo

func init() {
	proto.RegisterType((*DeviceReport)(nil), "edgeproto.DeviceReport")
	proto.RegisterType((*DeviceKey)(nil), "edgeproto.DeviceKey")
	proto.RegisterType((*Device)(nil), "edgeproto.Device")
	proto.RegisterType((*DeviceData)(nil), "edgeproto.DeviceData")
}

func init() { proto.RegisterFile("device.proto", fileDescriptor_870276a56ac00da5) }

var fileDescriptor_870276a56ac00da5 = []byte{
	// 683 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x53, 0x4f, 0x4f, 0x13, 0x4f,
	0x18, 0xee, 0xb4, 0x85, 0x5f, 0x77, 0x58, 0x08, 0xec, 0x8f, 0xc8, 0xd8, 0x90, 0xd2, 0xec, 0x09,
	0x09, 0x76, 0x11, 0xff, 0x44, 0xeb, 0x89, 0x8a, 0x87, 0xc6, 0x78, 0x59, 0x88, 0x57, 0xb2, 0xdd,
	0x7d, 0xbb, 0x8c, 0xb4, 0x33, 0xeb, 0xee, 0x16, 0x6c, 0xa2, 0x89, 0xf1, 0x13, 0x10, 0xbd, 0x78,
	0x24, 0x1e, 0x8c, 0x47, 0xc3, 0x91, 0x4f, 0xc0, 0x91, 0xc4, 0x83, 0x9e, 0x0c, 0x82, 0x07, 0xc3,
	0xc9, 0x84, 0xa6, 0xf1, 0x68, 0x76, 0x66, 0xb7, 0x34, 0x81, 0x84, 0x72, 0xda, 0x77, 0xde, 0x7d,
	0xde, 0xe7, 0x79, 0x9f, 0x67, 0x32, 0x58, 0x75, 0x60, 0x93, 0xda, 0x50, 0xf2, 0x7c, 0x1e, 0x72,
	0x4d, 0x01, 0xc7, 0x05, 0x51, 0xe6, 0xa7, 0x5d, 0xce, 0xdd, 0x06, 0x18, 0x96, 0x47, 0x0d, 0x8b,
	0x31, 0x1e, 0x5a, 0x21, 0xe5, 0x2c, 0x90, 0xc0, 0xfc, 0x1d, 0x97, 0x86, 0xeb, 0xad, 0x5a, 0xc9,
	0xe6, 0x4d, 0x23, 0x9a, 0x79, 0xe9, 0x8b, 0xcf, 0x4d, 0xbb, 0xc1, 0x5b, 0x8e, 0x21, 0x30, 0x2e,
	0xb0, 0x5e, 0x11, 0x4f, 0x4d, 0xba, 0xdc, 0xe5, 0xa2, 0x34, 0xa2, 0x2a, 0xee, 0xaa, 0x3e, 0x04,
	0xad, 0x46, 0x18, 0x9f, 0x66, 0x62, 0x5d, 0x71, 0xaa, 0xb5, 0xea, 0x46, 0x48, 0x9b, 0x10, 0x84,
	0x56, 0xd3, 0x93, 0x00, 0xfd, 0x23, 0xc2, 0xea, 0xb2, 0x58, 0xda, 0x04, 0x8f, 0xfb, 0xa1, 0x36,
	0x8f, 0x33, 0x1b, 0xd0, 0x26, 0xa8, 0x88, 0x66, 0x47, 0x16, 0x27, 0x4b, 0x3d, 0x0b, 0x25, 0x89,
	0x7a, 0x02, 0xed, 0x4a, 0x76, 0xff, 0xc7, 0x4c, 0xca, 0x8c, 0x60, 0xda, 0x02, 0x1e, 0xaa, 0x81,
	0x4b, 0x19, 0x49, 0x0b, 0x7c, 0xbe, 0x24, 0xf5, 0x4a, 0x89, 0x5e, 0x69, 0x35, 0xd1, 0x33, 0x25,
	0x30, 0xe2, 0x07, 0xe6, 0x90, 0xcc, 0xa5, 0xf8, 0x08, 0x56, 0xce, 0xfe, 0x39, 0x25, 0x48, 0x7f,
	0x85, 0x95, 0x9e, 0xba, 0x76, 0x0f, 0x8f, 0xb5, 0x18, 0x7d, 0xd1, 0x82, 0x35, 0xea, 0xac, 0x85,
	0x6d, 0x0f, 0xc4, 0xae, 0x4a, 0x65, 0x7c, 0xaf, 0x4b, 0xe2, 0xfc, 0xa9, 0x13, 0xf5, 0x4d, 0x55,
	0xe2, 0xaa, 0xce, 0x6a, 0xdb, 0x03, 0xed, 0x06, 0x56, 0x7a, 0x73, 0x62, 0x5d, 0xa5, 0xa2, 0xee,
	0x75, 0x49, 0x2e, 0x19, 0x31, 0x73, 0x09, 0xbc, 0xac, 0xfe, 0x3e, 0x25, 0xe8, 0xef, 0x29, 0x41,
	0x5f, 0x76, 0x66, 0x90, 0xfe, 0x29, 0x8d, 0x87, 0xa5, 0xbc, 0x76, 0x0d, 0x0f, 0xd7, 0x29, 0x34,
	0x9c, 0x80, 0xa0, 0x62, 0x66, 0x56, 0x31, 0xe3, 0x53, 0x12, 0x5a, 0x7a, 0xb0, 0xd0, 0x96, 0x31,
	0xae, 0x53, 0x3f, 0x08, 0xd7, 0x02, 0x00, 0x76, 0x79, 0x12, 0x15, 0xe5, 0xdd, 0xee, 0xf5, 0x21,
	0xc6, 0xed, 0xa6, 0x67, 0x2a, 0x62, 0x70, 0x05, 0x80, 0x69, 0x15, 0xac, 0x34, 0xac, 0x84, 0x24,
	0x7b, 0x15, 0x92, 0x5c, 0x34, 0x27, 0x38, 0xe6, 0xb0, 0xc2, 0x78, 0x48, 0xeb, 0xed, 0x28, 0x93,
	0xa1, 0x22, 0x9a, 0xcd, 0x54, 0x46, 0x3f, 0x77, 0x08, 0xea, 0xc3, 0xca, 0xff, 0x55, 0xa7, 0x5c,
	0x8c, 0x42, 0x89, 0xae, 0xe3, 0x4d, 0x87, 0xa0, 0xed, 0x0e, 0x41, 0x3b, 0x1d, 0x82, 0x0e, 0x3b,
	0x04, 0xed, 0x76, 0x49, 0x96, 0x71, 0x06, 0x7a, 0x15, 0x63, 0xe9, 0x77, 0xd9, 0x0a, 0x2d, 0xed,
	0x16, 0xfe, 0x4f, 0x46, 0x2b, 0xc3, 0x1a, 0x59, 0x9c, 0x38, 0x97, 0x4b, 0x1c, 0x4a, 0x82, 0x2b,
	0xe7, 0x3e, 0x74, 0x09, 0xda, 0xe9, 0x92, 0xd4, 0xe2, 0xb7, 0x4c, 0x72, 0xe5, 0x4b, 0x1e, 0xd5,
	0x38, 0x56, 0xab, 0xec, 0x39, 0xd8, 0x61, 0x7c, 0x0d, 0xe7, 0x99, 0xf2, 0xfd, 0x2d, 0x53, 0xbc,
	0x00, 0xfd, 0xc1, 0x49, 0x87, 0x4c, 0x9b, 0x10, 0xf0, 0x96, 0x6f, 0xc3, 0x23, 0xce, 0xea, 0xd4,
	0x9d, 0x5f, 0xb2, 0xa3, 0x77, 0xf7, 0xd4, 0x62, 0x96, 0x0b, 0xf3, 0x6f, 0xbf, 0xfe, 0x7a, 0x9f,
	0xfe, 0x5f, 0x1f, 0x33, 0x6c, 0x1f, 0xac, 0x10, 0x0c, 0xb9, 0x46, 0x19, 0xcd, 0x69, 0x1b, 0x18,
	0xaf, 0xac, 0xf3, 0xad, 0xc1, 0xe4, 0x64, 0x4b, 0xbf, 0x7b, 0xd2, 0x21, 0xf9, 0x0b, 0xe5, 0x9e,
	0x51, 0xd8, 0x92, 0x62, 0x13, 0xba, 0x6a, 0x04, 0xeb, 0x7c, 0xeb, 0x4c, 0x6a, 0x01, 0x69, 0x4d,
	0x3c, 0xf2, 0x78, 0x93, 0x5e, 0xd1, 0xdc, 0xfd, 0x81, 0xcc, 0x69, 0xfa, 0xa8, 0x11, 0x51, 0x84,
	0x7d, 0xde, 0x5e, 0xe3, 0xf1, 0x33, 0x6f, 0xf1, 0xa3, 0x9f, 0x3a, 0xa7, 0x29, 0x7f, 0x5c, 0xe4,
	0xf3, 0xe1, 0x00, 0x3e, 0xa7, 0x74, 0xad, 0xdf, 0xa7, 0x2f, 0xc8, 0x84, 0xdb, 0xca, 0xf4, 0xfe,
	0xcf, 0x42, 0x6a, 0xff, 0xa8, 0x80, 0x0e, 0x8e, 0x0a, 0xe8, 0xf0, 0xa8, 0x80, 0xb6, 0x8f, 0x0b,
	0xa9, 0x83, 0xe3, 0x42, 0xea, 0xfb, 0x71, 0x21, 0x55, 0x1b, 0x16, 0x52, 0xb7, 0xff, 0x05, 0x00,
	0x00, 0xff, 0xff, 0x47, 0x4b, 0x82, 0xf5, 0x49, 0x05, 0x00, 0x00,
}

func (this *DeviceKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&edgeproto.DeviceKey{")
	s = append(s, "UniqueIdType: "+fmt.Sprintf("%#v", this.UniqueIdType)+",\n")
	s = append(s, "UniqueId: "+fmt.Sprintf("%#v", this.UniqueId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringDevice(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DeviceApiClient is the client API for DeviceApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DeviceApiClient interface {
	// Inject a device
	InjectDevice(ctx context.Context, in *Device, opts ...grpc.CallOption) (*Result, error)
	// Show devices
	ShowDevice(ctx context.Context, in *Device, opts ...grpc.CallOption) (DeviceApi_ShowDeviceClient, error)
	// Evict a device
	EvictDevice(ctx context.Context, in *Device, opts ...grpc.CallOption) (*Result, error)
	// Device Reports API.
	ShowDeviceReport(ctx context.Context, in *DeviceReport, opts ...grpc.CallOption) (DeviceApi_ShowDeviceReportClient, error)
}

type deviceApiClient struct {
	cc *grpc.ClientConn
}

func NewDeviceApiClient(cc *grpc.ClientConn) DeviceApiClient {
	return &deviceApiClient{cc}
}

func (c *deviceApiClient) InjectDevice(ctx context.Context, in *Device, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.DeviceApi/InjectDevice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceApiClient) ShowDevice(ctx context.Context, in *Device, opts ...grpc.CallOption) (DeviceApi_ShowDeviceClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DeviceApi_serviceDesc.Streams[0], "/edgeproto.DeviceApi/ShowDevice", opts...)
	if err != nil {
		return nil, err
	}
	x := &deviceApiShowDeviceClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DeviceApi_ShowDeviceClient interface {
	Recv() (*Device, error)
	grpc.ClientStream
}

type deviceApiShowDeviceClient struct {
	grpc.ClientStream
}

func (x *deviceApiShowDeviceClient) Recv() (*Device, error) {
	m := new(Device)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *deviceApiClient) EvictDevice(ctx context.Context, in *Device, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.DeviceApi/EvictDevice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceApiClient) ShowDeviceReport(ctx context.Context, in *DeviceReport, opts ...grpc.CallOption) (DeviceApi_ShowDeviceReportClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DeviceApi_serviceDesc.Streams[1], "/edgeproto.DeviceApi/ShowDeviceReport", opts...)
	if err != nil {
		return nil, err
	}
	x := &deviceApiShowDeviceReportClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DeviceApi_ShowDeviceReportClient interface {
	Recv() (*Device, error)
	grpc.ClientStream
}

type deviceApiShowDeviceReportClient struct {
	grpc.ClientStream
}

func (x *deviceApiShowDeviceReportClient) Recv() (*Device, error) {
	m := new(Device)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DeviceApiServer is the server API for DeviceApi service.
type DeviceApiServer interface {
	// Inject a device
	InjectDevice(context.Context, *Device) (*Result, error)
	// Show devices
	ShowDevice(*Device, DeviceApi_ShowDeviceServer) error
	// Evict a device
	EvictDevice(context.Context, *Device) (*Result, error)
	// Device Reports API.
	ShowDeviceReport(*DeviceReport, DeviceApi_ShowDeviceReportServer) error
}

// UnimplementedDeviceApiServer can be embedded to have forward compatible implementations.
type UnimplementedDeviceApiServer struct {
}

func (*UnimplementedDeviceApiServer) InjectDevice(ctx context.Context, req *Device) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InjectDevice not implemented")
}
func (*UnimplementedDeviceApiServer) ShowDevice(req *Device, srv DeviceApi_ShowDeviceServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowDevice not implemented")
}
func (*UnimplementedDeviceApiServer) EvictDevice(ctx context.Context, req *Device) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvictDevice not implemented")
}
func (*UnimplementedDeviceApiServer) ShowDeviceReport(req *DeviceReport, srv DeviceApi_ShowDeviceReportServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowDeviceReport not implemented")
}

func RegisterDeviceApiServer(s *grpc.Server, srv DeviceApiServer) {
	s.RegisterService(&_DeviceApi_serviceDesc, srv)
}

func _DeviceApi_InjectDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceApiServer).InjectDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.DeviceApi/InjectDevice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceApiServer).InjectDevice(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceApi_ShowDevice_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Device)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DeviceApiServer).ShowDevice(m, &deviceApiShowDeviceServer{stream})
}

type DeviceApi_ShowDeviceServer interface {
	Send(*Device) error
	grpc.ServerStream
}

type deviceApiShowDeviceServer struct {
	grpc.ServerStream
}

func (x *deviceApiShowDeviceServer) Send(m *Device) error {
	return x.ServerStream.SendMsg(m)
}

func _DeviceApi_EvictDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceApiServer).EvictDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.DeviceApi/EvictDevice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceApiServer).EvictDevice(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceApi_ShowDeviceReport_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DeviceReport)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DeviceApiServer).ShowDeviceReport(m, &deviceApiShowDeviceReportServer{stream})
}

type DeviceApi_ShowDeviceReportServer interface {
	Send(*Device) error
	grpc.ServerStream
}

type deviceApiShowDeviceReportServer struct {
	grpc.ServerStream
}

func (x *deviceApiShowDeviceReportServer) Send(m *Device) error {
	return x.ServerStream.SendMsg(m)
}

var _DeviceApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.DeviceApi",
	HandlerType: (*DeviceApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InjectDevice",
			Handler:    _DeviceApi_InjectDevice_Handler,
		},
		{
			MethodName: "EvictDevice",
			Handler:    _DeviceApi_EvictDevice_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowDevice",
			Handler:       _DeviceApi_ShowDevice_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowDeviceReport",
			Handler:       _DeviceApi_ShowDeviceReport_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "device.proto",
}

func (m *DeviceReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Begin != nil {
		{
			size, err := m.Begin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintDevice(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeviceKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UniqueId) > 0 {
		i -= len(m.UniqueId)
		copy(dAtA[i:], m.UniqueId)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.UniqueId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UniqueIdType) > 0 {
		i -= len(m.UniqueIdType)
		copy(dAtA[i:], m.UniqueIdType)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.UniqueIdType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Device) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Device) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Device) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NotifyId != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.NotifyId))
		i--
		dAtA[i] = 0x28
	}
	if m.LastSeen != nil {
		{
			size, err := m.LastSeen.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.FirstSeen != nil {
		{
			size, err := m.FirstSeen.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintDevice(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintDevice(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeviceData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Devices) > 0 {
		for iNdEx := len(m.Devices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Devices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDevice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintDevice(dAtA []byte, offset int, v uint64) int {
	offset -= sovDevice(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DeviceReport) CopyInFields(src *DeviceReport) int {
	changed := 0
	if m.Key.UniqueIdType != src.Key.UniqueIdType {
		m.Key.UniqueIdType = src.Key.UniqueIdType
		changed++
	}
	if m.Key.UniqueId != src.Key.UniqueId {
		m.Key.UniqueId = src.Key.UniqueId
		changed++
	}
	if src.Begin != nil {
		if m.Begin == nil {
			m.Begin = &google_protobuf.Timestamp{}
		}
		if m.Begin.Seconds != src.Begin.Seconds {
			m.Begin.Seconds = src.Begin.Seconds
			changed++
		}
		if m.Begin.Nanos != src.Begin.Nanos {
			m.Begin.Nanos = src.Begin.Nanos
			changed++
		}
	} else if m.Begin != nil {
		m.Begin = nil
		changed++
	}
	if src.End != nil {
		if m.End == nil {
			m.End = &google_protobuf.Timestamp{}
		}
		if m.End.Seconds != src.End.Seconds {
			m.End.Seconds = src.End.Seconds
			changed++
		}
		if m.End.Nanos != src.End.Nanos {
			m.End.Nanos = src.End.Nanos
			changed++
		}
	} else if m.End != nil {
		m.End = nil
		changed++
	}
	return changed
}

func (m *DeviceReport) DeepCopyIn(src *DeviceReport) {
	m.Key.DeepCopyIn(&src.Key)
	if src.Begin != nil {
		var tmp_Begin google_protobuf.Timestamp
		tmp_Begin = *src.Begin
		m.Begin = &tmp_Begin
	} else {
		m.Begin = nil
	}
	if src.End != nil {
		var tmp_End google_protobuf.Timestamp
		tmp_End = *src.End
		m.End = &tmp_End
	} else {
		m.End = nil
	}
}

func (s *DeviceReport) HasFields() bool {
	return false
}

type DeviceReportStore interface {
	Create(ctx context.Context, m *DeviceReport, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *DeviceReport, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *DeviceReport, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *DeviceReport, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*DeviceReport, int64, error)
	Get(ctx context.Context, key *DeviceKey, buf *DeviceReport) bool
	STMGet(stm concurrency.STM, key *DeviceKey, buf *DeviceReport) bool
	STMPut(stm concurrency.STM, obj *DeviceReport, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *DeviceKey)
}

type DeviceReportStoreImpl struct {
	kvstore objstore.KVStore
}

func NewDeviceReportStore(kvstore objstore.KVStore) *DeviceReportStoreImpl {
	return &DeviceReportStoreImpl{kvstore: kvstore}
}

func (s *DeviceReportStoreImpl) Create(ctx context.Context, m *DeviceReport, wait func(int64)) (*Result, error) {
	err := m.Validate(nil)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("DeviceReport", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *DeviceReportStoreImpl) Update(ctx context.Context, m *DeviceReport, wait func(int64)) (*Result, error) {
	err := m.Validate(nil)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("DeviceReport", m.GetKey())
	var vers int64 = 0
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *DeviceReportStoreImpl) Put(ctx context.Context, m *DeviceReport, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(nil)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("DeviceReport", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *DeviceReportStoreImpl) Delete(ctx context.Context, m *DeviceReport, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("DeviceReport", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *DeviceReportStoreImpl) LoadOne(key string) (*DeviceReport, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj DeviceReport
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse DeviceReport data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *DeviceReportStoreImpl) Get(ctx context.Context, key *DeviceKey, buf *DeviceReport) bool {
	keystr := objstore.DbKeyString("DeviceReport", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *DeviceReportStoreImpl) STMGet(stm concurrency.STM, key *DeviceKey, buf *DeviceReport) bool {
	keystr := objstore.DbKeyString("DeviceReport", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *DeviceReportStoreImpl) parseGetData(val []byte, buf *DeviceReport) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = DeviceReport{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *DeviceReportStoreImpl) STMPut(stm concurrency.STM, obj *DeviceReport, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("DeviceReport", obj.GetKey())

	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("DeviceReport json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *DeviceReportStoreImpl) STMDel(stm concurrency.STM, key *DeviceKey) {
	keystr := objstore.DbKeyString("DeviceReport", key)
	stm.Del(keystr)
}

func (m *DeviceReport) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *DeviceReport) GetKey() *DeviceKey {
	return &m.Key
}

func (m *DeviceReport) GetKeyVal() DeviceKey {
	return m.Key
}

func (m *DeviceReport) SetKey(key *DeviceKey) {
	m.Key = *key
}

func CmpSortDeviceReport(a DeviceReport, b DeviceReport) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *DeviceReport) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *DeviceReport) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
}

func (m *DeviceKey) Matches(o *DeviceKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.UniqueIdType != "" {
		if o.UniqueIdType != m.UniqueIdType {
			return false
		}
	}
	if !opts.Filter || o.UniqueId != "" {
		if o.UniqueId != m.UniqueId {
			return false
		}
	}
	return true
}

func (m *DeviceKey) CopyInFields(src *DeviceKey) int {
	changed := 0
	if m.UniqueIdType != src.UniqueIdType {
		m.UniqueIdType = src.UniqueIdType
		changed++
	}
	if m.UniqueId != src.UniqueId {
		m.UniqueId = src.UniqueId
		changed++
	}
	return changed
}

func (m *DeviceKey) DeepCopyIn(src *DeviceKey) {
	m.UniqueIdType = src.UniqueIdType
	m.UniqueId = src.UniqueId
}

func (m *DeviceKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal DeviceKey key string", "obj", m)
	}
	return string(key)
}

func DeviceKeyStringParse(str string, key *DeviceKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal DeviceKey key string", "str", str)
	}
}

func (m *DeviceKey) NotFoundError() error {
	return fmt.Errorf("Device key %s not found", m.GetKeyString())
}

func (m *DeviceKey) ExistsError() error {
	return fmt.Errorf("Device key %s already exists", m.GetKeyString())
}

func (m *DeviceKey) BeingDeletedError() error {
	return fmt.Errorf("Device %s is being deleted", m.GetKeyString())
}

var DeviceKeyTagUniqueIdType = "deviceidtype"
var DeviceKeyTagUniqueId = "deviceid"

func (m *DeviceKey) GetTags() map[string]string {
	tags := make(map[string]string)
	tags["deviceidtype"] = m.UniqueIdType
	tags["deviceid"] = m.UniqueId
	return tags
}

// Helper method to check that enums have valid values
func (m *DeviceKey) ValidateEnums() error {
	return nil
}

func (s *DeviceKey) ClearTagged(tags map[string]struct{}) {
}

func (m *Device) Matches(o *Device, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.FirstSeen != nil {
		if m.FirstSeen == nil && o.FirstSeen != nil || m.FirstSeen != nil && o.FirstSeen == nil {
			return false
		} else if m.FirstSeen != nil && o.FirstSeen != nil {
			if m.FirstSeen.Seconds != o.FirstSeen.Seconds || m.FirstSeen.Nanos != o.FirstSeen.Nanos {
				return false
			}
		}
	}
	if !opts.Filter || o.LastSeen != nil {
		if m.LastSeen == nil && o.LastSeen != nil || m.LastSeen != nil && o.LastSeen == nil {
			return false
		} else if m.LastSeen != nil && o.LastSeen != nil {
			if m.LastSeen.Seconds != o.LastSeen.Seconds || m.LastSeen.Nanos != o.LastSeen.Nanos {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.NotifyId != 0 {
			if o.NotifyId != m.NotifyId {
				return false
			}
		}
	}
	return true
}

const DeviceFieldKey = "2"
const DeviceFieldKeyUniqueIdType = "2.1"
const DeviceFieldKeyUniqueId = "2.2"
const DeviceFieldFirstSeen = "3"
const DeviceFieldFirstSeenSeconds = "3.1"
const DeviceFieldFirstSeenNanos = "3.2"
const DeviceFieldLastSeen = "4"
const DeviceFieldLastSeenSeconds = "4.1"
const DeviceFieldLastSeenNanos = "4.2"
const DeviceFieldNotifyId = "5"

var DeviceAllFields = []string{
	DeviceFieldKeyUniqueIdType,
	DeviceFieldKeyUniqueId,
	DeviceFieldFirstSeenSeconds,
	DeviceFieldFirstSeenNanos,
	DeviceFieldLastSeenSeconds,
	DeviceFieldLastSeenNanos,
	DeviceFieldNotifyId,
}

var DeviceAllFieldsMap = map[string]struct{}{
	DeviceFieldKeyUniqueIdType:  struct{}{},
	DeviceFieldKeyUniqueId:      struct{}{},
	DeviceFieldFirstSeenSeconds: struct{}{},
	DeviceFieldFirstSeenNanos:   struct{}{},
	DeviceFieldLastSeenSeconds:  struct{}{},
	DeviceFieldLastSeenNanos:    struct{}{},
	DeviceFieldNotifyId:         struct{}{},
}

var DeviceAllFieldsStringMap = map[string]string{
	DeviceFieldKeyUniqueIdType:  "Key Unique Id Type",
	DeviceFieldKeyUniqueId:      "Key Unique Id",
	DeviceFieldFirstSeenSeconds: "First Seen Seconds",
	DeviceFieldFirstSeenNanos:   "First Seen Nanos",
	DeviceFieldLastSeenSeconds:  "Last Seen Seconds",
	DeviceFieldLastSeenNanos:    "Last Seen Nanos",
	DeviceFieldNotifyId:         "Notify Id",
}

func (m *Device) IsKeyField(s string) bool {
	return strings.HasPrefix(s, DeviceFieldKey+".") || s == DeviceFieldKey
}

func (m *Device) DiffFields(o *Device, fields map[string]struct{}) {
	if m.Key.UniqueIdType != o.Key.UniqueIdType {
		fields[DeviceFieldKeyUniqueIdType] = struct{}{}
		fields[DeviceFieldKey] = struct{}{}
	}
	if m.Key.UniqueId != o.Key.UniqueId {
		fields[DeviceFieldKeyUniqueId] = struct{}{}
		fields[DeviceFieldKey] = struct{}{}
	}
	if m.FirstSeen != nil && o.FirstSeen != nil {
		if m.FirstSeen.Seconds != o.FirstSeen.Seconds {
			fields[DeviceFieldFirstSeenSeconds] = struct{}{}
			fields[DeviceFieldFirstSeen] = struct{}{}
		}
		if m.FirstSeen.Nanos != o.FirstSeen.Nanos {
			fields[DeviceFieldFirstSeenNanos] = struct{}{}
			fields[DeviceFieldFirstSeen] = struct{}{}
		}
	} else if (m.FirstSeen != nil && o.FirstSeen == nil) || (m.FirstSeen == nil && o.FirstSeen != nil) {
		fields[DeviceFieldFirstSeen] = struct{}{}
	}
	if m.LastSeen != nil && o.LastSeen != nil {
		if m.LastSeen.Seconds != o.LastSeen.Seconds {
			fields[DeviceFieldLastSeenSeconds] = struct{}{}
			fields[DeviceFieldLastSeen] = struct{}{}
		}
		if m.LastSeen.Nanos != o.LastSeen.Nanos {
			fields[DeviceFieldLastSeenNanos] = struct{}{}
			fields[DeviceFieldLastSeen] = struct{}{}
		}
	} else if (m.LastSeen != nil && o.LastSeen == nil) || (m.LastSeen == nil && o.LastSeen != nil) {
		fields[DeviceFieldLastSeen] = struct{}{}
	}
	if m.NotifyId != o.NotifyId {
		fields[DeviceFieldNotifyId] = struct{}{}
	}
}

func (m *Device) CopyInFields(src *Device) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if m.Key.UniqueIdType != src.Key.UniqueIdType {
				m.Key.UniqueIdType = src.Key.UniqueIdType
				changed++
			}
		}
		if _, set := fmap["2.2"]; set {
			if m.Key.UniqueId != src.Key.UniqueId {
				m.Key.UniqueId = src.Key.UniqueId
				changed++
			}
		}
	}
	if _, set := fmap["3"]; set {
		if src.FirstSeen != nil {
			if m.FirstSeen == nil {
				m.FirstSeen = &google_protobuf.Timestamp{}
			}
			if _, set := fmap["3.1"]; set {
				if m.FirstSeen.Seconds != src.FirstSeen.Seconds {
					m.FirstSeen.Seconds = src.FirstSeen.Seconds
					changed++
				}
			}
			if _, set := fmap["3.2"]; set {
				if m.FirstSeen.Nanos != src.FirstSeen.Nanos {
					m.FirstSeen.Nanos = src.FirstSeen.Nanos
					changed++
				}
			}
		} else if m.FirstSeen != nil {
			m.FirstSeen = nil
			changed++
		}
	}
	if _, set := fmap["4"]; set {
		if src.LastSeen != nil {
			if m.LastSeen == nil {
				m.LastSeen = &google_protobuf.Timestamp{}
			}
			if _, set := fmap["4.1"]; set {
				if m.LastSeen.Seconds != src.LastSeen.Seconds {
					m.LastSeen.Seconds = src.LastSeen.Seconds
					changed++
				}
			}
			if _, set := fmap["4.2"]; set {
				if m.LastSeen.Nanos != src.LastSeen.Nanos {
					m.LastSeen.Nanos = src.LastSeen.Nanos
					changed++
				}
			}
		} else if m.LastSeen != nil {
			m.LastSeen = nil
			changed++
		}
	}
	if _, set := fmap["5"]; set {
		if m.NotifyId != src.NotifyId {
			m.NotifyId = src.NotifyId
			changed++
		}
	}
	return changed
}

func (m *Device) DeepCopyIn(src *Device) {
	m.Key.DeepCopyIn(&src.Key)
	if src.FirstSeen != nil {
		var tmp_FirstSeen google_protobuf.Timestamp
		tmp_FirstSeen = *src.FirstSeen
		m.FirstSeen = &tmp_FirstSeen
	} else {
		m.FirstSeen = nil
	}
	if src.LastSeen != nil {
		var tmp_LastSeen google_protobuf.Timestamp
		tmp_LastSeen = *src.LastSeen
		m.LastSeen = &tmp_LastSeen
	} else {
		m.LastSeen = nil
	}
	m.NotifyId = src.NotifyId
}

func (s *Device) HasFields() bool {
	return true
}

type DeviceStore interface {
	Create(ctx context.Context, m *Device, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *Device, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *Device, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *Device, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*Device, int64, error)
	Get(ctx context.Context, key *DeviceKey, buf *Device) bool
	STMGet(stm concurrency.STM, key *DeviceKey, buf *Device) bool
	STMPut(stm concurrency.STM, obj *Device, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *DeviceKey)
}

type DeviceStoreImpl struct {
	kvstore objstore.KVStore
}

func NewDeviceStore(kvstore objstore.KVStore) *DeviceStoreImpl {
	return &DeviceStoreImpl{kvstore: kvstore}
}

func (s *DeviceStoreImpl) Create(ctx context.Context, m *Device, wait func(int64)) (*Result, error) {
	err := m.Validate(DeviceAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Device", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *DeviceStoreImpl) Update(ctx context.Context, m *Device, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Device", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur Device
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *DeviceStoreImpl) Put(ctx context.Context, m *Device, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(DeviceAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Device", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *DeviceStoreImpl) Delete(ctx context.Context, m *Device, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Device", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *DeviceStoreImpl) LoadOne(key string) (*Device, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj Device
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse Device data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *DeviceStoreImpl) Get(ctx context.Context, key *DeviceKey, buf *Device) bool {
	keystr := objstore.DbKeyString("Device", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *DeviceStoreImpl) STMGet(stm concurrency.STM, key *DeviceKey, buf *Device) bool {
	keystr := objstore.DbKeyString("Device", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *DeviceStoreImpl) parseGetData(val []byte, buf *Device) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = Device{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *DeviceStoreImpl) STMPut(stm concurrency.STM, obj *Device, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("Device", obj.GetKey())

	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("Device json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *DeviceStoreImpl) STMDel(stm concurrency.STM, key *DeviceKey) {
	keystr := objstore.DbKeyString("Device", key)
	stm.Del(keystr)
}

type DeviceKeyWatcher struct {
	cb func(ctx context.Context)
}

type DeviceCacheData struct {
	Obj    *Device
	ModRev int64
}

// DeviceCache caches Device objects in memory in a hash table
// and keeps them in sync with the database.
type DeviceCache struct {
	Objs          map[DeviceKey]*DeviceCacheData
	Mux           util.Mutex
	List          map[DeviceKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *DeviceKey, old *Device, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *Device, new *Device)
	DeletedCbs    []func(ctx context.Context, old *Device)
	KeyWatchers   map[DeviceKey][]*DeviceKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *DeviceKey)
	DeletedKeyCbs []func(ctx context.Context, key *DeviceKey)
}

func NewDeviceCache() *DeviceCache {
	cache := DeviceCache{}
	InitDeviceCache(&cache)
	return &cache
}

func InitDeviceCache(cache *DeviceCache) {
	cache.Objs = make(map[DeviceKey]*DeviceCacheData)
	cache.KeyWatchers = make(map[DeviceKey][]*DeviceKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *DeviceCache) GetTypeString() string {
	return "Device"
}

func (c *DeviceCache) Get(key *DeviceKey, valbuf *Device) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *DeviceCache) GetWithRev(key *DeviceKey, valbuf *Device, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *DeviceCache) HasKey(key *DeviceKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *DeviceCache) GetAllKeys(ctx context.Context, cb func(key *DeviceKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *DeviceCache) Update(ctx context.Context, in *Device, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *Device) (*Device, bool) {
		return in, true
	})
}

func (c *DeviceCache) UpdateModFunc(ctx context.Context, key *DeviceKey, modRev int64, modFunc func(old *Device) (new *Device, changed bool)) {
	c.Mux.Lock()
	var old *Device
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	for _, cb := range c.UpdatedCbs {
		newCopy := &Device{}
		newCopy.DeepCopyIn(new)
		defer cb(ctx, old, newCopy)
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			defer cb(ctx, new.GetKey(), old, modRev)
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &Device{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &DeviceCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *DeviceCache) Delete(ctx context.Context, in *Device, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *Device) bool {
		return true
	})
}

func (c *DeviceCache) DeleteCondFunc(ctx context.Context, in *Device, modRev int64, condFunc func(old *Device) bool) {
	c.Mux.Lock()
	var old *Device
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	c.Mux.Unlock()
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, in.GetKey(), old, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *DeviceCache) Prune(ctx context.Context, validKeys map[DeviceKey]struct{}) {
	notify := make(map[DeviceKey]*DeviceCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, old.Obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *DeviceCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *DeviceCache) Flush(ctx context.Context, notifyId int64) {
	log.SpanLog(ctx, log.DebugLevelApi, "CacheFlush Device", "notifyId", notifyId, "FlushAll", c.FlushAll)
	flushed := make(map[DeviceKey]*DeviceCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if !c.FlushAll && val.Obj.NotifyId != notifyId {
			continue
		}
		flushed[key] = c.Objs[key]
		log.SpanLog(ctx, log.DebugLevelApi, "CacheFlush Device delete", "key", key)
		delete(c.Objs, key)
	}
	c.Mux.Unlock()
	if len(flushed) > 0 {
		for key, old := range flushed {
			for _, cb := range c.NotifyCbs {
				if cb != nil {
					cb(ctx, &key, old.Obj, old.ModRev)
				}
			}
			for _, cb := range c.DeletedKeyCbs {
				cb(ctx, &key)
			}
			if old.Obj != nil {
				for _, cb := range c.DeletedCbs {
					cb(ctx, old.Obj)
				}
			}
			c.TriggerKeyWatchers(ctx, &key)
		}
	}
}

func (c *DeviceCache) Show(filter *Device, cb func(ret *Device) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func DeviceGenericNotifyCb(fn func(key *DeviceKey, old *Device)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*DeviceKey), obj.(*Device))
	}
}

func (c *DeviceCache) SetNotifyCb(fn func(ctx context.Context, obj *DeviceKey, old *Device, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *DeviceKey, old *Device, modRev int64){fn}
}

func (c *DeviceCache) SetUpdatedCb(fn func(ctx context.Context, old *Device, new *Device)) {
	c.UpdatedCbs = []func(ctx context.Context, old *Device, new *Device){fn}
}

func (c *DeviceCache) SetDeletedCb(fn func(ctx context.Context, old *Device)) {
	c.DeletedCbs = []func(ctx context.Context, old *Device){fn}
}

func (c *DeviceCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *DeviceKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *DeviceKey){fn}
}

func (c *DeviceCache) SetDeletedKeyCb(fn func(ctx context.Context, key *DeviceKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *DeviceKey){fn}
}

func (c *DeviceCache) AddUpdatedCb(fn func(ctx context.Context, old *Device, new *Device)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *DeviceCache) AddDeletedCb(fn func(ctx context.Context, old *Device)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *DeviceCache) AddNotifyCb(fn func(ctx context.Context, obj *DeviceKey, old *Device, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *DeviceCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *DeviceKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *DeviceCache) AddDeletedKeyCb(fn func(ctx context.Context, key *DeviceKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *DeviceCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *DeviceCache) WatchKey(key *DeviceKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*DeviceKeyWatcher, 0)
	}
	watcher := DeviceKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching Device", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *DeviceCache) TriggerKeyWatchers(ctx context.Context, key *DeviceKey) {
	watchers := make([]*DeviceKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *DeviceCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := Device{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse Device data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *DeviceCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := Device{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	DeviceKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *DeviceCache) SyncListStart(ctx context.Context) {
	c.List = make(map[DeviceKey]struct{})
}

func (c *DeviceCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[DeviceKey]*DeviceCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, val.Obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *DeviceCache) UsesOrg(org string) bool {
	return false
}

func (m *Device) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *Device) GetKey() *DeviceKey {
	return &m.Key
}

func (m *Device) GetKeyVal() DeviceKey {
	return m.Key
}

func (m *Device) SetKey(key *DeviceKey) {
	m.Key = *key
}

func CmpSortDevice(a Device, b Device) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *Device) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *Device) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	if _, found := tags["nocmp"]; found {
		s.FirstSeen = nil
	}
	if _, found := tags["nocmp"]; found {
		s.LastSeen = nil
	}
	if _, found := tags["nocmp"]; found {
		s.NotifyId = 0
	}
}

func IgnoreDeviceFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "FirstSeen")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "LastSeen")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "NotifyId")
	}
	return cmpopts.IgnoreFields(Device{}, names...)
}

func (m *DeviceData) DeepCopyIn(src *DeviceData) {
	if src.Devices != nil {
		m.Devices = make([]Device, len(src.Devices), len(src.Devices))
		for ii, s := range src.Devices {
			m.Devices[ii].DeepCopyIn(&s)
		}
	} else {
		m.Devices = nil
	}
}

// Helper method to check that enums have valid values
func (m *DeviceData) ValidateEnums() error {
	for _, e := range m.Devices {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *DeviceData) ClearTagged(tags map[string]struct{}) {
	if s.Devices != nil {
		for ii := 0; ii < len(s.Devices); ii++ {
			s.Devices[ii].ClearTagged(tags)
		}
	}
}

func IgnoreDeviceDataFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Devices.FirstSeen")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Devices.LastSeen")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Devices.NotifyId")
	}
	return cmpopts.IgnoreFields(DeviceData{}, names...)
}

func (m *Device) IsValidArgsForInjectDevice() error {
	return nil
}

func (m *Device) IsValidArgsForEvictDevice() error {
	return nil
}

func (m *DeviceReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovDevice(uint64(l))
	if m.Begin != nil {
		l = m.Begin.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UniqueIdType)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.UniqueId)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *Device) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovDevice(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovDevice(uint64(l))
	if m.FirstSeen != nil {
		l = m.FirstSeen.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.LastSeen != nil {
		l = m.LastSeen.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.NotifyId != 0 {
		n += 1 + sovDevice(uint64(m.NotifyId))
	}
	return n
}

func (m *DeviceData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovDevice(uint64(l))
		}
	}
	return n
}

func sovDevice(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDevice(x uint64) (n int) {
	return sovDevice(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DeviceReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Begin == nil {
				m.Begin = &types.Timestamp{}
			}
			if err := m.Begin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &types.Timestamp{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueIdType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueIdType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Device) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Device: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Device: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstSeen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FirstSeen == nil {
				m.FirstSeen = &types.Timestamp{}
			}
			if err := m.FirstSeen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSeen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastSeen == nil {
				m.LastSeen = &types.Timestamp{}
			}
			if err := m.LastSeen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyId", wireType)
			}
			m.NotifyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotifyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, Device{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDevice(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDevice
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDevice
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDevice
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDevice        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDevice          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDevice = fmt.Errorf("proto: unexpected end of group")
)
