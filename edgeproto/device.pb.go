// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: device.proto

package edgeproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/mobiledgex/edge-cloud/protogen"
import _ "github.com/gogo/protobuf/gogoproto"
import google_protobuf1 "github.com/gogo/protobuf/types"

import strings "strings"
import reflect "reflect"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import "encoding/json"
import "github.com/mobiledgex/edge-cloud/objstore"
import "github.com/coreos/etcd/clientv3/concurrency"
import "github.com/mobiledgex/edge-cloud/util"
import "github.com/mobiledgex/edge-cloud/log"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// DeviceKey is an identifier for a given device on the MobiledgeX platform
// It is defined by a unique id and unique id type
// And example of such a device is a MEL device that hosts several applications
type DeviceKey struct {
	// Type of unique ID provided by the client
	UniqueIdType string `protobuf:"bytes,1,opt,name=unique_id_type,json=uniqueIdType,proto3" json:"unique_id_type,omitempty"`
	// Unique identification of the client device or user. May be overridden by the server.
	UniqueId string `protobuf:"bytes,2,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
}

func (m *DeviceKey) Reset()                    { *m = DeviceKey{} }
func (m *DeviceKey) String() string            { return proto.CompactTextString(m) }
func (*DeviceKey) ProtoMessage()               {}
func (*DeviceKey) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{0} }

// Device represents a device on the MobiledgeX platform
// We record when this device first showed up on our platform
type Device struct {
	Fields []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty"`
	// Key
	Key DeviceKey `protobuf:"bytes,2,opt,name=key" json:"key"`
	// Timestamp when the device was registered
	Timestamp google_protobuf1.Timestamp `protobuf:"bytes,3,opt,name=timestamp" json:"timestamp"`
}

func (m *Device) Reset()                    { *m = Device{} }
func (m *Device) String() string            { return proto.CompactTextString(m) }
func (*Device) ProtoMessage()               {}
func (*Device) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{1} }

func init() {
	proto.RegisterType((*DeviceKey)(nil), "edgeproto.DeviceKey")
	proto.RegisterType((*Device)(nil), "edgeproto.Device")
}
func (this *DeviceKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&edgeproto.DeviceKey{")
	s = append(s, "UniqueIdType: "+fmt.Sprintf("%#v", this.UniqueIdType)+",\n")
	s = append(s, "UniqueId: "+fmt.Sprintf("%#v", this.UniqueId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringDevice(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DeviceApi service

type DeviceApiClient interface {
	CreateDevice(ctx context.Context, in *Device, opts ...grpc.CallOption) (*Result, error)
	ShowDevice(ctx context.Context, in *Device, opts ...grpc.CallOption) (DeviceApi_ShowDeviceClient, error)
}

type deviceApiClient struct {
	cc *grpc.ClientConn
}

func NewDeviceApiClient(cc *grpc.ClientConn) DeviceApiClient {
	return &deviceApiClient{cc}
}

func (c *deviceApiClient) CreateDevice(ctx context.Context, in *Device, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/edgeproto.DeviceApi/CreateDevice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceApiClient) ShowDevice(ctx context.Context, in *Device, opts ...grpc.CallOption) (DeviceApi_ShowDeviceClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DeviceApi_serviceDesc.Streams[0], c.cc, "/edgeproto.DeviceApi/ShowDevice", opts...)
	if err != nil {
		return nil, err
	}
	x := &deviceApiShowDeviceClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DeviceApi_ShowDeviceClient interface {
	Recv() (*Device, error)
	grpc.ClientStream
}

type deviceApiShowDeviceClient struct {
	grpc.ClientStream
}

func (x *deviceApiShowDeviceClient) Recv() (*Device, error) {
	m := new(Device)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for DeviceApi service

type DeviceApiServer interface {
	CreateDevice(context.Context, *Device) (*Result, error)
	ShowDevice(*Device, DeviceApi_ShowDeviceServer) error
}

func RegisterDeviceApiServer(s *grpc.Server, srv DeviceApiServer) {
	s.RegisterService(&_DeviceApi_serviceDesc, srv)
}

func _DeviceApi_CreateDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceApiServer).CreateDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.DeviceApi/CreateDevice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceApiServer).CreateDevice(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceApi_ShowDevice_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Device)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DeviceApiServer).ShowDevice(m, &deviceApiShowDeviceServer{stream})
}

type DeviceApi_ShowDeviceServer interface {
	Send(*Device) error
	grpc.ServerStream
}

type deviceApiShowDeviceServer struct {
	grpc.ServerStream
}

func (x *deviceApiShowDeviceServer) Send(m *Device) error {
	return x.ServerStream.SendMsg(m)
}

var _DeviceApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.DeviceApi",
	HandlerType: (*DeviceApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateDevice",
			Handler:    _DeviceApi_CreateDevice_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowDevice",
			Handler:       _DeviceApi_ShowDevice_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "device.proto",
}

func (m *DeviceKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UniqueIdType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.UniqueIdType)))
		i += copy(dAtA[i:], m.UniqueIdType)
	}
	if len(m.UniqueId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.UniqueId)))
		i += copy(dAtA[i:], m.UniqueId)
	}
	return i, nil
}

func (m *Device) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Device) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintDevice(dAtA, i, uint64(m.Key.Size()))
	n1, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x1a
	i++
	i = encodeVarintDevice(dAtA, i, uint64(m.Timestamp.Size()))
	n2, err := m.Timestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	return i, nil
}

func encodeVarintDevice(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DeviceKey) Matches(o *DeviceKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.UniqueIdType != "" {
		if o.UniqueIdType != m.UniqueIdType {
			return false
		}
	}
	if !opts.Filter || o.UniqueId != "" {
		if o.UniqueId != m.UniqueId {
			return false
		}
	}
	return true
}

func (m *DeviceKey) CopyInFields(src *DeviceKey) int {
	changed := 0
	if m.UniqueIdType != src.UniqueIdType {
		m.UniqueIdType = src.UniqueIdType
		changed++
	}
	if m.UniqueId != src.UniqueId {
		m.UniqueId = src.UniqueId
		changed++
	}
	return changed
}

func (m *DeviceKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal DeviceKey key string", "obj", m)
	}
	return string(key)
}

func DeviceKeyStringParse(str string, key *DeviceKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal DeviceKey key string", "str", str)
	}
}

func (m *DeviceKey) NotFoundError() error {
	return fmt.Errorf("Device key %s not found", m.GetKeyString())
}

func (m *DeviceKey) ExistsError() error {
	return fmt.Errorf("Device key %s already exists", m.GetKeyString())
}

// Helper method to check that enums have valid values
func (m *DeviceKey) ValidateEnums() error {
	return nil
}

func (m *Device) Matches(o *Device, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if m.Timestamp.Seconds != o.Timestamp.Seconds || m.Timestamp.Nanos != o.Timestamp.Nanos {
		return false
	}
	return true
}

const DeviceFieldKey = "2"
const DeviceFieldKeyUniqueIdType = "2.1"
const DeviceFieldKeyUniqueId = "2.2"
const DeviceFieldTimestamp = "3"
const DeviceFieldTimestampSeconds = "3.1"
const DeviceFieldTimestampNanos = "3.2"

var DeviceAllFields = []string{
	DeviceFieldKeyUniqueIdType,
	DeviceFieldKeyUniqueId,
	DeviceFieldTimestampSeconds,
	DeviceFieldTimestampNanos,
}

var DeviceAllFieldsMap = map[string]struct{}{
	DeviceFieldKeyUniqueIdType:  struct{}{},
	DeviceFieldKeyUniqueId:      struct{}{},
	DeviceFieldTimestampSeconds: struct{}{},
	DeviceFieldTimestampNanos:   struct{}{},
}

var DeviceAllFieldsStringMap = map[string]string{
	DeviceFieldKeyUniqueIdType:  "Key Unique Id Type",
	DeviceFieldKeyUniqueId:      "Key Unique Id",
	DeviceFieldTimestampSeconds: "Timestamp Seconds",
	DeviceFieldTimestampNanos:   "Timestamp Nanos",
}

func (m *Device) IsKeyField(s string) bool {
	return strings.HasPrefix(s, DeviceFieldKey+".")
}

func (m *Device) DiffFields(o *Device, fields map[string]struct{}) {
	if m.Key.UniqueIdType != o.Key.UniqueIdType {
		fields[DeviceFieldKeyUniqueIdType] = struct{}{}
		fields[DeviceFieldKey] = struct{}{}
	}
	if m.Key.UniqueId != o.Key.UniqueId {
		fields[DeviceFieldKeyUniqueId] = struct{}{}
		fields[DeviceFieldKey] = struct{}{}
	}
	if m.Timestamp.Seconds != o.Timestamp.Seconds {
		fields[DeviceFieldTimestampSeconds] = struct{}{}
		fields[DeviceFieldTimestamp] = struct{}{}
	}
	if m.Timestamp.Nanos != o.Timestamp.Nanos {
		fields[DeviceFieldTimestampNanos] = struct{}{}
		fields[DeviceFieldTimestamp] = struct{}{}
	}
}

func (m *Device) CopyInFields(src *Device) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if m.Key.UniqueIdType != src.Key.UniqueIdType {
				m.Key.UniqueIdType = src.Key.UniqueIdType
				changed++
			}
		}
		if _, set := fmap["2.2"]; set {
			if m.Key.UniqueId != src.Key.UniqueId {
				m.Key.UniqueId = src.Key.UniqueId
				changed++
			}
		}
	}
	if _, set := fmap["3"]; set {
		if _, set := fmap["3.1"]; set {
			if m.Timestamp.Seconds != src.Timestamp.Seconds {
				m.Timestamp.Seconds = src.Timestamp.Seconds
				changed++
			}
		}
		if _, set := fmap["3.2"]; set {
			if m.Timestamp.Nanos != src.Timestamp.Nanos {
				m.Timestamp.Nanos = src.Timestamp.Nanos
				changed++
			}
		}
	}
	return changed
}

func (s *Device) HasFields() bool {
	return true
}

type DeviceStore struct {
	kvstore objstore.KVStore
}

func NewDeviceStore(kvstore objstore.KVStore) DeviceStore {
	return DeviceStore{kvstore: kvstore}
}

func (s *DeviceStore) Create(ctx context.Context, m *Device, wait func(int64)) (*Result, error) {
	err := m.Validate(DeviceAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Device", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *DeviceStore) Update(ctx context.Context, m *Device, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Device", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur Device
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *DeviceStore) Put(ctx context.Context, m *Device, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(DeviceAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Device", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *DeviceStore) Delete(ctx context.Context, m *Device, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Device", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *DeviceStore) LoadOne(key string) (*Device, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj Device
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse Device data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *DeviceStore) STMGet(stm concurrency.STM, key *DeviceKey, buf *Device) bool {
	keystr := objstore.DbKeyString("Device", key)
	valstr := stm.Get(keystr)
	if valstr == "" {
		return false
	}
	if buf != nil {
		err := json.Unmarshal([]byte(valstr), buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *DeviceStore) STMPut(stm concurrency.STM, obj *Device, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("Device", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("Device json marsahal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *DeviceStore) STMDel(stm concurrency.STM, key *DeviceKey) {
	keystr := objstore.DbKeyString("Device", key)
	stm.Del(keystr)
}

type DeviceKeyWatcher struct {
	cb func(ctx context.Context)
}

// DeviceCache caches Device objects in memory in a hash table
// and keeps them in sync with the database.
type DeviceCache struct {
	Objs        map[DeviceKey]*Device
	Mux         util.Mutex
	List        map[DeviceKey]struct{}
	NotifyCb    func(ctx context.Context, obj *DeviceKey, old *Device)
	UpdatedCb   func(ctx context.Context, old *Device, new *Device)
	KeyWatchers map[DeviceKey][]*DeviceKeyWatcher
}

func NewDeviceCache() *DeviceCache {
	cache := DeviceCache{}
	InitDeviceCache(&cache)
	return &cache
}

func InitDeviceCache(cache *DeviceCache) {
	cache.Objs = make(map[DeviceKey]*Device)
	cache.KeyWatchers = make(map[DeviceKey][]*DeviceKeyWatcher)
}

func (c *DeviceCache) GetTypeString() string {
	return "Device"
}

func (c *DeviceCache) Get(key *DeviceKey, valbuf *Device) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		*valbuf = *inst
	}
	return found
}

func (c *DeviceCache) HasKey(key *DeviceKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *DeviceCache) GetAllKeys(ctx context.Context, keys map[DeviceKey]context.Context) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		keys[key] = ctx
	}
}

func (c *DeviceCache) Update(ctx context.Context, in *Device, rev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), rev, func(old *Device) (*Device, bool) {
		return in, true
	})
}

func (c *DeviceCache) UpdateModFunc(ctx context.Context, key *DeviceKey, rev int64, modFunc func(old *Device) (new *Device, changed bool)) {
	c.Mux.Lock()
	old := c.Objs[*key]
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	if c.UpdatedCb != nil || c.NotifyCb != nil {
		if c.UpdatedCb != nil {
			newCopy := &Device{}
			*newCopy = *new
			defer c.UpdatedCb(ctx, old, newCopy)
		}
		if c.NotifyCb != nil {
			defer c.NotifyCb(ctx, new.GetKey(), old)
		}
	}
	c.Objs[new.GetKeyVal()] = new
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", new)
	log.DebugLog(log.DebugLevelApi, "SyncUpdate Device", "obj", new, "rev", rev)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *DeviceCache) Delete(ctx context.Context, in *Device, rev int64) {
	c.Mux.Lock()
	old := c.Objs[in.GetKeyVal()]
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	log.DebugLog(log.DebugLevelApi, "SyncDelete Device", "key", in.GetKey(), "rev", rev)
	c.Mux.Unlock()
	if c.NotifyCb != nil {
		c.NotifyCb(ctx, in.GetKey(), old)
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *DeviceCache) Prune(ctx context.Context, validKeys map[DeviceKey]struct{}) {
	notify := make(map[DeviceKey]*Device)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if c.NotifyCb != nil {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		if c.NotifyCb != nil {
			c.NotifyCb(ctx, &key, old)
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *DeviceCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *DeviceCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *DeviceCache) Show(filter *Device, cb func(ret *Device) error) error {
	log.DebugLog(log.DebugLevelApi, "Show Device", "count", len(c.Objs))
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, obj := range c.Objs {
		log.DebugLog(log.DebugLevelApi, "Compare Device", "filter", filter, "obj", obj)
		if !obj.Matches(filter, MatchFilter()) {
			continue
		}
		log.DebugLog(log.DebugLevelApi, "Show Device", "obj", obj)
		err := cb(obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func DeviceGenericNotifyCb(fn func(key *DeviceKey, old *Device)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*DeviceKey), obj.(*Device))
	}
}

func (c *DeviceCache) SetNotifyCb(fn func(ctx context.Context, obj *DeviceKey, old *Device)) {
	c.NotifyCb = fn
}

func (c *DeviceCache) SetUpdatedCb(fn func(ctx context.Context, old *Device, new *Device)) {
	c.UpdatedCb = fn
}

func (c *DeviceCache) WatchKey(key *DeviceKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*DeviceKeyWatcher, 0)
	}
	watcher := DeviceKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching Device", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *DeviceCache) TriggerKeyWatchers(ctx context.Context, key *DeviceKey) {
	watchers := make([]*DeviceKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}
func (c *DeviceCache) SyncUpdate(ctx context.Context, key, val []byte, rev int64) {
	obj := Device{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse Device data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, rev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *DeviceCache) SyncDelete(ctx context.Context, key []byte, rev int64) {
	obj := Device{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	DeviceKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, rev)
}

func (c *DeviceCache) SyncListStart(ctx context.Context) {
	c.List = make(map[DeviceKey]struct{})
}

func (c *DeviceCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[DeviceKey]*Device)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	if c.NotifyCb != nil {
		for key, val := range deleted {
			c.NotifyCb(ctx, &key, val)
			c.TriggerKeyWatchers(ctx, &key)
		}
	}
}

func (m *Device) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *Device) GetKey() *DeviceKey {
	return &m.Key
}

func (m *Device) GetKeyVal() DeviceKey {
	return m.Key
}

func (m *Device) SetKey(key *DeviceKey) {
	m.Key = *key
}

func CmpSortDevice(a Device, b Device) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *Device) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *DeviceKey) Size() (n int) {
	var l int
	_ = l
	l = len(m.UniqueIdType)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.UniqueId)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *Device) Size() (n int) {
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovDevice(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovDevice(uint64(l))
	l = m.Timestamp.Size()
	n += 1 + l + sovDevice(uint64(l))
	return n
}

func sovDevice(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDevice(x uint64) (n int) {
	return sovDevice(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DeviceKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueIdType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueIdType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Device) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Device: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Device: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDevice(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDevice
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDevice
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDevice(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDevice = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDevice   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("device.proto", fileDescriptorDevice) }

var fileDescriptorDevice = []byte{
	// 448 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x92, 0xcf, 0x6a, 0x14, 0x41,
	0x10, 0xc6, 0x53, 0x59, 0x59, 0x9c, 0x76, 0x08, 0x49, 0x1b, 0xa4, 0x1d, 0x65, 0x37, 0x0c, 0x1e,
	0x82, 0xac, 0xd3, 0x12, 0x11, 0x64, 0x0f, 0x42, 0x12, 0x2f, 0xe2, 0x41, 0x18, 0x83, 0x27, 0x21,
	0xcc, 0xce, 0xd4, 0xf6, 0x36, 0x99, 0x9d, 0x1e, 0x77, 0x7a, 0x5c, 0xe7, 0x26, 0x3e, 0x81, 0xe0,
	0x0b, 0xe4, 0x11, 0x7c, 0x8c, 0xf5, 0x26, 0x78, 0x17, 0x5d, 0x3c, 0x88, 0x27, 0x61, 0xf7, 0xe0,
	0x51, 0xa6, 0xe7, 0x4f, 0x04, 0x2f, 0x5e, 0x9a, 0xaa, 0xe2, 0xf7, 0x55, 0x7d, 0x55, 0x34, 0xb1,
	0x23, 0x7c, 0x25, 0x43, 0xf4, 0xd2, 0x99, 0xd2, 0x8a, 0x5a, 0x18, 0x09, 0x34, 0xa1, 0x73, 0x53,
	0x28, 0x25, 0x62, 0xe4, 0x41, 0x2a, 0x79, 0x90, 0x24, 0x4a, 0x07, 0x5a, 0xaa, 0x24, 0xab, 0x40,
	0xe7, 0x81, 0x90, 0x7a, 0x92, 0x8f, 0xbc, 0x50, 0x4d, 0xf9, 0x54, 0x8d, 0x64, 0x5c, 0x0a, 0x5f,
	0xf3, 0xf2, 0xbd, 0x13, 0xc6, 0x2a, 0x8f, 0xb8, 0xe1, 0x04, 0x26, 0x6d, 0x50, 0x2b, 0x77, 0x85,
	0x12, 0xca, 0x84, 0xbc, 0x8c, 0xea, 0xaa, 0x3d, 0xc3, 0x2c, 0x8f, 0x75, 0x9d, 0xf5, 0xeb, 0xd9,
	0x26, 0x1b, 0xe5, 0x63, 0xae, 0xe5, 0x14, 0x33, 0x1d, 0x4c, 0xd3, 0x0a, 0x70, 0x5f, 0x10, 0xeb,
	0x91, 0xf1, 0xfd, 0x04, 0x0b, 0x7a, 0x8b, 0x6c, 0xe5, 0x89, 0x7c, 0x99, 0xe3, 0xa9, 0x8c, 0x4e,
	0x75, 0x91, 0x22, 0x83, 0x3d, 0xd8, 0xb7, 0x7c, 0xbb, 0xaa, 0x3e, 0x8e, 0x4e, 0x8a, 0x14, 0xe9,
	0x0d, 0x62, 0xb5, 0x14, 0xdb, 0x34, 0xc0, 0xe5, 0x06, 0x18, 0xda, 0x3f, 0x56, 0x0c, 0x7e, 0xaf,
	0x18, 0x7c, 0x38, 0xef, 0x83, 0x7b, 0x0e, 0xa4, 0x5b, 0xb5, 0xa7, 0xd7, 0x48, 0x77, 0x2c, 0x31,
	0x8e, 0x32, 0x06, 0x7b, 0x9d, 0x7d, 0xcb, 0xaf, 0x33, 0x3a, 0x20, 0x9d, 0x33, 0x2c, 0x4c, 0x9f,
	0x2b, 0x07, 0xbb, 0x5e, 0x7b, 0x36, 0xaf, 0xb5, 0x75, 0x74, 0x69, 0xf1, 0xa5, 0xbf, 0xe1, 0x97,
	0x18, 0x7d, 0x48, 0xac, 0x76, 0x03, 0xd6, 0x31, 0x1a, 0xc7, 0xab, 0x76, 0xf4, 0x9a, 0x1d, 0xbd,
	0x93, 0x86, 0xa8, 0x95, 0x17, 0x92, 0xe1, 0x76, 0x69, 0xef, 0xd7, 0x8a, 0xc1, 0x9b, 0x35, 0x83,
	0x77, 0x6b, 0x06, 0x07, 0x1f, 0xa1, 0xb9, 0xc0, 0x61, 0x2a, 0xe9, 0x53, 0x62, 0x1f, 0xcf, 0x30,
	0xd0, 0x58, 0xbb, 0xde, 0xf9, 0xc7, 0x90, 0xf3, 0x77, 0xc9, 0x37, 0xb7, 0x76, 0xaf, 0xbf, 0xfd,
	0xfc, 0xfd, 0xfd, 0xe6, 0x55, 0x77, 0x8b, 0x87, 0x46, 0xcc, 0xab, 0xaf, 0x30, 0x84, 0xdb, 0xf4,
	0x8c, 0x90, 0x67, 0x13, 0x35, 0xff, 0xbf, 0x76, 0x55, 0xc9, 0xbd, 0xff, 0x73, 0xcd, 0x1c, 0x1f,
	0x33, 0x95, 0xcf, 0x42, 0x3c, 0x56, 0xc9, 0x58, 0x8a, 0xc1, 0x61, 0x58, 0x7e, 0x9a, 0xe7, 0x12,
	0xe7, 0x03, 0x33, 0x6c, 0xc7, 0xb5, 0x79, 0x36, 0x51, 0xf3, 0x8b, 0x51, 0x77, 0xe1, 0x68, 0x7b,
	0xf1, 0xad, 0xb7, 0xb1, 0x58, 0xf6, 0xe0, 0xd3, 0xb2, 0x07, 0x5f, 0x97, 0x3d, 0x18, 0x75, 0x4d,
	0xe3, 0x7b, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x68, 0xb3, 0x49, 0xfa, 0x9d, 0x02, 0x00, 0x00,
}
