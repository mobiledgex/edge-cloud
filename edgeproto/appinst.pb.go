// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: appinst.proto

package edgeproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/mobiledgex/edge-cloud/protogen"
import distributed_match_engine "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto"
import distributed_match_engine1 "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto"
import _ "github.com/gogo/protobuf/gogoproto"

import strings "strings"
import reflect "reflect"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import "encoding/json"
import "github.com/mobiledgex/edge-cloud/objstore"
import "github.com/coreos/etcd/clientv3/concurrency"
import "github.com/mobiledgex/edge-cloud/util"
import "github.com/mobiledgex/edge-cloud/log"
import "errors"
import "strconv"
import "time"
import "github.com/google/go-cmp/cmp"
import "github.com/google/go-cmp/cmp/cmpopts"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Health check status
//
// Health check status gets set by external, or rootLB health check
type HealthCheck int32

const (
	// Health Check is unknown
	HealthCheck_HEALTH_CHECK_UNKNOWN HealthCheck = 0
	// Health Check failure due to RootLB being offline
	HealthCheck_HEALTH_CHECK_FAIL_ROOTLB_OFFLINE HealthCheck = 1
	// Health Check failure due to Backend server being unavailable
	HealthCheck_HEALTH_CHECK_FAIL_SERVER_FAIL HealthCheck = 2
	// Health Check is ok
	HealthCheck_HEALTH_CHECK_OK HealthCheck = 3
)

var HealthCheck_name = map[int32]string{
	0: "HEALTH_CHECK_UNKNOWN",
	1: "HEALTH_CHECK_FAIL_ROOTLB_OFFLINE",
	2: "HEALTH_CHECK_FAIL_SERVER_FAIL",
	3: "HEALTH_CHECK_OK",
}
var HealthCheck_value = map[string]int32{
	"HEALTH_CHECK_UNKNOWN":             0,
	"HEALTH_CHECK_FAIL_ROOTLB_OFFLINE": 1,
	"HEALTH_CHECK_FAIL_SERVER_FAIL":    2,
	"HEALTH_CHECK_OK":                  3,
}

func (x HealthCheck) String() string {
	return proto.EnumName(HealthCheck_name, int32(x))
}
func (HealthCheck) EnumDescriptor() ([]byte, []int) { return fileDescriptorAppinst, []int{0} }

// Power State
//
// Power State of the AppInst
type PowerState int32

const (
	// Unknown
	PowerState_POWER_STATE_UNKNOWN PowerState = 0
	// Power On Requested
	PowerState_POWER_ON_REQUESTED PowerState = 1
	// Powering On
	PowerState_POWERING_ON PowerState = 2
	// Power On
	PowerState_POWER_ON PowerState = 3
	// Power Off Requested
	PowerState_POWER_OFF_REQUESTED PowerState = 4
	// Powering Off
	PowerState_POWERING_OFF PowerState = 5
	// Power Off
	PowerState_POWER_OFF PowerState = 6
	// Reboot Requested
	PowerState_REBOOT_REQUESTED PowerState = 7
	// Rebooting
	PowerState_REBOOTING PowerState = 8
	// Reboot
	PowerState_REBOOT PowerState = 9
	// Error
	PowerState_POWER_STATE_ERROR PowerState = 10
)

var PowerState_name = map[int32]string{
	0:  "POWER_STATE_UNKNOWN",
	1:  "POWER_ON_REQUESTED",
	2:  "POWERING_ON",
	3:  "POWER_ON",
	4:  "POWER_OFF_REQUESTED",
	5:  "POWERING_OFF",
	6:  "POWER_OFF",
	7:  "REBOOT_REQUESTED",
	8:  "REBOOTING",
	9:  "REBOOT",
	10: "POWER_STATE_ERROR",
}
var PowerState_value = map[string]int32{
	"POWER_STATE_UNKNOWN": 0,
	"POWER_ON_REQUESTED":  1,
	"POWERING_ON":         2,
	"POWER_ON":            3,
	"POWER_OFF_REQUESTED": 4,
	"POWERING_OFF":        5,
	"POWER_OFF":           6,
	"REBOOT_REQUESTED":    7,
	"REBOOTING":           8,
	"REBOOT":              9,
	"POWER_STATE_ERROR":   10,
}

func (x PowerState) String() string {
	return proto.EnumName(PowerState_name, int32(x))
}
func (PowerState) EnumDescriptor() ([]byte, []int) { return fileDescriptorAppinst, []int{1} }

// App Instance Unique Key
//
// AppInstKey uniquely identifies an Application Instance (AppInst) or Application Instance state (AppInstInfo).
type AppInstKey struct {
	// App key
	AppKey AppKey `protobuf:"bytes,1,opt,name=app_key,json=appKey" json:"app_key"`
	// Cluster instance on which this is instantiated
	ClusterInstKey ClusterInstKey `protobuf:"bytes,4,opt,name=cluster_inst_key,json=clusterInstKey" json:"cluster_inst_key"`
}

func (m *AppInstKey) Reset()                    { *m = AppInstKey{} }
func (m *AppInstKey) String() string            { return proto.CompactTextString(m) }
func (*AppInstKey) ProtoMessage()               {}
func (*AppInstKey) Descriptor() ([]byte, []int) { return fileDescriptorAppinst, []int{0} }

// Application Instance
//
// AppInst is an instance of an App on a Cloudlet where it is defined by an App plus a ClusterInst key.
// Many of the fields here are inherited from the App definition.
type AppInst struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty"`
	// required: true
	// Unique identifier key
	Key AppInstKey `protobuf:"bytes,2,opt,name=key" json:"key"`
	// Cached location of the cloudlet
	CloudletLoc distributed_match_engine.Loc `protobuf:"bytes,3,opt,name=cloudlet_loc,json=cloudletLoc" json:"cloudlet_loc"`
	// Base FQDN (not really URI) for the App. See Service FQDN for endpoint access.
	Uri string `protobuf:"bytes,4,opt,name=uri,proto3" json:"uri,omitempty"`
	// Liveness of instance (see Liveness)
	Liveness Liveness `protobuf:"varint,6,opt,name=liveness,proto3,enum=edgeproto.Liveness" json:"liveness,omitempty"`
	// For instances accessible via a shared load balancer, defines the external
	// ports on the shared load balancer that map to the internal ports
	// External ports should be appended to the Uri for L4 access.
	MappedPorts []distributed_match_engine1.AppPort `protobuf:"bytes,9,rep,name=mapped_ports,json=mappedPorts" json:"mapped_ports"`
	// Flavor defining resource requirements
	Flavor FlavorKey `protobuf:"bytes,12,opt,name=flavor" json:"flavor"`
	// Current state of the AppInst on the Cloudlet
	State TrackedState `protobuf:"varint,14,opt,name=state,proto3,enum=edgeproto.TrackedState" json:"state,omitempty"`
	// Any errors trying to create, update, or delete the AppInst on the Cloudlet
	Errors []string `protobuf:"bytes,15,rep,name=errors" json:"errors,omitempty"`
	// Override actions to CRM
	CrmOverride CRMOverride `protobuf:"varint,16,opt,name=crm_override,json=crmOverride,proto3,enum=edgeproto.CRMOverride" json:"crm_override,omitempty"`
	// AppInst runtime information
	RuntimeInfo AppInstRuntime `protobuf:"bytes,17,opt,name=runtime_info,json=runtimeInfo" json:"runtime_info"`
	// Created at time
	CreatedAt distributed_match_engine.Timestamp `protobuf:"bytes,21,opt,name=created_at,json=createdAt" json:"created_at"`
	// IpAccess for auto-clusters. Ignored otherwise.
	AutoClusterIpAccess IpAccess `protobuf:"varint,22,opt,name=auto_cluster_ip_access,json=autoClusterIpAccess,proto3,enum=edgeproto.IpAccess" json:"auto_cluster_ip_access,omitempty"`
	// status is used to reflect progress of creation or other events
	Status StatusInfo `protobuf:"bytes,23,opt,name=status" json:"status"`
	// Revision changes each time the App is updated.  Refreshing the App Instance will sync the revision with that of the App
	Revision string `protobuf:"bytes,24,opt,name=revision,proto3" json:"revision,omitempty"`
	// Force Appinst refresh even if revision number matches App revision number.
	ForceUpdate bool `protobuf:"varint,25,opt,name=force_update,json=forceUpdate,proto3" json:"force_update,omitempty"`
	// Allow multiple instances to be updated at once
	UpdateMultiple bool `protobuf:"varint,26,opt,name=update_multiple,json=updateMultiple,proto3" json:"update_multiple,omitempty"`
	// Customization files passed through to implementing services
	Configs []*ConfigFile `protobuf:"bytes,27,rep,name=configs" json:"configs,omitempty"`
	// shared volume size when creating auto cluster
	SharedVolumeSize uint64 `protobuf:"varint,28,opt,name=shared_volume_size,json=sharedVolumeSize,proto3" json:"shared_volume_size,omitempty"`
	// Health Check status
	HealthCheck HealthCheck `protobuf:"varint,29,opt,name=health_check,json=healthCheck,proto3,enum=edgeproto.HealthCheck" json:"health_check,omitempty"`
	// Optional privacy policy name
	PrivacyPolicy string `protobuf:"bytes,30,opt,name=privacy_policy,json=privacyPolicy,proto3" json:"privacy_policy,omitempty"`
	// Power State of the AppInst
	PowerState PowerState `protobuf:"varint,31,opt,name=power_state,json=powerState,proto3,enum=edgeproto.PowerState" json:"power_state,omitempty"`
	// Size of external volume to be attached to nodes.  This is for the root partition
	ExternalVolumeSize uint64 `protobuf:"varint,32,opt,name=external_volume_size,json=externalVolumeSize,proto3" json:"external_volume_size,omitempty"`
	// Optional Availability Zone if any
	AvailabilityZone string `protobuf:"bytes,33,opt,name=availability_zone,json=availabilityZone,proto3" json:"availability_zone,omitempty"`
	// OS node flavor to use
	VmFlavor string `protobuf:"bytes,34,opt,name=vm_flavor,json=vmFlavor,proto3" json:"vm_flavor,omitempty"`
	// Optional Resources required by OS flavor if any
	OptRes string `protobuf:"bytes,35,opt,name=opt_res,json=optRes,proto3" json:"opt_res,omitempty"`
}

func (m *AppInst) Reset()                    { *m = AppInst{} }
func (m *AppInst) String() string            { return proto.CompactTextString(m) }
func (*AppInst) ProtoMessage()               {}
func (*AppInst) Descriptor() ([]byte, []int) { return fileDescriptorAppinst, []int{1} }

// AppInst Runtime Info
//
// Runtime information of active AppInsts
type AppInstRuntime struct {
	// List of container names
	ContainerIds []string `protobuf:"bytes,1,rep,name=container_ids,json=containerIds" json:"container_ids,omitempty"`
}

func (m *AppInstRuntime) Reset()                    { *m = AppInstRuntime{} }
func (m *AppInstRuntime) String() string            { return proto.CompactTextString(m) }
func (*AppInstRuntime) ProtoMessage()               {}
func (*AppInstRuntime) Descriptor() ([]byte, []int) { return fileDescriptorAppinst, []int{2} }

// AppInstInfo provides information from the Cloudlet Resource Manager about the state of the AppInst on the Cloudlet. Whereas the AppInst defines the intent of instantiating an App on a Cloudlet, the AppInstInfo defines the current state of trying to apply that intent on the physical resources of the Cloudlet.
type AppInstInfo struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty"`
	// Unique identifier key
	Key AppInstKey `protobuf:"bytes,2,opt,name=key" json:"key"`
	// Id of client assigned by server (internal use only)
	NotifyId int64 `protobuf:"varint,3,opt,name=notify_id,json=notifyId,proto3" json:"notify_id,omitempty"`
	// Current state of the AppInst on the Cloudlet
	State TrackedState `protobuf:"varint,4,opt,name=state,proto3,enum=edgeproto.TrackedState" json:"state,omitempty"`
	// Any errors trying to create, update, or delete the AppInst on the Cloudlet
	Errors []string `protobuf:"bytes,5,rep,name=errors" json:"errors,omitempty"`
	// AppInst runtime information
	RuntimeInfo AppInstRuntime `protobuf:"bytes,6,opt,name=runtime_info,json=runtimeInfo" json:"runtime_info"`
	// status is used to reflect progress of creation or other events
	Status StatusInfo `protobuf:"bytes,7,opt,name=status" json:"status"`
	// Power State of the AppInst
	PowerState PowerState `protobuf:"varint,8,opt,name=power_state,json=powerState,proto3,enum=edgeproto.PowerState" json:"power_state,omitempty"`
}

func (m *AppInstInfo) Reset()                    { *m = AppInstInfo{} }
func (m *AppInstInfo) String() string            { return proto.CompactTextString(m) }
func (*AppInstInfo) ProtoMessage()               {}
func (*AppInstInfo) Descriptor() ([]byte, []int) { return fileDescriptorAppinst, []int{3} }

// (TODO) AppInstMetrics provide metrics collected about the application instance on the Cloudlet. They are sent to a metrics collector for analytics. They are not stored in the persistent distributed database, but are stored as a time series in some other database or files.
type AppInstMetrics struct {
	// what goes here?
	// Note that metrics for grpc calls can be done by a prometheus
	// interceptor in grpc, so adding call metrics here may be
	// redundant unless they're needed for billing.
	Something uint64 `protobuf:"varint,5,opt,name=something,proto3" json:"something,omitempty"`
}

func (m *AppInstMetrics) Reset()                    { *m = AppInstMetrics{} }
func (m *AppInstMetrics) String() string            { return proto.CompactTextString(m) }
func (*AppInstMetrics) ProtoMessage()               {}
func (*AppInstMetrics) Descriptor() ([]byte, []int) { return fileDescriptorAppinst, []int{4} }

// AppInstLookup is used to generate reverse lookup caches
type AppInstLookup struct {
	// unique key
	Key AppInstKey `protobuf:"bytes,1,opt,name=key" json:"key"`
	// lookup by AutoProvPolicy
	PolicyKey PolicyKey `protobuf:"bytes,2,opt,name=policy_key,json=policyKey" json:"policy_key"`
}

func (m *AppInstLookup) Reset()                    { *m = AppInstLookup{} }
func (m *AppInstLookup) String() string            { return proto.CompactTextString(m) }
func (*AppInstLookup) ProtoMessage()               {}
func (*AppInstLookup) Descriptor() ([]byte, []int) { return fileDescriptorAppinst, []int{5} }

func init() {
	proto.RegisterType((*AppInstKey)(nil), "edgeproto.AppInstKey")
	proto.RegisterType((*AppInst)(nil), "edgeproto.AppInst")
	proto.RegisterType((*AppInstRuntime)(nil), "edgeproto.AppInstRuntime")
	proto.RegisterType((*AppInstInfo)(nil), "edgeproto.AppInstInfo")
	proto.RegisterType((*AppInstMetrics)(nil), "edgeproto.AppInstMetrics")
	proto.RegisterType((*AppInstLookup)(nil), "edgeproto.AppInstLookup")
	proto.RegisterEnum("edgeproto.HealthCheck", HealthCheck_name, HealthCheck_value)
	proto.RegisterEnum("edgeproto.PowerState", PowerState_name, PowerState_value)
}
func (this *AppInstKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&edgeproto.AppInstKey{")
	s = append(s, "AppKey: "+strings.Replace(this.AppKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "ClusterInstKey: "+strings.Replace(this.ClusterInstKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAppinst(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AppInstApi service

type AppInstApiClient interface {
	// Create Application Instance. Creates an instance of an App on a Cloudlet where it is
	// defined by an App plus a ClusterInst key. Many of the fields here are inherited from
	// the App definition.
	CreateAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_CreateAppInstClient, error)
	// Delete Application Instance. Deletes an instance of the App from the Cloudlet.
	DeleteAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_DeleteAppInstClient, error)
	// Refresh Application Instance. Restarts an App instance with new App settings or image.
	RefreshAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_RefreshAppInstClient, error)
	// Update Application Instance. Updates an Application instance and then refreshes it.
	UpdateAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_UpdateAppInstClient, error)
	// Show Application Instances. Lists all the Application instances managed by the Edge Controller.
	// Any fields specified will be used to filter results.
	ShowAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_ShowAppInstClient, error)
}

type appInstApiClient struct {
	cc *grpc.ClientConn
}

func NewAppInstApiClient(cc *grpc.ClientConn) AppInstApiClient {
	return &appInstApiClient{cc}
}

func (c *appInstApiClient) CreateAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_CreateAppInstClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AppInstApi_serviceDesc.Streams[0], c.cc, "/edgeproto.AppInstApi/CreateAppInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstApiCreateAppInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstApi_CreateAppInstClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type appInstApiCreateAppInstClient struct {
	grpc.ClientStream
}

func (x *appInstApiCreateAppInstClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *appInstApiClient) DeleteAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_DeleteAppInstClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AppInstApi_serviceDesc.Streams[1], c.cc, "/edgeproto.AppInstApi/DeleteAppInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstApiDeleteAppInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstApi_DeleteAppInstClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type appInstApiDeleteAppInstClient struct {
	grpc.ClientStream
}

func (x *appInstApiDeleteAppInstClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *appInstApiClient) RefreshAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_RefreshAppInstClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AppInstApi_serviceDesc.Streams[2], c.cc, "/edgeproto.AppInstApi/RefreshAppInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstApiRefreshAppInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstApi_RefreshAppInstClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type appInstApiRefreshAppInstClient struct {
	grpc.ClientStream
}

func (x *appInstApiRefreshAppInstClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *appInstApiClient) UpdateAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_UpdateAppInstClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AppInstApi_serviceDesc.Streams[3], c.cc, "/edgeproto.AppInstApi/UpdateAppInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstApiUpdateAppInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstApi_UpdateAppInstClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type appInstApiUpdateAppInstClient struct {
	grpc.ClientStream
}

func (x *appInstApiUpdateAppInstClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *appInstApiClient) ShowAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_ShowAppInstClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AppInstApi_serviceDesc.Streams[4], c.cc, "/edgeproto.AppInstApi/ShowAppInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstApiShowAppInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstApi_ShowAppInstClient interface {
	Recv() (*AppInst, error)
	grpc.ClientStream
}

type appInstApiShowAppInstClient struct {
	grpc.ClientStream
}

func (x *appInstApiShowAppInstClient) Recv() (*AppInst, error) {
	m := new(AppInst)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AppInstApi service

type AppInstApiServer interface {
	// Create Application Instance. Creates an instance of an App on a Cloudlet where it is
	// defined by an App plus a ClusterInst key. Many of the fields here are inherited from
	// the App definition.
	CreateAppInst(*AppInst, AppInstApi_CreateAppInstServer) error
	// Delete Application Instance. Deletes an instance of the App from the Cloudlet.
	DeleteAppInst(*AppInst, AppInstApi_DeleteAppInstServer) error
	// Refresh Application Instance. Restarts an App instance with new App settings or image.
	RefreshAppInst(*AppInst, AppInstApi_RefreshAppInstServer) error
	// Update Application Instance. Updates an Application instance and then refreshes it.
	UpdateAppInst(*AppInst, AppInstApi_UpdateAppInstServer) error
	// Show Application Instances. Lists all the Application instances managed by the Edge Controller.
	// Any fields specified will be used to filter results.
	ShowAppInst(*AppInst, AppInstApi_ShowAppInstServer) error
}

func RegisterAppInstApiServer(s *grpc.Server, srv AppInstApiServer) {
	s.RegisterService(&_AppInstApi_serviceDesc, srv)
}

func _AppInstApi_CreateAppInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstApiServer).CreateAppInst(m, &appInstApiCreateAppInstServer{stream})
}

type AppInstApi_CreateAppInstServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type appInstApiCreateAppInstServer struct {
	grpc.ServerStream
}

func (x *appInstApiCreateAppInstServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _AppInstApi_DeleteAppInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstApiServer).DeleteAppInst(m, &appInstApiDeleteAppInstServer{stream})
}

type AppInstApi_DeleteAppInstServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type appInstApiDeleteAppInstServer struct {
	grpc.ServerStream
}

func (x *appInstApiDeleteAppInstServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _AppInstApi_RefreshAppInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstApiServer).RefreshAppInst(m, &appInstApiRefreshAppInstServer{stream})
}

type AppInstApi_RefreshAppInstServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type appInstApiRefreshAppInstServer struct {
	grpc.ServerStream
}

func (x *appInstApiRefreshAppInstServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _AppInstApi_UpdateAppInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstApiServer).UpdateAppInst(m, &appInstApiUpdateAppInstServer{stream})
}

type AppInstApi_UpdateAppInstServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type appInstApiUpdateAppInstServer struct {
	grpc.ServerStream
}

func (x *appInstApiUpdateAppInstServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _AppInstApi_ShowAppInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstApiServer).ShowAppInst(m, &appInstApiShowAppInstServer{stream})
}

type AppInstApi_ShowAppInstServer interface {
	Send(*AppInst) error
	grpc.ServerStream
}

type appInstApiShowAppInstServer struct {
	grpc.ServerStream
}

func (x *appInstApiShowAppInstServer) Send(m *AppInst) error {
	return x.ServerStream.SendMsg(m)
}

var _AppInstApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.AppInstApi",
	HandlerType: (*AppInstApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreateAppInst",
			Handler:       _AppInstApi_CreateAppInst_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DeleteAppInst",
			Handler:       _AppInstApi_DeleteAppInst_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RefreshAppInst",
			Handler:       _AppInstApi_RefreshAppInst_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdateAppInst",
			Handler:       _AppInstApi_UpdateAppInst_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowAppInst",
			Handler:       _AppInstApi_ShowAppInst_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "appinst.proto",
}

// Client API for AppInstInfoApi service

type AppInstInfoApiClient interface {
	// Show application instances state.
	ShowAppInstInfo(ctx context.Context, in *AppInstInfo, opts ...grpc.CallOption) (AppInstInfoApi_ShowAppInstInfoClient, error)
}

type appInstInfoApiClient struct {
	cc *grpc.ClientConn
}

func NewAppInstInfoApiClient(cc *grpc.ClientConn) AppInstInfoApiClient {
	return &appInstInfoApiClient{cc}
}

func (c *appInstInfoApiClient) ShowAppInstInfo(ctx context.Context, in *AppInstInfo, opts ...grpc.CallOption) (AppInstInfoApi_ShowAppInstInfoClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AppInstInfoApi_serviceDesc.Streams[0], c.cc, "/edgeproto.AppInstInfoApi/ShowAppInstInfo", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstInfoApiShowAppInstInfoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstInfoApi_ShowAppInstInfoClient interface {
	Recv() (*AppInstInfo, error)
	grpc.ClientStream
}

type appInstInfoApiShowAppInstInfoClient struct {
	grpc.ClientStream
}

func (x *appInstInfoApiShowAppInstInfoClient) Recv() (*AppInstInfo, error) {
	m := new(AppInstInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AppInstInfoApi service

type AppInstInfoApiServer interface {
	// Show application instances state.
	ShowAppInstInfo(*AppInstInfo, AppInstInfoApi_ShowAppInstInfoServer) error
}

func RegisterAppInstInfoApiServer(s *grpc.Server, srv AppInstInfoApiServer) {
	s.RegisterService(&_AppInstInfoApi_serviceDesc, srv)
}

func _AppInstInfoApi_ShowAppInstInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInstInfo)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstInfoApiServer).ShowAppInstInfo(m, &appInstInfoApiShowAppInstInfoServer{stream})
}

type AppInstInfoApi_ShowAppInstInfoServer interface {
	Send(*AppInstInfo) error
	grpc.ServerStream
}

type appInstInfoApiShowAppInstInfoServer struct {
	grpc.ServerStream
}

func (x *appInstInfoApiShowAppInstInfoServer) Send(m *AppInstInfo) error {
	return x.ServerStream.SendMsg(m)
}

var _AppInstInfoApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.AppInstInfoApi",
	HandlerType: (*AppInstInfoApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowAppInstInfo",
			Handler:       _AppInstInfoApi_ShowAppInstInfo_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "appinst.proto",
}

// Client API for AppInstMetricsApi service

type AppInstMetricsApiClient interface {
	// Show application instance metrics.
	ShowAppInstMetrics(ctx context.Context, in *AppInstMetrics, opts ...grpc.CallOption) (AppInstMetricsApi_ShowAppInstMetricsClient, error)
}

type appInstMetricsApiClient struct {
	cc *grpc.ClientConn
}

func NewAppInstMetricsApiClient(cc *grpc.ClientConn) AppInstMetricsApiClient {
	return &appInstMetricsApiClient{cc}
}

func (c *appInstMetricsApiClient) ShowAppInstMetrics(ctx context.Context, in *AppInstMetrics, opts ...grpc.CallOption) (AppInstMetricsApi_ShowAppInstMetricsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AppInstMetricsApi_serviceDesc.Streams[0], c.cc, "/edgeproto.AppInstMetricsApi/ShowAppInstMetrics", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstMetricsApiShowAppInstMetricsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstMetricsApi_ShowAppInstMetricsClient interface {
	Recv() (*AppInstMetrics, error)
	grpc.ClientStream
}

type appInstMetricsApiShowAppInstMetricsClient struct {
	grpc.ClientStream
}

func (x *appInstMetricsApiShowAppInstMetricsClient) Recv() (*AppInstMetrics, error) {
	m := new(AppInstMetrics)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AppInstMetricsApi service

type AppInstMetricsApiServer interface {
	// Show application instance metrics.
	ShowAppInstMetrics(*AppInstMetrics, AppInstMetricsApi_ShowAppInstMetricsServer) error
}

func RegisterAppInstMetricsApiServer(s *grpc.Server, srv AppInstMetricsApiServer) {
	s.RegisterService(&_AppInstMetricsApi_serviceDesc, srv)
}

func _AppInstMetricsApi_ShowAppInstMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInstMetrics)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstMetricsApiServer).ShowAppInstMetrics(m, &appInstMetricsApiShowAppInstMetricsServer{stream})
}

type AppInstMetricsApi_ShowAppInstMetricsServer interface {
	Send(*AppInstMetrics) error
	grpc.ServerStream
}

type appInstMetricsApiShowAppInstMetricsServer struct {
	grpc.ServerStream
}

func (x *appInstMetricsApiShowAppInstMetricsServer) Send(m *AppInstMetrics) error {
	return x.ServerStream.SendMsg(m)
}

var _AppInstMetricsApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.AppInstMetricsApi",
	HandlerType: (*AppInstMetricsApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowAppInstMetrics",
			Handler:       _AppInstMetricsApi_ShowAppInstMetrics_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "appinst.proto",
}

func (m *AppInstKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAppinst(dAtA, i, uint64(m.AppKey.Size()))
	n1, err := m.AppKey.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x22
	i++
	i = encodeVarintAppinst(dAtA, i, uint64(m.ClusterInstKey.Size()))
	n2, err := m.ClusterInstKey.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	return i, nil
}

func (m *AppInst) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInst) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintAppinst(dAtA, i, uint64(m.Key.Size()))
	n3, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAppinst(dAtA, i, uint64(m.CloudletLoc.Size()))
	n4, err := m.CloudletLoc.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if len(m.Uri) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	if m.Liveness != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAppinst(dAtA, i, uint64(m.Liveness))
	}
	if len(m.MappedPorts) > 0 {
		for _, msg := range m.MappedPorts {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintAppinst(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x62
	i++
	i = encodeVarintAppinst(dAtA, i, uint64(m.Flavor.Size()))
	n5, err := m.Flavor.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if m.State != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintAppinst(dAtA, i, uint64(m.State))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			dAtA[i] = 0x7a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.CrmOverride != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAppinst(dAtA, i, uint64(m.CrmOverride))
	}
	dAtA[i] = 0x8a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintAppinst(dAtA, i, uint64(m.RuntimeInfo.Size()))
	n6, err := m.RuntimeInfo.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0xaa
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintAppinst(dAtA, i, uint64(m.CreatedAt.Size()))
	n7, err := m.CreatedAt.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if m.AutoClusterIpAccess != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAppinst(dAtA, i, uint64(m.AutoClusterIpAccess))
	}
	dAtA[i] = 0xba
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintAppinst(dAtA, i, uint64(m.Status.Size()))
	n8, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if len(m.Revision) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.Revision)))
		i += copy(dAtA[i:], m.Revision)
	}
	if m.ForceUpdate {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		if m.ForceUpdate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UpdateMultiple {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		if m.UpdateMultiple {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Configs) > 0 {
		for _, msg := range m.Configs {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintAppinst(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SharedVolumeSize != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAppinst(dAtA, i, uint64(m.SharedVolumeSize))
	}
	if m.HealthCheck != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAppinst(dAtA, i, uint64(m.HealthCheck))
	}
	if len(m.PrivacyPolicy) > 0 {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.PrivacyPolicy)))
		i += copy(dAtA[i:], m.PrivacyPolicy)
	}
	if m.PowerState != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAppinst(dAtA, i, uint64(m.PowerState))
	}
	if m.ExternalVolumeSize != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintAppinst(dAtA, i, uint64(m.ExternalVolumeSize))
	}
	if len(m.AvailabilityZone) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.AvailabilityZone)))
		i += copy(dAtA[i:], m.AvailabilityZone)
	}
	if len(m.VmFlavor) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.VmFlavor)))
		i += copy(dAtA[i:], m.VmFlavor)
	}
	if len(m.OptRes) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.OptRes)))
		i += copy(dAtA[i:], m.OptRes)
	}
	return i, nil
}

func (m *AppInstRuntime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstRuntime) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ContainerIds) > 0 {
		for _, s := range m.ContainerIds {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *AppInstInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintAppinst(dAtA, i, uint64(m.Key.Size()))
	n9, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if m.NotifyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppinst(dAtA, i, uint64(m.NotifyId))
	}
	if m.State != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAppinst(dAtA, i, uint64(m.State))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x32
	i++
	i = encodeVarintAppinst(dAtA, i, uint64(m.RuntimeInfo.Size()))
	n10, err := m.RuntimeInfo.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	dAtA[i] = 0x3a
	i++
	i = encodeVarintAppinst(dAtA, i, uint64(m.Status.Size()))
	n11, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	if m.PowerState != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAppinst(dAtA, i, uint64(m.PowerState))
	}
	return i, nil
}

func (m *AppInstMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstMetrics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Something != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAppinst(dAtA, i, uint64(m.Something))
	}
	return i, nil
}

func (m *AppInstLookup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstLookup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAppinst(dAtA, i, uint64(m.Key.Size()))
	n12, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0x12
	i++
	i = encodeVarintAppinst(dAtA, i, uint64(m.PolicyKey.Size()))
	n13, err := m.PolicyKey.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	return i, nil
}

func encodeVarintAppinst(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AppInstKey) Matches(o *AppInstKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.AppKey.Matches(&o.AppKey, fopts...) {
		return false
	}
	if !opts.IgnoreBackend {
		if !m.ClusterInstKey.Matches(&o.ClusterInstKey, fopts...) {
			return false
		}
	}
	return true
}

func (m *AppInstKey) CopyInFields(src *AppInstKey) int {
	changed := 0
	if m.AppKey.Organization != src.AppKey.Organization {
		m.AppKey.Organization = src.AppKey.Organization
		changed++
	}
	if m.AppKey.Name != src.AppKey.Name {
		m.AppKey.Name = src.AppKey.Name
		changed++
	}
	if m.AppKey.Version != src.AppKey.Version {
		m.AppKey.Version = src.AppKey.Version
		changed++
	}
	if m.ClusterInstKey.ClusterKey.Name != src.ClusterInstKey.ClusterKey.Name {
		m.ClusterInstKey.ClusterKey.Name = src.ClusterInstKey.ClusterKey.Name
		changed++
	}
	if m.ClusterInstKey.CloudletKey.Organization != src.ClusterInstKey.CloudletKey.Organization {
		m.ClusterInstKey.CloudletKey.Organization = src.ClusterInstKey.CloudletKey.Organization
		changed++
	}
	if m.ClusterInstKey.CloudletKey.Name != src.ClusterInstKey.CloudletKey.Name {
		m.ClusterInstKey.CloudletKey.Name = src.ClusterInstKey.CloudletKey.Name
		changed++
	}
	if m.ClusterInstKey.Organization != src.ClusterInstKey.Organization {
		m.ClusterInstKey.Organization = src.ClusterInstKey.Organization
		changed++
	}
	return changed
}

func (m *AppInstKey) DeepCopyIn(src *AppInstKey) {
	m.AppKey.DeepCopyIn(&src.AppKey)
	m.ClusterInstKey.DeepCopyIn(&src.ClusterInstKey)
}

func (m *AppInstKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal AppInstKey key string", "obj", m)
	}
	return string(key)
}

func AppInstKeyStringParse(str string, key *AppInstKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal AppInstKey key string", "str", str)
	}
}

func (m *AppInstKey) NotFoundError() error {
	return fmt.Errorf("AppInst key %s not found", m.GetKeyString())
}

func (m *AppInstKey) ExistsError() error {
	return fmt.Errorf("AppInst key %s already exists", m.GetKeyString())
}

func (m *AppInstKey) GetTags() map[string]string {
	tags := make(map[string]string)
	tags["apporg"] = m.AppKey.Organization
	tags["app"] = m.AppKey.Name
	tags["appver"] = m.AppKey.Version
	tags["cluster"] = m.ClusterInstKey.ClusterKey.Name
	tags["cloudletorg"] = m.ClusterInstKey.CloudletKey.Organization
	tags["cloudlet"] = m.ClusterInstKey.CloudletKey.Name
	tags["clusterorg"] = m.ClusterInstKey.Organization
	return tags
}

// Helper method to check that enums have valid values
func (m *AppInstKey) ValidateEnums() error {
	if err := m.AppKey.ValidateEnums(); err != nil {
		return err
	}
	if err := m.ClusterInstKey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *AppInst) Matches(o *AppInst, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Uri != "" {
			if o.Uri != m.Uri {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Liveness != 0 {
			if o.Liveness != m.Liveness {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.MappedPorts != nil {
			if m.MappedPorts == nil && o.MappedPorts != nil || m.MappedPorts != nil && o.MappedPorts == nil {
				return false
			} else if m.MappedPorts != nil && o.MappedPorts != nil {
				if len(m.MappedPorts) != len(o.MappedPorts) {
					return false
				}
				for i := 0; i < len(m.MappedPorts); i++ {
				}
			}
		}
	}
	if !opts.IgnoreBackend {
		if !m.Flavor.Matches(&o.Flavor, fopts...) {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.State != 0 {
			if o.State != m.State {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Errors != nil {
			if m.Errors == nil && o.Errors != nil || m.Errors != nil && o.Errors == nil {
				return false
			} else if m.Errors != nil && o.Errors != nil {
				if len(m.Errors) != len(o.Errors) {
					return false
				}
				for i := 0; i < len(m.Errors); i++ {
					if o.Errors[i] != m.Errors[i] {
						return false
					}
				}
			}
		}
	}
	if !opts.Filter || o.CrmOverride != 0 {
		if o.CrmOverride != m.CrmOverride {
			return false
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.AutoClusterIpAccess != 0 {
			if o.AutoClusterIpAccess != m.AutoClusterIpAccess {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.Filter || o.Revision != "" {
		if o.Revision != m.Revision {
			return false
		}
	}
	if !opts.Filter || o.ForceUpdate != false {
		if o.ForceUpdate != m.ForceUpdate {
			return false
		}
	}
	if !opts.Filter || o.UpdateMultiple != false {
		if o.UpdateMultiple != m.UpdateMultiple {
			return false
		}
	}
	if !opts.Filter || o.Configs != nil {
		if m.Configs == nil && o.Configs != nil || m.Configs != nil && o.Configs == nil {
			return false
		} else if m.Configs != nil && o.Configs != nil {
			if len(m.Configs) != len(o.Configs) {
				return false
			}
			for i := 0; i < len(m.Configs); i++ {
			}
		}
	}
	if !opts.Filter || o.SharedVolumeSize != 0 {
		if o.SharedVolumeSize != m.SharedVolumeSize {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.HealthCheck != 0 {
			if o.HealthCheck != m.HealthCheck {
				return false
			}
		}
	}
	if !opts.Filter || o.PrivacyPolicy != "" {
		if o.PrivacyPolicy != m.PrivacyPolicy {
			return false
		}
	}
	if !opts.Filter || o.PowerState != 0 {
		if o.PowerState != m.PowerState {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.ExternalVolumeSize != 0 {
			if o.ExternalVolumeSize != m.ExternalVolumeSize {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.AvailabilityZone != "" {
			if o.AvailabilityZone != m.AvailabilityZone {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.VmFlavor != "" {
			if o.VmFlavor != m.VmFlavor {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.OptRes != "" {
			if o.OptRes != m.OptRes {
				return false
			}
		}
	}
	return true
}

const AppInstFieldKey = "2"
const AppInstFieldKeyAppKey = "2.1"
const AppInstFieldKeyAppKeyOrganization = "2.1.1"
const AppInstFieldKeyAppKeyName = "2.1.2"
const AppInstFieldKeyAppKeyVersion = "2.1.3"
const AppInstFieldKeyClusterInstKey = "2.4"
const AppInstFieldKeyClusterInstKeyClusterKey = "2.4.1"
const AppInstFieldKeyClusterInstKeyClusterKeyName = "2.4.1.1"
const AppInstFieldKeyClusterInstKeyCloudletKey = "2.4.2"
const AppInstFieldKeyClusterInstKeyCloudletKeyOrganization = "2.4.2.1"
const AppInstFieldKeyClusterInstKeyCloudletKeyName = "2.4.2.2"
const AppInstFieldKeyClusterInstKeyOrganization = "2.4.3"
const AppInstFieldCloudletLoc = "3"
const AppInstFieldCloudletLocLatitude = "3.1"
const AppInstFieldCloudletLocLongitude = "3.2"
const AppInstFieldCloudletLocHorizontalAccuracy = "3.3"
const AppInstFieldCloudletLocVerticalAccuracy = "3.4"
const AppInstFieldCloudletLocAltitude = "3.5"
const AppInstFieldCloudletLocCourse = "3.6"
const AppInstFieldCloudletLocSpeed = "3.7"
const AppInstFieldCloudletLocTimestamp = "3.8"
const AppInstFieldCloudletLocTimestampSeconds = "3.8.1"
const AppInstFieldCloudletLocTimestampNanos = "3.8.2"
const AppInstFieldUri = "4"
const AppInstFieldLiveness = "6"
const AppInstFieldMappedPorts = "9"
const AppInstFieldMappedPortsProto = "9.1"
const AppInstFieldMappedPortsInternalPort = "9.2"
const AppInstFieldMappedPortsPublicPort = "9.3"
const AppInstFieldMappedPortsFqdnPrefix = "9.5"
const AppInstFieldMappedPortsEndPort = "9.6"
const AppInstFieldMappedPortsTls = "9.7"
const AppInstFieldMappedPortsNginx = "9.8"
const AppInstFieldFlavor = "12"
const AppInstFieldFlavorName = "12.1"
const AppInstFieldState = "14"
const AppInstFieldErrors = "15"
const AppInstFieldCrmOverride = "16"
const AppInstFieldRuntimeInfo = "17"
const AppInstFieldRuntimeInfoContainerIds = "17.1"
const AppInstFieldCreatedAt = "21"
const AppInstFieldCreatedAtSeconds = "21.1"
const AppInstFieldCreatedAtNanos = "21.2"
const AppInstFieldAutoClusterIpAccess = "22"
const AppInstFieldStatus = "23"
const AppInstFieldStatusTaskNumber = "23.1"
const AppInstFieldStatusMaxTasks = "23.2"
const AppInstFieldStatusTaskName = "23.3"
const AppInstFieldStatusStepName = "23.4"
const AppInstFieldRevision = "24"
const AppInstFieldForceUpdate = "25"
const AppInstFieldUpdateMultiple = "26"
const AppInstFieldConfigs = "27"
const AppInstFieldConfigsKind = "27.1"
const AppInstFieldConfigsConfig = "27.2"
const AppInstFieldSharedVolumeSize = "28"
const AppInstFieldHealthCheck = "29"
const AppInstFieldPrivacyPolicy = "30"
const AppInstFieldPowerState = "31"
const AppInstFieldExternalVolumeSize = "32"
const AppInstFieldAvailabilityZone = "33"
const AppInstFieldVmFlavor = "34"
const AppInstFieldOptRes = "35"

var AppInstAllFields = []string{
	AppInstFieldKeyAppKeyOrganization,
	AppInstFieldKeyAppKeyName,
	AppInstFieldKeyAppKeyVersion,
	AppInstFieldKeyClusterInstKeyClusterKeyName,
	AppInstFieldKeyClusterInstKeyCloudletKeyOrganization,
	AppInstFieldKeyClusterInstKeyCloudletKeyName,
	AppInstFieldKeyClusterInstKeyOrganization,
	AppInstFieldCloudletLocLatitude,
	AppInstFieldCloudletLocLongitude,
	AppInstFieldCloudletLocHorizontalAccuracy,
	AppInstFieldCloudletLocVerticalAccuracy,
	AppInstFieldCloudletLocAltitude,
	AppInstFieldCloudletLocCourse,
	AppInstFieldCloudletLocSpeed,
	AppInstFieldCloudletLocTimestampSeconds,
	AppInstFieldCloudletLocTimestampNanos,
	AppInstFieldUri,
	AppInstFieldLiveness,
	AppInstFieldMappedPortsProto,
	AppInstFieldMappedPortsInternalPort,
	AppInstFieldMappedPortsPublicPort,
	AppInstFieldMappedPortsFqdnPrefix,
	AppInstFieldMappedPortsEndPort,
	AppInstFieldMappedPortsTls,
	AppInstFieldMappedPortsNginx,
	AppInstFieldFlavorName,
	AppInstFieldState,
	AppInstFieldErrors,
	AppInstFieldCrmOverride,
	AppInstFieldRuntimeInfoContainerIds,
	AppInstFieldCreatedAtSeconds,
	AppInstFieldCreatedAtNanos,
	AppInstFieldAutoClusterIpAccess,
	AppInstFieldStatusTaskNumber,
	AppInstFieldStatusMaxTasks,
	AppInstFieldStatusTaskName,
	AppInstFieldStatusStepName,
	AppInstFieldRevision,
	AppInstFieldForceUpdate,
	AppInstFieldUpdateMultiple,
	AppInstFieldConfigsKind,
	AppInstFieldConfigsConfig,
	AppInstFieldSharedVolumeSize,
	AppInstFieldHealthCheck,
	AppInstFieldPrivacyPolicy,
	AppInstFieldPowerState,
	AppInstFieldExternalVolumeSize,
	AppInstFieldAvailabilityZone,
	AppInstFieldVmFlavor,
	AppInstFieldOptRes,
}

var AppInstAllFieldsMap = map[string]struct{}{
	AppInstFieldKeyAppKeyOrganization:                    struct{}{},
	AppInstFieldKeyAppKeyName:                            struct{}{},
	AppInstFieldKeyAppKeyVersion:                         struct{}{},
	AppInstFieldKeyClusterInstKeyClusterKeyName:          struct{}{},
	AppInstFieldKeyClusterInstKeyCloudletKeyOrganization: struct{}{},
	AppInstFieldKeyClusterInstKeyCloudletKeyName:         struct{}{},
	AppInstFieldKeyClusterInstKeyOrganization:            struct{}{},
	AppInstFieldCloudletLocLatitude:                      struct{}{},
	AppInstFieldCloudletLocLongitude:                     struct{}{},
	AppInstFieldCloudletLocHorizontalAccuracy:            struct{}{},
	AppInstFieldCloudletLocVerticalAccuracy:              struct{}{},
	AppInstFieldCloudletLocAltitude:                      struct{}{},
	AppInstFieldCloudletLocCourse:                        struct{}{},
	AppInstFieldCloudletLocSpeed:                         struct{}{},
	AppInstFieldCloudletLocTimestampSeconds:              struct{}{},
	AppInstFieldCloudletLocTimestampNanos:                struct{}{},
	AppInstFieldUri:                                      struct{}{},
	AppInstFieldLiveness:                                 struct{}{},
	AppInstFieldMappedPortsProto:                         struct{}{},
	AppInstFieldMappedPortsInternalPort:                  struct{}{},
	AppInstFieldMappedPortsPublicPort:                    struct{}{},
	AppInstFieldMappedPortsFqdnPrefix:                    struct{}{},
	AppInstFieldMappedPortsEndPort:                       struct{}{},
	AppInstFieldMappedPortsTls:                           struct{}{},
	AppInstFieldMappedPortsNginx:                         struct{}{},
	AppInstFieldFlavorName:                               struct{}{},
	AppInstFieldState:                                    struct{}{},
	AppInstFieldErrors:                                   struct{}{},
	AppInstFieldCrmOverride:                              struct{}{},
	AppInstFieldRuntimeInfoContainerIds:                  struct{}{},
	AppInstFieldCreatedAtSeconds:                         struct{}{},
	AppInstFieldCreatedAtNanos:                           struct{}{},
	AppInstFieldAutoClusterIpAccess:                      struct{}{},
	AppInstFieldStatusTaskNumber:                         struct{}{},
	AppInstFieldStatusMaxTasks:                           struct{}{},
	AppInstFieldStatusTaskName:                           struct{}{},
	AppInstFieldStatusStepName:                           struct{}{},
	AppInstFieldRevision:                                 struct{}{},
	AppInstFieldForceUpdate:                              struct{}{},
	AppInstFieldUpdateMultiple:                           struct{}{},
	AppInstFieldConfigsKind:                              struct{}{},
	AppInstFieldConfigsConfig:                            struct{}{},
	AppInstFieldSharedVolumeSize:                         struct{}{},
	AppInstFieldHealthCheck:                              struct{}{},
	AppInstFieldPrivacyPolicy:                            struct{}{},
	AppInstFieldPowerState:                               struct{}{},
	AppInstFieldExternalVolumeSize:                       struct{}{},
	AppInstFieldAvailabilityZone:                         struct{}{},
	AppInstFieldVmFlavor:                                 struct{}{},
	AppInstFieldOptRes:                                   struct{}{},
}

var AppInstAllFieldsStringMap = map[string]string{
	AppInstFieldKeyAppKeyOrganization:                    "Key App Key Organization",
	AppInstFieldKeyAppKeyName:                            "Key App Key Name",
	AppInstFieldKeyAppKeyVersion:                         "Key App Key Version",
	AppInstFieldKeyClusterInstKeyClusterKeyName:          "Key Cluster Inst Key Cluster Key Name",
	AppInstFieldKeyClusterInstKeyCloudletKeyOrganization: "Key Cluster Inst Key Cloudlet Key Organization",
	AppInstFieldKeyClusterInstKeyCloudletKeyName:         "Key Cluster Inst Key Cloudlet Key Name",
	AppInstFieldKeyClusterInstKeyOrganization:            "Key Cluster Inst Key Organization",
	AppInstFieldCloudletLocLatitude:                      "Cloudlet Loc Latitude",
	AppInstFieldCloudletLocLongitude:                     "Cloudlet Loc Longitude",
	AppInstFieldCloudletLocHorizontalAccuracy:            "Cloudlet Loc Horizontal Accuracy",
	AppInstFieldCloudletLocVerticalAccuracy:              "Cloudlet Loc Vertical Accuracy",
	AppInstFieldCloudletLocAltitude:                      "Cloudlet Loc Altitude",
	AppInstFieldCloudletLocCourse:                        "Cloudlet Loc Course",
	AppInstFieldCloudletLocSpeed:                         "Cloudlet Loc Speed",
	AppInstFieldCloudletLocTimestampSeconds:              "Cloudlet Loc Timestamp Seconds",
	AppInstFieldCloudletLocTimestampNanos:                "Cloudlet Loc Timestamp Nanos",
	AppInstFieldUri:                                      "Uri",
	AppInstFieldLiveness:                                 "Liveness",
	AppInstFieldMappedPortsProto:                         "Mapped Ports Proto",
	AppInstFieldMappedPortsInternalPort:                  "Mapped Ports Internal Port",
	AppInstFieldMappedPortsPublicPort:                    "Mapped Ports Public Port",
	AppInstFieldMappedPortsFqdnPrefix:                    "Mapped Ports Fqdn Prefix",
	AppInstFieldMappedPortsEndPort:                       "Mapped Ports End Port",
	AppInstFieldMappedPortsTls:                           "Mapped Ports Tls",
	AppInstFieldMappedPortsNginx:                         "Mapped Ports Nginx",
	AppInstFieldFlavorName:                               "Flavor Name",
	AppInstFieldState:                                    "State",
	AppInstFieldErrors:                                   "Errors",
	AppInstFieldCrmOverride:                              "Crm Override",
	AppInstFieldRuntimeInfoContainerIds:                  "Runtime Info Container Ids",
	AppInstFieldCreatedAtSeconds:                         "Created At Seconds",
	AppInstFieldCreatedAtNanos:                           "Created At Nanos",
	AppInstFieldAutoClusterIpAccess:                      "Auto Cluster Ip Access",
	AppInstFieldStatusTaskNumber:                         "Status Task Number",
	AppInstFieldStatusMaxTasks:                           "Status Max Tasks",
	AppInstFieldStatusTaskName:                           "Status Task Name",
	AppInstFieldStatusStepName:                           "Status Step Name",
	AppInstFieldRevision:                                 "Revision",
	AppInstFieldForceUpdate:                              "Force Update",
	AppInstFieldUpdateMultiple:                           "Update Multiple",
	AppInstFieldConfigsKind:                              "Configs Kind",
	AppInstFieldConfigsConfig:                            "Configs Config",
	AppInstFieldSharedVolumeSize:                         "Shared Volume Size",
	AppInstFieldHealthCheck:                              "Health Check",
	AppInstFieldPrivacyPolicy:                            "Privacy Policy",
	AppInstFieldPowerState:                               "Power State",
	AppInstFieldExternalVolumeSize:                       "External Volume Size",
	AppInstFieldAvailabilityZone:                         "Availability Zone",
	AppInstFieldVmFlavor:                                 "Vm Flavor",
	AppInstFieldOptRes:                                   "Opt Res",
}

func (m *AppInst) IsKeyField(s string) bool {
	return strings.HasPrefix(s, AppInstFieldKey+".") || s == AppInstFieldKey
}

func (m *AppInst) DiffFields(o *AppInst, fields map[string]struct{}) {
	if m.Key.AppKey.Organization != o.Key.AppKey.Organization {
		fields[AppInstFieldKeyAppKeyOrganization] = struct{}{}
		fields[AppInstFieldKeyAppKey] = struct{}{}
		fields[AppInstFieldKey] = struct{}{}
	}
	if m.Key.AppKey.Name != o.Key.AppKey.Name {
		fields[AppInstFieldKeyAppKeyName] = struct{}{}
		fields[AppInstFieldKeyAppKey] = struct{}{}
		fields[AppInstFieldKey] = struct{}{}
	}
	if m.Key.AppKey.Version != o.Key.AppKey.Version {
		fields[AppInstFieldKeyAppKeyVersion] = struct{}{}
		fields[AppInstFieldKeyAppKey] = struct{}{}
		fields[AppInstFieldKey] = struct{}{}
	}
	if m.Key.ClusterInstKey.ClusterKey.Name != o.Key.ClusterInstKey.ClusterKey.Name {
		fields[AppInstFieldKeyClusterInstKeyClusterKeyName] = struct{}{}
		fields[AppInstFieldKeyClusterInstKeyClusterKey] = struct{}{}
		fields[AppInstFieldKeyClusterInstKey] = struct{}{}
		fields[AppInstFieldKey] = struct{}{}
	}
	if m.Key.ClusterInstKey.CloudletKey.Organization != o.Key.ClusterInstKey.CloudletKey.Organization {
		fields[AppInstFieldKeyClusterInstKeyCloudletKeyOrganization] = struct{}{}
		fields[AppInstFieldKeyClusterInstKeyCloudletKey] = struct{}{}
		fields[AppInstFieldKeyClusterInstKey] = struct{}{}
		fields[AppInstFieldKey] = struct{}{}
	}
	if m.Key.ClusterInstKey.CloudletKey.Name != o.Key.ClusterInstKey.CloudletKey.Name {
		fields[AppInstFieldKeyClusterInstKeyCloudletKeyName] = struct{}{}
		fields[AppInstFieldKeyClusterInstKeyCloudletKey] = struct{}{}
		fields[AppInstFieldKeyClusterInstKey] = struct{}{}
		fields[AppInstFieldKey] = struct{}{}
	}
	if m.Key.ClusterInstKey.Organization != o.Key.ClusterInstKey.Organization {
		fields[AppInstFieldKeyClusterInstKeyOrganization] = struct{}{}
		fields[AppInstFieldKeyClusterInstKey] = struct{}{}
		fields[AppInstFieldKey] = struct{}{}
	}
	if m.CloudletLoc.Latitude != o.CloudletLoc.Latitude {
		fields[AppInstFieldCloudletLocLatitude] = struct{}{}
		fields[AppInstFieldCloudletLoc] = struct{}{}
	}
	if m.CloudletLoc.Longitude != o.CloudletLoc.Longitude {
		fields[AppInstFieldCloudletLocLongitude] = struct{}{}
		fields[AppInstFieldCloudletLoc] = struct{}{}
	}
	if m.CloudletLoc.HorizontalAccuracy != o.CloudletLoc.HorizontalAccuracy {
		fields[AppInstFieldCloudletLocHorizontalAccuracy] = struct{}{}
		fields[AppInstFieldCloudletLoc] = struct{}{}
	}
	if m.CloudletLoc.VerticalAccuracy != o.CloudletLoc.VerticalAccuracy {
		fields[AppInstFieldCloudletLocVerticalAccuracy] = struct{}{}
		fields[AppInstFieldCloudletLoc] = struct{}{}
	}
	if m.CloudletLoc.Altitude != o.CloudletLoc.Altitude {
		fields[AppInstFieldCloudletLocAltitude] = struct{}{}
		fields[AppInstFieldCloudletLoc] = struct{}{}
	}
	if m.CloudletLoc.Course != o.CloudletLoc.Course {
		fields[AppInstFieldCloudletLocCourse] = struct{}{}
		fields[AppInstFieldCloudletLoc] = struct{}{}
	}
	if m.CloudletLoc.Speed != o.CloudletLoc.Speed {
		fields[AppInstFieldCloudletLocSpeed] = struct{}{}
		fields[AppInstFieldCloudletLoc] = struct{}{}
	}
	if m.CloudletLoc.Timestamp != nil && o.CloudletLoc.Timestamp != nil {
		if m.CloudletLoc.Timestamp.Seconds != o.CloudletLoc.Timestamp.Seconds {
			fields[AppInstFieldCloudletLocTimestampSeconds] = struct{}{}
			fields[AppInstFieldCloudletLocTimestamp] = struct{}{}
			fields[AppInstFieldCloudletLoc] = struct{}{}
		}
		if m.CloudletLoc.Timestamp.Nanos != o.CloudletLoc.Timestamp.Nanos {
			fields[AppInstFieldCloudletLocTimestampNanos] = struct{}{}
			fields[AppInstFieldCloudletLocTimestamp] = struct{}{}
			fields[AppInstFieldCloudletLoc] = struct{}{}
		}
	} else if (m.CloudletLoc.Timestamp != nil && o.CloudletLoc.Timestamp == nil) || (m.CloudletLoc.Timestamp == nil && o.CloudletLoc.Timestamp != nil) {
		fields[AppInstFieldCloudletLocTimestamp] = struct{}{}
		fields[AppInstFieldCloudletLoc] = struct{}{}
	}
	if m.Uri != o.Uri {
		fields[AppInstFieldUri] = struct{}{}
	}
	if m.Liveness != o.Liveness {
		fields[AppInstFieldLiveness] = struct{}{}
	}
	if len(m.MappedPorts) != len(o.MappedPorts) {
		fields[AppInstFieldMappedPorts] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.MappedPorts); i0++ {
			if m.MappedPorts[i0].Proto != o.MappedPorts[i0].Proto {
				fields[AppInstFieldMappedPortsProto] = struct{}{}
				fields[AppInstFieldMappedPorts] = struct{}{}
			}
			if m.MappedPorts[i0].InternalPort != o.MappedPorts[i0].InternalPort {
				fields[AppInstFieldMappedPortsInternalPort] = struct{}{}
				fields[AppInstFieldMappedPorts] = struct{}{}
			}
			if m.MappedPorts[i0].PublicPort != o.MappedPorts[i0].PublicPort {
				fields[AppInstFieldMappedPortsPublicPort] = struct{}{}
				fields[AppInstFieldMappedPorts] = struct{}{}
			}
			if m.MappedPorts[i0].FqdnPrefix != o.MappedPorts[i0].FqdnPrefix {
				fields[AppInstFieldMappedPortsFqdnPrefix] = struct{}{}
				fields[AppInstFieldMappedPorts] = struct{}{}
			}
			if m.MappedPorts[i0].EndPort != o.MappedPorts[i0].EndPort {
				fields[AppInstFieldMappedPortsEndPort] = struct{}{}
				fields[AppInstFieldMappedPorts] = struct{}{}
			}
			if m.MappedPorts[i0].Tls != o.MappedPorts[i0].Tls {
				fields[AppInstFieldMappedPortsTls] = struct{}{}
				fields[AppInstFieldMappedPorts] = struct{}{}
			}
			if m.MappedPorts[i0].Nginx != o.MappedPorts[i0].Nginx {
				fields[AppInstFieldMappedPortsNginx] = struct{}{}
				fields[AppInstFieldMappedPorts] = struct{}{}
			}
		}
	}
	if m.Flavor.Name != o.Flavor.Name {
		fields[AppInstFieldFlavorName] = struct{}{}
		fields[AppInstFieldFlavor] = struct{}{}
	}
	if m.State != o.State {
		fields[AppInstFieldState] = struct{}{}
	}
	if len(m.Errors) != len(o.Errors) {
		fields[AppInstFieldErrors] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.Errors); i0++ {
			if m.Errors[i0] != o.Errors[i0] {
				fields[AppInstFieldErrors] = struct{}{}
				break
			}
		}
	}
	if m.CrmOverride != o.CrmOverride {
		fields[AppInstFieldCrmOverride] = struct{}{}
	}
	if len(m.RuntimeInfo.ContainerIds) != len(o.RuntimeInfo.ContainerIds) {
		fields[AppInstFieldRuntimeInfoContainerIds] = struct{}{}
		fields[AppInstFieldRuntimeInfo] = struct{}{}
	} else {
		for i1 := 0; i1 < len(m.RuntimeInfo.ContainerIds); i1++ {
			if m.RuntimeInfo.ContainerIds[i1] != o.RuntimeInfo.ContainerIds[i1] {
				fields[AppInstFieldRuntimeInfoContainerIds] = struct{}{}
				fields[AppInstFieldRuntimeInfo] = struct{}{}
				break
			}
		}
	}
	if m.CreatedAt.Seconds != o.CreatedAt.Seconds {
		fields[AppInstFieldCreatedAtSeconds] = struct{}{}
		fields[AppInstFieldCreatedAt] = struct{}{}
	}
	if m.CreatedAt.Nanos != o.CreatedAt.Nanos {
		fields[AppInstFieldCreatedAtNanos] = struct{}{}
		fields[AppInstFieldCreatedAt] = struct{}{}
	}
	if m.AutoClusterIpAccess != o.AutoClusterIpAccess {
		fields[AppInstFieldAutoClusterIpAccess] = struct{}{}
	}
	if m.Status.TaskNumber != o.Status.TaskNumber {
		fields[AppInstFieldStatusTaskNumber] = struct{}{}
		fields[AppInstFieldStatus] = struct{}{}
	}
	if m.Status.MaxTasks != o.Status.MaxTasks {
		fields[AppInstFieldStatusMaxTasks] = struct{}{}
		fields[AppInstFieldStatus] = struct{}{}
	}
	if m.Status.TaskName != o.Status.TaskName {
		fields[AppInstFieldStatusTaskName] = struct{}{}
		fields[AppInstFieldStatus] = struct{}{}
	}
	if m.Status.StepName != o.Status.StepName {
		fields[AppInstFieldStatusStepName] = struct{}{}
		fields[AppInstFieldStatus] = struct{}{}
	}
	if m.Revision != o.Revision {
		fields[AppInstFieldRevision] = struct{}{}
	}
	if m.ForceUpdate != o.ForceUpdate {
		fields[AppInstFieldForceUpdate] = struct{}{}
	}
	if m.UpdateMultiple != o.UpdateMultiple {
		fields[AppInstFieldUpdateMultiple] = struct{}{}
	}
	if m.Configs != nil && o.Configs != nil {
		if len(m.Configs) != len(o.Configs) {
			fields[AppInstFieldConfigs] = struct{}{}
		} else {
			for i0 := 0; i0 < len(m.Configs); i0++ {
				if m.Configs[i0].Kind != o.Configs[i0].Kind {
					fields[AppInstFieldConfigsKind] = struct{}{}
					fields[AppInstFieldConfigs] = struct{}{}
				}
				if m.Configs[i0].Config != o.Configs[i0].Config {
					fields[AppInstFieldConfigsConfig] = struct{}{}
					fields[AppInstFieldConfigs] = struct{}{}
				}
			}
		}
	} else if (m.Configs != nil && o.Configs == nil) || (m.Configs == nil && o.Configs != nil) {
		fields[AppInstFieldConfigs] = struct{}{}
	}
	if m.SharedVolumeSize != o.SharedVolumeSize {
		fields[AppInstFieldSharedVolumeSize] = struct{}{}
	}
	if m.HealthCheck != o.HealthCheck {
		fields[AppInstFieldHealthCheck] = struct{}{}
	}
	if m.PrivacyPolicy != o.PrivacyPolicy {
		fields[AppInstFieldPrivacyPolicy] = struct{}{}
	}
	if m.PowerState != o.PowerState {
		fields[AppInstFieldPowerState] = struct{}{}
	}
	if m.ExternalVolumeSize != o.ExternalVolumeSize {
		fields[AppInstFieldExternalVolumeSize] = struct{}{}
	}
	if m.AvailabilityZone != o.AvailabilityZone {
		fields[AppInstFieldAvailabilityZone] = struct{}{}
	}
	if m.VmFlavor != o.VmFlavor {
		fields[AppInstFieldVmFlavor] = struct{}{}
	}
	if m.OptRes != o.OptRes {
		fields[AppInstFieldOptRes] = struct{}{}
	}
}

var UpdateAppInstFieldsMap = map[string]struct{}{
	AppInstFieldCrmOverride:   struct{}{},
	AppInstFieldConfigs:       struct{}{},
	AppInstFieldConfigsKind:   struct{}{},
	AppInstFieldConfigsConfig: struct{}{},
	AppInstFieldPowerState:    struct{}{},
}

func (m *AppInst) ValidateUpdateFields() error {
	if m.Fields == nil {
		return fmt.Errorf("nothing specified to update")
	}
	fmap := MakeFieldMap(m.Fields)
	badFieldStrs := []string{}
	for field, _ := range fmap {
		if m.IsKeyField(field) {
			continue
		}
		if _, ok := UpdateAppInstFieldsMap[field]; !ok {
			if _, ok := AppInstAllFieldsStringMap[field]; !ok {
				continue
			}
			badFieldStrs = append(badFieldStrs, AppInstAllFieldsStringMap[field])
		}
	}
	if len(badFieldStrs) > 0 {
		return fmt.Errorf("specified field(s) %s cannot be modified", strings.Join(badFieldStrs, ","))
	}
	return nil
}

func (m *AppInst) CopyInFields(src *AppInst) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if _, set := fmap["2.1.1"]; set {
				if m.Key.AppKey.Organization != src.Key.AppKey.Organization {
					m.Key.AppKey.Organization = src.Key.AppKey.Organization
					changed++
				}
			}
			if _, set := fmap["2.1.2"]; set {
				if m.Key.AppKey.Name != src.Key.AppKey.Name {
					m.Key.AppKey.Name = src.Key.AppKey.Name
					changed++
				}
			}
			if _, set := fmap["2.1.3"]; set {
				if m.Key.AppKey.Version != src.Key.AppKey.Version {
					m.Key.AppKey.Version = src.Key.AppKey.Version
					changed++
				}
			}
		}
		if _, set := fmap["2.4"]; set {
			if _, set := fmap["2.4.1"]; set {
				if _, set := fmap["2.4.1.1"]; set {
					if m.Key.ClusterInstKey.ClusterKey.Name != src.Key.ClusterInstKey.ClusterKey.Name {
						m.Key.ClusterInstKey.ClusterKey.Name = src.Key.ClusterInstKey.ClusterKey.Name
						changed++
					}
				}
			}
			if _, set := fmap["2.4.2"]; set {
				if _, set := fmap["2.4.2.1"]; set {
					if m.Key.ClusterInstKey.CloudletKey.Organization != src.Key.ClusterInstKey.CloudletKey.Organization {
						m.Key.ClusterInstKey.CloudletKey.Organization = src.Key.ClusterInstKey.CloudletKey.Organization
						changed++
					}
				}
				if _, set := fmap["2.4.2.2"]; set {
					if m.Key.ClusterInstKey.CloudletKey.Name != src.Key.ClusterInstKey.CloudletKey.Name {
						m.Key.ClusterInstKey.CloudletKey.Name = src.Key.ClusterInstKey.CloudletKey.Name
						changed++
					}
				}
			}
			if _, set := fmap["2.4.3"]; set {
				if m.Key.ClusterInstKey.Organization != src.Key.ClusterInstKey.Organization {
					m.Key.ClusterInstKey.Organization = src.Key.ClusterInstKey.Organization
					changed++
				}
			}
		}
	}
	if _, set := fmap["3"]; set {
		if _, set := fmap["3.1"]; set {
			if m.CloudletLoc.Latitude != src.CloudletLoc.Latitude {
				m.CloudletLoc.Latitude = src.CloudletLoc.Latitude
				changed++
			}
		}
		if _, set := fmap["3.2"]; set {
			if m.CloudletLoc.Longitude != src.CloudletLoc.Longitude {
				m.CloudletLoc.Longitude = src.CloudletLoc.Longitude
				changed++
			}
		}
		if _, set := fmap["3.3"]; set {
			if m.CloudletLoc.HorizontalAccuracy != src.CloudletLoc.HorizontalAccuracy {
				m.CloudletLoc.HorizontalAccuracy = src.CloudletLoc.HorizontalAccuracy
				changed++
			}
		}
		if _, set := fmap["3.4"]; set {
			if m.CloudletLoc.VerticalAccuracy != src.CloudletLoc.VerticalAccuracy {
				m.CloudletLoc.VerticalAccuracy = src.CloudletLoc.VerticalAccuracy
				changed++
			}
		}
		if _, set := fmap["3.5"]; set {
			if m.CloudletLoc.Altitude != src.CloudletLoc.Altitude {
				m.CloudletLoc.Altitude = src.CloudletLoc.Altitude
				changed++
			}
		}
		if _, set := fmap["3.6"]; set {
			if m.CloudletLoc.Course != src.CloudletLoc.Course {
				m.CloudletLoc.Course = src.CloudletLoc.Course
				changed++
			}
		}
		if _, set := fmap["3.7"]; set {
			if m.CloudletLoc.Speed != src.CloudletLoc.Speed {
				m.CloudletLoc.Speed = src.CloudletLoc.Speed
				changed++
			}
		}
		if _, set := fmap["3.8"]; set {
			if src.CloudletLoc.Timestamp != nil {
				m.CloudletLoc.Timestamp = &distributed_match_engine.Timestamp{}
				if _, set := fmap["3.8.1"]; set {
					if m.CloudletLoc.Timestamp.Seconds != src.CloudletLoc.Timestamp.Seconds {
						m.CloudletLoc.Timestamp.Seconds = src.CloudletLoc.Timestamp.Seconds
						changed++
					}
				}
				if _, set := fmap["3.8.2"]; set {
					if m.CloudletLoc.Timestamp.Nanos != src.CloudletLoc.Timestamp.Nanos {
						m.CloudletLoc.Timestamp.Nanos = src.CloudletLoc.Timestamp.Nanos
						changed++
					}
				}
			} else if m.CloudletLoc.Timestamp != nil {
				m.CloudletLoc.Timestamp = nil
				changed++
			}
		}
	}
	if _, set := fmap["4"]; set {
		if m.Uri != src.Uri {
			m.Uri = src.Uri
			changed++
		}
	}
	if _, set := fmap["6"]; set {
		if m.Liveness != src.Liveness {
			m.Liveness = src.Liveness
			changed++
		}
	}
	if _, set := fmap["9"]; set {
		if src.MappedPorts != nil {
			m.MappedPorts = src.MappedPorts
			changed++
		} else if m.MappedPorts != nil {
			m.MappedPorts = nil
			changed++
		}
	}
	if _, set := fmap["12"]; set {
		if _, set := fmap["12.1"]; set {
			if m.Flavor.Name != src.Flavor.Name {
				m.Flavor.Name = src.Flavor.Name
				changed++
			}
		}
	}
	if _, set := fmap["14"]; set {
		if m.State != src.State {
			m.State = src.State
			changed++
		}
	}
	if _, set := fmap["15"]; set {
		if src.Errors != nil {
			m.Errors = src.Errors
			changed++
		} else if m.Errors != nil {
			m.Errors = nil
			changed++
		}
	}
	if _, set := fmap["16"]; set {
		if m.CrmOverride != src.CrmOverride {
			m.CrmOverride = src.CrmOverride
			changed++
		}
	}
	if _, set := fmap["17"]; set {
		if _, set := fmap["17.1"]; set {
			if src.RuntimeInfo.ContainerIds != nil {
				m.RuntimeInfo.ContainerIds = src.RuntimeInfo.ContainerIds
				changed++
			} else if m.RuntimeInfo.ContainerIds != nil {
				m.RuntimeInfo.ContainerIds = nil
				changed++
			}
		}
	}
	if _, set := fmap["21"]; set {
		if _, set := fmap["21.1"]; set {
			if m.CreatedAt.Seconds != src.CreatedAt.Seconds {
				m.CreatedAt.Seconds = src.CreatedAt.Seconds
				changed++
			}
		}
		if _, set := fmap["21.2"]; set {
			if m.CreatedAt.Nanos != src.CreatedAt.Nanos {
				m.CreatedAt.Nanos = src.CreatedAt.Nanos
				changed++
			}
		}
	}
	if _, set := fmap["22"]; set {
		if m.AutoClusterIpAccess != src.AutoClusterIpAccess {
			m.AutoClusterIpAccess = src.AutoClusterIpAccess
			changed++
		}
	}
	if _, set := fmap["23"]; set {
		if _, set := fmap["23.1"]; set {
			if m.Status.TaskNumber != src.Status.TaskNumber {
				m.Status.TaskNumber = src.Status.TaskNumber
				changed++
			}
		}
		if _, set := fmap["23.2"]; set {
			if m.Status.MaxTasks != src.Status.MaxTasks {
				m.Status.MaxTasks = src.Status.MaxTasks
				changed++
			}
		}
		if _, set := fmap["23.3"]; set {
			if m.Status.TaskName != src.Status.TaskName {
				m.Status.TaskName = src.Status.TaskName
				changed++
			}
		}
		if _, set := fmap["23.4"]; set {
			if m.Status.StepName != src.Status.StepName {
				m.Status.StepName = src.Status.StepName
				changed++
			}
		}
	}
	if _, set := fmap["24"]; set {
		if m.Revision != src.Revision {
			m.Revision = src.Revision
			changed++
		}
	}
	if _, set := fmap["25"]; set {
		if m.ForceUpdate != src.ForceUpdate {
			m.ForceUpdate = src.ForceUpdate
			changed++
		}
	}
	if _, set := fmap["26"]; set {
		if m.UpdateMultiple != src.UpdateMultiple {
			m.UpdateMultiple = src.UpdateMultiple
			changed++
		}
	}
	if _, set := fmap["27"]; set {
		if src.Configs != nil {
			m.Configs = src.Configs
			changed++
		} else if m.Configs != nil {
			m.Configs = nil
			changed++
		}
	}
	if _, set := fmap["28"]; set {
		if m.SharedVolumeSize != src.SharedVolumeSize {
			m.SharedVolumeSize = src.SharedVolumeSize
			changed++
		}
	}
	if _, set := fmap["29"]; set {
		if m.HealthCheck != src.HealthCheck {
			m.HealthCheck = src.HealthCheck
			changed++
		}
	}
	if _, set := fmap["30"]; set {
		if m.PrivacyPolicy != src.PrivacyPolicy {
			m.PrivacyPolicy = src.PrivacyPolicy
			changed++
		}
	}
	if _, set := fmap["31"]; set {
		if m.PowerState != src.PowerState {
			m.PowerState = src.PowerState
			changed++
		}
	}
	if _, set := fmap["32"]; set {
		if m.ExternalVolumeSize != src.ExternalVolumeSize {
			m.ExternalVolumeSize = src.ExternalVolumeSize
			changed++
		}
	}
	if _, set := fmap["33"]; set {
		if m.AvailabilityZone != src.AvailabilityZone {
			m.AvailabilityZone = src.AvailabilityZone
			changed++
		}
	}
	if _, set := fmap["34"]; set {
		if m.VmFlavor != src.VmFlavor {
			m.VmFlavor = src.VmFlavor
			changed++
		}
	}
	if _, set := fmap["35"]; set {
		if m.OptRes != src.OptRes {
			m.OptRes = src.OptRes
			changed++
		}
	}
	return changed
}

func (m *AppInst) DeepCopyIn(src *AppInst) {
	m.Key.DeepCopyIn(&src.Key)
	m.CloudletLoc = src.CloudletLoc
	m.Uri = src.Uri
	m.Liveness = src.Liveness
	if src.MappedPorts != nil {
		m.MappedPorts = make([]distributed_match_engine.AppPort, len(src.MappedPorts), len(src.MappedPorts))
		for ii, s := range src.MappedPorts {
			m.MappedPorts[ii] = s
		}
	} else {
		m.MappedPorts = nil
	}
	m.Flavor.DeepCopyIn(&src.Flavor)
	m.State = src.State
	if src.Errors != nil {
		m.Errors = make([]string, len(src.Errors), len(src.Errors))
		for ii, s := range src.Errors {
			m.Errors[ii] = s
		}
	} else {
		m.Errors = nil
	}
	m.CrmOverride = src.CrmOverride
	m.RuntimeInfo.DeepCopyIn(&src.RuntimeInfo)
	m.CreatedAt = src.CreatedAt
	m.AutoClusterIpAccess = src.AutoClusterIpAccess
	m.Status.DeepCopyIn(&src.Status)
	m.Revision = src.Revision
	m.ForceUpdate = src.ForceUpdate
	m.UpdateMultiple = src.UpdateMultiple
	if src.Configs != nil {
		m.Configs = make([]*ConfigFile, len(src.Configs), len(src.Configs))
		for ii, s := range src.Configs {
			var tmp_s ConfigFile
			tmp_s.DeepCopyIn(s)
			m.Configs[ii] = &tmp_s
		}
	} else {
		m.Configs = nil
	}
	m.SharedVolumeSize = src.SharedVolumeSize
	m.HealthCheck = src.HealthCheck
	m.PrivacyPolicy = src.PrivacyPolicy
	m.PowerState = src.PowerState
	m.ExternalVolumeSize = src.ExternalVolumeSize
	m.AvailabilityZone = src.AvailabilityZone
	m.VmFlavor = src.VmFlavor
	m.OptRes = src.OptRes
}

func (s *AppInst) HasFields() bool {
	return true
}

type AppInstStore struct {
	kvstore objstore.KVStore
}

func NewAppInstStore(kvstore objstore.KVStore) AppInstStore {
	return AppInstStore{kvstore: kvstore}
}

func (s *AppInstStore) Create(ctx context.Context, m *AppInst, wait func(int64)) (*Result, error) {
	err := m.Validate(AppInstAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInst", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstStore) Update(ctx context.Context, m *AppInst, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInst", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur AppInst
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstStore) Put(ctx context.Context, m *AppInst, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(AppInstAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInst", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstStore) Delete(ctx context.Context, m *AppInst, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInst", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstStore) LoadOne(key string) (*AppInst, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj AppInst
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse AppInst data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *AppInstStore) STMGet(stm concurrency.STM, key *AppInstKey, buf *AppInst) bool {
	keystr := objstore.DbKeyString("AppInst", key)
	valstr := stm.Get(keystr)
	if valstr == "" {
		return false
	}
	if buf != nil {
		err := json.Unmarshal([]byte(valstr), buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *AppInstStore) STMPut(stm concurrency.STM, obj *AppInst, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("AppInst", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("AppInst json marsahal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *AppInstStore) STMDel(stm concurrency.STM, key *AppInstKey) {
	keystr := objstore.DbKeyString("AppInst", key)
	stm.Del(keystr)
}

type AppInstKeyWatcher struct {
	cb func(ctx context.Context)
}

type AppInstCacheData struct {
	Obj    *AppInst
	ModRev int64
}

// AppInstCache caches AppInst objects in memory in a hash table
// and keeps them in sync with the database.
type AppInstCache struct {
	Objs          map[AppInstKey]*AppInstCacheData
	Mux           util.Mutex
	List          map[AppInstKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *AppInstKey, old *AppInst, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *AppInst, new *AppInst)
	DeletedCbs    []func(ctx context.Context, old *AppInst)
	KeyWatchers   map[AppInstKey][]*AppInstKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *AppInstKey)
	DeletedKeyCbs []func(ctx context.Context, key *AppInstKey)
}

func NewAppInstCache() *AppInstCache {
	cache := AppInstCache{}
	InitAppInstCache(&cache)
	return &cache
}

func InitAppInstCache(cache *AppInstCache) {
	cache.Objs = make(map[AppInstKey]*AppInstCacheData)
	cache.KeyWatchers = make(map[AppInstKey][]*AppInstKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *AppInstCache) GetTypeString() string {
	return "AppInst"
}

func (c *AppInstCache) Get(key *AppInstKey, valbuf *AppInst) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *AppInstCache) GetWithRev(key *AppInstKey, valbuf *AppInst, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *AppInstCache) HasKey(key *AppInstKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *AppInstCache) GetAllKeys(ctx context.Context, cb func(key *AppInstKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *AppInstCache) Update(ctx context.Context, in *AppInst, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *AppInst) (*AppInst, bool) {
		return in, true
	})
}

func (c *AppInstCache) UpdateModFunc(ctx context.Context, key *AppInstKey, modRev int64, modFunc func(old *AppInst) (new *AppInst, changed bool)) {
	c.Mux.Lock()
	var old *AppInst
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	for _, cb := range c.UpdatedCbs {
		newCopy := &AppInst{}
		newCopy.DeepCopyIn(new)
		defer cb(ctx, old, newCopy)
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			defer cb(ctx, new.GetKey(), old, modRev)
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &AppInst{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &AppInstCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *AppInstCache) Delete(ctx context.Context, in *AppInst, modRev int64) {
	c.Mux.Lock()
	var old *AppInst
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	c.Mux.Unlock()
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, in.GetKey(), old, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *AppInstCache) Prune(ctx context.Context, validKeys map[AppInstKey]struct{}) {
	notify := make(map[AppInstKey]*AppInstCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, old.Obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *AppInstCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *AppInstCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *AppInstCache) Show(filter *AppInst, cb func(ret *AppInst) error) error {
	log.DebugLog(log.DebugLevelApi, "Show AppInst", "count", len(c.Objs))
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		log.DebugLog(log.DebugLevelApi, "Compare AppInst", "filter", filter, "data", data)
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		log.DebugLog(log.DebugLevelApi, "Show AppInst", "obj", data.Obj)
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func AppInstGenericNotifyCb(fn func(key *AppInstKey, old *AppInst)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*AppInstKey), obj.(*AppInst))
	}
}

func (c *AppInstCache) SetNotifyCb(fn func(ctx context.Context, obj *AppInstKey, old *AppInst, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *AppInstKey, old *AppInst, modRev int64){fn}
}

func (c *AppInstCache) SetUpdatedCb(fn func(ctx context.Context, old *AppInst, new *AppInst)) {
	c.UpdatedCbs = []func(ctx context.Context, old *AppInst, new *AppInst){fn}
}

func (c *AppInstCache) SetDeletedCb(fn func(ctx context.Context, old *AppInst)) {
	c.DeletedCbs = []func(ctx context.Context, old *AppInst){fn}
}

func (c *AppInstCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *AppInstKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *AppInstKey){fn}
}

func (c *AppInstCache) SetDeletedKeyCb(fn func(ctx context.Context, key *AppInstKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *AppInstKey){fn}
}

func (c *AppInstCache) AddUpdatedCb(fn func(ctx context.Context, old *AppInst, new *AppInst)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *AppInstCache) AddDeletedCb(fn func(ctx context.Context, old *AppInst)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *AppInstCache) AddNotifyCb(fn func(ctx context.Context, obj *AppInstKey, old *AppInst, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *AppInstCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *AppInstKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *AppInstCache) AddDeletedKeyCb(fn func(ctx context.Context, key *AppInstKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *AppInstCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *AppInstCache) WatchKey(key *AppInstKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*AppInstKeyWatcher, 0)
	}
	watcher := AppInstKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching AppInst", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *AppInstCache) TriggerKeyWatchers(ctx context.Context, key *AppInstKey) {
	watchers := make([]*AppInstKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *AppInstCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := AppInst{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse AppInst data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *AppInstCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := AppInst{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	AppInstKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *AppInstCache) SyncListStart(ctx context.Context) {
	c.List = make(map[AppInstKey]struct{})
}

func (c *AppInstCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[AppInstKey]*AppInstCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, val.Obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *AppInstCache) WaitForState(ctx context.Context, key *AppInstKey, targetState TrackedState, transitionStates map[TrackedState]struct{}, errorState TrackedState, timeout time.Duration, successMsg string, send func(*Result) error) error {
	curState := TrackedState_TRACKED_STATE_UNKNOWN
	done := make(chan bool, 1)
	failed := make(chan bool, 1)
	var err error

	cancel := c.WatchKey(key, func(ctx context.Context) {
		info := AppInst{}
		if c.Get(key, &info) {
			curState = info.State
		} else {
			curState = TrackedState_NOT_PRESENT
		}
		if send != nil {
			statusString := info.Status.ToString()
			var msg string
			if statusString != "" {
				msg = statusString
			} else {
				msg = TrackedState_CamelName[int32(curState)]
			}
			send(&Result{Message: msg})
		}
		log.SpanLog(ctx, log.DebugLevelApi, "watch event for AppInst")
		log.DebugLog(log.DebugLevelApi, "Watch event for AppInst", "key", key, "state", TrackedState_CamelName[int32(curState)], "status", info.Status)
		if curState == errorState {
			failed <- true
		} else if curState == targetState {
			done <- true
		}
	})
	// After setting up watch, check current state,
	// as it may have already changed to target state
	info := AppInst{}
	if c.Get(key, &info) {
		curState = info.State
	} else {
		curState = TrackedState_NOT_PRESENT
	}
	if curState == targetState {
		done <- true
	}

	select {
	case <-done:
		err = nil
		if successMsg != "" && send != nil {
			send(&Result{Message: successMsg})
		}
	case <-failed:
		if c.Get(key, &info) {
			errs := strings.Join(info.Errors, ", ")
			err = fmt.Errorf("Encountered failures: %s", errs)
		} else {
			// this shouldn't happen, since only way to get here
			// is if info state is set to Error
			err = errors.New("Unknown failure")
		}
	case <-time.After(timeout):
		hasInfo := c.Get(key, &info)
		if hasInfo && info.State == errorState {
			// error may have been sent back before watch started
			errs := strings.Join(info.Errors, ", ")
			err = fmt.Errorf("Encountered failures: %s", errs)
		} else if _, found := transitionStates[info.State]; hasInfo && found {
			// no success response, but state is a valid transition
			// state. That means work is still in progress.
			// Notify user that this is not an error.
			// Do not undo since CRM is still busy.
			if send != nil {
				msg := fmt.Sprintf("Timed out while work still in progress state %s. Please use ShowAppInst to check current status", TrackedState_CamelName[int32(info.State)])
				send(&Result{Message: msg})
			}
			err = nil
		} else {
			err = fmt.Errorf("Timed out; expected state %s but is %s",
				TrackedState_CamelName[int32(targetState)],
				TrackedState_CamelName[int32(curState)])
		}
	}
	cancel()
	// note: do not close done/failed, garbage collector will deal with it.
	return err
}

func (c *AppInstCache) UsesOrg(org string) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		if key.AppKey.Organization == org {
			return true
		}
		if key.ClusterInstKey.Organization == org {
			return true
		}
		if key.ClusterInstKey.CloudletKey.Organization == org {
			return true
		}
	}
	return false
}

func (m *AppInst) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *AppInst) GetKey() *AppInstKey {
	return &m.Key
}

func (m *AppInst) GetKeyVal() AppInstKey {
	return m.Key
}

func (m *AppInst) SetKey(key *AppInstKey) {
	m.Key = *key
}

func CmpSortAppInst(a AppInst, b AppInst) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *AppInst) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := Liveness_name[int32(m.Liveness)]; !ok {
		return errors.New("invalid Liveness")
	}
	if err := m.Flavor.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := TrackedState_name[int32(m.State)]; !ok {
		return errors.New("invalid State")
	}
	if _, ok := CRMOverride_name[int32(m.CrmOverride)]; !ok {
		return errors.New("invalid CrmOverride")
	}
	if err := m.RuntimeInfo.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := IpAccess_name[int32(m.AutoClusterIpAccess)]; !ok {
		return errors.New("invalid AutoClusterIpAccess")
	}
	if err := m.Status.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.Configs {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if _, ok := HealthCheck_name[int32(m.HealthCheck)]; !ok {
		return errors.New("invalid HealthCheck")
	}
	if _, ok := PowerState_name[int32(m.PowerState)]; !ok {
		return errors.New("invalid PowerState")
	}
	return nil
}

func IgnoreAppInstFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Uri")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "State")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Errors")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "CrmOverride")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "RuntimeInfo.ContainerIds")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "CreatedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Revision")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "ForceUpdate")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "UpdateMultiple")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "HealthCheck")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "PowerState")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "ExternalVolumeSize")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "AvailabilityZone")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "VmFlavor")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "OptRes")
	}
	return cmpopts.IgnoreFields(AppInst{}, names...)
}

func (m *AppInstRuntime) CopyInFields(src *AppInstRuntime) int {
	changed := 0
	if src.ContainerIds != nil {
		m.ContainerIds = src.ContainerIds
		changed++
	} else if m.ContainerIds != nil {
		m.ContainerIds = nil
		changed++
	}
	return changed
}

func (m *AppInstRuntime) DeepCopyIn(src *AppInstRuntime) {
	if src.ContainerIds != nil {
		m.ContainerIds = make([]string, len(src.ContainerIds), len(src.ContainerIds))
		for ii, s := range src.ContainerIds {
			m.ContainerIds[ii] = s
		}
	} else {
		m.ContainerIds = nil
	}
}

// Helper method to check that enums have valid values
func (m *AppInstRuntime) ValidateEnums() error {
	return nil
}

func IgnoreAppInstRuntimeFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "ContainerIds")
	}
	return cmpopts.IgnoreFields(AppInstRuntime{}, names...)
}

func (m *AppInstInfo) Matches(o *AppInstInfo, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.NotifyId != 0 {
		if o.NotifyId != m.NotifyId {
			return false
		}
	}
	if !opts.Filter || o.State != 0 {
		if o.State != m.State {
			return false
		}
	}
	if !opts.Filter || o.Errors != nil {
		if m.Errors == nil && o.Errors != nil || m.Errors != nil && o.Errors == nil {
			return false
		} else if m.Errors != nil && o.Errors != nil {
			if len(m.Errors) != len(o.Errors) {
				return false
			}
			for i := 0; i < len(m.Errors); i++ {
				if o.Errors[i] != m.Errors[i] {
					return false
				}
			}
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.Filter || o.PowerState != 0 {
		if o.PowerState != m.PowerState {
			return false
		}
	}
	return true
}

const AppInstInfoFieldKey = "2"
const AppInstInfoFieldKeyAppKey = "2.1"
const AppInstInfoFieldKeyAppKeyOrganization = "2.1.1"
const AppInstInfoFieldKeyAppKeyName = "2.1.2"
const AppInstInfoFieldKeyAppKeyVersion = "2.1.3"
const AppInstInfoFieldKeyClusterInstKey = "2.4"
const AppInstInfoFieldKeyClusterInstKeyClusterKey = "2.4.1"
const AppInstInfoFieldKeyClusterInstKeyClusterKeyName = "2.4.1.1"
const AppInstInfoFieldKeyClusterInstKeyCloudletKey = "2.4.2"
const AppInstInfoFieldKeyClusterInstKeyCloudletKeyOrganization = "2.4.2.1"
const AppInstInfoFieldKeyClusterInstKeyCloudletKeyName = "2.4.2.2"
const AppInstInfoFieldKeyClusterInstKeyOrganization = "2.4.3"
const AppInstInfoFieldNotifyId = "3"
const AppInstInfoFieldState = "4"
const AppInstInfoFieldErrors = "5"
const AppInstInfoFieldRuntimeInfo = "6"
const AppInstInfoFieldRuntimeInfoContainerIds = "6.1"
const AppInstInfoFieldStatus = "7"
const AppInstInfoFieldStatusTaskNumber = "7.1"
const AppInstInfoFieldStatusMaxTasks = "7.2"
const AppInstInfoFieldStatusTaskName = "7.3"
const AppInstInfoFieldStatusStepName = "7.4"
const AppInstInfoFieldPowerState = "8"

var AppInstInfoAllFields = []string{
	AppInstInfoFieldKeyAppKeyOrganization,
	AppInstInfoFieldKeyAppKeyName,
	AppInstInfoFieldKeyAppKeyVersion,
	AppInstInfoFieldKeyClusterInstKeyClusterKeyName,
	AppInstInfoFieldKeyClusterInstKeyCloudletKeyOrganization,
	AppInstInfoFieldKeyClusterInstKeyCloudletKeyName,
	AppInstInfoFieldKeyClusterInstKeyOrganization,
	AppInstInfoFieldNotifyId,
	AppInstInfoFieldState,
	AppInstInfoFieldErrors,
	AppInstInfoFieldRuntimeInfoContainerIds,
	AppInstInfoFieldStatusTaskNumber,
	AppInstInfoFieldStatusMaxTasks,
	AppInstInfoFieldStatusTaskName,
	AppInstInfoFieldStatusStepName,
	AppInstInfoFieldPowerState,
}

var AppInstInfoAllFieldsMap = map[string]struct{}{
	AppInstInfoFieldKeyAppKeyOrganization:                    struct{}{},
	AppInstInfoFieldKeyAppKeyName:                            struct{}{},
	AppInstInfoFieldKeyAppKeyVersion:                         struct{}{},
	AppInstInfoFieldKeyClusterInstKeyClusterKeyName:          struct{}{},
	AppInstInfoFieldKeyClusterInstKeyCloudletKeyOrganization: struct{}{},
	AppInstInfoFieldKeyClusterInstKeyCloudletKeyName:         struct{}{},
	AppInstInfoFieldKeyClusterInstKeyOrganization:            struct{}{},
	AppInstInfoFieldNotifyId:                                 struct{}{},
	AppInstInfoFieldState:                                    struct{}{},
	AppInstInfoFieldErrors:                                   struct{}{},
	AppInstInfoFieldRuntimeInfoContainerIds:                  struct{}{},
	AppInstInfoFieldStatusTaskNumber:                         struct{}{},
	AppInstInfoFieldStatusMaxTasks:                           struct{}{},
	AppInstInfoFieldStatusTaskName:                           struct{}{},
	AppInstInfoFieldStatusStepName:                           struct{}{},
	AppInstInfoFieldPowerState:                               struct{}{},
}

var AppInstInfoAllFieldsStringMap = map[string]string{
	AppInstInfoFieldKeyAppKeyOrganization:                    "Key App Key Organization",
	AppInstInfoFieldKeyAppKeyName:                            "Key App Key Name",
	AppInstInfoFieldKeyAppKeyVersion:                         "Key App Key Version",
	AppInstInfoFieldKeyClusterInstKeyClusterKeyName:          "Key Cluster Inst Key Cluster Key Name",
	AppInstInfoFieldKeyClusterInstKeyCloudletKeyOrganization: "Key Cluster Inst Key Cloudlet Key Organization",
	AppInstInfoFieldKeyClusterInstKeyCloudletKeyName:         "Key Cluster Inst Key Cloudlet Key Name",
	AppInstInfoFieldKeyClusterInstKeyOrganization:            "Key Cluster Inst Key Organization",
	AppInstInfoFieldNotifyId:                                 "Notify Id",
	AppInstInfoFieldState:                                    "State",
	AppInstInfoFieldErrors:                                   "Errors",
	AppInstInfoFieldRuntimeInfoContainerIds:                  "Runtime Info Container Ids",
	AppInstInfoFieldStatusTaskNumber:                         "Status Task Number",
	AppInstInfoFieldStatusMaxTasks:                           "Status Max Tasks",
	AppInstInfoFieldStatusTaskName:                           "Status Task Name",
	AppInstInfoFieldStatusStepName:                           "Status Step Name",
	AppInstInfoFieldPowerState:                               "Power State",
}

func (m *AppInstInfo) IsKeyField(s string) bool {
	return strings.HasPrefix(s, AppInstInfoFieldKey+".") || s == AppInstInfoFieldKey
}

func (m *AppInstInfo) DiffFields(o *AppInstInfo, fields map[string]struct{}) {
	if m.Key.AppKey.Organization != o.Key.AppKey.Organization {
		fields[AppInstInfoFieldKeyAppKeyOrganization] = struct{}{}
		fields[AppInstInfoFieldKeyAppKey] = struct{}{}
		fields[AppInstInfoFieldKey] = struct{}{}
	}
	if m.Key.AppKey.Name != o.Key.AppKey.Name {
		fields[AppInstInfoFieldKeyAppKeyName] = struct{}{}
		fields[AppInstInfoFieldKeyAppKey] = struct{}{}
		fields[AppInstInfoFieldKey] = struct{}{}
	}
	if m.Key.AppKey.Version != o.Key.AppKey.Version {
		fields[AppInstInfoFieldKeyAppKeyVersion] = struct{}{}
		fields[AppInstInfoFieldKeyAppKey] = struct{}{}
		fields[AppInstInfoFieldKey] = struct{}{}
	}
	if m.Key.ClusterInstKey.ClusterKey.Name != o.Key.ClusterInstKey.ClusterKey.Name {
		fields[AppInstInfoFieldKeyClusterInstKeyClusterKeyName] = struct{}{}
		fields[AppInstInfoFieldKeyClusterInstKeyClusterKey] = struct{}{}
		fields[AppInstInfoFieldKeyClusterInstKey] = struct{}{}
		fields[AppInstInfoFieldKey] = struct{}{}
	}
	if m.Key.ClusterInstKey.CloudletKey.Organization != o.Key.ClusterInstKey.CloudletKey.Organization {
		fields[AppInstInfoFieldKeyClusterInstKeyCloudletKeyOrganization] = struct{}{}
		fields[AppInstInfoFieldKeyClusterInstKeyCloudletKey] = struct{}{}
		fields[AppInstInfoFieldKeyClusterInstKey] = struct{}{}
		fields[AppInstInfoFieldKey] = struct{}{}
	}
	if m.Key.ClusterInstKey.CloudletKey.Name != o.Key.ClusterInstKey.CloudletKey.Name {
		fields[AppInstInfoFieldKeyClusterInstKeyCloudletKeyName] = struct{}{}
		fields[AppInstInfoFieldKeyClusterInstKeyCloudletKey] = struct{}{}
		fields[AppInstInfoFieldKeyClusterInstKey] = struct{}{}
		fields[AppInstInfoFieldKey] = struct{}{}
	}
	if m.Key.ClusterInstKey.Organization != o.Key.ClusterInstKey.Organization {
		fields[AppInstInfoFieldKeyClusterInstKeyOrganization] = struct{}{}
		fields[AppInstInfoFieldKeyClusterInstKey] = struct{}{}
		fields[AppInstInfoFieldKey] = struct{}{}
	}
	if m.NotifyId != o.NotifyId {
		fields[AppInstInfoFieldNotifyId] = struct{}{}
	}
	if m.State != o.State {
		fields[AppInstInfoFieldState] = struct{}{}
	}
	if len(m.Errors) != len(o.Errors) {
		fields[AppInstInfoFieldErrors] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.Errors); i0++ {
			if m.Errors[i0] != o.Errors[i0] {
				fields[AppInstInfoFieldErrors] = struct{}{}
				break
			}
		}
	}
	if len(m.RuntimeInfo.ContainerIds) != len(o.RuntimeInfo.ContainerIds) {
		fields[AppInstInfoFieldRuntimeInfoContainerIds] = struct{}{}
		fields[AppInstInfoFieldRuntimeInfo] = struct{}{}
	} else {
		for i1 := 0; i1 < len(m.RuntimeInfo.ContainerIds); i1++ {
			if m.RuntimeInfo.ContainerIds[i1] != o.RuntimeInfo.ContainerIds[i1] {
				fields[AppInstInfoFieldRuntimeInfoContainerIds] = struct{}{}
				fields[AppInstInfoFieldRuntimeInfo] = struct{}{}
				break
			}
		}
	}
	if m.Status.TaskNumber != o.Status.TaskNumber {
		fields[AppInstInfoFieldStatusTaskNumber] = struct{}{}
		fields[AppInstInfoFieldStatus] = struct{}{}
	}
	if m.Status.MaxTasks != o.Status.MaxTasks {
		fields[AppInstInfoFieldStatusMaxTasks] = struct{}{}
		fields[AppInstInfoFieldStatus] = struct{}{}
	}
	if m.Status.TaskName != o.Status.TaskName {
		fields[AppInstInfoFieldStatusTaskName] = struct{}{}
		fields[AppInstInfoFieldStatus] = struct{}{}
	}
	if m.Status.StepName != o.Status.StepName {
		fields[AppInstInfoFieldStatusStepName] = struct{}{}
		fields[AppInstInfoFieldStatus] = struct{}{}
	}
	if m.PowerState != o.PowerState {
		fields[AppInstInfoFieldPowerState] = struct{}{}
	}
}

func (m *AppInstInfo) CopyInFields(src *AppInstInfo) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if _, set := fmap["2.1.1"]; set {
				if m.Key.AppKey.Organization != src.Key.AppKey.Organization {
					m.Key.AppKey.Organization = src.Key.AppKey.Organization
					changed++
				}
			}
			if _, set := fmap["2.1.2"]; set {
				if m.Key.AppKey.Name != src.Key.AppKey.Name {
					m.Key.AppKey.Name = src.Key.AppKey.Name
					changed++
				}
			}
			if _, set := fmap["2.1.3"]; set {
				if m.Key.AppKey.Version != src.Key.AppKey.Version {
					m.Key.AppKey.Version = src.Key.AppKey.Version
					changed++
				}
			}
		}
		if _, set := fmap["2.4"]; set {
			if _, set := fmap["2.4.1"]; set {
				if _, set := fmap["2.4.1.1"]; set {
					if m.Key.ClusterInstKey.ClusterKey.Name != src.Key.ClusterInstKey.ClusterKey.Name {
						m.Key.ClusterInstKey.ClusterKey.Name = src.Key.ClusterInstKey.ClusterKey.Name
						changed++
					}
				}
			}
			if _, set := fmap["2.4.2"]; set {
				if _, set := fmap["2.4.2.1"]; set {
					if m.Key.ClusterInstKey.CloudletKey.Organization != src.Key.ClusterInstKey.CloudletKey.Organization {
						m.Key.ClusterInstKey.CloudletKey.Organization = src.Key.ClusterInstKey.CloudletKey.Organization
						changed++
					}
				}
				if _, set := fmap["2.4.2.2"]; set {
					if m.Key.ClusterInstKey.CloudletKey.Name != src.Key.ClusterInstKey.CloudletKey.Name {
						m.Key.ClusterInstKey.CloudletKey.Name = src.Key.ClusterInstKey.CloudletKey.Name
						changed++
					}
				}
			}
			if _, set := fmap["2.4.3"]; set {
				if m.Key.ClusterInstKey.Organization != src.Key.ClusterInstKey.Organization {
					m.Key.ClusterInstKey.Organization = src.Key.ClusterInstKey.Organization
					changed++
				}
			}
		}
	}
	if _, set := fmap["3"]; set {
		if m.NotifyId != src.NotifyId {
			m.NotifyId = src.NotifyId
			changed++
		}
	}
	if _, set := fmap["4"]; set {
		if m.State != src.State {
			m.State = src.State
			changed++
		}
	}
	if _, set := fmap["5"]; set {
		if src.Errors != nil {
			m.Errors = src.Errors
			changed++
		} else if m.Errors != nil {
			m.Errors = nil
			changed++
		}
	}
	if _, set := fmap["6"]; set {
		if _, set := fmap["6.1"]; set {
			if src.RuntimeInfo.ContainerIds != nil {
				m.RuntimeInfo.ContainerIds = src.RuntimeInfo.ContainerIds
				changed++
			} else if m.RuntimeInfo.ContainerIds != nil {
				m.RuntimeInfo.ContainerIds = nil
				changed++
			}
		}
	}
	if _, set := fmap["7"]; set {
		if _, set := fmap["7.1"]; set {
			if m.Status.TaskNumber != src.Status.TaskNumber {
				m.Status.TaskNumber = src.Status.TaskNumber
				changed++
			}
		}
		if _, set := fmap["7.2"]; set {
			if m.Status.MaxTasks != src.Status.MaxTasks {
				m.Status.MaxTasks = src.Status.MaxTasks
				changed++
			}
		}
		if _, set := fmap["7.3"]; set {
			if m.Status.TaskName != src.Status.TaskName {
				m.Status.TaskName = src.Status.TaskName
				changed++
			}
		}
		if _, set := fmap["7.4"]; set {
			if m.Status.StepName != src.Status.StepName {
				m.Status.StepName = src.Status.StepName
				changed++
			}
		}
	}
	if _, set := fmap["8"]; set {
		if m.PowerState != src.PowerState {
			m.PowerState = src.PowerState
			changed++
		}
	}
	return changed
}

func (m *AppInstInfo) DeepCopyIn(src *AppInstInfo) {
	m.Key.DeepCopyIn(&src.Key)
	m.NotifyId = src.NotifyId
	m.State = src.State
	if src.Errors != nil {
		m.Errors = make([]string, len(src.Errors), len(src.Errors))
		for ii, s := range src.Errors {
			m.Errors[ii] = s
		}
	} else {
		m.Errors = nil
	}
	m.RuntimeInfo.DeepCopyIn(&src.RuntimeInfo)
	m.Status.DeepCopyIn(&src.Status)
	m.PowerState = src.PowerState
}

func (s *AppInstInfo) HasFields() bool {
	return true
}

type AppInstInfoStore struct {
	kvstore objstore.KVStore
}

func NewAppInstInfoStore(kvstore objstore.KVStore) AppInstInfoStore {
	return AppInstInfoStore{kvstore: kvstore}
}

func (s *AppInstInfoStore) Create(ctx context.Context, m *AppInstInfo, wait func(int64)) (*Result, error) {
	err := m.Validate(AppInstInfoAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstInfo", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstInfoStore) Update(ctx context.Context, m *AppInstInfo, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstInfo", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur AppInstInfo
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstInfoStore) Put(ctx context.Context, m *AppInstInfo, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(AppInstInfoAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstInfo", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstInfoStore) Delete(ctx context.Context, m *AppInstInfo, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstInfo", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstInfoStore) LoadOne(key string) (*AppInstInfo, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj AppInstInfo
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse AppInstInfo data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *AppInstInfoStore) STMGet(stm concurrency.STM, key *AppInstKey, buf *AppInstInfo) bool {
	keystr := objstore.DbKeyString("AppInstInfo", key)
	valstr := stm.Get(keystr)
	if valstr == "" {
		return false
	}
	if buf != nil {
		err := json.Unmarshal([]byte(valstr), buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *AppInstInfoStore) STMPut(stm concurrency.STM, obj *AppInstInfo, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("AppInstInfo", obj.GetKey())
	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("AppInstInfo json marsahal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *AppInstInfoStore) STMDel(stm concurrency.STM, key *AppInstKey) {
	keystr := objstore.DbKeyString("AppInstInfo", key)
	stm.Del(keystr)
}

type AppInstInfoKeyWatcher struct {
	cb func(ctx context.Context)
}

type AppInstInfoCacheData struct {
	Obj    *AppInstInfo
	ModRev int64
}

// AppInstInfoCache caches AppInstInfo objects in memory in a hash table
// and keeps them in sync with the database.
type AppInstInfoCache struct {
	Objs          map[AppInstKey]*AppInstInfoCacheData
	Mux           util.Mutex
	List          map[AppInstKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *AppInstKey, old *AppInstInfo, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *AppInstInfo, new *AppInstInfo)
	DeletedCbs    []func(ctx context.Context, old *AppInstInfo)
	KeyWatchers   map[AppInstKey][]*AppInstInfoKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *AppInstKey)
	DeletedKeyCbs []func(ctx context.Context, key *AppInstKey)
}

func NewAppInstInfoCache() *AppInstInfoCache {
	cache := AppInstInfoCache{}
	InitAppInstInfoCache(&cache)
	return &cache
}

func InitAppInstInfoCache(cache *AppInstInfoCache) {
	cache.Objs = make(map[AppInstKey]*AppInstInfoCacheData)
	cache.KeyWatchers = make(map[AppInstKey][]*AppInstInfoKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *AppInstInfoCache) GetTypeString() string {
	return "AppInstInfo"
}

func (c *AppInstInfoCache) Get(key *AppInstKey, valbuf *AppInstInfo) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *AppInstInfoCache) GetWithRev(key *AppInstKey, valbuf *AppInstInfo, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *AppInstInfoCache) HasKey(key *AppInstKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *AppInstInfoCache) GetAllKeys(ctx context.Context, cb func(key *AppInstKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *AppInstInfoCache) Update(ctx context.Context, in *AppInstInfo, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *AppInstInfo) (*AppInstInfo, bool) {
		return in, true
	})
}

func (c *AppInstInfoCache) UpdateModFunc(ctx context.Context, key *AppInstKey, modRev int64, modFunc func(old *AppInstInfo) (new *AppInstInfo, changed bool)) {
	c.Mux.Lock()
	var old *AppInstInfo
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	for _, cb := range c.UpdatedCbs {
		newCopy := &AppInstInfo{}
		newCopy.DeepCopyIn(new)
		defer cb(ctx, old, newCopy)
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			defer cb(ctx, new.GetKey(), old, modRev)
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &AppInstInfo{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &AppInstInfoCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *AppInstInfoCache) Delete(ctx context.Context, in *AppInstInfo, modRev int64) {
	c.Mux.Lock()
	var old *AppInstInfo
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete")
	c.Mux.Unlock()
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, in.GetKey(), old, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *AppInstInfoCache) Prune(ctx context.Context, validKeys map[AppInstKey]struct{}) {
	notify := make(map[AppInstKey]*AppInstInfoCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, old.Obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *AppInstInfoCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *AppInstInfoCache) Flush(ctx context.Context, notifyId int64) {
	log.SpanLog(ctx, log.DebugLevelApi, "CacheFlush AppInstInfo", "notifyId", notifyId, "FlushAll", c.FlushAll)
	flushed := make(map[AppInstKey]*AppInstInfoCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if !c.FlushAll && val.Obj.NotifyId != notifyId {
			continue
		}
		flushed[key] = c.Objs[key]
		log.SpanLog(ctx, log.DebugLevelApi, "CacheFlush AppInstInfo delete", "key", key)
		delete(c.Objs, key)
	}
	c.Mux.Unlock()
	if len(flushed) > 0 {
		for key, old := range flushed {
			for _, cb := range c.NotifyCbs {
				if cb != nil {
					cb(ctx, &key, old.Obj, old.ModRev)
				}
			}
			for _, cb := range c.DeletedKeyCbs {
				cb(ctx, &key)
			}
			if old.Obj != nil {
				for _, cb := range c.DeletedCbs {
					cb(ctx, old.Obj)
				}
			}
			c.TriggerKeyWatchers(ctx, &key)
		}
	}
}

func (c *AppInstInfoCache) Show(filter *AppInstInfo, cb func(ret *AppInstInfo) error) error {
	log.DebugLog(log.DebugLevelApi, "Show AppInstInfo", "count", len(c.Objs))
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		log.DebugLog(log.DebugLevelApi, "Compare AppInstInfo", "filter", filter, "data", data)
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		log.DebugLog(log.DebugLevelApi, "Show AppInstInfo", "obj", data.Obj)
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func AppInstInfoGenericNotifyCb(fn func(key *AppInstKey, old *AppInstInfo)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*AppInstKey), obj.(*AppInstInfo))
	}
}

func (c *AppInstInfoCache) SetNotifyCb(fn func(ctx context.Context, obj *AppInstKey, old *AppInstInfo, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *AppInstKey, old *AppInstInfo, modRev int64){fn}
}

func (c *AppInstInfoCache) SetUpdatedCb(fn func(ctx context.Context, old *AppInstInfo, new *AppInstInfo)) {
	c.UpdatedCbs = []func(ctx context.Context, old *AppInstInfo, new *AppInstInfo){fn}
}

func (c *AppInstInfoCache) SetDeletedCb(fn func(ctx context.Context, old *AppInstInfo)) {
	c.DeletedCbs = []func(ctx context.Context, old *AppInstInfo){fn}
}

func (c *AppInstInfoCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *AppInstKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *AppInstKey){fn}
}

func (c *AppInstInfoCache) SetDeletedKeyCb(fn func(ctx context.Context, key *AppInstKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *AppInstKey){fn}
}

func (c *AppInstInfoCache) AddUpdatedCb(fn func(ctx context.Context, old *AppInstInfo, new *AppInstInfo)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *AppInstInfoCache) AddDeletedCb(fn func(ctx context.Context, old *AppInstInfo)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *AppInstInfoCache) AddNotifyCb(fn func(ctx context.Context, obj *AppInstKey, old *AppInstInfo, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *AppInstInfoCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *AppInstKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *AppInstInfoCache) AddDeletedKeyCb(fn func(ctx context.Context, key *AppInstKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *AppInstInfoCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *AppInstInfoCache) WatchKey(key *AppInstKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*AppInstInfoKeyWatcher, 0)
	}
	watcher := AppInstInfoKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching AppInstInfo", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *AppInstInfoCache) TriggerKeyWatchers(ctx context.Context, key *AppInstKey) {
	watchers := make([]*AppInstInfoKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *AppInstInfoCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := AppInstInfo{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse AppInstInfo data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *AppInstInfoCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := AppInstInfo{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	AppInstKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *AppInstInfoCache) SyncListStart(ctx context.Context) {
	c.List = make(map[AppInstKey]struct{})
}

func (c *AppInstInfoCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[AppInstKey]*AppInstInfoCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, &key, val.Obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *AppInstInfoCache) UsesOrg(org string) bool {
	return false
}

func (m *AppInstInfo) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *AppInstInfo) GetKey() *AppInstKey {
	return &m.Key
}

func (m *AppInstInfo) GetKeyVal() AppInstKey {
	return m.Key
}

func (m *AppInstInfo) SetKey(key *AppInstKey) {
	m.Key = *key
}

func CmpSortAppInstInfo(a AppInstInfo, b AppInstInfo) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *AppInstInfo) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := TrackedState_name[int32(m.State)]; !ok {
		return errors.New("invalid State")
	}
	if err := m.RuntimeInfo.ValidateEnums(); err != nil {
		return err
	}
	if err := m.Status.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := PowerState_name[int32(m.PowerState)]; !ok {
		return errors.New("invalid PowerState")
	}
	return nil
}

func IgnoreAppInstInfoFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "NotifyId")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "RuntimeInfo.ContainerIds")
	}
	return cmpopts.IgnoreFields(AppInstInfo{}, names...)
}

func (m *AppInstMetrics) CopyInFields(src *AppInstMetrics) int {
	changed := 0
	if m.Something != src.Something {
		m.Something = src.Something
		changed++
	}
	return changed
}

func (m *AppInstMetrics) DeepCopyIn(src *AppInstMetrics) {
	m.Something = src.Something
}

// Helper method to check that enums have valid values
func (m *AppInstMetrics) ValidateEnums() error {
	return nil
}

func (m *AppInstLookup) CopyInFields(src *AppInstLookup) int {
	changed := 0
	if m.Key.AppKey.Organization != src.Key.AppKey.Organization {
		m.Key.AppKey.Organization = src.Key.AppKey.Organization
		changed++
	}
	if m.Key.AppKey.Name != src.Key.AppKey.Name {
		m.Key.AppKey.Name = src.Key.AppKey.Name
		changed++
	}
	if m.Key.AppKey.Version != src.Key.AppKey.Version {
		m.Key.AppKey.Version = src.Key.AppKey.Version
		changed++
	}
	if m.Key.ClusterInstKey.ClusterKey.Name != src.Key.ClusterInstKey.ClusterKey.Name {
		m.Key.ClusterInstKey.ClusterKey.Name = src.Key.ClusterInstKey.ClusterKey.Name
		changed++
	}
	if m.Key.ClusterInstKey.CloudletKey.Organization != src.Key.ClusterInstKey.CloudletKey.Organization {
		m.Key.ClusterInstKey.CloudletKey.Organization = src.Key.ClusterInstKey.CloudletKey.Organization
		changed++
	}
	if m.Key.ClusterInstKey.CloudletKey.Name != src.Key.ClusterInstKey.CloudletKey.Name {
		m.Key.ClusterInstKey.CloudletKey.Name = src.Key.ClusterInstKey.CloudletKey.Name
		changed++
	}
	if m.Key.ClusterInstKey.Organization != src.Key.ClusterInstKey.Organization {
		m.Key.ClusterInstKey.Organization = src.Key.ClusterInstKey.Organization
		changed++
	}
	if m.PolicyKey.Organization != src.PolicyKey.Organization {
		m.PolicyKey.Organization = src.PolicyKey.Organization
		changed++
	}
	if m.PolicyKey.Name != src.PolicyKey.Name {
		m.PolicyKey.Name = src.PolicyKey.Name
		changed++
	}
	return changed
}

func (m *AppInstLookup) DeepCopyIn(src *AppInstLookup) {
	m.Key.DeepCopyIn(&src.Key)
	m.PolicyKey.DeepCopyIn(&src.PolicyKey)
}

type AppInstLookupByPolicyKey struct {
	PolicyKeys map[PolicyKey]map[AppInstKey]struct{}
	Mux        util.Mutex
}

func (s *AppInstLookupByPolicyKey) Init() {
	s.PolicyKeys = make(map[PolicyKey]map[AppInstKey]struct{})
}

func (s *AppInstLookupByPolicyKey) Updated(obj *AppInstLookup) {
	lookup := obj.PolicyKey

	s.Mux.Lock()
	defer s.Mux.Unlock()

	AppInstKeys, found := s.PolicyKeys[lookup]
	if !found {
		AppInstKeys = make(map[AppInstKey]struct{})
		s.PolicyKeys[lookup] = AppInstKeys
	}
	AppInstKeys[obj.GetKeyVal()] = struct{}{}
}

func (s *AppInstLookupByPolicyKey) Deleted(obj *AppInstLookup) {
	lookup := obj.PolicyKey

	s.Mux.Lock()
	defer s.Mux.Unlock()

	AppInstKeys, found := s.PolicyKeys[lookup]
	if found {
		delete(AppInstKeys, obj.GetKeyVal())
		if len(AppInstKeys) == 0 {
			delete(s.PolicyKeys, lookup)
		}
	}
}

func (s *AppInstLookupByPolicyKey) Find(lookup PolicyKey) []AppInstKey {
	s.Mux.Lock()
	defer s.Mux.Unlock()

	list := []AppInstKey{}
	for k, _ := range s.PolicyKeys[lookup] {
		list = append(list, k)
	}
	return list
}

func (m *AppInstLookup) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *AppInstLookup) GetKey() *AppInstKey {
	return &m.Key
}

func (m *AppInstLookup) GetKeyVal() AppInstKey {
	return m.Key
}

func (m *AppInstLookup) SetKey(key *AppInstKey) {
	m.Key = *key
}

func CmpSortAppInstLookup(a AppInstLookup, b AppInstLookup) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *AppInstLookup) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if err := m.PolicyKey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

var HealthCheckStrings = []string{
	"HEALTH_CHECK_UNKNOWN",
	"HEALTH_CHECK_FAIL_ROOTLB_OFFLINE",
	"HEALTH_CHECK_FAIL_SERVER_FAIL",
	"HEALTH_CHECK_OK",
}

const (
	HealthCheckHEALTH_CHECK_UNKNOWN             uint64 = 1 << 0
	HealthCheckHEALTH_CHECK_FAIL_ROOTLB_OFFLINE uint64 = 1 << 1
	HealthCheckHEALTH_CHECK_FAIL_SERVER_FAIL    uint64 = 1 << 2
	HealthCheckHEALTH_CHECK_OK                  uint64 = 1 << 3
)

var HealthCheck_CamelName = map[int32]string{
	// HEALTH_CHECK_UNKNOWN -> HealthCheckUnknown
	0: "HealthCheckUnknown",
	// HEALTH_CHECK_FAIL_ROOTLB_OFFLINE -> HealthCheckFailRootlbOffline
	1: "HealthCheckFailRootlbOffline",
	// HEALTH_CHECK_FAIL_SERVER_FAIL -> HealthCheckFailServerFail
	2: "HealthCheckFailServerFail",
	// HEALTH_CHECK_OK -> HealthCheckOk
	3: "HealthCheckOk",
}
var HealthCheck_CamelValue = map[string]int32{
	"HealthCheckUnknown":           0,
	"HealthCheckFailRootlbOffline": 1,
	"HealthCheckFailServerFail":    2,
	"HealthCheckOk":                3,
}

func (e *HealthCheck) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := HealthCheck_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = HealthCheck_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = HealthCheck(val)
	return nil
}

func (e HealthCheck) MarshalYAML() (interface{}, error) {
	return proto.EnumName(HealthCheck_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *HealthCheck) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := HealthCheck_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = HealthCheck_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = HealthCheck(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = HealthCheck(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

var PowerStateStrings = []string{
	"POWER_STATE_UNKNOWN",
	"POWER_ON_REQUESTED",
	"POWERING_ON",
	"POWER_ON",
	"POWER_OFF_REQUESTED",
	"POWERING_OFF",
	"POWER_OFF",
	"REBOOT_REQUESTED",
	"REBOOTING",
	"REBOOT",
	"POWER_STATE_ERROR",
}

const (
	PowerStatePOWER_STATE_UNKNOWN uint64 = 1 << 0
	PowerStatePOWER_ON_REQUESTED  uint64 = 1 << 1
	PowerStatePOWERING_ON         uint64 = 1 << 2
	PowerStatePOWER_ON            uint64 = 1 << 3
	PowerStatePOWER_OFF_REQUESTED uint64 = 1 << 4
	PowerStatePOWERING_OFF        uint64 = 1 << 5
	PowerStatePOWER_OFF           uint64 = 1 << 6
	PowerStateREBOOT_REQUESTED    uint64 = 1 << 7
	PowerStateREBOOTING           uint64 = 1 << 8
	PowerStateREBOOT              uint64 = 1 << 9
	PowerStatePOWER_STATE_ERROR   uint64 = 1 << 10
)

var PowerState_CamelName = map[int32]string{
	// POWER_STATE_UNKNOWN -> PowerStateUnknown
	0: "PowerStateUnknown",
	// POWER_ON_REQUESTED -> PowerOnRequested
	1: "PowerOnRequested",
	// POWERING_ON -> PoweringOn
	2: "PoweringOn",
	// POWER_ON -> PowerOn
	3: "PowerOn",
	// POWER_OFF_REQUESTED -> PowerOffRequested
	4: "PowerOffRequested",
	// POWERING_OFF -> PoweringOff
	5: "PoweringOff",
	// POWER_OFF -> PowerOff
	6: "PowerOff",
	// REBOOT_REQUESTED -> RebootRequested
	7: "RebootRequested",
	// REBOOTING -> Rebooting
	8: "Rebooting",
	// REBOOT -> Reboot
	9: "Reboot",
	// POWER_STATE_ERROR -> PowerStateError
	10: "PowerStateError",
}
var PowerState_CamelValue = map[string]int32{
	"PowerStateUnknown": 0,
	"PowerOnRequested":  1,
	"PoweringOn":        2,
	"PowerOn":           3,
	"PowerOffRequested": 4,
	"PoweringOff":       5,
	"PowerOff":          6,
	"RebootRequested":   7,
	"Rebooting":         8,
	"Reboot":            9,
	"PowerStateError":   10,
}

func (e *PowerState) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := PowerState_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = PowerState_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = PowerState(val)
	return nil
}

func (e PowerState) MarshalYAML() (interface{}, error) {
	return proto.EnumName(PowerState_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *PowerState) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := PowerState_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = PowerState_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = PowerState(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = PowerState(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}
func (m *AppInstKey) Size() (n int) {
	var l int
	_ = l
	l = m.AppKey.Size()
	n += 1 + l + sovAppinst(uint64(l))
	l = m.ClusterInstKey.Size()
	n += 1 + l + sovAppinst(uint64(l))
	return n
}

func (m *AppInst) Size() (n int) {
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovAppinst(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovAppinst(uint64(l))
	l = m.CloudletLoc.Size()
	n += 1 + l + sovAppinst(uint64(l))
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovAppinst(uint64(l))
	}
	if m.Liveness != 0 {
		n += 1 + sovAppinst(uint64(m.Liveness))
	}
	if len(m.MappedPorts) > 0 {
		for _, e := range m.MappedPorts {
			l = e.Size()
			n += 1 + l + sovAppinst(uint64(l))
		}
	}
	l = m.Flavor.Size()
	n += 1 + l + sovAppinst(uint64(l))
	if m.State != 0 {
		n += 1 + sovAppinst(uint64(m.State))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovAppinst(uint64(l))
		}
	}
	if m.CrmOverride != 0 {
		n += 2 + sovAppinst(uint64(m.CrmOverride))
	}
	l = m.RuntimeInfo.Size()
	n += 2 + l + sovAppinst(uint64(l))
	l = m.CreatedAt.Size()
	n += 2 + l + sovAppinst(uint64(l))
	if m.AutoClusterIpAccess != 0 {
		n += 2 + sovAppinst(uint64(m.AutoClusterIpAccess))
	}
	l = m.Status.Size()
	n += 2 + l + sovAppinst(uint64(l))
	l = len(m.Revision)
	if l > 0 {
		n += 2 + l + sovAppinst(uint64(l))
	}
	if m.ForceUpdate {
		n += 3
	}
	if m.UpdateMultiple {
		n += 3
	}
	if len(m.Configs) > 0 {
		for _, e := range m.Configs {
			l = e.Size()
			n += 2 + l + sovAppinst(uint64(l))
		}
	}
	if m.SharedVolumeSize != 0 {
		n += 2 + sovAppinst(uint64(m.SharedVolumeSize))
	}
	if m.HealthCheck != 0 {
		n += 2 + sovAppinst(uint64(m.HealthCheck))
	}
	l = len(m.PrivacyPolicy)
	if l > 0 {
		n += 2 + l + sovAppinst(uint64(l))
	}
	if m.PowerState != 0 {
		n += 2 + sovAppinst(uint64(m.PowerState))
	}
	if m.ExternalVolumeSize != 0 {
		n += 2 + sovAppinst(uint64(m.ExternalVolumeSize))
	}
	l = len(m.AvailabilityZone)
	if l > 0 {
		n += 2 + l + sovAppinst(uint64(l))
	}
	l = len(m.VmFlavor)
	if l > 0 {
		n += 2 + l + sovAppinst(uint64(l))
	}
	l = len(m.OptRes)
	if l > 0 {
		n += 2 + l + sovAppinst(uint64(l))
	}
	return n
}

func (m *AppInstRuntime) Size() (n int) {
	var l int
	_ = l
	if len(m.ContainerIds) > 0 {
		for _, s := range m.ContainerIds {
			l = len(s)
			n += 1 + l + sovAppinst(uint64(l))
		}
	}
	return n
}

func (m *AppInstInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovAppinst(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovAppinst(uint64(l))
	if m.NotifyId != 0 {
		n += 1 + sovAppinst(uint64(m.NotifyId))
	}
	if m.State != 0 {
		n += 1 + sovAppinst(uint64(m.State))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovAppinst(uint64(l))
		}
	}
	l = m.RuntimeInfo.Size()
	n += 1 + l + sovAppinst(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAppinst(uint64(l))
	if m.PowerState != 0 {
		n += 1 + sovAppinst(uint64(m.PowerState))
	}
	return n
}

func (m *AppInstMetrics) Size() (n int) {
	var l int
	_ = l
	if m.Something != 0 {
		n += 1 + sovAppinst(uint64(m.Something))
	}
	return n
}

func (m *AppInstLookup) Size() (n int) {
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovAppinst(uint64(l))
	l = m.PolicyKey.Size()
	n += 1 + l + sovAppinst(uint64(l))
	return n
}

func sovAppinst(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAppinst(x uint64) (n int) {
	return sovAppinst(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AppInstKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AppKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterInstKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterInstKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInst) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInst: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInst: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletLoc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CloudletLoc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liveness", wireType)
			}
			m.Liveness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Liveness |= (Liveness(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MappedPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MappedPorts = append(m.MappedPorts, distributed_match_engine1.AppPort{})
			if err := m.MappedPorts[len(m.MappedPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flavor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Flavor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (TrackedState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrmOverride", wireType)
			}
			m.CrmOverride = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrmOverride |= (CRMOverride(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RuntimeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoClusterIpAccess", wireType)
			}
			m.AutoClusterIpAccess = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoClusterIpAccess |= (IpAccess(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Revision = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceUpdate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceUpdate = bool(v != 0)
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateMultiple", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateMultiple = bool(v != 0)
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Configs = append(m.Configs, &ConfigFile{})
			if err := m.Configs[len(m.Configs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedVolumeSize", wireType)
			}
			m.SharedVolumeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SharedVolumeSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheck", wireType)
			}
			m.HealthCheck = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HealthCheck |= (HealthCheck(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivacyPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivacyPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerState", wireType)
			}
			m.PowerState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerState |= (PowerState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalVolumeSize", wireType)
			}
			m.ExternalVolumeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalVolumeSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmFlavor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmFlavor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptRes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptRes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstRuntime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstRuntime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstRuntime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerIds = append(m.ContainerIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyId", wireType)
			}
			m.NotifyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotifyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (TrackedState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RuntimeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerState", wireType)
			}
			m.PowerState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerState |= (PowerState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Something", wireType)
			}
			m.Something = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Something |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstLookup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstLookup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstLookup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PolicyKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAppinst(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAppinst
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAppinst
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAppinst(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAppinst = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAppinst   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("appinst.proto", fileDescriptorAppinst) }

var fileDescriptorAppinst = []byte{
	// 1977 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x4d, 0x6c, 0x1b, 0xc7,
	0x15, 0xf6, 0xe8, 0x87, 0x12, 0x87, 0xa4, 0xbc, 0x1a, 0x4b, 0xca, 0x98, 0xb1, 0x65, 0x99, 0xa9,
	0x03, 0xc1, 0x58, 0x89, 0x81, 0x82, 0xa4, 0xad, 0x50, 0xa3, 0x20, 0x65, 0x32, 0x26, 0x24, 0x91,
	0xee, 0x4a, 0x76, 0xd0, 0x5e, 0x16, 0xeb, 0xe5, 0x88, 0x5c, 0x68, 0x77, 0x67, 0xb0, 0xbb, 0xa4,
	0x23, 0x9f, 0x8a, 0x00, 0x2d, 0x8c, 0x1e, 0x8a, 0xa0, 0xbd, 0x14, 0xee, 0x25, 0x48, 0x2f, 0xb9,
	0x14, 0x48, 0x7d, 0xec, 0xb5, 0x17, 0xa3, 0x97, 0x06, 0xe8, 0xa5, 0xf0, 0x21, 0x48, 0x8d, 0x1e,
	0x0a, 0xa3, 0x87, 0x02, 0xa6, 0x84, 0x1e, 0x8b, 0x9d, 0x99, 0x25, 0x77, 0x49, 0x51, 0xae, 0xed,
	0x5e, 0x08, 0xee, 0xfb, 0xde, 0xef, 0x37, 0x6f, 0xdf, 0x9b, 0x85, 0x39, 0x83, 0x31, 0xcb, 0xf5,
	0x83, 0x75, 0xe6, 0xd1, 0x80, 0xa2, 0x34, 0x69, 0xb6, 0x08, 0xff, 0x9b, 0xbf, 0xd4, 0xa2, 0xb4,
	0x65, 0x93, 0xa2, 0xc1, 0xac, 0xa2, 0xe1, 0xba, 0x34, 0x30, 0x02, 0x8b, 0xba, 0xbe, 0x50, 0xcc,
	0x67, 0x3d, 0xe2, 0x77, 0x6c, 0x69, 0x96, 0xff, 0x5e, 0xcb, 0x0a, 0xda, 0x9d, 0x7b, 0xeb, 0x26,
	0x75, 0x8a, 0x0e, 0xbd, 0x67, 0xd9, 0xa1, 0x9b, 0x4f, 0x8a, 0xe1, 0xef, 0x9a, 0x69, 0xd3, 0x4e,
	0xb3, 0xc8, 0xf5, 0x5a, 0xc4, 0xed, 0xff, 0x91, 0x96, 0x69, 0x83, 0xb1, 0xc8, 0xe5, 0x81, 0x6d,
	0x74, 0xa9, 0x27, 0x9f, 0xe6, 0x4d, 0xbb, 0xe3, 0x07, 0xc4, 0x1b, 0x24, 0x97, 0xcf, 0x9a, 0xd4,
	0x71, 0x68, 0x64, 0xb9, 0x68, 0x74, 0x02, 0xea, 0x9b, 0x86, 0x4d, 0x18, 0xb5, 0x2d, 0xf3, 0x48,
	0x8a, 0xb7, 0x5e, 0x9a, 0x4a, 0x73, 0xcd, 0x31, 0x02, 0xb3, 0xbd, 0x46, 0xdc, 0x96, 0xe5, 0x92,
	0x62, 0xd3, 0x21, 0x6b, 0xdc, 0xb4, 0x68, 0x53, 0x53, 0x3a, 0xa9, 0xbd, 0xbe, 0x13, 0x83, 0xb1,
	0x44, 0x9a, 0x0b, 0x2d, 0xda, 0xa2, 0x02, 0x0a, 0xff, 0x09, 0x69, 0xe1, 0xb7, 0x00, 0xc2, 0x12,
	0x63, 0x35, 0xd7, 0x0f, 0xb6, 0xc9, 0x11, 0x7a, 0x0f, 0xce, 0x18, 0x8c, 0xe9, 0x87, 0xe4, 0x08,
	0x83, 0x15, 0xb0, 0x9a, 0xd9, 0x98, 0x5f, 0xef, 0x1f, 0xc4, 0x7a, 0x89, 0xb1, 0x6d, 0x72, 0x54,
	0x9e, 0x7a, 0xf2, 0xcd, 0x95, 0x73, 0x5a, 0xca, 0xe0, 0x4f, 0x68, 0x17, 0x2a, 0x92, 0x20, 0x3d,
	0x64, 0x88, 0x9b, 0x4e, 0x71, 0xd3, 0x8b, 0x31, 0xd3, 0x2d, 0xa1, 0x22, 0xc3, 0x94, 0x67, 0xbf,
	0xec, 0x61, 0xc0, 0xdd, 0xcc, 0x99, 0x09, 0x64, 0x33, 0xfb, 0xcf, 0x17, 0x18, 0xfc, 0xe7, 0x05,
	0x06, 0x5f, 0x7d, 0x7e, 0x05, 0x14, 0xfe, 0xa5, 0xc0, 0x19, 0x99, 0x1d, 0x5a, 0x82, 0xa9, 0x03,
	0x8b, 0xd8, 0x4d, 0x1f, 0x83, 0x95, 0xc9, 0xd5, 0xb4, 0x26, 0x9f, 0xd0, 0x1a, 0x9c, 0x0c, 0x63,
	0x4e, 0xf0, 0x98, 0x8b, 0xc9, 0x74, 0xa3, 0x78, 0x22, 0xe5, 0x50, 0x0f, 0x55, 0x61, 0x96, 0x13,
	0x67, 0x93, 0x40, 0xb7, 0xa9, 0x89, 0x27, 0xb9, 0xdd, 0xe5, 0xf5, 0xa6, 0xe5, 0x07, 0x9e, 0x75,
	0xaf, 0x13, 0x90, 0xa6, 0xce, 0x19, 0xd5, 0x05, 0xa3, 0xeb, 0x3b, 0xd4, 0x94, 0xf6, 0x99, 0xc8,
	0x70, 0x87, 0x9a, 0xe8, 0x0a, 0x9c, 0xec, 0x78, 0x16, 0x2f, 0x35, 0x5d, 0xce, 0x85, 0xf5, 0xfc,
	0xea, 0xf1, 0xc5, 0x69, 0x97, 0x9a, 0x0e, 0xd3, 0x42, 0x04, 0x7d, 0x00, 0x67, 0x6d, 0xab, 0x4b,
	0x5c, 0xe2, 0xfb, 0x38, 0xb5, 0x02, 0x56, 0xe7, 0x36, 0x2e, 0xc4, 0x92, 0xdb, 0x91, 0x50, 0x79,
	0x2a, 0x34, 0xd5, 0xfa, 0xaa, 0xa8, 0x0e, 0xb3, 0x8e, 0xc1, 0x18, 0x69, 0xea, 0x8c, 0x7a, 0x81,
	0x8f, 0xd3, 0x2b, 0x93, 0xab, 0x99, 0x8d, 0xab, 0xe3, 0xf3, 0x2b, 0x31, 0x76, 0x9b, 0x7a, 0x41,
	0x8c, 0xd3, 0x8c, 0x70, 0x10, 0x4a, 0x7d, 0xf4, 0x21, 0x4c, 0x89, 0x76, 0xc6, 0x59, 0x5e, 0xe9,
	0x42, 0x2c, 0x89, 0x2a, 0x07, 0x92, 0x07, 0x22, 0xb5, 0xd1, 0x0f, 0xe0, 0xb4, 0x1f, 0x18, 0x01,
	0xc1, 0x73, 0x3c, 0xf7, 0xb7, 0x62, 0x66, 0xfb, 0x9e, 0x61, 0x1e, 0x92, 0xe6, 0x5e, 0x08, 0x0f,
	0x97, 0x2e, 0x8c, 0xd0, 0x35, 0x98, 0x22, 0x9e, 0x47, 0x3d, 0x1f, 0x9f, 0x0f, 0x0f, 0x6b, 0x58,
	0x4b, 0x82, 0xe8, 0x26, 0xcc, 0x9a, 0x9e, 0xa3, 0xd3, 0x2e, 0xf1, 0x3c, 0xab, 0x49, 0xb0, 0xc2,
	0x63, 0x2d, 0xc5, 0x1b, 0x47, 0xdb, 0x6d, 0x48, 0xb4, 0x9c, 0x1e, 0x38, 0xc8, 0x98, 0x9e, 0x13,
	0xc9, 0x51, 0x19, 0x66, 0xbd, 0x8e, 0x1b, 0x58, 0x0e, 0xd1, 0x2d, 0xf7, 0x80, 0xe2, 0xf9, 0x91,
	0xf6, 0x93, 0xad, 0xa0, 0x09, 0xad, 0xe8, 0x38, 0xa5, 0x51, 0xcd, 0x3d, 0xa0, 0xe8, 0xc7, 0x10,
	0x9a, 0x1e, 0x31, 0x42, 0x76, 0x8d, 0x00, 0x2f, 0x72, 0x0f, 0xef, 0x8c, 0x27, 0x7d, 0xdf, 0x72,
	0x88, 0x1f, 0x18, 0x0e, 0x2b, 0x2f, 0xca, 0xca, 0xd2, 0x41, 0x24, 0xe2, 0xce, 0xd3, 0xd2, 0x5b,
	0x29, 0x40, 0x75, 0xb8, 0x14, 0x4e, 0x08, 0xbd, 0xff, 0x9a, 0x30, 0xdd, 0x30, 0xcd, 0xb0, 0x2d,
	0x96, 0x46, 0xda, 0xa2, 0xc6, 0x4a, 0x1c, 0x92, 0x6d, 0x71, 0x21, 0x34, 0x8c, 0xde, 0x1d, 0x09,
	0xa1, 0xef, 0xc2, 0x54, 0x48, 0x72, 0xc7, 0xc7, 0x6f, 0x8d, 0xf4, 0xfc, 0x1e, 0x07, 0xc2, 0x8a,
	0xe2, 0x47, 0x2a, 0xd4, 0xd1, 0x35, 0x38, 0xeb, 0x91, 0xae, 0xe5, 0x5b, 0xd4, 0xc5, 0x98, 0xf7,
	0x6d, 0x8c, 0xd1, 0x3e, 0x84, 0x54, 0x98, 0x3d, 0xa0, 0x9e, 0x49, 0xf4, 0x0e, 0x6b, 0x86, 0x0d,
	0x70, 0x71, 0x05, 0xac, 0xce, 0x26, 0xc8, 0xe7, 0xf0, 0x1d, 0x8e, 0xa2, 0x0d, 0x78, 0x5e, 0xe8,
	0xe9, 0x4e, 0xc7, 0x0e, 0x2c, 0x66, 0x13, 0x9c, 0x1f, 0x36, 0x98, 0x13, 0x1a, 0xbb, 0x52, 0x01,
	0x15, 0xe1, 0x8c, 0x49, 0xdd, 0x03, 0xab, 0xe5, 0xe3, 0xb7, 0x79, 0x7b, 0xc7, 0x4b, 0xd8, 0xe2,
	0x48, 0xd5, 0xb2, 0x89, 0x16, 0x69, 0x21, 0x15, 0x22, 0xbf, 0x6d, 0x78, 0xa4, 0xa9, 0x77, 0xa9,
	0xdd, 0x71, 0x88, 0xee, 0x5b, 0x0f, 0x08, 0xbe, 0xb4, 0x02, 0x56, 0xa7, 0x34, 0x45, 0x20, 0x77,
	0x39, 0xb0, 0x67, 0x3d, 0x20, 0xe8, 0x16, 0xcc, 0xb6, 0x89, 0x61, 0x07, 0x6d, 0xdd, 0x6c, 0x13,
	0xf3, 0x10, 0x5f, 0x1e, 0xe9, 0xaa, 0x5b, 0x1c, 0xde, 0x0a, 0xd1, 0xe1, 0xd6, 0xcc, 0xb4, 0x07,
	0x18, 0xba, 0x06, 0xe7, 0x98, 0x67, 0x75, 0x0d, 0xf3, 0x48, 0x17, 0xb3, 0x1d, 0x2f, 0x87, 0xbc,
	0x69, 0x39, 0x29, 0xbd, 0xcd, 0x85, 0xa8, 0x04, 0x33, 0x8c, 0xde, 0x27, 0x9e, 0x2e, 0xde, 0x98,
	0x2b, 0x3c, 0x5e, 0xbc, 0xa6, 0xdb, 0x21, 0x2a, 0xde, 0x97, 0x18, 0x2d, 0x90, 0xf5, 0xc5, 0xe8,
	0x87, 0x70, 0x81, 0x7c, 0x12, 0x10, 0xcf, 0x35, 0xec, 0x44, 0x8d, 0x2b, 0x61, 0x8d, 0xc3, 0x39,
	0xa2, 0x48, 0x35, 0x56, 0xf4, 0x26, 0x9c, 0x37, 0xba, 0x86, 0x65, 0x1b, 0xf7, 0x2c, 0xdb, 0x0a,
	0x8e, 0xf4, 0x07, 0xd4, 0x25, 0xf8, 0xea, 0x69, 0xd3, 0x49, 0x89, 0xeb, 0xfd, 0x84, 0xba, 0x04,
	0x5d, 0x87, 0xe9, 0xae, 0xa3, 0xcb, 0x31, 0x51, 0x38, 0xcd, 0x66, 0xb6, 0xeb, 0x88, 0x61, 0x81,
	0xde, 0x85, 0x33, 0x94, 0x05, 0xba, 0x47, 0x7c, 0xfc, 0xce, 0x69, 0x9a, 0x29, 0xca, 0x02, 0x8d,
	0xf8, 0x9b, 0x7f, 0x98, 0x0e, 0x27, 0xf9, 0xbf, 0x5f, 0x60, 0xf0, 0xd3, 0x1e, 0x06, 0x9f, 0xf5,
	0x30, 0xf8, 0x4d, 0x0f, 0x83, 0xaf, 0x7a, 0x18, 0xfc, 0xb1, 0x87, 0xb3, 0xf1, 0x11, 0xf2, 0xa4,
	0x87, 0xc1, 0xdf, 0x42, 0x1f, 0xc7, 0xf8, 0xe7, 0x60, 0x6b, 0x30, 0x62, 0xd5, 0x3b, 0x9e, 0xa5,
	0xee, 0x0e, 0x46, 0x99, 0x1a, 0xcd, 0x4c, 0x75, 0x2b, 0x7a, 0xb7, 0x54, 0xd1, 0xef, 0xaa, 0x26,
	0x7b, 0x57, 0xad, 0xf0, 0xb9, 0xa2, 0x6a, 0x83, 0x37, 0x5b, 0xad, 0xd3, 0x26, 0x11, 0xb9, 0xab,
	0x95, 0x11, 0xda, 0xd4, 0xd2, 0x10, 0x17, 0xdc, 0x23, 0x79, 0x74, 0x8c, 0xbf, 0x98, 0x30, 0x18,
	0x73, 0x0d, 0x87, 0xdc, 0xd8, 0x26, 0x47, 0x72, 0xf5, 0xad, 0xd7, 0x0d, 0x87, 0xa8, 0x06, 0x63,
	0x5d, 0xe2, 0xf9, 0x71, 0xf9, 0x5d, 0xe2, 0xf1, 0xf0, 0x06, 0x63, 0x6b, 0xd4, 0x6b, 0xc5, 0xa1,
	0x86, 0xd7, 0x32, 0x5c, 0xeb, 0x01, 0xbf, 0xb3, 0xa8, 0x72, 0x04, 0x70, 0x3c, 0xb9, 0x12, 0xa3,
	0xc7, 0x7e, 0x14, 0xa9, 0xda, 0x77, 0x37, 0xa4, 0x3e, 0xe4, 0x56, 0x90, 0x76, 0xba, 0x5f, 0x81,
	0xc5, 0x1c, 0x0b, 0xc1, 0x38, 0xcf, 0x71, 0x83, 0x44, 0x14, 0xd1, 0x1f, 0x37, 0x04, 0x97, 0xdc,
	0xd7, 0x17, 0xc7, 0xb8, 0xfc, 0xb2, 0xdc, 0x5e, 0x5e, 0xea, 0xd3, 0x63, 0xbc, 0x7c, 0x76, 0x1e,
	0x8f, 0x4f, 0xb0, 0x79, 0x48, 0x8e, 0x6e, 0x9c, 0x46, 0x69, 0x28, 0x3f, 0x2b, 0xfe, 0x29, 0xf8,
	0xb8, 0x0a, 0x0b, 0x37, 0xe1, 0x5c, 0x72, 0x53, 0xa0, 0x0d, 0x98, 0x33, 0xa9, 0x1b, 0x18, 0x96,
	0x1b, 0x0e, 0xee, 0xe8, 0xee, 0x31, 0xdc, 0xf3, 0xd9, 0xbe, 0x4e, 0xad, 0xe9, 0x17, 0x1e, 0x4d,
	0xc2, 0x8c, 0x74, 0xc3, 0x57, 0xcb, 0xff, 0xe9, 0xe2, 0xf2, 0x2e, 0x4c, 0xbb, 0x34, 0xb0, 0x0e,
	0x8e, 0x74, 0xab, 0xc9, 0x6f, 0x2d, 0x93, 0x89, 0xf1, 0x2d, 0xb0, 0x5a, 0x13, 0xad, 0x45, 0x8b,
	0x7b, 0xea, 0xcc, 0xc5, 0x1d, 0x6d, 0xea, 0xa5, 0xfe, 0xa6, 0x9e, 0x16, 0xd9, 0xc9, 0xd5, 0x3c,
	0xbc, 0x54, 0x53, 0xaf, 0xb1, 0x54, 0x07, 0x9b, 0x6a, 0xe6, 0xd5, 0x36, 0xd5, 0x87, 0xc9, 0x81,
	0x3a, 0x7b, 0xc6, 0x40, 0x8d, 0x4f, 0xd1, 0xcd, 0x95, 0xe1, 0x99, 0xf3, 0x79, 0x0f, 0x83, 0x6f,
	0x7b, 0x18, 0x3c, 0x3e, 0xc1, 0x53, 0x2e, 0x75, 0x49, 0x61, 0xbd, 0x7f, 0xc4, 0xbb, 0x24, 0xf0,
	0x2c, 0xd3, 0x47, 0x97, 0x60, 0xda, 0xa7, 0x0e, 0x09, 0xda, 0x96, 0xdb, 0xc2, 0xd3, 0x7c, 0xa5,
	0x0c, 0x04, 0x85, 0x87, 0x00, 0xe6, 0xa4, 0xc1, 0x0e, 0xa5, 0x87, 0x1d, 0x16, 0x1d, 0x1b, 0xf8,
	0x1f, 0x8f, 0xed, 0xfb, 0x10, 0x8a, 0xd5, 0xa1, 0x0f, 0x0e, 0x7b, 0x21, 0x51, 0x49, 0x08, 0x0e,
	0x8c, 0xd2, 0x2c, 0x12, 0x6c, 0xe6, 0xfe, 0x7c, 0x82, 0xd3, 0x7d, 0xfc, 0xfa, 0xcf, 0x00, 0xcc,
	0xc4, 0x16, 0x17, 0xc2, 0x70, 0xe1, 0x56, 0xa5, 0xb4, 0xb3, 0x7f, 0x4b, 0xdf, 0xba, 0x55, 0xd9,
	0xda, 0xd6, 0xef, 0xd4, 0xb7, 0xeb, 0x8d, 0x8f, 0xeb, 0xca, 0x39, 0xf4, 0x1d, 0xb8, 0x92, 0x40,
	0xaa, 0xa5, 0xda, 0x8e, 0xae, 0x35, 0x1a, 0xfb, 0x3b, 0x65, 0xbd, 0x51, 0xad, 0xee, 0xd4, 0xea,
	0x15, 0x05, 0xa0, 0xab, 0xf0, 0xf2, 0xa8, 0xd6, 0x5e, 0x45, 0xbb, 0x5b, 0xd1, 0xf8, 0x7f, 0x65,
	0x02, 0x5d, 0x80, 0xe7, 0x13, 0x2a, 0x8d, 0x6d, 0x65, 0xf2, 0xfa, 0x2f, 0x27, 0x20, 0x1c, 0xf0,
	0x8f, 0x2e, 0xc3, 0x0b, 0xb7, 0x1b, 0x1f, 0x57, 0x34, 0x7d, 0x6f, 0xbf, 0xb4, 0x5f, 0x19, 0x64,
	0x91, 0x9f, 0xfa, 0xec, 0x04, 0x03, 0x74, 0x09, 0x22, 0x01, 0x37, 0xea, 0xba, 0x56, 0xf9, 0xd1,
	0x9d, 0xca, 0xde, 0x7e, 0xe5, 0xa6, 0x02, 0x24, 0xba, 0x08, 0x33, 0x1c, 0xad, 0xd5, 0x3f, 0xd2,
	0x1b, 0x75, 0x65, 0x42, 0x8a, 0xb3, 0x70, 0x36, 0x32, 0x52, 0x26, 0x07, 0x11, 0x1a, 0xd5, 0x6a,
	0xcc, 0xc7, 0x94, 0x54, 0x5e, 0x82, 0xd9, 0x81, 0x8f, 0x6a, 0x55, 0x99, 0x96, 0xf2, 0x1c, 0x4c,
	0xf7, 0xcd, 0x94, 0x14, 0xca, 0x43, 0x45, 0xab, 0x94, 0x1b, 0x8d, 0xfd, 0x98, 0x8b, 0x19, 0xa9,
	0x7a, 0x01, 0xa6, 0x05, 0x56, 0xab, 0x7f, 0xa4, 0xcc, 0x4a, 0x21, 0x84, 0x29, 0x21, 0x54, 0xd2,
	0xe8, 0x6d, 0x38, 0x1f, 0x2f, 0xb2, 0xa2, 0x69, 0x0d, 0x4d, 0x81, 0x42, 0x71, 0xe3, 0xf7, 0xb3,
	0xfd, 0x6f, 0xa8, 0x12, 0xb3, 0xd0, 0x9f, 0x00, 0xcc, 0x89, 0x0d, 0x15, 0x7d, 0xba, 0xa0, 0xd1,
	0x2e, 0xc9, 0xc7, 0x3f, 0xac, 0x34, 0xfe, 0x09, 0x5b, 0x78, 0x08, 0x9e, 0xf7, 0xf0, 0x07, 0x1a,
	0xf1, 0x69, 0xc7, 0x33, 0x23, 0x63, 0x5f, 0x2d, 0x99, 0xe1, 0x70, 0xda, 0x35, 0x5c, 0xa3, 0x45,
	0xd4, 0x31, 0x9b, 0xe5, 0xcb, 0x63, 0x0c, 0xbe, 0x3e, 0xc6, 0xe0, 0xe9, 0x31, 0xbe, 0x76, 0x27,
	0x71, 0xd9, 0x52, 0xab, 0x83, 0xcb, 0x9a, 0x3a, 0x38, 0xb6, 0x87, 0x27, 0x18, 0x7c, 0xfa, 0xd7,
	0x7f, 0xfc, 0x7a, 0x62, 0xa1, 0x70, 0xbe, 0x28, 0xee, 0xaa, 0x45, 0xf9, 0x05, 0xbe, 0x09, 0xae,
	0xbf, 0x07, 0xd0, 0xef, 0x00, 0xcc, 0xdd, 0x24, 0x36, 0x79, 0xe5, 0x2a, 0xac, 0x37, 0x2a, 0xe2,
	0xe9, 0x31, 0x86, 0x63, 0xb2, 0x6c, 0xf2, 0x6c, 0x92, 0x59, 0x3e, 0x9a, 0x80, 0x73, 0x1a, 0x39,
	0xf0, 0x88, 0xdf, 0x7e, 0xc5, 0x34, 0xbf, 0x01, 0x6f, 0x9a, 0x67, 0x5b, 0xde, 0x2a, 0x4a, 0xa3,
	0x77, 0x74, 0x55, 0x5c, 0x62, 0xfd, 0x18, 0xe1, 0xea, 0xed, 0xf8, 0x95, 0x51, 0x8d, 0xbd, 0xc8,
	0xea, 0xde, 0xd0, 0x05, 0x56, 0xbd, 0x2b, 0x2f, 0x5b, 0x6a, 0x83, 0xdf, 0xa5, 0x9e, 0x1f, 0x63,
	0x34, 0xba, 0x20, 0xfb, 0xdc, 0x2c, 0x16, 0x94, 0xa2, 0x27, 0x38, 0x48, 0x92, 0xf3, 0x8b, 0x09,
	0x98, 0x13, 0x07, 0xff, 0x8a, 0xdc, 0xfc, 0xe5, 0x8d, 0xb9, 0x61, 0x67, 0x70, 0x73, 0x56, 0x7f,
	0xbe, 0x36, 0x47, 0x89, 0x4e, 0x11, 0x9f, 0x1b, 0x49, 0x32, 0x1e, 0x02, 0x98, 0xd9, 0x6b, 0xd3,
	0xfb, 0x67, 0x51, 0x71, 0x8a, 0xac, 0xd0, 0x78, 0xde, 0xc3, 0xef, 0x8f, 0xa1, 0xe2, 0xae, 0x45,
	0xee, 0x8f, 0x23, 0x82, 0x27, 0x83, 0x0a, 0xb9, 0xa2, 0xdf, 0xa6, 0xf7, 0x13, 0xa9, 0x6c, 0xf8,
	0xfd, 0x1d, 0x14, 0xae, 0xbf, 0x70, 0x64, 0x18, 0xf0, 0x7c, 0x2c, 0x37, 0x71, 0x6b, 0x18, 0xcd,
	0x25, 0x94, 0xe7, 0xc7, 0xc8, 0x0b, 0x97, 0x78, 0xc0, 0xa5, 0xc2, 0x7c, 0x22, 0x60, 0xb8, 0xba,
	0x45, 0xd0, 0x4f, 0x01, 0x9c, 0x4f, 0x6e, 0xbe, 0x30, 0xb0, 0x03, 0x51, 0x2c, 0x70, 0xb4, 0x12,
	0x4f, 0xd9, 0xf2, 0x12, 0xca, 0x8f, 0x87, 0x0a, 0x57, 0x78, 0x06, 0x17, 0x0b, 0x0b, 0x89, 0x0c,
	0x1c, 0x81, 0xf2, 0x24, 0xca, 0xca, 0x93, 0xbf, 0x2f, 0x9f, 0x7b, 0xf2, 0x6c, 0x19, 0x7c, 0xfd,
	0x6c, 0x19, 0x7c, 0xfb, 0x6c, 0x19, 0xdc, 0x4b, 0x71, 0x57, 0xef, 0xff, 0x37, 0x00, 0x00, 0xff,
	0xff, 0xe8, 0x20, 0x97, 0xb3, 0xff, 0x13, 0x00, 0x00,
}
