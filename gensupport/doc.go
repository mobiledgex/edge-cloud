// copyright

package gensupport

/*
Package gensupport provides a framework for generating code based on
proto buffers .proto files. Rather that act as a plugin for generating
code that ends up in the same .pb.go file as the standard proto buffers
and grpc code, the intent here is that 1) generated code ends up in its
own file, 2) the generated file is not in the same directory nor the same
pakcage as the .proto/.pb.go source files.

The generator acts very much like a plugin that is used to add more generated
code. In particular, package naming and imports must be handled differently
because the source and target packages and source and target directories are
no longer the same.

We have so far avoiding forking the gogo proto buffers repo, and rely on the
using the existing generator code.

Descriptor vs DescriptorProto; EnumDescriptor vs EnumDescriptorProto

The data generated by the protoc binary (not our protoc-gen-xxx binary)
produces all the data in the descriptor library. On top of that, the generator
wraps Messages (DescriptorProtos) in Descriptors, and Enums (EnumDescriptorProtos)
in EnumDescriptors. This done to capture the hierarchical nature of these
two objects since they can have nested definitions (enums and messages defined
within other messages, with no recursion limit).

The plugin code should always iterate and use the wrapped versions, as the
generator and this support library require those objects to generate proper
hierarchical names for nested objects. Other objects like Services and Methods
are not wrapped (because they are not nestable).

Type Names

Type names as referenced by fields and method input/output types are used
as a reference for looking up the definition of the object. They are
generated by protoc and may be of several formats:

	// Builtin definitions such as:
	.google.protobuf.Timestamp

	// Message/Enum types with leading package name:
	.edgeproto.Loc

	//Nested Message/Enum types with leading package name:
	.edgeproto.AppInst.Liveness

There are two typical operations that involve type names. The first is to look
up the definition of a Message or Enum based on the type name in a Field or Method.
Use to GetDesc() and GetEnumDesc() functions to do this.

The second is to get the type name from a Message or Enum Object.
To get a type name that includes the package package and hierarchy (for nested
definitions), use the FQTypeName() function. For a type name that excludes
the package name, use the GetMsgName() and GetEnumName() functions.
*/
