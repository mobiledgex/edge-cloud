// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: clusterinst.proto

package main

import (
	"context"
	fmt "fmt"
	"github.com/coreos/etcd/clientv3/concurrency"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto"
	"github.com/mobiledgex/edge-cloud/edgeproto"
	"github.com/mobiledgex/edge-cloud/objstore"
	_ "github.com/mobiledgex/edge-cloud/protogen"
	"github.com/mobiledgex/edge-cloud/testutil"
	"github.com/stretchr/testify/require"
	math "math"
	"testing"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Auto-generated code: DO NOT EDIT

// Caller must write by hand the test data generator.
// Each Ref object should only have a single reference to the key,
// in order to properly test each reference (i.e. don't have a single
// object that has multiple references).
type ClusterInstDeleteDataGen interface {
	GetClusterInstTestObj() (*edgeproto.ClusterInst, *testSupportData)
	GetClusterInstAppInstAppsRef(key *edgeproto.ClusterInstKey) (*edgeproto.ClusterRefs, *testSupportData)
}

// ClusterInstDeleteStore wraps around the usual
// store to instrument checks and inject data while
// the delete api code is running.
type ClusterInstDeleteStore struct {
	edgeproto.ClusterInstStore
	t                   *testing.T
	allApis             *AllApis
	putDeletePrepare    bool
	putDeletePrepareCb  func()
	putDeletePrepareSTM concurrency.STM
}

func (s *ClusterInstDeleteStore) Put(ctx context.Context, m *edgeproto.ClusterInst, wait func(int64), ops ...objstore.KVOp) (*edgeproto.Result, error) {
	if wait != nil {
		s.putDeletePrepare = m.DeletePrepare
	}
	res, err := s.ClusterInstStore.Put(ctx, m, wait, ops...)
	if s.putDeletePrepare && s.putDeletePrepareCb != nil {
		s.putDeletePrepareCb()
	}
	return res, err
}

func (s *ClusterInstDeleteStore) STMPut(stm concurrency.STM, obj *edgeproto.ClusterInst, ops ...objstore.KVOp) {
	// there's an assumption that this is run within an ApplySTMWait,
	// where we wait for the caches to be updated with the transaction.
	if obj.DeletePrepare {
		s.putDeletePrepare = true
		s.putDeletePrepareSTM = stm
	} else {
		s.putDeletePrepare = false
		s.putDeletePrepareSTM = nil
	}
	s.ClusterInstStore.STMPut(stm, obj, ops...)
	if s.putDeletePrepare && s.putDeletePrepareCb != nil {
		s.putDeletePrepareCb()
	}
}

func (s *ClusterInstDeleteStore) Delete(ctx context.Context, m *edgeproto.ClusterInst, wait func(int64)) (*edgeproto.Result, error) {
	require.True(s.t, s.putDeletePrepare, "DeletePrepare must be comitted to database with a sync.Wait before deleting")
	return s.ClusterInstStore.Delete(ctx, m, wait)
}

func (s *ClusterInstDeleteStore) STMDel(stm concurrency.STM, key *edgeproto.ClusterInstKey) {
	require.True(s.t, s.putDeletePrepare, "DeletePrepare must be comitted to database with a sync.Wait before deleting")
	s.ClusterInstStore.STMDel(stm, key)
}

func (s *ClusterInstDeleteStore) requireUndoDeletePrepare(ctx context.Context, obj *edgeproto.ClusterInst) {
	deletePrepare := s.getDeletePrepare(ctx, obj)
	require.False(s.t, deletePrepare, "must undo delete prepare field on failure")
}

func (s *ClusterInstDeleteStore) getDeletePrepare(ctx context.Context, obj *edgeproto.ClusterInst) bool {
	buf := edgeproto.ClusterInst{}
	found := s.Get(ctx, obj.GetKey(), &buf)
	require.True(s.t, found, "expected test object to be found")
	return buf.DeletePrepare
}

func deleteClusterInstChecks(t *testing.T, ctx context.Context, all *AllApis, dataGen ClusterInstDeleteDataGen) {
	var err error
	// override store so we can inject data and check data
	api := all.clusterInstApi
	origStore := api.store
	deleteStore := &ClusterInstDeleteStore{
		ClusterInstStore: origStore,
		t:                t,
		allApis:          all,
	}
	api.store = deleteStore
	origclusterRefsApiStore := all.clusterRefsApi.store
	clusterRefsApiStore := &ClusterRefsDeleteStore{
		ClusterRefsStore: origclusterRefsApiStore,
	}
	all.clusterRefsApi.store = clusterRefsApiStore
	defer func() {
		api.store = origStore
		all.clusterRefsApi.store = origclusterRefsApiStore
	}()

	// inject testObj directly, bypassing create checks/deps
	testObj, supportData := dataGen.GetClusterInstTestObj()
	supportData.put(t, ctx, all)
	defer supportData.delete(t, ctx, all)
	origStore.Put(ctx, testObj, api.sync.syncWait)

	// Positive test, delete should succeed without any references.
	// The overrided store checks that delete prepare was set on the
	// object in the database before actually doing the delete.
	// This call back checks that any refs lookups are done in the
	// same stm as the delete prepare is set.
	deleteStore.putDeletePrepareCb = func() {
		// make sure ref objects reads happen in same stm
		// as delete prepare is set
		require.NotNil(t, deleteStore.putDeletePrepareSTM, "must set delete prepare in STM")
		require.NotNil(t, clusterRefsApiStore.getRefSTM, "must check for refs from ClusterRefs in STM")
		require.Equal(t, deleteStore.putDeletePrepareSTM, clusterRefsApiStore.getRefSTM, "delete prepare and ref check for ClusterRefs must be done in the same STM")
	}
	testObj, _ = dataGen.GetClusterInstTestObj()
	err = api.DeleteClusterInst(testObj, testutil.NewCudStreamoutClusterInst(ctx))
	require.Nil(t, err, "delete must succeed with no refs")
	deleteStore.putDeletePrepareCb = nil

	// Negative test, inject testObj with delete prepare already set.
	testObj, _ = dataGen.GetClusterInstTestObj()
	testObj.DeletePrepare = true
	origStore.Put(ctx, testObj, api.sync.syncWait)
	// delete should fail with already being deleted
	testObj, _ = dataGen.GetClusterInstTestObj()
	err = api.DeleteClusterInst(testObj, testutil.NewCudStreamoutClusterInst(ctx))
	require.NotNil(t, err, "delete must fail if already being deleted")
	require.Contains(t, err.Error(), "already being deleted")
	// failed delete must not interfere with existing delete prepare state
	require.True(t, deleteStore.getDeletePrepare(ctx, testObj), "delete prepare must not be modified by failed delete")

	// inject testObj for ref tests
	testObj, _ = dataGen.GetClusterInstTestObj()
	origStore.Put(ctx, testObj, api.sync.syncWait)

	{
		// Negative test, ClusterRefs refers to ClusterInst via refs object.
		// Inject the refs object to trigger an "in use" error.
		refBy, supportData := dataGen.GetClusterInstAppInstAppsRef(testObj.GetKey())
		supportData.put(t, ctx, all)
		_, err = all.clusterRefsApi.store.Put(ctx, refBy, all.clusterRefsApi.sync.syncWait)
		require.Nil(t, err)
		testObj, _ = dataGen.GetClusterInstTestObj()
		err = api.DeleteClusterInst(testObj, testutil.NewCudStreamoutClusterInst(ctx))
		require.NotNil(t, err, "delete with ref from ClusterRefs must fail")
		require.Contains(t, err.Error(), "in use")
		// check that delete prepare was reset
		deleteStore.requireUndoDeletePrepare(ctx, testObj)
		// remove ClusterRefs obj
		_, err = all.clusterRefsApi.store.Delete(ctx, refBy, all.clusterRefsApi.sync.syncWait)
		require.Nil(t, err, "cleanup ref from ClusterRefs must succeed")
		supportData.delete(t, ctx, all)
	}

	// clean up testObj
	testObj, _ = dataGen.GetClusterInstTestObj()
	err = api.DeleteClusterInst(testObj, testutil.NewCudStreamoutClusterInst(ctx))
	require.Nil(t, err, "cleanup must succeed")
}
