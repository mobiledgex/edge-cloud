// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: autoprovpolicy.proto

package main

import (
	"context"
	fmt "fmt"
	"github.com/coreos/etcd/clientv3/concurrency"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	_ "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto"
	"github.com/mobiledgex/edge-cloud/edgeproto"
	"github.com/mobiledgex/edge-cloud/objstore"
	_ "github.com/mobiledgex/edge-cloud/protogen"
	"github.com/stretchr/testify/require"
	math "math"
	"testing"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Auto-generated code: DO NOT EDIT

// AutoProvPolicyStoreTracker wraps around the usual
// store to track the STM used for gets/puts.
type AutoProvPolicyStoreTracker struct {
	edgeproto.AutoProvPolicyStore
	getSTM concurrency.STM
	putSTM concurrency.STM
}

// Wrap the Api's store with a tracker store.
// Returns the tracker store, and the unwrap function to defer.
func wrapAutoProvPolicyTrackerStore(api *AutoProvPolicyApi) (*AutoProvPolicyStoreTracker, func()) {
	orig := api.store
	tracker := &AutoProvPolicyStoreTracker{
		AutoProvPolicyStore: api.store,
	}
	api.store = tracker
	unwrap := func() {
		api.store = orig
	}
	return tracker, unwrap
}

func (s *AutoProvPolicyStoreTracker) STMGet(stm concurrency.STM, key *edgeproto.PolicyKey, buf *edgeproto.AutoProvPolicy) bool {
	found := s.AutoProvPolicyStore.STMGet(stm, key, buf)
	if s.getSTM == nil {
		s.getSTM = stm
	}
	return found
}

func (s *AutoProvPolicyStoreTracker) STMPut(stm concurrency.STM, obj *edgeproto.AutoProvPolicy, ops ...objstore.KVOp) {
	s.AutoProvPolicyStore.STMPut(stm, obj, ops...)
	if s.putSTM == nil {
		s.putSTM = stm
	}
}

// Caller must write by hand the test data generator.
// Each Ref object should only have a single reference to the key,
// in order to properly test each reference (i.e. don't have a single
// object that has multiple references).
type AutoProvPolicyDeleteDataGen interface {
	GetAutoProvPolicyTestObj() (*edgeproto.AutoProvPolicy, *testSupportData)
	GetAppAutoProvPoliciesRef(key *edgeproto.PolicyKey) (*edgeproto.App, *testSupportData)
}

// AutoProvPolicyDeleteStore wraps around the usual
// store to instrument checks and inject data while
// the delete api code is running.
type AutoProvPolicyDeleteStore struct {
	edgeproto.AutoProvPolicyStore
	t                   *testing.T
	allApis             *AllApis
	putDeletePrepare    bool
	putDeletePrepareCb  func()
	putDeletePrepareSTM concurrency.STM
}

func (s *AutoProvPolicyDeleteStore) Put(ctx context.Context, m *edgeproto.AutoProvPolicy, wait func(int64), ops ...objstore.KVOp) (*edgeproto.Result, error) {
	if wait != nil {
		s.putDeletePrepare = m.DeletePrepare
	}
	res, err := s.AutoProvPolicyStore.Put(ctx, m, wait, ops...)
	if s.putDeletePrepare && s.putDeletePrepareCb != nil {
		s.putDeletePrepareCb()
	}
	return res, err
}

func (s *AutoProvPolicyDeleteStore) STMPut(stm concurrency.STM, obj *edgeproto.AutoProvPolicy, ops ...objstore.KVOp) {
	// there's an assumption that this is run within an ApplySTMWait,
	// where we wait for the caches to be updated with the transaction.
	if obj.DeletePrepare {
		s.putDeletePrepare = true
		s.putDeletePrepareSTM = stm
	} else {
		s.putDeletePrepare = false
		s.putDeletePrepareSTM = nil
	}
	s.AutoProvPolicyStore.STMPut(stm, obj, ops...)
	if s.putDeletePrepare && s.putDeletePrepareCb != nil {
		s.putDeletePrepareCb()
	}
}

func (s *AutoProvPolicyDeleteStore) Delete(ctx context.Context, m *edgeproto.AutoProvPolicy, wait func(int64)) (*edgeproto.Result, error) {
	require.True(s.t, s.putDeletePrepare, "DeletePrepare must be comitted to database with a sync.Wait before deleting")
	return s.AutoProvPolicyStore.Delete(ctx, m, wait)
}

func (s *AutoProvPolicyDeleteStore) STMDel(stm concurrency.STM, key *edgeproto.PolicyKey) {
	require.True(s.t, s.putDeletePrepare, "DeletePrepare must be comitted to database with a sync.Wait before deleting")
	s.AutoProvPolicyStore.STMDel(stm, key)
}

func (s *AutoProvPolicyDeleteStore) requireUndoDeletePrepare(ctx context.Context, obj *edgeproto.AutoProvPolicy) {
	deletePrepare := s.getDeletePrepare(ctx, obj)
	require.False(s.t, deletePrepare, "must undo delete prepare field on failure")
}

func (s *AutoProvPolicyDeleteStore) getDeletePrepare(ctx context.Context, obj *edgeproto.AutoProvPolicy) bool {
	buf := edgeproto.AutoProvPolicy{}
	found := s.Get(ctx, obj.GetKey(), &buf)
	require.True(s.t, found, "expected test object to be found")
	return buf.DeletePrepare
}

func deleteAutoProvPolicyChecks(t *testing.T, ctx context.Context, all *AllApis, dataGen AutoProvPolicyDeleteDataGen) {
	var err error
	// override store so we can inject data and check data
	api := all.autoProvPolicyApi
	origStore := api.store
	deleteStore := &AutoProvPolicyDeleteStore{
		AutoProvPolicyStore: origStore,
		t:                   t,
		allApis:             all,
	}
	api.store = deleteStore
	defer func() {
		api.store = origStore
	}()

	// inject testObj directly, bypassing create checks/deps
	testObj, supportData := dataGen.GetAutoProvPolicyTestObj()
	supportData.put(t, ctx, all)
	defer supportData.delete(t, ctx, all)
	origStore.Put(ctx, testObj, api.sync.syncWait)

	// Positive test, delete should succeed without any references.
	// The overrided store checks that delete prepare was set on the
	// object in the database before actually doing the delete.
	testObj, _ = dataGen.GetAutoProvPolicyTestObj()
	_, err = api.DeleteAutoProvPolicy(ctx, testObj)
	require.Nil(t, err, "delete must succeed with no refs")

	// Negative test, inject testObj with delete prepare already set.
	testObj, _ = dataGen.GetAutoProvPolicyTestObj()
	testObj.DeletePrepare = true
	origStore.Put(ctx, testObj, api.sync.syncWait)
	// delete should fail with already being deleted
	testObj, _ = dataGen.GetAutoProvPolicyTestObj()
	_, err = api.DeleteAutoProvPolicy(ctx, testObj)
	require.NotNil(t, err, "delete must fail if already being deleted")
	require.Equal(t, testObj.GetKey().BeingDeletedError().Error(), err.Error())
	// failed delete must not interfere with existing delete prepare state
	require.True(t, deleteStore.getDeletePrepare(ctx, testObj), "delete prepare must not be modified by failed delete")

	// inject testObj for ref tests
	testObj, _ = dataGen.GetAutoProvPolicyTestObj()
	origStore.Put(ctx, testObj, api.sync.syncWait)

	{
		// Negative test, App refers to AutoProvPolicy.
		// The cb will inject refBy obj after delete prepare has been set.
		refBy, supportData := dataGen.GetAppAutoProvPoliciesRef(testObj.GetKey())
		supportData.put(t, ctx, all)
		deleteStore.putDeletePrepareCb = func() {
			all.appApi.store.Put(ctx, refBy, all.appApi.sync.syncWait)
		}
		testObj, _ = dataGen.GetAutoProvPolicyTestObj()
		_, err = api.DeleteAutoProvPolicy(ctx, testObj)
		require.NotNil(t, err, "must fail delete with ref from App")
		require.Contains(t, err.Error(), "in use")
		// check that delete prepare was reset
		deleteStore.requireUndoDeletePrepare(ctx, testObj)
		// remove App obj
		_, err = all.appApi.store.Delete(ctx, refBy, all.appApi.sync.syncWait)
		require.Nil(t, err, "cleanup ref from App must succeed")
		deleteStore.putDeletePrepareCb = nil
		supportData.delete(t, ctx, all)
	}

	// clean up testObj
	testObj, _ = dataGen.GetAutoProvPolicyTestObj()
	_, err = api.DeleteAutoProvPolicy(ctx, testObj)
	require.Nil(t, err, "cleanup must succeed")
}

func CreateAutoProvPolicyAddRefsChecks(t *testing.T, ctx context.Context, all *AllApis, dataGen AllAddRefsDataGen) {
	var err error

	testObj, supportData := dataGen.GetCreateAutoProvPolicyTestObj()
	supportData.put(t, ctx, all)
	{
		// set delete_prepare on referenced Cloudlet
		ref := supportData.getOneCloudlet()
		require.NotNil(t, ref, "support data must include one referenced Cloudlet")
		ref.DeletePrepare = true
		_, err = all.cloudletApi.store.Put(ctx, ref, all.cloudletApi.sync.syncWait)
		require.Nil(t, err)
		// api call must fail with object being deleted
		testObj, _ = dataGen.GetCreateAutoProvPolicyTestObj()
		_, err = all.autoProvPolicyApi.CreateAutoProvPolicy(ctx, testObj)
		require.NotNil(t, err, "CreateAutoProvPolicy must fail with Cloudlet.DeletePrepare set")
		require.Equal(t, ref.GetKey().BeingDeletedError().Error(), err.Error())
		// reset delete_prepare on referenced Cloudlet
		ref.DeletePrepare = false
		_, err = all.cloudletApi.store.Put(ctx, ref, all.cloudletApi.sync.syncWait)
		require.Nil(t, err)
	}

	// wrap the stores so we can make sure all checks and changes
	// happen in the same STM.
	autoProvPolicyApiStore, autoProvPolicyApiUnwrap := wrapAutoProvPolicyTrackerStore(all.autoProvPolicyApi)
	defer autoProvPolicyApiUnwrap()
	cloudletApiStore, cloudletApiUnwrap := wrapCloudletTrackerStore(all.cloudletApi)
	defer cloudletApiUnwrap()

	// CreateAutoProvPolicy should succeed if no references are in delete_prepare
	testObj, _ = dataGen.GetCreateAutoProvPolicyTestObj()
	_, err = all.autoProvPolicyApi.CreateAutoProvPolicy(ctx, testObj)
	require.Nil(t, err, "CreateAutoProvPolicy should succeed if no references are in delete prepare")
	// make sure everything ran in the same STM
	require.NotNil(t, autoProvPolicyApiStore.putSTM, "CreateAutoProvPolicy put AutoProvPolicy must be done in STM")
	require.NotNil(t, cloudletApiStore.getSTM, "CreateAutoProvPolicy check Cloudlet ref must be done in STM")
	require.Equal(t, autoProvPolicyApiStore.putSTM, cloudletApiStore.getSTM, "CreateAutoProvPolicy check Cloudlet ref must be done in same STM as AutoProvPolicy put")

	// clean up
	// delete created test obj
	testObj, _ = dataGen.GetCreateAutoProvPolicyTestObj()
	_, err = all.autoProvPolicyApi.DeleteAutoProvPolicy(ctx, testObj)
	require.Nil(t, err)
	supportData.delete(t, ctx, all)
}

func UpdateAutoProvPolicyAddRefsChecks(t *testing.T, ctx context.Context, all *AllApis, dataGen AllAddRefsDataGen) {
	var err error

	testObj, supportData := dataGen.GetUpdateAutoProvPolicyTestObj()
	supportData.put(t, ctx, all)
	{
		// set delete_prepare on referenced Cloudlet
		ref := supportData.getOneCloudlet()
		require.NotNil(t, ref, "support data must include one referenced Cloudlet")
		ref.DeletePrepare = true
		_, err = all.cloudletApi.store.Put(ctx, ref, all.cloudletApi.sync.syncWait)
		require.Nil(t, err)
		// api call must fail with object being deleted
		testObj, _ = dataGen.GetUpdateAutoProvPolicyTestObj()
		_, err = all.autoProvPolicyApi.UpdateAutoProvPolicy(ctx, testObj)
		require.NotNil(t, err, "UpdateAutoProvPolicy must fail with Cloudlet.DeletePrepare set")
		require.Equal(t, ref.GetKey().BeingDeletedError().Error(), err.Error())
		// reset delete_prepare on referenced Cloudlet
		ref.DeletePrepare = false
		_, err = all.cloudletApi.store.Put(ctx, ref, all.cloudletApi.sync.syncWait)
		require.Nil(t, err)
	}

	// wrap the stores so we can make sure all checks and changes
	// happen in the same STM.
	autoProvPolicyApiStore, autoProvPolicyApiUnwrap := wrapAutoProvPolicyTrackerStore(all.autoProvPolicyApi)
	defer autoProvPolicyApiUnwrap()
	cloudletApiStore, cloudletApiUnwrap := wrapCloudletTrackerStore(all.cloudletApi)
	defer cloudletApiUnwrap()

	// UpdateAutoProvPolicy should succeed if no references are in delete_prepare
	testObj, _ = dataGen.GetUpdateAutoProvPolicyTestObj()
	_, err = all.autoProvPolicyApi.UpdateAutoProvPolicy(ctx, testObj)
	require.Nil(t, err, "UpdateAutoProvPolicy should succeed if no references are in delete prepare")
	// make sure everything ran in the same STM
	require.NotNil(t, autoProvPolicyApiStore.putSTM, "UpdateAutoProvPolicy put AutoProvPolicy must be done in STM")
	require.NotNil(t, cloudletApiStore.getSTM, "UpdateAutoProvPolicy check Cloudlet ref must be done in STM")
	require.Equal(t, autoProvPolicyApiStore.putSTM, cloudletApiStore.getSTM, "UpdateAutoProvPolicy check Cloudlet ref must be done in same STM as AutoProvPolicy put")

	// clean up
	supportData.delete(t, ctx, all)
}

func AddAutoProvPolicyCloudletAddRefsChecks(t *testing.T, ctx context.Context, all *AllApis, dataGen AllAddRefsDataGen) {
	var err error

	testObj, supportData := dataGen.GetAddAutoProvPolicyCloudletTestObj()
	supportData.put(t, ctx, all)
	{
		// set delete_prepare on referenced Cloudlet
		ref := supportData.getOneCloudlet()
		require.NotNil(t, ref, "support data must include one referenced Cloudlet")
		ref.DeletePrepare = true
		_, err = all.cloudletApi.store.Put(ctx, ref, all.cloudletApi.sync.syncWait)
		require.Nil(t, err)
		// api call must fail with object being deleted
		testObj, _ = dataGen.GetAddAutoProvPolicyCloudletTestObj()
		_, err = all.autoProvPolicyApi.AddAutoProvPolicyCloudlet(ctx, testObj)
		require.NotNil(t, err, "AddAutoProvPolicyCloudlet must fail with Cloudlet.DeletePrepare set")
		require.Equal(t, ref.GetKey().BeingDeletedError().Error(), err.Error())
		// reset delete_prepare on referenced Cloudlet
		ref.DeletePrepare = false
		_, err = all.cloudletApi.store.Put(ctx, ref, all.cloudletApi.sync.syncWait)
		require.Nil(t, err)
	}

	// wrap the stores so we can make sure all checks and changes
	// happen in the same STM.
	autoProvPolicyApiStore, autoProvPolicyApiUnwrap := wrapAutoProvPolicyTrackerStore(all.autoProvPolicyApi)
	defer autoProvPolicyApiUnwrap()
	cloudletApiStore, cloudletApiUnwrap := wrapCloudletTrackerStore(all.cloudletApi)
	defer cloudletApiUnwrap()

	// AddAutoProvPolicyCloudlet should succeed if no references are in delete_prepare
	testObj, _ = dataGen.GetAddAutoProvPolicyCloudletTestObj()
	_, err = all.autoProvPolicyApi.AddAutoProvPolicyCloudlet(ctx, testObj)
	require.Nil(t, err, "AddAutoProvPolicyCloudlet should succeed if no references are in delete prepare")
	// make sure everything ran in the same STM
	require.NotNil(t, autoProvPolicyApiStore.putSTM, "AddAutoProvPolicyCloudlet put AutoProvPolicy must be done in STM")
	require.NotNil(t, cloudletApiStore.getSTM, "AddAutoProvPolicyCloudlet check Cloudlet ref must be done in STM")
	require.Equal(t, autoProvPolicyApiStore.putSTM, cloudletApiStore.getSTM, "AddAutoProvPolicyCloudlet check Cloudlet ref must be done in same STM as AutoProvPolicy put")

	// clean up
	supportData.delete(t, ctx, all)
}
